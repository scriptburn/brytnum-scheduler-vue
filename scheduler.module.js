/*

Bryntum Scheduler 3.1.0
Copyright(c) 2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/license

*/

const productName = 'scheduler';

var support = {
  searchParams: 'URLSearchParams' in self,
  iterable: 'Symbol' in self && 'iterator' in Symbol,
  blob:
    'FileReader' in self &&
    'Blob' in self &&
    (function() {
      try {
        new Blob();
        return true
      } catch (e) {
        return false
      }
    })(),
  formData: 'FormData' in self,
  arrayBuffer: 'ArrayBuffer' in self
};

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj)
}

if (support.arrayBuffer) {
  var viewClasses = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]'
  ];

  var isArrayBufferView =
    ArrayBuffer.isView ||
    function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    };
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
    throw new TypeError('Invalid character in header field name')
  }
  return name.toLowerCase()
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value);
  }
  return value
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return {done: value === undefined, value: value}
    }
  };

  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator
    };
  }

  return iterator
}

function Headers$1(headers) {
  this.map = {};

  if (headers instanceof Headers$1) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}

Headers$1.prototype.append = function(name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
};

Headers$1.prototype['delete'] = function(name) {
  delete this.map[normalizeName(name)];
};

Headers$1.prototype.get = function(name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null
};

Headers$1.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name))
};

Headers$1.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};

Headers$1.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};

Headers$1.prototype.keys = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push(name);
  });
  return iteratorFor(items)
};

Headers$1.prototype.values = function() {
  var items = [];
  this.forEach(function(value) {
    items.push(value);
  });
  return iteratorFor(items)
};

Headers$1.prototype.entries = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items)
};

if (support.iterable) {
  Headers$1.prototype[Symbol.iterator] = Headers$1.prototype.entries;
}

function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'))
  }
  body.bodyUsed = true;
}

function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result);
    };
    reader.onerror = function() {
      reject(reader.error);
    };
  })
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise
}

function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsText(blob);
  return promise
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join('')
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0)
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer
  }
}

function Body() {
  this.bodyUsed = false;

  this._initBody = function(body) {
    this._bodyInit = body;
    if (!body) {
      this._bodyText = '';
    } else if (typeof body === 'string') {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      // IE 10-11 can't handle a DataView body.
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8');
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
      }
    }
  };

  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob')
      } else {
        return Promise.resolve(new Blob([this._bodyText]))
      }
    };

    this.arrayBuffer = function() {
      if (this._bodyArrayBuffer) {
        return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
      } else {
        return this.blob().then(readBlobAsArrayBuffer)
      }
    };
  }

  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob)
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text')
    } else {
      return Promise.resolve(this._bodyText)
    }
  };

  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode)
    };
  }

  this.json = function() {
    return this.text().then(JSON.parse)
  };

  return this
}

// HTTP methods whose capitalization should be normalized
var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method
}

function Request(input, options) {
  options = options || {};
  var body = options.body;

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read')
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers$1(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }

  this.credentials = options.credentials || this.credentials || 'same-origin';
  if (options.headers || !this.headers) {
    this.headers = new Headers$1(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || 'GET');
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal;
  this.referrer = null;

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests')
  }
  this._initBody(body);
}

Request.prototype.clone = function() {
  return new Request(this, {body: this._bodyInit})
};

function decode(body) {
  var form = new FormData();
  body
    .trim()
    .split('&')
    .forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
  return form
}

function parseHeaders(rawHeaders) {
  var headers = new Headers$1();
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
  preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
    var parts = line.split(':');
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(':').trim();
      headers.append(key, value);
    }
  });
  return headers
}

Body.call(Request.prototype);

function Response$1(bodyInit, options) {
  if (!options) {
    options = {};
  }

  this.type = 'default';
  this.status = options.status === undefined ? 200 : options.status;
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = 'statusText' in options ? options.statusText : 'OK';
  this.headers = new Headers$1(options.headers);
  this.url = options.url || '';
  this._initBody(bodyInit);
}

Body.call(Response$1.prototype);

Response$1.prototype.clone = function() {
  return new Response$1(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers$1(this.headers),
    url: this.url
  })
};

Response$1.error = function() {
  var response = new Response$1(null, {status: 0, statusText: ''});
  response.type = 'error';
  return response
};

var redirectStatuses = [301, 302, 303, 307, 308];

Response$1.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code')
  }

  return new Response$1(null, {status: status, headers: {location: url}})
};

var DOMException$1 = self.DOMException;
try {
  new DOMException$1();
} catch (err) {
  DOMException$1 = function(message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };
  DOMException$1.prototype = Object.create(Error.prototype);
  DOMException$1.prototype.constructor = DOMException$1;
}

function fetch$1(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init);

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException$1('Aborted', 'AbortError'))
    }

    var xhr = new XMLHttpRequest();

    function abortXhr() {
      xhr.abort();
    }

    xhr.onload = function() {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      };
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
      var body = 'response' in xhr ? xhr.response : xhr.responseText;
      resolve(new Response$1(body, options));
    };

    xhr.onerror = function() {
      reject(new TypeError('Network request failed'));
    };

    xhr.ontimeout = function() {
      reject(new TypeError('Network request failed'));
    };

    xhr.onabort = function() {
      reject(new DOMException$1('Aborted', 'AbortError'));
    };

    xhr.open(request.method, request.url, true);

    if (request.credentials === 'include') {
      xhr.withCredentials = true;
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false;
    }

    if ('responseType' in xhr && support.blob) {
      xhr.responseType = 'blob';
    }

    request.headers.forEach(function(value, name) {
      xhr.setRequestHeader(name, value);
    });

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr);

      xhr.onreadystatechange = function() {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr);
        }
      };
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
  })
}

fetch$1.polyfill = true;

if (!self.fetch) {
  self.fetch = fetch$1;
  self.Headers = Headers$1;
  self.Request = Request;
  self.Response = Response$1;
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

(function (factory) {
  
  factory();
}((function () {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  var Emitter =
  /*#__PURE__*/
  function () {
    function Emitter() {
      _classCallCheck(this, Emitter);

      Object.defineProperty(this, 'listeners', {
        value: {},
        writable: true,
        configurable: true
      });
    }

    _createClass(Emitter, [{
      key: "addEventListener",
      value: function addEventListener(type, callback) {
        if (!(type in this.listeners)) {
          this.listeners[type] = [];
        }

        this.listeners[type].push(callback);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, callback) {
        if (!(type in this.listeners)) {
          return;
        }

        var stack = this.listeners[type];

        for (var i = 0, l = stack.length; i < l; i++) {
          if (stack[i] === callback) {
            stack.splice(i, 1);
            return;
          }
        }
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        var _this = this;

        if (!(event.type in this.listeners)) {
          return;
        }

        var debounce = function debounce(callback) {
          setTimeout(function () {
            return callback.call(_this, event);
          });
        };

        var stack = this.listeners[event.type];

        for (var i = 0, l = stack.length; i < l; i++) {
          debounce(stack[i]);
        }

        return !event.defaultPrevented;
      }
    }]);

    return Emitter;
  }();

  var AbortSignal =
  /*#__PURE__*/
  function (_Emitter) {
    _inherits(AbortSignal, _Emitter);

    function AbortSignal() {
      var _this2;

      _classCallCheck(this, AbortSignal);

      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(AbortSignal).call(this)); // Some versions of babel does not transpile super() correctly for IE <= 10, if the parent
      // constructor has failed to run, then "this.listeners" will still be undefined and then we call
      // the parent constructor directly instead as a workaround. For general details, see babel bug:
      // https://github.com/babel/babel/issues/3041
      // This hack was added as a fix for the issue described here:
      // https://github.com/Financial-Times/polyfill-library/pull/59#issuecomment-477558042

      if (!_this2.listeners) {
        Emitter.call(_assertThisInitialized(_this2));
      } // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and
      // we want Object.keys(new AbortController().signal) to be [] for compat with the native impl


      Object.defineProperty(_assertThisInitialized(_this2), 'aborted', {
        value: false,
        writable: true,
        configurable: true
      });
      Object.defineProperty(_assertThisInitialized(_this2), 'onabort', {
        value: null,
        writable: true,
        configurable: true
      });
      return _this2;
    }

    _createClass(AbortSignal, [{
      key: "toString",
      value: function toString() {
        return '[object AbortSignal]';
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        if (event.type === 'abort') {
          this.aborted = true;

          if (typeof this.onabort === 'function') {
            this.onabort.call(this, event);
          }
        }

        _get(_getPrototypeOf(AbortSignal.prototype), "dispatchEvent", this).call(this, event);
      }
    }]);

    return AbortSignal;
  }(Emitter);
  var AbortController =
  /*#__PURE__*/
  function () {
    function AbortController() {
      _classCallCheck(this, AbortController);

      // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and
      // we want Object.keys(new AbortController()) to be [] for compat with the native impl
      Object.defineProperty(this, 'signal', {
        value: new AbortSignal(),
        writable: true,
        configurable: true
      });
    }

    _createClass(AbortController, [{
      key: "abort",
      value: function abort() {
        var event;

        try {
          event = new Event('abort');
        } catch (e) {
          if (typeof document !== 'undefined') {
            if (!document.createEvent) {
              // For Internet Explorer 8:
              event = document.createEventObject();
              event.type = 'abort';
            } else {
              // For Internet Explorer 11:
              event = document.createEvent('Event');
              event.initEvent('abort', false, false);
            }
          } else {
            // Fallback where document isn't available:
            event = {
              type: 'abort',
              bubbles: false,
              cancelable: false
            };
          }
        }

        this.signal.dispatchEvent(event);
      }
    }, {
      key: "toString",
      value: function toString() {
        return '[object AbortController]';
      }
    }]);

    return AbortController;
  }();

  if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
    // These are necessary to make sure that we get correct output for:
    // Object.prototype.toString.call(new AbortController())
    AbortController.prototype[Symbol.toStringTag] = 'AbortController';
    AbortSignal.prototype[Symbol.toStringTag] = 'AbortSignal';
  }

  function polyfillNeeded(self) {
    if (self.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
      console.log('__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill');
      return true;
    } // Note that the "unfetch" minimal fetch polyfill defines fetch() without
    // defining window.Request, and this polyfill need to work on top of unfetch
    // so the below feature detection needs the !self.AbortController part.
    // The Request.prototype check is also needed because Safari versions 11.1.2
    // up to and including 12.1.x has a window.AbortController present but still
    // does NOT correctly implement abortable fetch:
    // https://bugs.webkit.org/show_bug.cgi?id=174980#c2


    return typeof self.Request === 'function' && !self.Request.prototype.hasOwnProperty('signal') || !self.AbortController;
  }

  /**
   * Note: the "fetch.Request" default value is available for fetch imported from
   * the "node-fetch" package and not in browsers. This is OK since browsers
   * will be importing umd-polyfill.js from that path "self" is passed the
   * decorator so the default value will not be used (because browsers that define
   * fetch also has Request). One quirky setup where self.fetch exists but
   * self.Request does not is when the "unfetch" minimal fetch polyfill is used
   * on top of IE11; for this case the browser will try to use the fetch.Request
   * default value which in turn will be undefined but then then "if (Request)"
   * will ensure that you get a patched fetch but still no Request (as expected).
   * @param {fetch, Request = fetch.Request}
   * @returns {fetch: abortableFetch, Request: AbortableRequest}
   */

  function abortableFetchDecorator(patchTargets) {
    if ('function' === typeof patchTargets) {
      patchTargets = {
        fetch: patchTargets
      };
    }

    var _patchTargets = patchTargets,
        fetch = _patchTargets.fetch,
        _patchTargets$Request = _patchTargets.Request,
        NativeRequest = _patchTargets$Request === void 0 ? fetch.Request : _patchTargets$Request,
        NativeAbortController = _patchTargets.AbortController,
        _patchTargets$__FORCE = _patchTargets.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL,
        __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL = _patchTargets$__FORCE === void 0 ? false : _patchTargets$__FORCE;

    if (!polyfillNeeded({
      fetch: fetch,
      Request: NativeRequest,
      AbortController: NativeAbortController,
      __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL: __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL
    })) {
      return {
        fetch: fetch,
        Request: Request
      };
    }

    var Request = NativeRequest; // Note that the "unfetch" minimal fetch polyfill defines fetch() without
    // defining window.Request, and this polyfill need to work on top of unfetch
    // hence we only patch it if it's available. Also we don't patch it if signal
    // is already available on the Request prototype because in this case support
    // is present and the patching below can cause a crash since it assigns to
    // request.signal which is technically a read-only property. This latter error
    // happens when you run the main5.js node-fetch example in the repo
    // "abortcontroller-polyfill-examples". The exact error is:
    //   request.signal = init.signal;
    //   ^
    // TypeError: Cannot set property signal of #<Request> which has only a getter

    if (Request && !Request.prototype.hasOwnProperty('signal') || __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
      Request = function Request(input, init) {
        var signal;

        if (init && init.signal) {
          signal = init.signal; // Never pass init.signal to the native Request implementation when the polyfill has
          // been installed because if we're running on top of a browser with a
          // working native AbortController (i.e. the polyfill was installed due to
          // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our
          // fake AbortSignal to the native fetch will trigger:
          // TypeError: Failed to construct 'Request': member signal is not of type AbortSignal.

          delete init.signal;
        }

        var request = new NativeRequest(input, init);

        if (signal) {
          Object.defineProperty(request, 'signal', {
            writable: false,
            enumerable: false,
            configurable: true,
            value: signal
          });
        }

        return request;
      };

      Request.prototype = NativeRequest.prototype;
    }

    var realFetch = fetch;

    var abortableFetch = function abortableFetch(input, init) {
      var signal = Request && Request.prototype.isPrototypeOf(input) ? input.signal : init ? init.signal : undefined;

      if (signal) {
        var abortError;

        try {
          abortError = new DOMException('Aborted', 'AbortError');
        } catch (err) {
          // IE 11 does not support calling the DOMException constructor, use a
          // regular error object on it instead.
          abortError = new Error('Aborted');
          abortError.name = 'AbortError';
        } // Return early if already aborted, thus avoiding making an HTTP request


        if (signal.aborted) {
          return Promise.reject(abortError);
        } // Turn an event into a promise, reject it once `abort` is dispatched


        var cancellation = new Promise(function (_, reject) {
          signal.addEventListener('abort', function () {
            return reject(abortError);
          }, {
            once: true
          });
        });

        if (init && init.signal) {
          // Never pass .signal to the native implementation when the polyfill has
          // been installed because if we're running on top of a browser with a
          // working native AbortController (i.e. the polyfill was installed due to
          // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our
          // fake AbortSignal to the native fetch will trigger:
          // TypeError: Failed to execute 'fetch' on 'Window': member signal is not of type AbortSignal.
          delete init.signal;
        } // Return the fastest promise (don't need to wait for request to finish)


        return Promise.race([cancellation, realFetch(input, init)]);
      }

      return realFetch(input, init);
    };

    return {
      fetch: abortableFetch,
      Request: Request
    };
  }

  (function (self) {

    if (!polyfillNeeded(self)) {
      return;
    }

    if (!self.fetch) {
      console.warn('fetch() is not available, cannot install abortcontroller-polyfill');
      return;
    }

    var _abortableFetch = abortableFetchDecorator(self),
        fetch = _abortableFetch.fetch,
        Request = _abortableFetch.Request;

    self.fetch = fetch;
    self.Request = Request;
    Object.defineProperty(self, 'AbortController', {
      writable: true,
      enumerable: false,
      configurable: true,
      value: AbortController
    });
    Object.defineProperty(self, 'AbortSignal', {
      writable: true,
      enumerable: false,
      configurable: true,
      value: AbortSignal
    });
  })(typeof self !== 'undefined' ? self : commonjsGlobal);

})));

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports 
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}
});

/**
 * @module Core/helper/StringHelper
 */

const camelLettersRe    = /([a-z])([A-Z])/g,
    escapeRegExpRe      = /[.*+?^${}()|[\]\\]/g,
    idRe                = /(^[^a-z]+|[^\w]+)/gi,
    replaceCamelLetters = (all, g1, g2) => {
        return g1 + '-' + g2.toLowerCase();
    },
    replaceNonIdChar    = c => {
        if (c) {
            return `_x${c.charCodeAt(0).toString(16)}`;
        }
        return '__blank__';
    },
    hyphenateCache      = {};

/**
 * Helper for string manipulation.
 */
class StringHelper {
    /**
     * Capitalizes the first letter of a string, myString -> MyString.
     * Doesn't alter the original string, use return value
     * @param string String to capitalize
     * @returns {String} Capitalized string
     */
    static capitalizeFirstLetter(string) {
        if (!string) return null;
        return string[0].toUpperCase() + string.substr(1);
    }

    /**
     * Makes the first letter of a string lowercase, MyString -> myString.
     * Doesn't alter the original string, use return value
     * @param string String to alter
     * @returns {String} Altered string
     */
    static lowercaseFirstLetter(string) {
        if (!string) return null;
        return string[0].toLowerCase() + string.substr(1);
    }

    /**
     * Converts the passed camelCased string to a hyphen-separated string. eg "minWidth" -> "min-width"
     * @param string The string to convert.
     * @return {String} The string with adjoining lower and upper case letters
     * separated by hyphens and converted to lower case.
     */
    static hyphenate(string) {
        // Cached since it is used heavily with DomHelper.sync()
        const cached = hyphenateCache[string];
        if (cached) {
            return cached;
        }
        return hyphenateCache[string] = string.replace(camelLettersRe, replaceCamelLetters);
    }

    /**
     * Parses JSON within a try-catch.
     * @param {String} string String to parse
     * @returns {Object} Resulting object or null if parse failed
     */
    static safeJsonParse(string) {
        let parsed = null;

        try {
            parsed = JSON.parse(string);
        }
        catch (e) {
            console.error(e);
        }

        return parsed;
    }

    /**
     * Stringifies an object within a try-catch.
     * @param {Object} object The object to stringify
     * @returns {Object} Resulting object or null if stringify failed
     */
    static safeJsonStringify(obj) {
        let result = null;

        try {
            result = JSON.stringify(obj);
        }
        catch (e) {
            console.error(e);
        }

        return result;
    }

    /**
     * Creates an alphanuneric identifier from any passed string. Encodes spaces and non-alpha characters.
     * @param inString The string from which to strip non-identifier characters.
     * @return {String}
     */
    static createId(inString) {
        return String(inString).replace(idRe, replaceNonIdChar);
    }

    // https://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
    static escapeRegExp(string) {
        // $& means the whole matched string
        return string.replace(escapeRegExpRe, '\\$&');
    }

    /**
     * Joins all given paths together using the separator as a delimiter and normalizes the resulting path.
     * @param paths {Array} array of paths to join
     * @param pathSeparator [{String}] path separator. Default value is '/'
     * @return {String}
     */
    static joinPaths(paths, pathSeparator = '/') {
        return paths.join(pathSeparator).replace(new RegExp('\\' + pathSeparator + '+', 'g'), pathSeparator);
    }

}
StringHelper._$name = 'StringHelper';

/**
 * @module Core/helper/VersionHelper
 */

let isSiesta = false;

try{
    isSiesta = Boolean(window !== window.parent && window.parent.Siesta);
} catch(e) {

}

/**
 * Helper for version handling
 * @private
 * @example
 *
 * VersionHelper.setVersion('grid', '1.5');
 *
 * if (VersionHelper.getVersion('grid').isNewerThan('1.0')) {
 *   ...
 * }
 */
class VersionHelper {
    /**
     * Set version for specified product
     * @private
     * @param {String} product
     * @param {String} version
     */
    static setVersion(product, version) {
        product = product.toLowerCase();

        this[product] = {
            version,
            isNewerThan(otherVersion) {
                return otherVersion < version;
            },
            isOlderThan(otherVersion) {
                return otherVersion > version;
            }
        };

        let bundleFor = '';

        // Var productName is only defined in bundles, it is internal to bundle so not available on window. Used to
        // tell importing combinations of grid/scheduler/gantt bundles apart from loading same bundle twice
        // eslint-disable-next-line no-undef
        if (typeof productName !== 'undefined') {
            bundleFor = productName;
        }

        // Set "global" flag to detect bundle being loaded twice
        const globalKey = `${bundleFor}.${product}${version.replace(/\./g, '-')}`;

        if (window.bryntum[globalKey] === true) {
            if (isSiesta) {
                window.BUNDLE_EXCEPTION = true;
            }
            else {
                throw new Error('Bundle included twice, check cache-busters and file types (.js)');
            }
        }
        else {
            window.bryntum[globalKey] = true;
        }
    }

    /**
     * Get (previously set) version for specified product
     * @private
     * @param {String} product
     */
    static getVersion(product) {
        product = product.toLowerCase();

        if (!this[product])  {
            throw new Error('No version specified');
        }

        return this[product].version;
    }

    /**
     * Checks the passed product against the passed version using the passed test.
     * @param {String} product The name of the product to test the version of
     * @param {String} version The version to test against
     * @param {String} test The test operator, `<=`, `<`, `=`, `>` or `>=`.
     * @param {String} [message] A warning message to log if the test is found to be true.
     * @returns {Boolean} `true` if the test passes.
     * @internal
     */
    static checkVersion(product, version, test, message) {
        const productVersion = this.getVersion(product);

        let result;

        switch (test) {
            case '<':
                result = productVersion < version;
                break;
            case '<=':
                result = productVersion <= version;
                break;
            case '=':
                result = productVersion === version;
                break;
            case '>=':
                result = productVersion >= version;
                break;
            case '>':
                result = productVersion > version;
                break;
        }

        return result;
    }

    /**
     * Based on a comparison of current product version and the passed version this method either outputs a console.warn or throws an error
     * @param {String} product The name of the product
     * @param {String} invalidAsOfVersion The version where the offending code is invalid (when any compatibility layer is actually removed)
     * @param {String} message Required! A helpful warning message to show to the developer using a deprecated API.
     * @internal
     */
    static deprecate(product, invalidAsOfVersion, message) {
        const justWarn = this.checkVersion(product, invalidAsOfVersion, '<', message);

        // <debug>
        if (!invalidAsOfVersion.endsWith('.0.0')) {
            throw new Error('May only break APIs in major releases');
        }
        if (!message) {
            throw new Error('Must provide helpful message for developers');
        }
        // </debug>

        if (justWarn) {
            // During the grace period (until the next major release following the deprecated code), just show a console warning
            console.warn(`Deprecation warning: You are using a deprecated API which will change in v${invalidAsOfVersion}. ${message}`);
        } else {
            throw new Error(`Deprecated API use. ${message}`);
        }
    }

    static get isTestEnv() {
        return isSiesta;
    }
}

(window.bryntum || (window.bryntum = {})).getVersion = VersionHelper.getVersion.bind(VersionHelper);
window.bryntum.checkVersion = VersionHelper.checkVersion.bind(VersionHelper);
window.bryntum.deprecate = VersionHelper.deprecate.bind(VersionHelper);
VersionHelper._$name = 'VersionHelper';

/**
 * @module Core/Base
 */

const defaultConfigSymbol = Symbol('defaultConfig'),
    propertyInitializersSymbol = Symbol('propertyInitializers'),
    classHierarchySymbol = Symbol('classHierarchy'),
    configurationSymbol = Symbol('configuration'),
    originalConfigSymbol = Symbol('originalConfig'),
    instancePropertiesSymbol = Symbol('instanceProperties');

/**
 * Base class for all configurable classes.
 *
 * Subclasses do not have to implement a constructor with its restriction of having to call super()
 * before there is a `this` reference. Subclasses instead implement a `construct` method which is
 * called by the `Base` constructor. This may call its `super` implementation at any time.
 *
 * The `Base` constructor applies all configs to properties of the new instance. The instance
 * will have been configured after the `super.construct(config)` is called.
 *
 * See the Class System documentation in the guides for more information.
 *
 * @abstract
 */
class Base {
    // defaultConfig & properties made private to not spam all other classes

    /**
     * A getter for the default configuration of this class, which can be overridden by configurations passed at construction time.
     * @member {Object} defaultConfig
     * @static
     * @category Configuration
     * @private
     */

    /**
     * A getter for the default values of internal properties for this class
     * @member {Object} properties
     * @static
     * @category Configuration
     * @private
     */

    /**
     * Base constructor, passes arguments to {@link #function-construct}.
     * @param args
     * @function constructor
     * @category Lifecycle
     */
    constructor(...args) {
        // Allow subclasses to have a pseudo constructor with "this" already set;
        this.construct(...args);

        this.afterConstruct();
    }

    /**
     * Base implementation applies configuration.
     *
     * Subclasses need only implement this if they have to initialize instance specific
     * properties required by the class. Often a `construct` method is
     * unnecessary. All initialization of incoming configuration properties can be
     * done in a `set propName` implementation.
     * @param {Object} [config] Usually called with a config object, but accepts any params
     * @category Lifecycle
     */
    construct(...args) {
        // Passing null to base construct means bypass the config system and stack creation (to gain performance)
        if (args[0] !== null) {
            
            this.configure(...args);
        }
        this.afterConfigure();
    }

    /**
     * Destroys the provided objects by calling their {@link #function-destroy} method.
     * Skips empty values or objects that are already destroyed.
     *
     * ```javascript
     * Base.destroy(myButton, toolbar1, helloWorldMessageBox);
     * ```
     *
     * @category Lifecycle
     */
    static destroy(...args) {
        args.forEach(object => {
            if (object && object.destroy && !object.isDestroyed) {
                object.destroy();
            }
        });
    }

    /**
     * Destroys the object.
     * Do not override this in subclasses. To provide class-specific destruction, implement a
     * doDestroy method. It is a lifecycle hook that will be called during destruction.
     * @category Lifecycle
     */
    destroy() {
        const me = this;

        

        me.isDestroying = true;
        me.doDestroy();

        Object.setPrototypeOf(this, null);

        // Clear all remaining instance properties.
        for (let key in me) {
            delete me[key];
        }
        delete me[originalConfigSymbol];

        // Only one property remains to signal why the object is inert.
        me.isDestroyed = true;
    }

    /**
     * This method is required to help `unused` getters to survive production build process. Some tools, like angular,
     * will remove `unused` code in production build, making our side-effected getters behind, breaking code heavily.
     * @internal
     * @param getter Getter to evaluate
     */
    _thisIsAUsedExpression(getter) {}

    static get $name() {
        return this.hasOwnProperty('_$name') && this._$name || this.name;
    }

    get $name() {
        return this.constructor.$name;
    }

    /**
     * Base implementation so that all subclasses and mixins may safely call super.startConfigure.
     *
     * This is called by the Base class before setting configuration properties, but after
     * the active initial getters have been set, so all configurations are available.
     *
     * This method allows all classes in the hierarchy to force some configs to be evaluated before others.
     * @internal
     * @category Lifecycle
     * @params {Object} config The configuration object use to set the initial state.
     */
    startConfigure(config) {

    }

    /**
     * Base implementation so that all subclasses and mixins may safely call super.finishConfigure.
     *
     * This is called by the Base class before exiting the {@link #function-configure} method.
     *
     * At this point, all configs have been applied, but the `isConfiguring` property is still set.
     *
     * This method allows all classes in the hierarchy to inject functionality
     * into the config phase.
     * @internal
     * @category Lifecycle
     * @params {Object} config The configuration object use to set the initial state.
     */
    finishConfigure(config) {

    }

    /**
     * Base implementation so that all subclasses and mixins may safely call `super.afterConfigure`. This is called by the Base class after the {@link #function-configure} method has been
     * called. At this point, all configs have been applied.
     *
     * This method allows all classes in the hierarchy to inject functionality
     * either before or after the super.afterConstruct();
     * @internal
     * @category Lifecycle
     */
    afterConfigure() {

    }

    /**
     * Base implementation so that all subclasses and mixins may safely call super.afterConstruct.
     *
     * This is called by the Base class after the {@link #function-construct} method has been
     * called.
     *
     * At this point, all configs have been applied.
     *
     * This method allows all classes in the hierarchy to inject functionality
     * either before or after the super.afterConstruct();
     * @internal
     * @function afterConstructor
     * @category Lifecycle
     */
    afterConstruct() {

    }

    /**
     * Provides a way of calling callbacks which may have been specified as the _name_ of a function
     * and optionally adds scope resolution.
     *
     * For example, if the callback is specified as a string, then if it is prefixed with `'this.'`
     * then the function is resolved in this object. This is useful when configuring listeners
     * at the class level.
     *
     * If the callback name is prefixed with `'up.'` then the ownership hierarchy is queried
     * using the `owner` property until an object with the named function is present, then the
     * named function is called upon that object.
     * @param {String|Function} handler The function to call, or the name of the function to call.
     * @param {Object} thisObj The `this` object of the function.
     * @param {Object[]} args The argument list to pass.
     */
    callback(fn, thisObject, args) { // Maintainer: do not make args ...args. This method may acquire more arguments
        if (thisObject === 'this') {
            thisObject = this;
        }

        const { handler, thisObj } = this.resolveCallback(fn, thisObject);

        return args ? handler.apply(thisObj, args) : handler.call(thisObj);
    }

    resolveCallback(handler, thisObj = this) {

        // It's a string, we find it in its own thisObj
        if (handler.substr) {
            if (handler.startsWith('up.')) {
                handler = handler.substr(3);

                // Empty loop until we find the function owner
                for (thisObj = this.owner; thisObj && !thisObj[handler]; thisObj = thisObj.owner);

                
            }
            else if (handler.startsWith('this.')) {
                thisObj = this;
            }
            

            handler = thisObj[handler];
        }

        return { handler, thisObj };
    }

    bindCallback(inHandler, inThisObj = this) {
        if (inHandler) {
            const { handler, thisObj } = this.resolveCallback(inHandler, inThisObj);
            if (handler) {
                return handler.bind(thisObj);
            }        }
    }

    /**
     * Delays the execution of the passed function by the passed time quantum, or if the time is omitted
     * or not a number, delays until the next animation frame. Note that this will use
     * {@link Core.mixin.Delayable#function-setTimeout} || {@link Core.mixin.Delayable#function-requestAnimationFrame}
     * if this class mixes in `Delayable`, otherwise it uses the global methods. The function will
     * be called using `this` object as its execution scope.
     * @param {Function} fn The function to call on a delay.
     * @param {Number} [by] The number of milliseconds to delay.
     * @private
     */
    delay(fn, by) {
        // Force scope on the fn if we are not a Delayable
        fn = this.setTimeout ? fn : fn.bind(this);

        (typeof by === 'number' ? (this.setTimeout || setTimeout) : (this.requestAnimationFrame || requestAnimationFrame))(fn, by);
    }

    /**
     * Base implementation so that all subclasses and mixins may safely call super.
     * doDestroy is how all subclasses must clean themselves up. It is called by the
     * Base class *before* final destruction of the object.
     * @internal
     * @category Lifecycle
     */
    doDestroy() {

    }

    /**
     * Destroys the named properties if they have been initialized, and if they have a `destroy` method.
     * Deletes the property from this object. For example:
     *
     *      this.destroyProperties('store', 'resourceStore', 'eventStore', 'dependencyStore', 'assignmentStore');
     *
     * @param {String} properties The names of the properties to destroy.
     * @internal
     * @category Lifecycle
     */
    destroyProperties(...properties) {
        const me = this;

        let key, propertyValue;

        for (key of properties) {
            // If the value has *not* been pulled in from the configuration object yet
            // we must not try to access it, as that will cause the property to be initialized.
            if (key in me && (!me[configurationSymbol] || !me[configurationSymbol][key])) {
                propertyValue = me[key];
                if (propertyValue && propertyValue.destroy) {
                    propertyValue.destroy();
                }
                delete me[key];
            }
        }
    }

    /**
     * Called by the Base constructor to apply configs to this instance. The must not be called.
     * @param {Object} config The configuration object from which instance properties are initialized.
     * @private
     * @category Lifecycle
     */
    configure(config = {}) {
        
        const me = this;

        me.initialConfig = config;

        // Important flag for setters to know whether they are being called during
        // configuration when this object is not fully alive, or whether it's being reconfgured.
        me.isConfiguring = true;

        // Assign any instance properties declared by the class.
        Object.assign(me, me.getProperties());

        // Apply configuration to default (Which is safe, because it's a chained object) from class definition.
        // Cache me.config for use by get config.
        me.setConfig(me[originalConfigSymbol] = Base.assign(me.getDefaultConfiguration(), config), true);

        me.isConfiguring = false;
    }

    /**
     * Sets configuration options this object with all the properties passed in the parameter object.
     * Timing is taken care of. If the setter of one config is called first, and references
     * the value of another config which has not yet been set, that config will be set just
     * in time, and the *new* value will be used.
     * @param {Object} config An object containing configurations to change.
     * @category Configuration
     */
    setConfig(config, isConstructing) {
        const me = this,
            wasConfiguring = me[configurationSymbol],
            configDone = wasConfiguring ? me.configDone : (me.configDone = {}),
            instanceProperties = me[instancePropertiesSymbol] = {};

        let key,
            instanceProperty;

        // Cache me.configuration for use by injected property initializers.
        me[configurationSymbol] = wasConfiguring ? Object.setPrototypeOf(Object.assign({}, config), wasConfiguring) : config;

        // For each incoming non-null configuration, create a temporary getter which will
        // pull the value in from the initialConfig so that it doesn't matter in
        // which order properties are set. You can access any property at any time.
        for (key in config) {
            // Don't default null configs inunless it's a direct property of the
            // the passed configuration. When used at construct time, defaultConfigs
            // will be prototype-chained onto the config.
            if (config[key] != null || config.hasOwnProperty(key)) {
                // If there is an existing property with a getter/setter, *not* a value
                // defined on the object for this config we must call it in our injected getter/setter.
                // Maintainer, this is testing the truthiness of the assignment, *not* a botched equality test.
                if (!instanceProperties[key] && (instanceProperty = Reflect.getOwnPropertyDescriptor(me, key)) && !('value' in instanceProperty)) {
                    instanceProperties[key] = instanceProperty;
                }
                // Set up a temporary instance property which will
                // Pull in the value from the initialConfig if the getter
                // is called first.
                Reflect.defineProperty(me, key, Base.createPropInitializer(key));

                if (!isConstructing) {
                    configDone[key] = false;
                }
            }
            else {
                configDone[key] = true;
            }
        }

        if (isConstructing) {
            me.startConfigure(config);
        }

        // Set all our properties from the config object.
        // If one of the properties needs to access a property that has not
        // yet been set, the above temporary property will pull it through.
        // Can't use Object.assign because that only uses own properties.
        // config value blocks are prototype chained subclass->superclass
        for (key in config) {
            // Only push the value through if the property initializer is still present.
            // If it gets triggered to pull the configuration value in, it deleted itself.
            if (!configDone[key]) {
                me[key] = config[key];
            }
        }

        if (wasConfiguring) {
            me[configurationSymbol] = wasConfiguring;
        }
        else {
            delete me[configurationSymbol];
        }

        if (isConstructing) {
            me.finishConfigure(config);
        }
    }

    /**
     * Returns a *copy* of the full configuration which was used to configure this object.
     * @returns {Object} All configuration properties which were used to configure this object.
     * @category Misc
     */
    get config() {
        let result = {},
            myConfig = this[originalConfigSymbol],
            key;

        // The configuration was created as a prototype chain of the class hierarchy's
        // defaultConfig values hanging off a copy of the initialConfig object, so
        // we must loop and copy since Object.assign only copies own properties.
        for (key in myConfig) {
            result[key] = myConfig[key];
        }
        return result;
    }

    /**
     * Gets the full {@link #property-defaultConfig-static} block for this object's entire inheritance chain
     * all the way up to but not including {@link Core.Base}
     * @return {Object} All default config values for this class.
     * @private
     * @category Configuration
     */
    getDefaultConfiguration() {
        return this.constructor.getDefaultConfiguration();
    }

    /**
     * Gets the full {@link #property-defaultConfig-static} block for the entire inheritance chain for this class
     * all the way up to but not including {@link Core.Base}
     * @return {Object} All default config values for this class.
     * @private
     * @category Configuration
     */
    static getDefaultConfiguration() {
        const
            configDescriptor = this.getConfigDescriptor(),
            config           = configDescriptor.needsFork ? this.fork(configDescriptor.defaultConfig) : Object.setPrototypeOf({}, configDescriptor.defaultConfig);

        // Allow tests to modify configuration of class instances
        if (VersionHelper.isTestEnv && config.testConfig && window.__applyTestConfigs) {
            for (const o in config.testConfig) {
                config[o] = config.testConfig[o];
            }
        }

        return config;
    }

    /**
     * Gets the full {@link #property-defaultConfig-static} block for this class's entire inheritance chain
     * all the way up to but not including {@link Core.Base}
     * @return {Object} All default config values for this class.
     * @private
     * @category Configuration
     */
    static getConfigDescriptor(shallow) {
        const me = this;

        let configDescriptor = !shallow && me.hasOwnProperty(defaultConfigSymbol) ? me[defaultConfigSymbol] : null,
            defaults, key, cls, value, superConfigDescriptor;

        if (!configDescriptor) {
            

            configDescriptor = {
                defaultConfig : defaults = me.hasOwnProperty('defaultConfig') ? me.defaultConfig : {},
                // Use 1 instead of true because below we're using |= to or up all the flags from the class hierarchy
                needsFork     : 0
            };

            // Only cache top level descriptors.
            if (!shallow) {
                me[defaultConfigSymbol] = configDescriptor;
            }
            for (key in defaults) {
                value = defaults[key];

                // If any default properties are *mutable* Objects or Array we need to clone them.
                // so that instances do not share configured values.
                if (value && (value.constructor === Object || Array.isArray(value)) && !Object.isFrozen(value)) {
                    // Use 1 instead of true because below we're using |= to or up all the flags from the class hierarchy
                    configDescriptor.needsFork = 1;
                    break;
                }
            }

            // Because of mixins being mixed into different parts of the class hiererchy,
            // we can't chain to an existing deep descriptor. We have to climb from
            // here and assemble the deep descriptor from shallow ones.
            // If any along the way need forking (have an Object or Array), so do we.
            // We chain them together because that is hundreds of times faster
            // than Object.assign: https://jsperf.com/setprototypeof-vs-object-assign/
            if (!shallow) {
                for (cls = me.superclass; cls && cls !== Base; cls = cls.superclass) {
                    superConfigDescriptor = cls.getConfigDescriptor(true);
                    if (Object.keys(superConfigDescriptor.defaultConfig).length) {
                        configDescriptor.needsFork |= superConfigDescriptor.needsFork;
                        Object.setPrototypeOf(defaults, defaults = superConfigDescriptor.defaultConfig);
                    }
                }
            }
        }

        return configDescriptor;
    }

    static fork(obj) {
        var ret, key, value;

        if (obj && obj.constructor === Object && !Object.isFrozen(obj)) {
            ret = Object.setPrototypeOf({}, obj);

            for (key in obj) {
                value = obj[key];

                if (value) {
                    if (value.constructor === Object) {
                        ret[key] = this.fork(value);
                    }
                    else if (value instanceof Array) {
                        ret[key] = value.slice();
                    }
                }
            }
        }
        else {
            ret = obj;
        }

        return ret;
    }

    static assign(dest, ...sources) {
        var i = 0,
            ln = sources.length,
            source, key;

        for (; i < ln; i++) {
            source = sources[i];

            for (key in source) {
                dest[key] = source[key];
            }
        }
        return dest;
    }

    /**
     * Gets the full {@link #property-properties-static} block for this class's entire inheritance chain
     * all the way up to but not including {@link Core.Base}
     * @return {Object} All default config values for this class.
     * @private
     * @category Configuration
     */
    getProperties() {
        const hierarchy = this.classHierarchy(),
            len = hierarchy.length;

        let result = {},
            i,
            cls;

        // TODO: if properties block does not change this could be cached? would speed up loading of big data sets into grid

        // Gather the class result in *top-down* order so that a subclass's properties
        // overrides properties from superclasses.
        //for (cls of this.classHierarchy()) { // replaced for of since it transpiles badly and this is called a lot when creating many instances
        for (i = 0; i < len; i++) {
            cls = hierarchy[i];
            // Skip classes which don't have it. We're going to ask its superclass anyway.
            if (cls.hasOwnProperty('properties')) {
                Object.assign(result, cls.properties);
            }
        }

        return result;
    }

    static get superclass() {
        return Object.getPrototypeOf(this);
    }

    static createPropInitializer(key) {
        // Because initializers for a property name are the same, cache them on the Base
        // class so that only one copy is created for each property name globally.
        var result = (this[propertyInitializersSymbol] || (this[propertyInitializersSymbol] = {}))[key];

        if (!result) {
            let initializingFlagName = 'initializing' + StringHelper.capitalizeFirstLetter(key);

            result = this[propertyInitializersSymbol][key] = {
                configurable : true,
                get() {
                    const me = this,
                        instanceProperty = me[instancePropertiesSymbol][key];

                    // If we took over from an instance property, replace it
                    if (instanceProperty) {
                        Reflect.defineProperty(me, key, instanceProperty);
                    }
                    // Otherwise just delete the instance property who's getter we are in.
                    else {
                        delete me[key];
                    }

                    // Set the value from the configuration.
                    me[initializingFlagName] = true;
                    me[key] = me[configurationSymbol][key];
                    me[initializingFlagName] = false;

                    // The property has been *pulled* from the configuration.
                    // Prevent the setting loop in configure from setting it again.
                    me.configDone[key] = true;

                    // Finally, allow the prototype getter to return the value.
                    return me[key];
                },
                set(value) {
                    const me = this,
                        instanceProperty = me[instancePropertiesSymbol][key];

                    // If we took over from an instance property, replace it
                    if (instanceProperty) {
                        Reflect.defineProperty(me, key, instanceProperty);
                    }
                    // Otherwise just delete the instance property who's getter we are in.
                    else {
                        delete me[key];
                    }

                    // The config has been set (some internal code may have called the setter)
                    // so prevent it from being called again and overwritten with data from initialConfig.
                    me.configDone[key] = true;

                    // Set the property normally (Any prototype setter will be invoked)
                    me[key] = value;
                }
            };
        }

        return result;
    }

    /**
     * Used by the Widget and GridFeatureManager class internally. Returns the class hierarchy of this object
     * starting from the `topClass` class (which defaults to `Base`).
     *
     * For example `classHierarchy(Widget)` on a Combo would yield `[Widget, Field, TextField, PickerField, Combo]`
     * @param {Function} [topClass] The topmost class constructor to start from.
     * @returns {Function[]} The class hierarchy of this instance.
     * @private
     * @category Configuration
     */
    classHierarchy(topClass) {
        let cls = this.constructor,
            fullClassHierarchy = cls.hasOwnProperty(classHierarchySymbol) ? cls[classHierarchySymbol] : null,
            result;

        // Collect the full class hierarchy only once.
        if (!fullClassHierarchy) {
            // Using Object.getPrototypeOf instead of Refect.getPrototypeOf because:
            // 1. The are almost the same, according to the MDN difference is handling getPrototypeOf('string')
            // 2. It allows to pass security check is salesforce environment
            for (fullClassHierarchy = cls[classHierarchySymbol] = []; cls !== Base; cls = Object.getPrototypeOf(cls)) {
                fullClassHierarchy.unshift(cls);
            }
            // Don't let anybody mutate this. It's cached.
            Object.freeze(fullClassHierarchy);
        }

        // Cut down to the requested topClass
        if (topClass) {
            for (let i = 0; !result && i < fullClassHierarchy.length; i++) {
                if (fullClassHierarchy[i] === topClass) {
                    result = fullClassHierarchy.slice(i);
                }
            }
        }
        else {
            result = fullClassHierarchy;
        }
        return result;
    }

    /**
     * Same as {@link #function-classHierarchy} but returns array of class names obtained via $name property
     *
     * @param {Function} [topClass] The topmost class constructor to start from.
     * @returns {String[]} The class name hierarchy of this instance.
     * @private
     * @category Configuration
     */
    classNameHierarchy(topClass) {
        return this.classHierarchy(topClass).map(f => f.$name);
    }

    /**
     * Checks if an obj is of type using object's $name property and doing string comparision of the property with the type parameter.
     *
     * @param {String} type
     * @return {Boolean}
     */
    static isOfTypeName(type) {
        return this.classNameHierarchy().includes(type);
    }

    /**
     * Removes all event listeners that were registered with the given `name`.
     * @param {String} name The name of the event listeners to be removed.
     */
    detachListeners(name) {
        let detachers = this.$detachers;

        detachers = detachers && detachers[name];

        if (detachers) {
            while (detachers.length) {
                detachers.pop()();
            }
        }
    }

    /**
     * Tracks a detacher function for the specified listener name.
     * @param {String} name The name assigned to the associated listeners.
     * @param {Function} detacher The detacher function.
     * @private
     */
    trackDetacher(name, detacher) {
        const
            detachers = this.$detachers || (this.$detachers = {}),
            bucket = detachers[name] || (detachers[name] = []);

        bucket.push(detacher);
    }

    /**
     * Removes all detacher functions for the specified `Events` object. This is called
     * by the `removeAllListeners` method on that object which is typically called by its
     * `destroy` invocation.
     * @param {Core.mixin.Events} eventer The `Events` instance to untrack.
     * @private
     */
    untrackDetachers(eventer) {
        const detachers = this.$detachers;

        if (detachers) {
            for (const name in detachers) {
                const bucket = detachers[name];

                for (let i = bucket.length; i-- > 0; /* empty */) {
                    if (bucket[i].eventer === eventer) {
                        bucket.splice(i, 1);
                    }
                }
            }
        }
    }
}

// Avoid some object shape changes:
Object.assign(Base.prototype, {
    $detachers : null
});



VersionHelper.setVersion('core', '0.0.0');
Base._$name = 'Base';

/**
 * @module Core/helper/ArrayHelper
 */

/**
 * Helper with useful functions for handling Arrays
 * @internal
 */
class ArrayHelper {
    static clean(array) {
        return array.reduce((res, item) => {
            if (item !== null && item !== undefined && !(Array.isArray(item) && item.length === 0) && item !== '') res.push(item);
            return res;
        }, []);
    }

    /**
     * Remove one or more items from an array
     * @param {Array} array Array to remove from
     * @param {Object} items One or more items to remove
     * @returns {boolean} Returns true if any item was removed
     */
    static remove(array, ...items) {
        let index,
            item,
            removed = false;

        for (let i = 0; i < items.length; i++) {
            item = items[i];
            if ((index = array.indexOf(item)) !== -1) {
                array.splice(index, 1);
                removed = true;
            }
        }

        return removed;
    }

    /*
     * Calculates the insertion index of a passed object into the passed Array according
     * to the passed comparator function. Note that the passed Array *MUST* already be ordered.
     * @param {Object} item The item to calculate the insertion index for.
     * @param {Array} The array into which the item is to be inserted.
     * @param {Function} comparatorFn The comparison function. Must return -1 or 0 or 1.
     * @param {Object} comparatorFn.lhs The left object to compare.
     * @param {Object} comparatorFn.rhs The right object to compare.
     * @param {Number} index The possible correct index to try first before a binary
     * search is instigated.
     */
    static findInsertionIndex(item, array, comparatorFn = this.lexicalCompare, index) {
        const len = array.length;
        let beforeCheck, afterCheck;

        if (index < len) {
            beforeCheck = index > 0 ? comparatorFn(array[index - 1], item) : 0;
            afterCheck = index < len - 1 ? comparatorFn(item, array[index]) : 0;
            if (beforeCheck < 1 && afterCheck < 1) {
                return index;
            }
        }

        return this.binarySearch(array, item, comparatorFn);
    }

    /**
     * This method returns the index that a given item would be inserted into the
     * given (sorted) `array`. Note that the given `item` may or may not be in the
     * array. This method will return the index of where the item *should* be.
     *
     * For example:
     *
     *      var array = [ 'A', 'D', 'G', 'K', 'O', 'R', 'X' ];
     *      var index = ArrayHelper.binarySearch(array, 'E');
     *
     *      console.log('index: ' + index);
     *      // logs "index: 2"
     *
     *      array.splice(index, 0, 'E');
     *
     *      console.log('array : ' + array.join(''));
     *      // logs "array: ADEGKORX"
     *
     * @param {Object[]} array The array to search.
     * @param {Object} item The item that you want to insert into the `array`.
     * @param {Number} [begin=0] The first index in the `array` to consider.
     * @param {Number} [end=array.length] The index that marks the end of the range
     * to consider. The item at this index is *not* considered.
     * @param {Function} [compareFn] The comparison function that matches the sort
     * order of the `array`. The default `compareFn` compares items using less-than
     * and greater-than operators.
     * @return {Number} The index for the given item in the given array based on
     * the passed `compareFn`.
     */
    static binarySearch(array, item, begin = 0, end = array.length, compareFn = this.lexicalCompare) {
        const length = array.length;
        let middle, comparison;

        if (begin instanceof Function) {
            compareFn = begin;
            begin = 0;
        }
        else if (end instanceof Function) {
            compareFn = end;
            end = length;
        }

        --end;

        while (begin <= end) {
            middle = (begin + end) >> 1;
            comparison = compareFn(item, array[middle]);
            if (comparison >= 0) {
                begin = middle + 1;
            }
            else if (comparison < 0) {
                end = middle - 1;
            }
        }

        return begin;
    }

    magnitudeCompare(lhs, rhs) {
        return (lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0);
    }

    lexicalCompare(lhs, rhs) {
        lhs = String(lhs);
        rhs = String(rhs);

        return (lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0);
    }

    /**
     * Similar to Array.prototype.fill(), but constructs a new array with the specified item count and fills it with
     * clones of the supplied item.
     * @param {Number} count Number of entries to create
     * @param {Object|Array} itemOrArray Item or array of items to clone (uses object spread to create shallow clone)
     * @param {Function} [fn] An optional function that is called for each item added, to allow processing
     * @returns {Array} A new populated array
     */
    static fill(count, itemOrArray = {}, fn = null) {
        const
            result = [],
            items  = Array.isArray(itemOrArray) ? itemOrArray : [ itemOrArray ];

        for (let i = 0; i < count; i++) {
            for (let item of items) {
                // Using object spread here forces us to use more babel plugins and will make
                // react_typescript demo very difficult to setup
                const processedItem = Object.assign({}, item);

                if (fn) {
                    fn(processedItem, i);
                }

                result.push(processedItem);
            }
        }
        return result;
    }

    /**
     * Populates an array with the return value from `fn`.
     * @param {Number} count Number of entries to create
     * @param {Function} fn A function that is called `count` times, return value is added to array
     * @param {Number} fn.index Current index in the array
     * @returns {Array} A new populated array
     */
    static populate(count, fn) {
        const items = [];
        for (let i = 0; i < count; i++) {
            items.push(fn(i));
        }
        return items;
    }

    /**
     * Pushes `item` on to the `array` if not already included
     * @param {Array}  array Array to push to
     * @param {Object} item Item to push if not already included
     */
    static include(array, item) {
        if (!array.includes(item)) {
            array.push(item);
        }
    }

    // Wanted to create an indexer on Stores, based on this. But turns out Proxy cannot be transpiled/polyfill for IE11
    // Keeping it for future reference
    static allowNegative(array) {
        // From https://github.com/sindresorhus/negative-array
        return new Proxy(array, {
            get(target, name, receiver) {
                if (typeof name !== 'string') {
                    return Reflect.get(target, name, receiver);
                }

                const index = Number(name);

                if (Number.isNaN(index)) {
                    return Reflect.get(target, name, receiver);
                }

                return target[index < 0 ? target.length + index : index];
            },
            set(target, name, value, receiver) {
                if (typeof name !== 'string') {
                    return Reflect.set(target, name, value, receiver);
                }

                const index = Number(name);

                if (Number.isNaN(index)) {
                    return Reflect.set(target, name, value, receiver);
                }

                target[index < 0 ? target.length + index : index] = value;

                return true;
            }
        });
    }

    static delta(a, b) {
        // Nicer syntax but about 40% slower (an extra iteration)
        // const
        //     onlyInA = a.filter(item => !b.includes(item)),
        //     onlyInB = b.filter(item => !a.includes(item)),
        //     inBoth  = a.filter(item => b.includes(item));

        // Quick bailout for nonexisting target array
        if (!b) {
            return { onlyInA : a, onlyInB : [], inBoth : [] };
        }

        const
            onlyInA = [],
            onlyInB = [],
            inBoth  = [];

        for (let i = 0; i < a.length; i++) {
            const item = a[i];

            if (b.includes(item)) {
                inBoth.push(item);
            }
            else {
                onlyInA.push(item);
            }
        }

        for (let i = 0; i < b.length; i++) {
            const item = b[i];

            if (!inBoth.includes(item)) {
                onlyInB.push(item);
            }
        }

        return { onlyInA, onlyInB, inBoth };
    }
}
ArrayHelper._$name = 'ArrayHelper';

//TODO: Implement mon

/**
 * @module Core/mixin/Events
 */

// Used to distinguish event names from listener options in addListener object config.
const specialProperties = {
        thisObj        : 1,
        detachable     : 1,
        once           : 1,
        detacher       : 1,
        prio           : 1,
        args           : 1,
        expires        : 1,
        name           : 1,
        _oldDestructor : 1
    },
    priorityComparator = (a, b) => b.prio - a.prio;

/**
 * Mix this into another class to enable event handling.
 *
 * ## Basic usage
 * Listeners can be added either through config:
 *
 * ```javascript
 * let button = new Button({
 *   listeners: {
 *     click: () => {},
 *     press: () => {},
 *     ...
 *   }
 * });
 * ```
 *
 * *NOTE*: Do not reuse listeners config object, use new every time:
 * ```javascript
 * // wrong
 * let config = { click : () => {} }
 * new Button({
 *     listeners : config
 * })
 * new Button({
 *     listeners : config
 * })
 * // right
 * new Button({
 *     listeners : { click : () => {} }
 * })
 * new Button({
 *     listeners : { click : () => {} }
 * })
 * ```
 *
 * Or by calling on()/addListener():
 *
 * ```javascript
 * let button = new Button();
 *
 * button.addListener('press', () => {});
 * // on is an alias for addListener
 * button.on('click', () => {});
 * ```
 *
 * This style also accepts multiple listeners in same way as when using config:
 *
 * ```javascript
 * button.on({
 *   click: () => {},
 *   press: () => {},
 *   ...
 * });
 * ```
 *
 * ## Options
 * ### Once
 * Listeners can be configured to automatically deregister after first trigger by specifing config option `once`:
 *
 * ```javascript
 * button.on({
 *   click: () => {},
 *   once: true
 * });
 * ```
 *
 * ### Priority
 * Specifying priority affects the order in which listeners are called when triggering an event. Higher prios will be
 * called before lower. Default value is 0.
 *
 * ```javascript
 * button.on({
 *   click: this.onClick,
 *   prio: 1
 * });
 * ```
 *
 * ### This reference
 * If desired, you can specify thisObj when configuring listeners. There is no need if you are using arrow functions as
 * listeners, but might be handy in other cases. Of course, you can also use bind to set `this` reference.
 *
 * ```javascript
 * button.on({
 *   click: this.onClick,
 *   thisObj: this
 * });
 *
 * // or
 *
 * button.on({
 *   click: this.onClick.bind(this)
 * });
 * ```
 *
 * ### Detacher
 * A convenient way of unregistering events is to use a detacher, a function returned when adding listeners that you
 * call later to deregister them. As of version 1.0, detachable defaults to true.
 *
 * ```javascript
 * let detacher = button.on({
 *   click: () => {},
 *   press: () => {},
 *   detachable: true
 * });
 *
 * // when you want to detach, for example in destroy()
 * detacher();
 * ```
 *
 * ### Auto detaching
 * When listeners are bound to a class instance using `thisObj`, the `thisObj`'s `doDestroy` method
 * is overridden to remove the listeners before calling the overridden doDestroy.
 *
 * ```javascript
 * class MyClass extends Base {
 *   construct() {
 *     let button = new Button({
 *       listeners: {
 *         click: () => {},
 *         thisObj: this
 *       }
 *     });
 *   }
 *
 *   doDestroy() {
 *     // clean up stuff
 *   }
 * }
 *
 * let myObj = new MyClass();
 * // clean up, also removes listeners
 * myObj.destroy();
 * ```
 *
 * ### On-functions
 * When mixing Events into another class it can be configured to call on-functions when events are triggered.
 * On-functions are functions named 'onEventname', for example 'onClick', 'onPress' declared on the class triggering
 * the event.
 *
 * ```javascript
 * // mix Events in with on-functions activated
 * let button = new Button({
 *   callOnFunctions: true,
 *
 *   onClick: () => {}
 * });
 *
 * // or add a getter in class declaration
 * ```
 *
 * ### Catching all events
 * By specifying a listener for `catchAll` a function can be notified when any event is triggered:
 *
 * ```javascript
 * const button = new Button({
 *    listeners : {
 *        catchAll(event) {
 *            // All events on the button will pass through here
 *        }
 *    }
 * });
 * ```
 *
 * @mixin
 */
var Events = Target => class Events extends (Target || Base) {
    //region Events

    /**
     * Fires before an object is destroyed.
     * @event beforeDestroy
     * @param {Object} source The Object that is being destroyed.
     */

    /**
     * Fires when an object is destroyed.
     * @event destroy
     * @param {Object} source The Object that is being destroyed.
     */

    //endregion

    //region Config

    static get defaultConfig() {
        return {
            /**
             * Listeners can be specified in target class config.
             * ```
             * let store = new Store({
             *   listeners: {
             *     load: () => {},
             *     ...
             *   }
             * });
             * ```
             * @config {Object}
             * @category Common
             */
            listeners : null
        };
    }

    destroy() {
        this.trigger('beforeDestroy');
        super.destroy();
    }

    //endregion

    //region Init

    // TODO: Check, because not sure about using @function constructor here
    /**
     * Adds configured listeners
     * @private
     * @function constructor
     */
    construct(...args) {
        super.construct(...args);

        this.processConfiguredListeners();
    }

    processConfiguredListeners(listeners = this.listeners && this.initialEventListeners) {
        const me = this;

        // TODO: listeners should be added first, so that any setters which fire or rely on listeners work.
        // This may also expose bugs where listeners are fired too early.
        if (listeners && !me.defaultListenersInitialized) {
            const ret = me.addListener(listeners, me);

            if (me.listeners.detachable !== false) {
                me.listenerDetacher = ret;
            }

            me.defaultListenersInitialized = true;
        }
    }

    /**
     * Auto detaches listeners registered from start, if set as detachable
     * @internal
     */
    doDestroy() {
        const me = this;

        me.trigger('destroy');
        if (me.listenerDetacher) {
            me.listenerDetacher();
        }
        me.removeAllListeners();

        super.doDestroy();
    }

    //endregion

    //region Listeners

    /**
     * Adds an event listener. This method accepts parameters in the following format:
     *
     * ```javascript
     *  {
     *      thisObj    : this,          // The this reference for the handlers
     *      eventname2 : 'functionName' // Resolved at invocation time using the thisObj,
     *      otherevent : {
     *          fn      : 'handlerFnName',
     *          once    : true          // Just this handler is auto-removed on fire
     *      },
     *      yetanother  : {
     *          fn      : 'yetAnotherHandler',
     *          args    : [ currentState1, currentState2 ] // Capture info to be passed to handler
     *      }
     *      prio        : 100           // Higher prio listeners are called before lower
     *  }
     * ```
     *
     * When listeners have a `thisObj` option, they are linked to the lifecycle of that object.
     * When it is destroyed, those listeners are removed.
     *
     * @param {Object} config An object containing listener definitions.
     * @param {Object} [config.thisObj] The `this` reference for all listeners.
     * (May be overridden if a handler is specified in object form)
     * @param {Boolean} [config.once] Specify as `true` to remove the listener as soon as it is invoked.
     * @param {Object[]} [config.args] An array of arguments to be passed to the handler before the event object.
     * @param {Object} [thisObj] `this` reference for all listeners.
     * @param {Number} [prio] The priority for all listeners; higher priority listeners are caled before lower.
     * @returns {Function} Returns a detacher function unless configured with `detachable: false`. Call detacher to remove listeners
     */
    addListener(config, thisObj, arg2) {
        const
            me = this,
            events = me.eventListeners || (me.eventListeners = {});

        if (typeof config === 'string') {
            // arguments[2] is thisObj if (eventname, handler, thisObj) form called.
            // Note that the other side of the if compares to undefined, so this will work.
            return me.addListener({
                [config]   : thisObj,
                detachable : thisObj.detachable !== false,
                thisObj    : arg2
            });
        }
        else {
            // If the thisObj came from the parameter, ensure the config object has it
            // because this is how autoDetaching works.
            thisObj = config.thisObj !== undefined ? config.thisObj : (config.thisObj = thisObj);

            for (const key in config) {
                if (!specialProperties[key]) {
                    const
                        listenerSpec = config[key],
                        listener  = {
                            fn       : typeof listenerSpec === 'object' ? listenerSpec.fn : listenerSpec,
                            thisObj  : listenerSpec.thisObj !== undefined ? listenerSpec.thisObj : thisObj,
                            args     : listenerSpec.args || config.args,
                            prio     : listenerSpec.prio !== undefined ? listenerSpec.prio : config.prio !== undefined ? config.prio : 0,
                            once     : listenerSpec.once !== undefined ? listenerSpec.once : config.once !== undefined ? config.once : false,
                            catchAll : key === 'catchAll'
                        },
                        eventName = key.toLowerCase(),
                        listeners = events[eventName] || (events[eventName] = []);

                    

                    if (listenerSpec.expires) {
                        me.delay(() => me.un(eventName, listener), config.expires);
                    }

                    // Insert listener directly in prio order
                    listeners.splice(ArrayHelper.findInsertionIndex(listener, listeners, priorityComparator, listeners.length), 0, listener);
                }
            }

            if (config.relayAll) {
                me.relayAll(config.relayAll);
            }

            // Hook into the thisObj's destruction sequence to remove these listeners.
            if (thisObj) {
                me.attachAutoDetacher(config);
            }

            const
                detachable = config.detachable !== false,
                name = config.name,
                destroy = (config.expires || detachable || name) ? () => {
                    // drop listeners if not destroyed yet
                    if (!me.isDestroyed) {
                        me.removeListener(config);
                    }
                } : null;

            if (destroy) {
                destroy.eventer = me;
                destroy.listenerName = name;

                if (name && thisObj && thisObj.trackDetacher) {
                    thisObj.trackDetacher(name, destroy);
                }

                if (config.expires) {
                    me.delay(destroy, config.expires);
                }

                if (detachable) {
                    return destroy;
                }
            }
        }
    }

    /**
     * Shorthand for addListener
     * @param config
     * @param [thisObj]
     */
    on() {
        return this.addListener(...arguments);
    }

    /**
     * Shorthand for removeListener
     * @param config
     * @param thisObj
     */
    un() {
        this.removeListener(...arguments);
    }

    /**
     * Sets the listener set for this object. Removes any existing listeners and adds the
     * specified set of listeners.
     * @property {Object} When *setting*, this is the listeners to add in object form, see {@link #function addListener}.
     * When *getting*, this is an object map keys by event name, but each value is an *array* of listener definitions.
     * @category Common
     */
    set listeners(listeners) {
        // Listeners are not applied during initial configuration.
        // Configured listeners are added by the constructor above.
        if (this.isConfiguring) {
            this.initialEventListeners = listeners;
        }
        else {
            this.removeAllListeners();
            if (listeners) {
                this.on(listeners);
            }
        }
    }

    get listeners() {
        return this.eventListeners || this.initialEventListeners;
    }

    /**
     * Removes an event listener. Same API signature as {@link #function-addListener}
     * @param {Object} config Listeners
     * @param {Object} thisObj `this` reference for all listeners
     */
    removeListener(config, thisObj = config.thisObj, ...params) {
        const me = this;

        if (typeof config === 'string') {
            me.removeListener({ [config] : thisObj }, params.length > 0 ? params[0] : true);
            return;
        }

        Object.entries(config).forEach(([key, configListener]) => {
            if (specialProperties[key]) {
                return;
            }

            const
                eventName = key.toLowerCase(),
                listeners = me.eventListeners && me.eventListeners[eventName];

            if (listeners) {
                const index = listeners.findIndex(listener =>
                    (listener.fn === configListener || listener.fn === configListener.fn) &&
                    (listener.thisObj === thisObj || listener.thisObj === configListener.thisObj || !thisObj)
                );
                if (index >= 0) {
                    // NOTE: we cannot untrack any detachers here because we may only be
                    // removing some of its listeners
                    listeners.splice(index, 1);
                    if (!listeners.length) {
                        delete me.eventListeners[eventName];
                    }
                }
            }
        });

        if (config.thisObj && !config.thisObj.isDestroyed) {
            me.detachAutoDetacher(config);
        }
    }

    /**
     * Check if any listener is registered for the specified eventName
     * @param {String} eventName
     * @returns {Boolean} `true` if listener is registered, otherwise `false`
     */
    hasListener(eventName) {
        return Boolean(this.eventListeners && this.eventListeners[eventName]);
    }

    /**
     * Relays all events through another object that also implements Events mixin. Adds a prefix to the event name
     * before relaying, for example add -> storeAdd
     * ```
     * // Relay all events from store through grid, will make it possible to listen for store events prefixed on grid:
     * 'storeLoad', 'storeChange', 'storeRemoveAll' etc.
     * store.relayAll(grid, 'store');
     *
     * grid.on('storeLoad', () => console.log('Store loaded');
     * ```
     * @param {Core.mixin.Events} through Object to relay the events through, needs to mix Events mixin in
     * @param {String} prefix Prefix to add to event name
     * @param {Boolean} [transformCase] Specify false to prevent making first letter of event name uppercase
     */
    relayAll(through, prefix, transformCase = true) {
        (this.relayAllTargets || (this.relayAllTargets = [])).push({ through, prefix, transformCase });
    }

    /**
     * Removes all listeners registered to this object
     */
    removeAllListeners() {
        const listeners = this.eventListeners;
        let i, thisObj;

        for (const event in listeners) {
            const bucket = listeners[event];

            // We iterate backwards since we call removeListener which will splice out of
            // this array as we go...
            for (i = bucket.length; i-- > 0; /* empty */) {
                const cfg = bucket[i];

                this.removeListener(event, cfg);

                thisObj = cfg.thisObj;

                if (thisObj && thisObj.untrackDetachers) {
                    thisObj.untrackDetachers(this);
                }
            }
        }
    }

    relayEvents(source, eventNames, prefix) {
        const
            listenerConfig = { detachable : true },
            retrigger = (eventName, ...params) => {
                return this.trigger((prefix || '') + eventName, ...params);
            };

        eventNames.forEach(eventName => {
            listenerConfig[eventName] = (...params) => {
                return retrigger(eventName, ...params);
            };
        });

        return source.on(listenerConfig);
    }

    /**
     * Internal function used to hook destroy() calls when using thisObj
     * @private
     */
    attachAutoDetacher(config) {
        const
            target = config.thisObj,
            // If it's a Bryntyum Base subclass, hook doDestroy, otherwise, destroy
            destructorName = ('doDestroy' in target) ? 'doDestroy' : 'destroy';

        if (destructorName in target) {
            config._oldDestructor = target[destructorName];
            target[destructorName]     = () => {
                // Remove listeners first, so that they do not fire during destruction.
                // The observable being listened to by the thisObj may already have
                // been destroyed in a clean up sequence
                if (!this.isDestroyed) {
                    this.removeListener(config);
                }
                config._oldDestructor.call(target);
            };
        }
        else {
            target[destructorName] = () => {
                this.removeListener(config);
            };
        }
    }

    /**
     * Internal function used restore hooked destroy() calls when using thisObj
     * @private
     */
    detachAutoDetacher(config) {
        const
            target = config.thisObj,
            destructorName = ('doDestroy' in target) ? 'doDestroy' : 'destroy';

        if (config._oldDestructor) {
            target[destructorName] = config._oldDestructor;
        }
    }

    //endregion

    //region Promise based workflow

    // experimental, used in tests to support async/await workflow
    await(eventName, options = { checkLog : true, resetLog : true }) {
        const me = this;

        if (options === false) {
            options = { checkLog : false };
        }

        return new Promise(resolve => {
            // check if previously triggered?
            if (options.checkLog && me._triggered && me._triggered[eventName]) {
                // resolve immediately, no params though...
                resolve();
                // reset log to be able to await again
                if (options.resetLog) {
                    me.clearLog(eventName);
                }
            }

            me.on({
                [eventName] : (...params) => {
                    // resolve when event is caught
                    resolve(...params);
                    // reset log to be able to await again
                    if (options.resetLog) {
                        me.clearLog(eventName);
                    }
                },
                prio : -10000, // Let others do their stuff first
                once : true // promises can only be resolved once anyway
            });
        });
    }

    clearLog(eventName) {
        if (this._triggered) {
            if (eventName) {
                delete this._triggered[eventName];
            }
            else {
                this._triggered = {};

            }
        }
    }

    //endregion

    //region Trigger

    /**
     * Wraps a function with event triggering. First triggers before[eventName] with the supplied eventObject. If it is
     * not prevented (by returning false) the supplied fn is called with the eventObject as first argument and any
     * optional arguments after that. It then triggers [eventName] with the eventObject (that might have been altered in
     * fn). Finally it returns the return value from the fn.
     * @param {String} eventName Event name, used to trigger 'beforeEventName' and 'eventName'
     * @param {Object} eventObject Passed when triggering events
     * @param {Function} fn Function to call if before is not prevented
     * @param {Array} args Arguments to pass to fn
     * @param {Boolean} quiet Specify true to not trigger events
     * @returns {*} Result returned from calling fn, or false if prevented
     * @internal
     */
    callPreventable(eventName, eventObject, fn, args = [], quiet = false) {
        const me = this;

        if (!quiet && me.trigger('before' + StringHelper.capitalizeFirstLetter(eventName), eventObject) === false) {
            return false;
        }

        const result = fn(eventObject, ...args);

        if (!quiet) {
            me.trigger(eventName, eventObject);
        }

        return result;
    }

    /**
     * Triggers an event, calling all registered listeners with the supplied arguments. Returning false from any listener
     * makes function return false.
     * @param {String} eventName Event name for which to trigger listeners
     * @param {Object} param Single parameter passed on to listeners, source property will be added to it (this)
     * @param {Boolean} [param.bubbles] Pass as `true` to indicate that the event will bubble up the widget
     * ownership hierarchy. For example up a Menu->parent Menu tree, or a Field->Container tree.
     * @returns {Boolean} Returns false if any listener returned false, otherwise true
     */
    // TODO: should returning false from a listener really prevent other listeners from executing?
    trigger(eventName, param) {
        
        const
            me   = this,
            name = eventName.toLowerCase(),
            {
                eventsSuspended,
                relayAllTargets,
                callOnFunctions,
                owner
            }   = me;

        let listeners = me.eventListeners && me.eventListeners[name],
            doSlice   = true;

        // log trigger, used by experimental promise support to resolve immediately when needed
        if (!me._triggered) {
            me._triggered = {};
        }
        me._triggered[eventName] = true;

        if (eventsSuspended) {
            if (eventsSuspended.shouldQueue) eventsSuspended.queue.push(arguments);
            return true;
        }

        // Include catchall listener for all events.
        // Do not push the catchAll listeners onto the events own listener array.
        if (me.eventListeners && me.eventListeners.catchall) {
            (listeners = (listeners ? listeners.slice() : [])).push(...me.eventListeners.catchall);

            // The catchAll listeners must honour their prio settings.
            listeners.sort(priorityComparator);
            doSlice = false;
        }

        if (!listeners && !relayAllTargets && !callOnFunctions) return true;

        // default to include source : this in param
        if (param) {
            if (!('source' in param)) {
                if (Object.isExtensible(param)) {
                    param.source = me;
                }
                else {
                    param = Object.setPrototypeOf({
                        source : me
                    }, param);
                }
            }
        }
        else {
            param = {
                source : me
            };
        }

        // Lowercased event name should be the "type" property in keeping with DOM events.
        if (param.type !== name) {
            // Create instance property because "type" is read only
            if (param.constructor !== Object) {
                Reflect.defineProperty(param, 'type', { get : () => name });
            }
            else {
                param.type = name;
            }
        }

        if (callOnFunctions) {
            const fnName = 'on' + StringHelper.capitalizeFirstLetter(eventName);
            if (fnName in me) {
                me.callback(me[fnName], me, [param]);

                // See if the called function was injected into the instance
                // masking an implementation in the prototype.
                // we must call the class's implementation after the injected one.
                // unless it's an injected chained function, in which case it will have been called above.
                // Note: The handler may have resulted in destruction.
                if (!me.isDestroyed && me.hasOwnProperty(fnName) && (!me.pluginFunctionChain || !me.pluginFunctionChain[fnName])) {
                    const myProto = Object.getPrototypeOf(me);
                    if (fnName in myProto) {
                        myProto[fnName].call(me, param);

                        // A handler may have resulted in destruction.
                        if (me.isDestroyed) {
                            return;
                        }
                    }
                }
            }
        }

        if (listeners) {
            let i = 0,
                listener, handler;

            // Make a flat copy of the listeners to protect against a situation where an event listener
            // adds another listener while triggering the event, which we do not want.
            // The array may already be a copy if there are catchAll listeners. See above.
            if (doSlice) {
                listeners = listeners.slice();
            }

            // If any listener resulted in our destruction, abort.
            for (i; i < listeners.length && !me.isDestroyed; i++) {
                listener = listeners[i];

                let thisObj = listener.thisObj;

                // Listeners that have thisObj are auto removed when thisObj is destroyed. If thisObj is destroyed from
                // a listener we might still end up here, since listeners are sliced and not affected by the removal
                if (!thisObj || !thisObj.isDestroyed) {
                    if (listener.once) {
                        me.removeListener(name, listener);
                    }

                    if (typeof listener.fn === 'string') {
                        if (thisObj) {
                            handler = thisObj[listener.fn];
                        }

                        // keep looking for the callback in the hierarchy
                        if (!handler) {
                            const result = me.resolveCallback(listener.fn);

                            handler = result.handler;
                            thisObj = result.thisObj;
                        }
                    }
                    else {
                        handler = listener.fn;
                    }

                    // If listener was declared with args, send our param after them
                    if (listener.args) {
                        if (handler.call(thisObj || me, ...listener.args, param) === false) {
                            return false;
                        }
                    }
                    else {
                        if (handler.call(thisObj || me, param) === false) {
                            return false;
                        }
                    }
                }
            }
        }

        // relay all?
        if (relayAllTargets) {
            relayAllTargets.forEach(config => {
                let name = eventName;
                if (config.transformCase) name = StringHelper.capitalizeFirstLetter(name);
                if (config.prefix) name = config.prefix + name;
                if (config.through.trigger(name, param) === false) return false;
            });
        }

        // Use DOM standard event property name to indicate that the event
        // bubbles up the owner axis.
        // False from any handler cancels the bubble.
        // The owner prop was cached above in case any handlers destroyed this object.
        // Must also avoid owner if any handlers destroyed the owner.
        if (param.bubbles && owner && !owner.isDestroyed) {
            return owner.trigger(eventName, param);
        }

        return true;
    }

    /**
     * Prevents events from being triggered until {@link #function-resumeEvents()} is called. Optionally queues events that are triggered while
     * suspended. Multiple calls stack to require matching calls to `resumeEvents()` before actually resuming.
     * @param {Boolean} queue Specify true to queue events triggered while suspended
     */
    suspendEvents(queue = false) {
        const eventsSuspended = this.eventsSuspended || (this.eventsSuspended = { shouldQueue : queue, queue : [], count : 0 });
        eventsSuspended.count++;
    }

    /**
     * Resume event triggering after a call to {@link #function-suspendEvents()}. If any triggered events were queued they will be triggered.
     * @returns `true` if events have been resumed (multiple calls to suspend require an equal number of resume calls to resume).
     */
    resumeEvents() {
        const suspended = this.eventsSuspended;
        if (suspended) {
            if (--suspended.count === 0) {
                this.eventsSuspended = null;
                if (suspended.shouldQueue) {
                    for (let queued of suspended.queue) {
                        this.trigger(...queued);
                    }
                }
            }
        }

        return !Boolean(this.eventsSuspended);
    }

    //endregion
};

/**
 * Keeps a map of registered widgets. Used by BryntumWidgetAdapter to create widgets using `{ type : 'xx' }`.
 * @private
 */
class BryntumWidgetAdapterRegister {
    static register(type, widgetClass) {
        const classEntry = widgetClassRegister[widgetClass];

        type = type.toLowerCase();
        
        // Create a mapping from the type to the class
        widgetRegister[type] = widgetClass;

        // Create a mapping from the class to its type identifier(s)
        if (classEntry) {
            classEntry[type] = 1;
        }
        else {
            widgetClassRegister[widgetClass] = {
                [type] : 1
            };
        }
    }

    static getClass(type) {
        return widgetRegister[type.toLowerCase()];
    }

    /**
     * Determines whether the passed widget matches the passed type. So a {@link Core.widget.Combo}
     * would match any of its three registered types, `'combobox'`, '`combo'` or `'dropdown'`.
     *
     * Pass the `deep` parameter as `true` to test the class hierarchy also, so if `deep`, a
     * {@link Core.widget.Combo} would also match `'pickerfield'`, `'field'` and `'widget'`.
     *
     * Note that this is *type* matching, not querying, so patterns such as `'*'` will not match.
     * @param {Core.widget.Widget} widget The widget to test.
     * @param {String} type The stype string to test against.
     * @param {Boolean} [deep] Whether to test the widget's superclass hierarchy.
     * @returns {Boolean} `true` if the passed widget matches the passed selector.
     */
    static isType(widget, type, deep) {
        type = type.toLowerCase();
        
        for (let widgetClass = widget.constructor; widgetClass; widgetClass = deep && Object.getPrototypeOf(widgetClass)) {
            // Find a registered entry.
            // If it's an abstract based class which was not registered (such as PickerField),
            // create an entry for it using its lowercased $name
            const
                // Built in widgets all define $name to be safer from obfustaction, but custom widgets might not
                name = widgetClass.hasOwnProperty('$name') ? widgetClass.$name : widgetClass.name,
                classEntry = widgetClassRegister[widgetClass] || (name && (widgetClassRegister[widgetClass] = {
                    [name.toLowerCase()] : 1
                }));

            if (classEntry && classEntry[type]) {
                return true;
            }
        }
    }

    static createWidget(type, config) {
        const widgetClass = this.getClass(type || 'widget');

        if (widgetClass) {
            return new widgetClass(config);
        }

        

        // eslint-disable-next-line no-unreachable
        return null;
    }
}

const
    widgetRegister = BryntumWidgetAdapterRegister.widgetRegister = {},
    widgetClassRegister = BryntumWidgetAdapterRegister.widgetClassRegister = {};
BryntumWidgetAdapterRegister._$name = 'BryntumWidgetAdapterRegister';

/**
 * @module Core/helper/IdHelper
 */

function isInstanceOfClass(instance, type) {
    const classHierarchy = instance.classHierarchy();

    for (let i = 0; i < classHierarchy.length; i++) {
        if (classHierarchy[i].$name.toLowerCase() === type) {
            return true;
        }
    }

    return false;
}

/**
 * IdHelper keeps an internal map of objects and ids, allowing easy retrieval by id. It can generate and assign
 * unique ids (in IdHelper context, not guaranteed to be unique on page), either explicitly or when registering objects
 * in its map.
 *
 * IdHelper also supplies some useful functions for querying Widgets.
 *
 * This class is not intended for application use, it is used internally by the Brytum infrastructure.
 * @internal
 * @private
 */
class IdHelper {
    /**
     * Generate a new id, using IdHelpers internal counter and a prefix
     * @param {String} prefix Id prefix
     * @returns {String} Generated id
     */
    static generateId(prefix = 'generatedId') {
        return prefix + (++IdHelper.idCounter);
    }

    /**
     * Register an object with IdHelper, assigning it a generated id if it has none. Throws if objects id is already
     * in use.
     * @param {Object} obj Any object
     * @param {String} prefix Prefix for generated id
     */
    static register(obj, prefix = '') {
        let objId = obj.id;

        if (objId == null) {
            objId = obj.id = IdHelper.generateId(prefix);
            obj.hasGeneratedId = true;
        }

        // Code editor sets `disableThrow` to not get conflicts when loading the same module again
        if (objId in IdHelper.idMap && !this.disableThrow) {
            throw new Error('Id ' + objId + ' already in use');
        }

        IdHelper.idMap[objId] = obj;
    }

    /**
     * Unregister from IdHelper, normally done on destruction
     * @param {Object} obj Object to unregister
     */
    static unregister(obj) {
        // Have to check for identity in case another instance by the same id has been created.
        if (IdHelper.idMap[obj.id] === obj) {
            delete IdHelper.idMap[obj.id];
        }
    }

    /**
     * Get an object using id
     * @param {String} id Object id
     * @returns {*} Object or undefined if none found
     */
    static get(id) {
        return IdHelper.idMap[id];
    }

    /**
     * Analogous to document.querySelector, finds the first Bryntum widget matching the passed
     * selector. Right now, only class name (lowercased) selector strings, or
     * a filter function which returns `true` for required object are allowed:
     * ```
     * bryntum.query('grid').destroy();
     * ```
     * @param {String|Function} selector A lowercased class name, or a filter function.
     * @param {Boolean} [deep] Specify `true` to search the prototype chain (requires supplying a string `selector`). For
     *   example 'widget' would then find a Grid
     * @return {Core.widget.Widget} The first matched widget if any.
     */
    static query(selector, deep = false) {
        const idMap = IdHelper.idMap;

        for (let id in idMap) {
            if (widgetMatches(idMap[id], selector, deep)) {
                return idMap[id];
            }
        }
        return null;
    }

    /**
     * Analogous to document.querySelectorAll, finds all Bryntum widgets matching the passed
     * selector. Right now, only registered widget `type` strings, or a filter function which
     * returns `true` for required object are allowed:
     * ```
     * let allFields = bryntum.queryAll('field', true);
     * ```
     * @param {String|Function} selector A lowercased class name, or a filter function.
     * @param {Boolean} [deep] Specify `true` to search the prototype chain (requires supplying a string `selector`). For
     *   example 'widget' would then find a Grid
     * @return {Core.widget.Widget[]} The first matched widgets if any - an empty array will be returned
     * if no matches are found.
     */
    static queryAll(selector, deep = false) {
        const
            idMap  = IdHelper.idMap,
            result = [];

        for (let id in idMap) {
            if (widgetMatches(idMap[id], selector, deep)) {
                result.push(idMap[id]);
            }
        }
        return result;
    }

    /**
     * Returns the Widget which owns the passed element (or event).
     * @param {HTMLElement|Event} element The element or event to start from
     * @param {String|Function} [type] The type of Widget to scan upwards for. The lowercase
     * class name. Or a filter function which returns `true` for the required Widget.
     * @param {HTMLElement|Number} [limit] The number of components to traverse upwards to find a
     * match of the type parameter, or the element to stop at.
     * @return {Widget} The found Widget or null.
     */
    static fromElement(element, type, limit) {
        const typeOfType = typeof type;

        // Event passed
        if (element && element instanceof Event) {
            element = element.target;
        }

        if (typeOfType === 'number' || type && type.nodeType === 1) {
            limit = type;
            type = null;
        }

        let target = element,
            cache = IdHelper.idMap,
            depth = 0,
            topmost, cmpId, cmp;

        if (typeof limit !== 'number') {
            topmost = limit;
            limit = Number.MAX_VALUE;
        }
        if (typeOfType === 'string') {
            type = type.toLowerCase();
        }

        while (target && target.nodeType === 1 && depth < limit && target !== topmost) {
            cmpId = (target.dataset && target.dataset.ownerCmp) || target.id;

            if (cmpId) {
                cmp = cache[cmpId];
                if (cmp) {
                    if (type) {
                        if (typeOfType === 'function') {
                            if (type(cmp)) {
                                return cmp;
                            }
                        }
                        else if (widgetMatches(cmp, type) || isInstanceOfClass(cmp, type)) {
                            return cmp;
                        }
                    }
                    else {
                        return cmp;
                    }
                }

                // Increment depth on every *Widget* found
                depth++;
            }

            target = target.parentNode;
        }

        return null;
    }
}

function widgetMatches(candidate, selector, deep) {
    if (selector === '*') {
        return true;
    }
    if (typeof selector === 'function') {
        return selector(candidate);
    }
    return BryntumWidgetAdapterRegister.isType(candidate, selector, deep);
}

IdHelper.idCounter = 0;
IdHelper.idMap = {};

// Simplify querying widgets by exposing fns in bryntum ns
(window.bryntum || (window.bryntum = {})).get = IdHelper.get;
window.bryntum.IdHelper = IdHelper;
window.bryntum.query = IdHelper.query;
window.bryntum.queryAll = IdHelper.queryAll;
window.bryntum.fromElement = IdHelper.fromElement;
IdHelper._$name = 'IdHelper';

/**
 * @module Core/helper/WidgetHelper
 */

/**
 * Helper for creating widgets. Needs an adapter to do the actual work, see
 * {@link Core.adapter.widget.BryntumWidgetAdapter} which is used in examples.
 *
 * NOTE: This concept is not yet fully realized.
 */
class WidgetHelper {
    //region Adapter

    /**
     * Gets/sets the adapter used for widgets. If not specified, it will default to {@link Core.adapter.widget.BryntumWidgetAdapter BryntumWidgetAdapter}
     * automatically as soon as this class is imported on the page. It's enough to use nameless import:
     *
     * ```javascript
     * import '../../lib/Core/adapter/widget/BryntumWidgetAdapter.js';
     * ```
     *
     * **Note:** If you try to operate on widgets before adapter is set, you'll get an error.
     *
     * @param adapterClass Adapter class
     * @category Adapter
     */
    static set adapter(adapterClass) {
        this._adapter = new adapterClass();
    }

    static get adapter() {
        if (!this._adapter) {
            throw new Error('Widget adapter is required. Please import BryntumWidgetAdapter class. See docs here: https://www.bryntum.com/docs/grid/#Core/adapter/widget/BryntumWidgetAdapter');
        }

        return this._adapter;
    }

    /**
     * Checks if an adapter is assigned
     * @returns {Boolean}
     * @category Adapter
     * @readonly
     */
    static get hasAdapter() {
        return !!this._adapter;
    }

    //endregion

    //region Querying

    /**
     * Returns the widget with the specified id.
     * @param id Id of widget to find
     * @returns {Core.widget.Widget} The widget if any
     * @category Querying
     */
    static getById(id) {
        return IdHelper.get(id);
    }

    /**
     * Returns the Widget which owns the passed element (or event).
     * @param {HTMLElement|Event} element The element or event to start from
     * @param {String|Function} [type] The type of Widget to scan upwards for. The lowercase
     * class name. Or a filter function which returns `true` for the required Widget.
     * @param {HTMLElement|Number} [limit] The number of components to traverse upwards to find a
     * match of the type parameter, or the element to stop at.
     * @returns {Core.widget.Widget} The found Widget or null.
     * @category Querying
     * @typings any
     */
    static fromElement(element, type, limit) {
        return IdHelper.fromElement(element, type, limit);
    }

    //endregion

    //region Widgets

    /**
     * Create a widget.
     * @example
     * WidgetHelper.createWidget({
     *   type: 'button',
     *   icon: 'user',
     *   text: 'Edit user'
     * });
     * @param config Widget config
     * @returns {Object} The widget
     * @category Widgets
     */
    static createWidget(config = {}) {
        return this.adapter.createWidget(config);
    }

    /**
     * Appends a widget (array of widgets) to the DOM tree. If config is empty, widgets are appended to the DOM. To
     * append widget to certain position you can pass HTMLElement or its id as config, or as a config, that will be
     * applied to all passed widgets.
     *
     * Usage:
     *
     * ```javascript
     * // Will append button as last item to element with id 'container'
     * let [button] = WidgetHelper.append({ type : 'button' }, 'container');
     *
     * // Same as above, but will add two buttons
     * let [button1, button2] = WidgetHelper.append([
     *     { type : 'button' },
     *     { type : 'button' }
     *     ], { appendTo : 'container' });
     *
     * // Will append two buttons before element with id 'someElement'. Order will be preserved and all widgets will have
     * // additional class 'my-cls'
     * let [button1, button2] = WidgetHelper.append([
     *     { type : 'button' },
     *     { type : 'button' }
     *     ], {
     *         insertBefore : 'someElement',
     *         cls          : 'my-cls'
     *     });
     * ```
     *
     * @param {Object|Object[]} widget Widget config or array of such configs
     * @param {HTMLElement|String|Object} [config] Element (or element id) to which to append the widget or config to apply to all passed widgets
     * @returns {Core.widget.Widget[]} Array or widgets
     * @category Widgets
     */
    static append(widget, config) {
        widget = Array.isArray(widget) && widget || [widget];

        if (config instanceof HTMLElement || typeof config === 'string') {
            config = {
                appendTo : config
            };
        }

        // We want to fix position to insert into to keep order of passed widgets
        if (config.insertFirst) {
            const target = typeof config.insertFirst === 'string' ? document.getElementById(config.insertFirst) : config.insertFirst;

            if (target.firstChild) {
                config.insertBefore = target.firstChild;
            }
            else {
                config.appendTo = target;
            }
        }

        return this.adapter.appendWidgets(widget, config);
    }

    //endregion

    //region Popups

    // TODO: Implement openWindow
    // /**
    //  * Opens a window with specified widgets. Not implemented yet...
    //  * @param config
    //  * @returns {Object}
    //  * @category Popups
    //  */
    // static openWindow(config) {
    //     return this.adapter.openWindow(config);
    // }

    /**
     * Shows a popup (~tooltip) containing widgets connected to specified element.
     * @example
     * WidgetHelper.openPopup(element, {
     *   position: 'bottom center',
     *   items: [
     *      { widgetConfig }
     *   ]
     * });
     * @param element Element to connect popup to
     * @param config Config object, or string to use as html in popup
     * @returns {*|{close, widgets}}
     * @category Popups
     */
    static openPopup(element, config) {
        return this.adapter.openPopup(element, config);
    }

    /**
     * Shows a context menu connected to the specified element.
     * @example
     * WidgetHelper.showContextMenu(element, {
     *   items: [
     *      { id: 'addItem', icon: 'add', text: 'Add' },
     *      ...
     *   ],
     *   onItem: item => alert('Clicked ' + item.text)
     * });
     * @param {HTMLElement|Number[]} element Element (or a coordinate) to show the context menu for
     * @param {Object} config Context menu config, see example
     * @returns {*|{close}}
     * @category Popups
     */
    static showContextMenu(element, config) {
        return this.adapter.showContextMenu(element, config);
    }

    /**
     * Attached a tooltip to the specified element.
     * @example
     * WidgetHelper.attachTooltip(element, {
     *   text: 'Useful information goes here'
     * });
     * @param element Element to attach tooltip for
     * @param configOrText Tooltip config or tooltip string, see example and source
     * @returns {Object}
     * @category Popups
     */
    static attachTooltip(element, configOrText) {
        return this.adapter.attachTooltip(element, configOrText);
    }

    /**
     * Checks if element has tooltip attached
     *
     * @param element Element to check
     * @return {Boolean}
     * @category Popups
     */
    static hasTooltipAttached(element) {
        return this.adapter.hasTooltipAttached(element);
    }

    /**
     * Destroys any tooltip attached to an element, removes it from the DOM and unregisters any tip related listeners
     * on the element.
     *
     * @param element Element to remove tooltip from
     * @category Popups
     */
    static destroyTooltipAttached(element) {
        return this.adapter.destroyTooltipAttached(element);
    }

    //endregion

    //region Mask

    /**
     * Masks the specified element, showing a message in the mask.
     * @param element Element to mask
     * @param msg Message to show in the mask
     * @category Mask
     */
    static mask(element, msg) {
        return this.adapter.mask(element, msg);
    }

    /**
     * Unmask the specified element.
     * @param element
     * @category Mask
     */
    static unmask(element, close = true) {
        this.adapter.unmask(element);
    }

    //endregion

    //region Toast

    /**
     * Show a toast
     * @param {String} msg message to show in the toast
     * @category Mask
     */
    static toast(msg) {
        this.adapter.toast(msg);
    }

    //endregion

    //region Style

    static set defaultStyle(style) {
        this.adapter.defaultStyle = style;
    }

    static get defaultStyle() {
        return this.adapter.defaultStyle;
    }

    //endregion
}
WidgetHelper._$name = 'WidgetHelper';

/**
 * @module Core/helper/BrowserHelper
 */

/**
 * Static helper class that does browser/feature detection.
 * @internal
 */
class BrowserHelper {

    static cacheFlags(platform = navigator.platform, userAgent = navigator.userAgent) {
        const me = this;

        // os
        me._isLinux = Boolean(platform.match(/Linux/));
        me._isMac = Boolean(platform.match(/Mac/));
        me._isWindows = Boolean(platform.match(/Win32/));

        // browser
        me._isIE11 = Boolean(userAgent.match(/rv:11/));

        me._edgeVersion = me.getVersion(userAgent, /Edge\/(\d+)\./);
        me._isEdge = me._edgeVersion > 0;

        // Edge user agent contain webkit too
        me._isWebkit = Boolean(userAgent.match(/WebKit/)) && !me._isEdge;

        me._firefoxVersion = me.getVersion(userAgent, /Firefox\/(\d+)\./);
        me._isFirefox = me._firefoxVersion > 0;

        me._chromeVersion = !me._isEdge ? me.getVersion(userAgent, /Chrom(?:e|ium)\/(\d+)\./) : 0;
        me._isChrome = me._chromeVersion > 0;

        me._isSafari = Boolean(userAgent.match(/Safari/)) && !me._isChrome && !me._isEdge;
        me._isMobileSafari = Boolean(userAgent.match(/Mobile.*Safari/));

        me._isAndroid = Boolean(userAgent.match(/Android/g));

        try {
            document.querySelector(':scope');
            // Scoped queries are not supported for custom element polyfill in firefox
            // https://app.assembla.com/spaces/bryntum/tickets/6781
            me.supportsQueryScope = !me._isFirefox;
        }
        catch (e) {
            me.supportsQueryScope = false;
        }

        me._supportsPassive = false;
        try {
            // If the browser asks the options object to yield its passive
            // property, we know it supports the object form options object
            // and passive listeners.
            document.addEventListener('__notvalid__', null, {
                get passive() {
                    me._supportsPassive = true;
                }
            });
        }
        catch (e) {}

        //document.addEventListener("DOMContentLoaded", me.onDocumentReady);
    }

    // NOTE: Not allowed with CSP, moved to Grid#render()
    // /**
    //  * Feature and browser detection which requires the document to be loaded.
    //  * @private
    //  */
    // static onDocumentReady() {
    //     // Firefox includes a part of the Y scroller jutting up which is not needed.
    //     // Also need to "mitre" the horizontal scrollbar to leave the gap at the end.
    //     if (BrowserHelper.isFirefox) {
    //         CSSHelper.insertRule(`.b-virtual-scroller {height: ${DomHelper.scrollBarWidth}px;}`);
    //         CSSHelper.insertRule(`.b-virtual-scrollers {padding-right: ${DomHelper.scrollBarWidth}px;}`);
    //     }
    // }

    /**
     * Returns matched version for userAgent
     * @param String versionRe version match regular expression
     * @returns {Number} matched version
     * @readonly
     * @private
     */
    static getVersion(userAgent, versionRe) {
        const match = userAgent.match(versionRe);
        return match ? parseInt(match[1]) : 0;
    }

    /**
     * Tries to determine if the user is using a touch device
     * @returns {Boolean}
     * @readonly
     */
    static get isTouchDevice() {
        if ('_isTouchDevice' in this) return this._isTouchDevice;

        return (('ontouchstart' in window) ||
            // edge tends to always have this with a value 2
            (!this.isEdge && navigator.maxTouchPoints > 0) ||
            // but if env is actually touchable, then window has this class present
            (this.isEdge && window.TouchEvent) ||
            (navigator.msMaxTouchPoints > 0));
    }

    // Since touch screen detection is unreliable we should allow client to configure it, or detect first touch
    static set isTouchDevice(value) {
        this._isTouchDevice = value;
    }

    /**
     * Checks if platform is mac
     * @returns {Boolean}
     * @readonly
     */
    static get isMac() {
        return this._isMac;
    }

    /**
     * Checks if platform is windows
     * @returns {Boolean}
     * @readonly
     */
    static get isWindows() {
        return this._isWindows;
    }

    /**
     * Checks if platform is linux
     * @returns {Boolean}
     * @readonly
     */
    static get isLinux() {
        return this._isLinux;
    }

    /**
     * Checks if browser is IE11
     * @returns {Boolean}
     * @readonly
     */
    static get isIE11() {
        return this._isIE11;
    }

    /**
     * Checks if browser is Edge
     * @returns {Boolean}
     * @readonly
     */
    static get isEdge() {
        return this._isEdge;
    }

    /**
     * Find the major Edge version
     * @returns {Number} Edge version or 0 for other browsers
     * @readonly
     */
    static get edgeVersion() {
        return this._edgeVersion;
    }

    /**
     * Checks if browser is Webkit
     * @returns {Boolean}
     * @readonly
     */
    static get isWebkit() {
        return this._isWebkit;
    }

    /**
     * Checks if browser is Chrome
     * @returns {Boolean}
     * @readonly
     */
    static get isChrome() {
        return this._isChrome;
    }

    /**
     * Find the major Chrome version
     * @returns {Number} Chrome version or 0 for other browsers
     * @readonly
     */
    static get chromeVersion() {
        return this._chromeVersion;
    }

    /**
     * Checks if browser is Firefox
     * @returns {Boolean}
     * @readonly
     */
    static get isFirefox() {
        return this._isFirefox;
    }

    /**
     * Find the major Firefox version.
     * @returns {Number} Firefox version or 0 for other browsers
     * @readonly
     */
    static get firefoxVersion() {
        return this._firefoxVersion;
    }
    /**
     * Checks if browser is Safari
     * @returns {Boolean}
     * @readonly
     */
    static get isSafari() {
        return this._isSafari;
    }

    /**
     * Checks if browser is mobile Safari
     * @returns {Boolean}
     * @readonly
     */
    static get isMobileSafari() {
        return this._isMobileSafari;
    }

    static get isAndroid() {
        return this._isAndroid;
    }

    /**
     * Returns `true` if the browser supports passive event listeners.
     */
    static get supportsPassive() {
        return this._supportsPassive;
    }

    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API
    static get storageAvailable() {
        let storage, x;

        try {
            storage = localStorage;
            x = '__storage_test__';

            storage.setItem(x, x);
            storage.removeItem(x);
            return true;
        }
        catch (e) {
            return e instanceof DOMException && (
                // everything except Firefox
                e.code === 22 ||
                // Firefox
                e.code === 1014 ||
                // test name field too, because code might not be present
                // everything except Firefox
                e.name === 'QuotaExceededError' ||
                // Firefox
                e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&
                // acknowledge QuotaExceededError only if there's something already stored
                storage.length !== 0;
        }
    }

    static setLocalStorageItem(key, value) {
        this.storageAvailable && localStorage.setItem(key, value);
    }

    static getLocalStorageItem(key) {
        return this.storageAvailable && localStorage.getItem(key);
    }

    static removeLocalStorageItem(key) {
        this.storageAvailable && localStorage.removeItem(key);
    }

    /**
     * Returns parameter value from search string by parameter name.
     * @param {String} paramName search parameter name
     * @param {*} [defaultValue] default value if parameter not found
     * @param {String} [search] search string. Defaults to `document.location.search`
     */
    static searchParam(paramName, defaultValue = null, search = document.location.search) {
        const
            re    = new RegExp(`[?&]${paramName}=([^&]*)`),
            match = search.match(re);
        return (match && match[1]) || defaultValue;
    }
}

BrowserHelper.cacheFlags();
BrowserHelper._$name = 'BrowserHelper';

/**
 * @module Core/helper/AjaxHelper
 */

const
    paramValueRegExp = /^(\w+)=(.*)$/,
    parseParams      = function (paramString) {
        const
            result = {},
            params = paramString.split('&');

        // loop through each 'filter={"field":"name","operator":"=","value":"Sweden","caseSensitive":true}' string
        // So we cannot use .split('=')
        for (const nameValuePair of params) {
            const [match, name, value] = paramValueRegExp.exec(nameValuePair);

            if (match) {
                let paramValue = result[name];

                if (paramValue) {
                    if (!Array.isArray(paramValue)) {
                        paramValue = result[name] = [paramValue];
                    }
                    paramValue.push(value);
                } else {
                    result[name] = value;
                }
            }
        }
        return result;
    };
/**
 * Simplifies Ajax requests. Uses fetch & promises.
 *
 * ```javascript
 * AjaxHelper.get('some-url').then(response => {
 *     // process request response here
 * });
 * ```
 *
 * Uploading file to server via FormData interface.
 * Please visit <https://developer.mozilla.org/en-US/docs/Web/API/FormData> for details.
 *
 * ```javascript
 * const formData = new FormData();
 * formData.append('file', 'fileNameToUpload');
 * AjaxHelper.post('file-upload-url', formData).then(response => {
 *     // process request response here
 * });
 * ```
 *
 */
class AjaxHelper {
    /**
     * Make a request (using GET) to the specified url.
     * @param {String} url Url
     * @param {Object} [options] The options for the `fetch` API. Please see <https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch> for details
     * @param {Object} [options.queryParams] A key-value pair Object containing the params to add to the query string
     * @param {Object} [options.headers] Any headers you want to add to your request, contained within a `Headers object or an object literal with ByteString values
     * @param {Object} [options.body] Any body that you want to add to your request: this can be a Blob, BufferSource, FormData, URLSearchParams, or USVString object. Note that a request using the GET or HEAD method cannot have a body.
     * @param {Object} [options.mode] The mode you want to use for the request, e.g., cors, no-cors, or same-origin.
     * @param {Object} [options.credentials] The request credentials you want to use for the request: omit, same-origin, or include. To automatically send cookies for the current domain, this option must be provided
     * @param {Object} [options.parseJson] Specify `true` to parses the response and attach the resulting object to the `Response` object as `parsedJson`
     * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
     */
    static get(url, options) {
        return this.fetch(url, options);
    }

    /**
     * POST data to the specified URL.
     * @param {String} url The URL
     * @param {String|Object|FormData} payload The data to post. If an object is supplied, it will be stringified
     * @param {Object} options The options for the `fetch` API. Please see <https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch> for details
     * @param {Object} [options.queryParams] A key-value pair Object containing the params to add to the query string
     * @param {Object} [options.headers] Any headers you want to add to your request, contained within a `Headers object or an object literal with ByteString values
     * @param {Object} [options.body] Any body that you want to add to your request: this can be a Blob, BufferSource, FormData, URLSearchParams, or USVString object. Note that a request using the GET or HEAD method cannot have a body.
     * @param {Object} [options.mode] The mode you want to use for the request, e.g., cors, no-cors, or same-origin.
     * @param {Object} [options.credentials] The request credentials you want to use for the request: omit, same-origin, or include. To automatically send cookies for the current domain, this option must be provided
     * @param {Object} [options.parseJson] Specify `true` to parses the response and attach the resulting object to the `Response` object as `parsedJson`
     * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
     */
    static post(url, payload, options = {}) {
        if (!(payload instanceof FormData) && !(typeof payload === 'string')) {
            payload = JSON.stringify(payload);
        }

        return this.fetch(url, Object.assign({
            method : 'POST',
            body   : payload
        }, options));
    }

    /**
     * Fetch the specified resource using the `fetch` API.
     * @param {String} url object to fetch
     * @param {Object} options The options for the `fetch` API. Please see <https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch> for details
     * @param {Object} [options.method] The request method, e.g., GET, POST
     * @param {Object} [options.queryParams] A key-value pair Object containing the params to add to the query string
     * @param {Object} [options.headers] Any headers you want to add to your request, contained within a `Headers object or an object literal with ByteString values
     * @param {Object} [options.body] Any body that you want to add to your request: this can be a Blob, BufferSource, FormData, URLSearchParams, or USVString object. Note that a request using the GET or HEAD method cannot have a body.
     * @param {Object} [options.mode] The mode you want to use for the request, e.g., cors, no-cors, or same-origin.
     * @param {Object} [options.credentials] The request credentials you want to use for the request: omit, same-origin, or include. To automatically send cookies for the current domain, this option must be provided
     * @param {Object} [options.parseJson] Specify `true` to parses the response and attach the resulting object to the `Response` object as `parsedJson`
     * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
     */
    static fetch(url, options = {}) {
        const
            controller = new AbortController();
        options.signal = controller.signal;

        if (!('credentials' in options)) {
            options.credentials = 'include';
        }

        if (options.queryParams) {
            const params = Object.entries(options.queryParams);
            if (params.length) {
                url += '?' + params.map(([param, value]) =>
                    `${param}=${encodeURIComponent(value)}`
                ).join('&');
            }
        }

        // Promise that will be resolved either when network request is finished or when json is parsed
        const promise = new Promise((resolve, reject) => {
            fetch(url, options).then(
                response => {
                    if (options.parseJson) {
                        response.json().then(json => {
                            response.parsedJson = json;
                            resolve(response);
                        }).catch(error => {
                            response.parsedJson = null;
                            response.error = error;
                            reject(response);
                        });
                    }
                    else {
                        resolve(response);
                    }
                }
            ).catch(error => {
                error.stack = promise.stack;

                reject(error);
            });
        });

        promise.stack = new Error().stack;

        promise.abort = function () {
            controller.abort();
        };

        return promise;
    }

    /**
     * Registers the passed URL to return the passed mocked up Fetch Response object to the
     * AjaxHelper's promise resolve function.
     * @param {String} url The url to return mock data for
     * @param {Object|Function} response A mocked up Fetch Response object which must contain
     * at least a `responseText` property, or a function to which the `url` and a `params` object
     * and the `Fetch` `options` object is passed which returns that.
     * @param {String} response.responseText The data to return.
     * @param {Boolean} [response.synchronous] resolve the Promise immediately
     * @param {Number} [response.delay=100] resolve the Promise after this number of milliseconds.
     */
    static mockUrl(url, response) {
        const me = this;

        (me.mockAjaxMap || (me.mockAjaxMap = {}))[url] = response;

        // Inject the override into the AjaxHelper instance
        if (!AjaxHelper.originalFetch) {
            AjaxHelper.originalFetch = AjaxHelper.fetch;
        }
        AjaxHelper.fetch = me.mockAjaxFetch.bind(me);
    }

    static mockAjaxFetch(url, options) {
        let urlAndParams = url.split('?'),
            result       = this.mockAjaxMap[urlAndParams[0]],
            parsedJson   = null;

        if (result) {
            if (typeof result === 'function') {
                result = result(urlAndParams[0], urlAndParams[1] && parseParams(urlAndParams[1]), options);
            }
            try {
                parsedJson = options.parseJson && JSON.parse(result.responseText);
            } catch (error) {
                parsedJson   = null;
                result.error = error;
            }

            result = Object.assign({
                status     : 200,
                ok         : true,
                headers    : new Headers(),
                statusText : 'OK',
                url        : url,
                parsedJson : parsedJson,
                text       : () => new Promise((resolve) => {
                    resolve(result.responseText);
                }),
                json       : () => new Promise((resolve) => {
                    resolve(parsedJson);
                })
            }, result);
            return new Promise(function (resolve, reject) {
                if (result.synchronous) {
                    resolve(result);
                } else {
                    setTimeout(function () {
                        resolve(result);
                    }, ('delay' in result ? result.delay : 100));
                }
            });
        } else {
            return AjaxHelper.originalFetch(url, options);
        }
    }
}
AjaxHelper._$name = 'AjaxHelper';

// No module tag here. That stops the singleton from being included by the docs.

/**
 * Singleton that handles switching locale. Locales can be included on page with `<script type="module">` tags or
 * loaded using ajax. When using script tags the first locale loaded is used per default, if another should be used as
 * default specify it on the script tag for the grid (see example below).
 *
 * ```
 * // Using Ecma 6 modules
 * &lt;script type="module" src="./Core/localization/SvSE.js"&gt;
 *
 * // Specify default when using scripts
 * &lt;script src="build/locales/grid-locale-SvSE.js"&gt;
 * &lt;script data-default-locale="En" src="build/grid-all.js"&gt;
 *
 * import LocaleManager from 'Core/localization/LocaleManager.js';
 * // Set locale using method
 * LocaleManager.applyLocale('SvSE');
 * // Or set locale using property
 * LocaleManager.locale = LocaleManager.locales.SvSE;
 * ```
 *
 * @demo Grid/localization
 * @singleton
 */
class LocaleManager extends Events(Base) {
    static get defaultConfig() {
        return {
            locales : {}
        };
    }

    construct(...args) {
        const me = this;

        super.construct(...args);

        // currentScript not working in IE11
        // if (document.currentScript && document.currentScript.dataset.defaultLocale) {
        //     me.defaultLocaleName = document.currentScript.dataset.defaultLocale;
        // }

        const
            scriptTag = document.querySelector('script[data-default-locale]');
        if (scriptTag) {
            me.defaultLocaleName = scriptTag.dataset.defaultLocale;
        }

        if (window.bryntum && window.bryntum.locales) {
            Object.keys(window.bryntum.locales).forEach(localeName => {
                // keeping this check in case some client tries to use an old locale
                if (!localeName.startsWith('moment')) {
                    const
                        locale = window.bryntum.locales[localeName];
                    if (locale.extends) {
                        me.extendLocale(locale.extends, locale);
                    }
                    else {
                        me.registerLocale(locale.localeName, { desc : locale.localeDesc, locale : locale });
                    }
                }
            });

            if (!me.locale) {
                // English locale is built in, no need to apply it here since it will be applied anyway
                if (me.defaultLocaleName !== 'En') {
                    // No locale applied, use default or first found
                    me.applyLocale(me.defaultLocaleName || Object.keys(me.locales)[0]);
                }
            }
        }
    }

    set locales(localeConfigs) {
        this._locales = localeConfigs;
    }

    /**
     * Get currently registered locales.
     * Returns an object with locale names (`localeName`) as properties.
     *
     * Example:
     * ```
     * const englishLocale = LocaleManager.locales.En;
     * ```
     *
     * this returns registered English locale object.
     * ```
     * {
     *   "desc": "English",
     *   "locale": {
     *     "localeName": "En",
     *     "localeDesc": "English",
     *
     *     ... (localization goes here)
     *
     *   }
     * }
     * ```
     * @readonly
     * @property {Object}
     */
    get locales() {
        return this._locales;
    }

    /**
     * Get/set currently used locale. Set a name of a locale to have it applied, or give a locale configuration to
     * have it registered and then applied
     * @property {String|Object}
     */
    set locale(locale) {
        if (typeof locale === 'string') {
            this.applyLocale(locale);
        }
        else {
            if (!locale.locale) {
                locale = {
                    locale,
                    localeName : locale.localeName || 'custom'
                };
            }

            this.registerLocale(locale.localeName, locale);
            this.applyLocale(locale.localeName);
        }
    }

    get locale() {
        return this._locale;
    }

    /**
     * Register a locale to make it available for applying.
     * Registered locales are available in {@link Core.localization.LocaleManager#property-locales-static}.
     * @param {String} name Name of locale (for example `En` or `SvSE`)
     * @param {Object} config Object with localized properties
     */
    registerLocale(name, config) {
        const me        = this,
            isDefault = me.defaultLocaleName === name,
            isCurrent = me.locale && me.locale.localeName === name,
            isFirst   = Object.keys(me.locales).length === 0;

        me.locales[name] = config;

        // if no default locale specified, use the first one. otherwise apply the default when it is registered
        // also reapply if current locale is registered again (first grid, then scheduler etc).
        if (isDefault || (!me.defaultLocaleName && (isFirst || isCurrent))) {
            me.internalApplyLocale(config);
        }
    }

    /**
     * Extend an already loaded locale to add additional translations.
     * @param {String} name Name of locale (for example `En` or `SvSE`)
     * @param {Object} config Object with localized properties
     */
    extendLocale(name, config) {
        const locale = this.locales[name];
        if (!locale) return false;

        Object.keys(config).forEach(cls => {
            if (!locale.locale[cls]) {
                locale.locale[cls] = config[cls];
            }
            else {
                Object.assign(locale.locale[cls], config[cls]);
            }
        });

        delete locale.locale.extends;

        return true;
    }

    internalApplyLocale(localeConfig) {
        const me = this;
        me._locale = localeConfig.locale;
        me.trigger('locale', localeConfig);
    }

    /**
     * Apply a locale. Locale must be defined in {@link Core.localization.LocaleManager#property-locales-static}.
     * If it is not loaded it will be loaded using AjaxHelper {@link Core.helper.AjaxHelper#function-get-static} request and then applied.
     * @param {String} name Name of locale to apply (for example `En` or `SvSE`)
     * @returns {boolean|Promise}
     */
    applyLocale(name, forceApply = false, ignoreError = false) {
        const me           = this,
            localeConfig = me.locales[name];

        if (localeConfig && localeConfig.locale && me._locale === localeConfig.locale && !forceApply) {
            // no need to apply same locale again
            return true;
        }

        // ignoreError is used in examples where one example might have defined a locale not available in another

        if (!localeConfig) {
            if (ignoreError) return true;

            throw new Error(`Locale ${name} not registered`);
        }

        function internalApply() {
            me.internalApplyLocale(localeConfig);
        }

        if (!localeConfig.locale) {
            return new Promise((resolve, reject) => {
                me.loadLocale(localeConfig.path).then(response => {
                    //const text      = response.substring(response.indexOf('{'), response.lastIndexOf('};') + 1),
                    //      getLocale = new Function('return ' + text);
                    response.text().then(text => {
                        // eslint-disable-next-line no-new-func
                        const parseLocale = new Function(text);
                        parseLocale();

                        localeConfig.locale = window.bryntum.locales[name];
                        internalApply();
                        resolve(localeConfig);
                    });
                }).catch(response => reject(response));
            });
        }

        internalApply();
        return true;
    }

    /**
     * Loads a locale using AjaxHelper {@link Core.helper.AjaxHelper#function-get-static} request.
     * @private
     * @param {String} path Path to locale file
     * @returns {Promise}
     */
    loadLocale(path) {
        return AjaxHelper.get(path);
    }
}

const
    LocaleManagerSingelton = new LocaleManager();

/**
 * @module Core/localization/Localizable
 */

/**
 * Mixin that simplifies localization of strings in a class.
 *
 * ```
 * // Get localized string
 * grid.L('sort')
 * ```
 *
 * @mixin
 */
var Localizable = Target => class Localizable extends (Target || Base) {
    static get defaultConfig() {
        return {
            localeClass           : null,
            localizableProperties : []
        };
    }

    static get inTextLocaleRegExp() {
        return /L{([^}]+)}/g;
    }

    // In case it's wrapped in 'L{text}'
    static parseText(text) {
        const match = this.inTextLocaleRegExp.exec(text);
        return match ? match[1] : text;
    }

    construct(config = {}, ...args) {
        const me = this;

        // Base class applies configs.
        super.construct(config, ...args);

        LocaleManagerSingelton.on('locale', me.updateLocalization, me);

        me.updateLocalization();
    }

    get localeClass() {
        // Trying to extract localeClass from a parent widget. null by default
        return this._localeClass || (this.parent && this.parent.localeClass) || null;
    }

    set localeClass(key) {
        this._localeClass = key;
    }

    localizeProperty(name) {
        const me = this;

        // need to translate string properties only
        if (typeof me[name] === 'string') {

            me.originalLocales = me.originalLocales || {};

            // Need to save original values since they will be overridden by localizable equivalents
            me.originalLocales[name] = me.originalLocales[name] || me[name];

            const text = me.originalLocales[name];

            // Doing localization from the original values
            if (text) {
                me[name] = me.L(text);
            }
        }
    }

    updateLocalization() {
        const me = this;

        me.localizableProperties && me.localizableProperties.forEach(me.localizeProperty, me);
    }

    static getTranslation(text, templateData, cls) {
        const { locale } = LocaleManagerSingelton;

        let result, name;

        if (locale) {
            text = this.parseText(text);

            // traverse prototypes to find localization
            while (cls && (name = typeof cls === 'string' ? cls : cls.$name || cls.name)) {
                const classTranslation = locale[name];

                if (classTranslation && text in classTranslation) {
                    const translation = classTranslation[text];

                    result = typeof translation === 'function' && templateData !== undefined ? translation(templateData) : translation;

                    // break the loop
                    break;
                }
                else if (typeof cls === 'string') {
                    break;
                }
                else {
                    cls = Object.getPrototypeOf(cls);
                }
            }
        }

        return result;
    }

    /**
     * Builds `localizableProperties` config value for the class instance by iterating
     * though the class ancestor classes and concatenating their `localizableProperties` values.
     * @param {Object} config The clas instance configuration object.
     * @private
     */
    buildLocalizableProperties(config) {
        const localizableProperties = [];

        if (config.localizableProperties) {
            localizableProperties.push(...config.localizableProperties);
        }

        // collect localizable properties defined on subclasses
        for (let cls = this.constructor.superclass; cls && cls !== Base; cls = cls.superclass) {
            const superConfigDefaultConfig = cls.getConfigDescriptor(true).defaultConfig;

            if (superConfigDefaultConfig && superConfigDefaultConfig.localizableProperties) {
                localizableProperties.push(
                    ...(superConfigDefaultConfig.localizableProperties.filter(i => localizableProperties.indexOf(i) < 0))
                );
            }
        }

        return localizableProperties;
    }

    startConfigure(config) {
        config.localizableProperties = this.buildLocalizableProperties(config);

        super.startConfigure(config);
    }

    /**
     * Get localized string, returns value of `text` if no localized string found
     * @param {String} text String key
     * @param {Object} [templateData] Data to supply to template if localized string is one
     * @returns {String}
     */
    static L(text, templateData = undefined, ...translationProviders) {

        // In case this static method is called directly third argument is not provided
        // just fallback to searching locales for the class itself
        if (!translationProviders.length) {
            translationProviders = [this];
        }

        let translation;

        translationProviders.some(cls => {
            translation = this.getTranslation(text, templateData, cls);
            return translation !== undefined;
        });

        return translation === undefined ? text : translation;
    }

    /**
     * Convenience function that can be called directly on the class that mixes Localizable in
     * @param {String} text String key
     * @param {Object} [templateData] Data to supply to template if localized string is one
     * @returns {String}
     * @category Misc
     * @example
     * button.text = grid.L('group');
     */
    L(text, templateData = undefined) {
        // If we have a different class set as translations provider
        // pass it first and use the class being translated as a fallback provider
        if (this.localeClass && this.localeClass !== this.constructor) {
            return Localizable.L(text, templateData, this.localeClass, this.constructor);
        }
        else {
            return Localizable.L(text, templateData, this.constructor);
        }
    }

    /**
     * Get the global LocaleManager
     * @returns {Core.localization.LocaleManager}
     * @category Misc
     */
    get localeManager() {
        return LocaleManagerSingelton;
    }
};

/*
Not ported:
-----------
Week of Year w 1 2 ... 52 53
wo 1st 2nd ... 52nd 53rd
ww 01 02 ... 52 53
Week Year gg 70 71 ... 29 30
gggg 1970 1971 ... 2029 2030
Week Year (ISO) GG 70 71 ... 29 30
GGGG 1970 1971 ... 2029 2030
Time Zone z or zz EST CST ... MST PST
Note: as of 1.6.0, the z/zz format tokens have been deprecated from plain moment objects. Read more about it here. However, they do work if you are using a specific time zone with the moment-timezone addon.
Z -07:00 -06:00 ... +06:00 +07:00
ZZ -0700 -0600 ... +0600 +0700
Unix Timestamp X 1360013296
Unix Millisecond Timestamp x 1360013296123
*/

const
    enOrdinalSuffix = number => number + ({ 1 : 'st', 2 : 'nd', 3 : 'rd' }[number[number.length - 1]] || 'th'),
    // Left-to-right unicode mark (https://www.codetable.net/decimal/8206)
    LTRSymbolRegexp = new RegExp('\u200E'),
    defaultValue    = (value, defValue) => isNaN(value) || value == null ? defValue : value,
    useIntlFormat   = (name, options, date) => {
        const formatter = intlFormatterCache[name] || (intlFormatterCache[name] = new Intl.DateTimeFormat(locale, options));
        let result = formatter.format(date);
        // IE11 inserts direction control characters to the start of the string
        // This breaks substring(0, 2). Skipping first character in the row for I
        // https://stackoverflow.com/questions/25574963/ies-tolocalestring-has-strange-characters-in-results
        if (BrowserHelper.isIE11) {
            result = result.replace(LTRSymbolRegexp, '');
        }
        return result;
    };

// These vars are set when changing locale

let locale             = 'en-US',
    ordinalSuffix      = enOrdinalSuffix,
    // Used to cache used formats, to not have to parse format string each time
    formatCache        = {},
    intlFormatterCache = {},
    parserCache        = {};

const
    MS_PER_DAY                 = 864e5,
    MS_PER_WEEK                = MS_PER_DAY * 7,
    DEFAULT_YEAR               = 1970,
    DEFAULT_MONTH              = 0,
    DEFAULT_DAY                = 1,
    formats                    = {
        // 1, 2, ... 11, 12
        M    : date => date.getMonth() + 1, //date.toLocaleDateString(locale, { month : 'numeric' }),
        // 1st, 2nd, 3rd, 4th, ... 11th, 12th
        Mo   : date => ordinalSuffix(formats.M(date).toString()),
        // 01, 02, ...
        MM   : date => (date.getMonth() + 1).toString().padStart(2, '0'), //date.toLocaleDateString(locale, { month : '2-digit' }),
        // Jan, Feb, ...
        MMM  : date => useIntlFormat('MMM', { month : 'short' }, date),
        // January, February, ...
        MMMM : date => useIntlFormat('MMMM', { month : 'long' }, date),

        // 1, 2, ...
        Q  : date => Math.ceil((date.getMonth() + 1) / 3),
        // 1st, 2nd, ...
        Qo : date => ordinalSuffix(formats.Q(date).toString()),

        // 1, 2, ...
        D  : date => date.getDate(), //date.toLocaleDateString(locale, { day : 'numeric' }),
        // 1st, 2nd, ...
        Do : date => ordinalSuffix(formats.D(date).toString()),
        // 01, 02, ...
        DD : date => date.getDate().toString().padStart(2, '0'), //date.toLocaleDateString(locale, { day : '2-digit' }),

        // 1, 2, ..., 365, 365
        DDD : date => Math.ceil(
            (
                new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12, 0, 0) -
                new Date(date.getFullYear(), 0, 0, 12, 0, 0)
            ) / MS_PER_DAY),
        // 1st, 2nd, ...
        DDDo : date => ordinalSuffix(formats.DDD(date).toString()),
        // 001, 002, ...
        DDDD : date => formats.DDD(date).toString().padStart(3, '0'),

        // 0, 1, ..., 6
        d    : date => date.getDay(),
        // 0th, 1st, ...
        do   : date => ordinalSuffix(date.getDay().toString()),
        // S, M, ...
        d1   : date => formats.ddd(date).substring(0, 1),
        // Su, Mo, ...
        dd   : date => formats.ddd(date).substring(0, 2),
        // Sun, Mon, ...
        ddd  : date => useIntlFormat('ddd', { weekday : 'short' }, date),
        // Sunday, Monday, ...
        dddd : date => useIntlFormat('dddd', { weekday : 'long' }, date),

        e : date => date.getDay(),
        E : date => date.getDay() + 1,

        // ISO week, 1, 2, ...
        W : date => {
            // Adapted from https://www.epochconverter.com/weeknumbers
            const target = new Date(date.valueOf());
            target.setDate(target.getDate() - (date.getDay() + 6) % 7 + 3);
            const firstThursday = target.valueOf();
            target.setMonth(0, 1);
            if (target.getDay() !== 4) {
                target.setMonth(0, 1 + ((4 - target.getDay()) + 7) % 7);
            }
            return 1 + Math.ceil((firstThursday - target) / MS_PER_WEEK);
        },
        Wo : date => ordinalSuffix(formats.W(date).toString()),
        WW : date => formats.W(date).toString().padStart(2, '0'),

        // 1979, 2018
        Y    : date => date.getFullYear(), //date.toLocaleDateString(locale, { year : 'numeric' }),
        // 79, 18
        YY   : date => date.getFullYear() % 100, //date.toLocaleDateString(locale, { year : '2-digit' }),
        // 1979, 2018
        YYYY : date => date.getFullYear(), //date.toLocaleDateString(locale, { year : 'numeric' }),

        // AM, PM
        A : date => date.getHours() < 12 ? 'AM' : 'PM',
        a : date => date.getHours() < 12 ? 'am' : 'pm',

        // 0, 1, ... 23
        H  : date => date.getHours(),
        // 00, 01, ...
        HH : date => date.getHours().toString().padStart(2, '0'),
        // 1, 2, ... 12
        h  : date => (date.getHours() % 12) || 12,
        // 01, 02, ...
        hh : date => formats.h(date).toString().padStart(2, '0'),
        // 1, 2, ... 24
        k  : date => date.getHours() + 1,
        // 01, 02, ...
        kk : date => formats.k(date).toString().padStart(2, '0'),
        // Locale specific (0 -> 24 or 1 AM -> 12 PM)
        K  : date => useIntlFormat('K', { hour : 'numeric' }, date),
        // Locale specific (00 -> 24 or 1 AM -> 12 PM)
        KK : date => useIntlFormat('KK', { hour : '2-digit' }, date),

        // 0, 1, ... 59
        m  : date => date.getMinutes(), //date.toLocaleTimeString(locale, { minute : 'numeric' }),
        // 00, 01, ...
        mm : date => formats.m(date).toString().padStart(2, '0'),

        // 0, 1, ... 59
        s  : date => date.getSeconds(), //date.toLocaleTimeString(locale, { second : 'numeric' }),
        // 00, 01, ...
        ss : date => formats.s(date).toString().padStart(2, '0'),

        // 0, 1, ... 9
        S   : date => date.getMilliseconds().toString().substr(0, 1),
        // 00, 01, ... 99
        SS  : date => date.getMilliseconds().toString().substr(0, 2).padEnd(2, '0'),
        // 000, 001, ... 999
        SSS : date => date.getMilliseconds().toString().substr(0, 3).padEnd(3, '0'),

        z  : date => useIntlFormat('z', { timeZoneName : 'short' }, date),
        zz : date => useIntlFormat('zz', { timeZoneName : 'long' }, date),

        LT  : date => useIntlFormat('LT', { hour : '2-digit', minute : '2-digit' }, date),
        LTS : date => useIntlFormat('LTS', { hour : '2-digit', minute : '2-digit', second : '2-digit' }, date),
        L   : date => useIntlFormat('L', { year : 'numeric', month : '2-digit', day : '2-digit' }, date),
        l   : date => useIntlFormat('l', { year : 'numeric', month : 'numeric', day : 'numeric' }, date),
        LL  : date => useIntlFormat('LL', { year : 'numeric', month : 'long', day : 'numeric' }, date),
        ll  : date => useIntlFormat('ll', { year : 'numeric', month : 'short', day : 'numeric' }, date),
        LLL : date => useIntlFormat('LLL', {
            year   : 'numeric',
            month  : 'long',
            day    : 'numeric',
            hour   : 'numeric',
            minute : '2-digit'
        }, date),
        lll : date => useIntlFormat('lll', {
            year   : 'numeric',
            month  : 'short',
            day    : 'numeric',
            hour   : 'numeric',
            minute : '2-digit'
        }, date),
        LLLL : date => useIntlFormat('LLLL', {
            year    : 'numeric',
            month   : 'long',
            day     : 'numeric',
            hour    : 'numeric',
            minute  : '2-digit',
            weekday : 'long'
        }, date),
        llll : date => useIntlFormat('llll', {
            year    : 'numeric',
            month   : 'short',
            day     : 'numeric',
            hour    : 'numeric',
            minute  : '2-digit',
            weekday : 'short'
        }, date)
    },
    // Want longest keys first, to not stop match at L of LTS etc.
    formatKeys                 = Object.keys(formats).sort((a, b) => b.length - a.length),
    formatRegexp               = `^(?:${formatKeys.join('|')})`,

    // return empty object, meaning value cannot be processed to a valuable date part
    emptyFn                    = () => ({}),
    parsers                    = {
        YYYY : str => ({ year : parseInt(str) }),
        Y    : str => ({ year : parseInt(str) }),
        YY   : str => {
            const year = parseInt(str);
            return { year : year + (year > 1968 ? 1900 : 2000) };
        },
        MM   : str => ({ month : parseInt(str) - 1 }),
        Mo   : str => ({ month : parseInt(str) - 1 }),
        DD   : str => ({ date : parseInt(str) }),
        M    : str => ({ month : parseInt(str) - 1 }),
        D    : str => ({ date : parseInt(str) }),
        Do   : str => ({ date : parseInt(str) }),
        DDD  : emptyFn,
        MMM  : emptyFn,
        MMMM : emptyFn,
        DDDo : emptyFn,
        DDDD : emptyFn,
        d    : emptyFn,
        do   : emptyFn,
        d1   : emptyFn,
        dd   : emptyFn,
        ddd  : emptyFn,
        dddd : emptyFn,
        Q    : emptyFn,
        Qo   : emptyFn,
        W    : emptyFn,
        Wo   : emptyFn,
        WW   : emptyFn,
        e    : emptyFn,
        E    : emptyFn,
        HH   : str => ({ hours : parseInt(str) }),
        hh   : str => ({ hours : parseInt(str) }),
        mm   : str => ({ minutes : parseInt(str) }),
        H    : str => ({ hours : parseInt(str) }),
        m    : str => ({ minutes : parseInt(str) }),
        ss   : str => ({ seconds : parseInt(str) }),
        s    : str => ({ seconds : parseInt(str) }),
        S    : str => ({ milliseconds : parseInt(str) }),
        SS   : str => ({ milliseconds : parseInt(str) }),
        SSS  : str => ({ milliseconds : parseInt(str) }),

        A : str => ({ amPm : str.toLowerCase() }),
        a : str => ({ amPm : str.toLowerCase() }),

        L  : 'MM/DD/YYYY',
        LT : 'HH:mm A',

        // Can either be Z (=UTC, 0) or +-HH:MM
        Z : str => {
            if (!str) {
                return {};
            }

            let timeZone = 0;
            // If string being parsed is more "detailed" than the format specified we can have more chars left,
            // thus check the last (for example HH:mmZ with input HH:mm:ssZ -> ssZ)
            if (!str.endsWith('Z')) {
                const matches = timeZoneRegEx.exec(str);

                // If timezone regexp matches, sting has time zone offset like '+02:00'
                if (matches) {
                    const
                        sign    = matches[1] === '+' ? 1 : -1,
                        hours   = parseInt(matches[2]) || 0,
                        minutes = parseInt(matches[3]) || 0;

                    timeZone = sign * (hours * 60 + minutes);
                }
                // otherwise we just return current time zone, because there's a Z key in the input
                else {
                    timeZone = -1 * new Date().getTimezoneOffset();
                }
            }
            return { timeZone };
        }
    },
    parserKeys                 = Object.keys(parsers).sort((a, b) => b.length - a.length),
    parserRegexp               = new RegExp(`(${parserKeys.join('|')})`),
    // Following regexp includes all formats that should be handled by Date class
    localeStrRegExp            = new RegExp('(l|LL|ll|LLL|lll|LLLL|llll)'),
    //    ISODateRegExp             = new RegExp('YYYY-MM-DD[T ]HH:mm:ss(.s+)?Z'),

    // Some validConversions are negative to show that it's not an exact conversion, just an estimate.
    validConversions           = {
        // The units below assume:
        // 30 days in a month, 91 days for a quarter and 365 for a year
        // 52 weeks per year, 4 per month, 13 per quarter
        year : {
            year        : 1,
            quarter     : 4,
            month       : 12,
            week        : 52,
            day         : 365,
            hour        : 24 * 365,
            minute      : 1440 * 365,
            second      : 86400 * 365,
            millisecond : 86400000 * 365
        },
        quarter : {
            year        : 1 / 4,
            quarter     : 1,
            month       : 3,
            week        : 4,
            day         : 91,
            hour        : 24 * 91,
            minute      : 1440 * 91,
            second      : 86400 * 91,
            millisecond : 86400000 * 91
        },
        month : {
            year        : 1 / 12,
            quarter     : 1 / 3,
            month       : 1,
            week        : 4,
            day         : -30,
            hour        : -24 * 30,
            minute      : -1440 * 30,
            second      : -86400 * 30,
            millisecond : -86400000 * 30
        },
        week : {
            year        : -1 / 52,
            quarter     : -1 / 13,
            month       : -1 / 4,
            day         : 7,
            hour        : 168,
            minute      : 10080,
            second      : 604800,
            millisecond : 604800000
        },
        day : {
            year        : -1 / 365,
            quarter     : -1 / 91,
            month       : -1 / 30,
            week        : 1 / 7,
            hour        : 24,
            minute      : 1440,
            second      : 86400,
            millisecond : 86400000
        },
        hour : {
            year        : -1 / (365 * 24),
            quarter     : -1 / (91 * 24),
            month       : -1 / (30 * 24),
            week        : 1 / 168,
            day         : 1 / 24,
            minute      : 60,
            second      : 3600,
            millisecond : 3600000
        },
        minute : {
            year        : -1 / (365 * 1440),
            quarter     : -1 / (91 * 1440),
            month       : -1 / (30 * 1440),
            week        : 1 / 10080,
            day         : 1 / 1440,
            hour        : 1 / 60,
            second      : 60,
            millisecond : 60000
        },
        second : {
            year        : -1 / (365 * 86400),
            quarter     : -1 / (91 * 86400),
            month       : -1 / (30 * 86400),
            week        : 1 / 604800,
            day         : 1 / 86400,
            hour        : 1 / 3600,
            minute      : 1 / 60,
            millisecond : 1000
        },
        millisecond : {
            year    : -1 / (365 * 86400000),
            quarter : -1 / (91 * 86400000),
            month   : -1 / (30 * 86400000),
            week    : 1 / 604800000,
            day     : 1 / 86400000,
            hour    : 1 / 3600000,
            minute  : 1 / 60000,
            second  : 1 / 1000
        }
    },

    normalizedUnits            = {
        ms           : 'millisecond',
        milliseconds : 'millisecond',
        s            : 'second',
        seconds      : 'second',
        m            : 'minute',
        minutes      : 'minute',
        h            : 'hour',
        hours        : 'hour',
        d            : 'day',
        days         : 'day',
        w            : 'week',
        weeks        : 'week',
        M            : 'month',
        months       : 'month',
        q            : 'quarter',
        quarters     : 'quarter',
        y            : 'year',
        years        : 'year'

    },

    withDecimalsDurationRegex  = /^\s*([-+]?\d+(?:[.,]\d*)?|[-+]?(?:[.,]\d+))\s*([^\s]+)?/i,
    noDecimalsDurationRegex    = /^\s*([-+]?\d+)(?![.,])\s*([^\s]+)?/i,
    canonicalUnitNames         = [
        'millisecond',
        'second',
        'minute',
        'hour',
        'day',
        'week',
        'month',
        'quarter',
        'year'
    ],
    canonicalUnitAbbreviations = [
        ['mil'],
        ['s', 'sec'],
        ['m', 'min'],
        ['h', 'hr'],
        ['d'],
        ['w', 'wk'],
        ['mo', 'mon', 'mnt'],
        ['q', 'quar', 'qrt'],
        ['y', 'yr']
    ],
    deltaUnits                 = [
        'year',
        'month',
        'week',
        'day',
        'hour',
        'minute',
        'second',
        'millisecond'
    ],
    // Used when creating a date from an object, to fill in any blanks
    dateProperties             = [
        'milliseconds',
        'seconds',
        'minutes',
        'hours',
        'date',
        'month',
        'year'
    ],
    // TODO: Should we provide special number parsing?
    parseNumber                = (n) => {
        const result = parseFloat(n);
        return isNaN(result) ? null : result;
    },
    timeZoneRegEx              = /([+-])(\d\d):*(\d\d)*$/,
    unitMagnitudes             = {
        millisecond : 0,
        second      : 1,
        minute      : 2,
        hour        : 3,
        day         : 4,
        week        : 5,
        month       : 6,
        quarter     : 7,
        year        : 8
    };

/**
 * @module Core/helper/DateHelper
 */

/**
 * Helps with date manipulation, comparison, parsing, formatting etc.
 *
 * ## Parsing strings
 * Use `DateHelper.parse()` to parse strings into dates. It accepts a date string and a format specifier.
 * The format specifier is string built up using the following tokens:
 *
 * | Unit        | Token | Description                |
 * |-------------|-------|----------------------------|
 * | Year        | YYYY  | 2018                       |
 * |             | YY    | < 68 -> 2000, > 68 -> 1900 |
 * | Month       | MM    | 01 - 12                    |
 * | Date        | DD    | 01 - 31                    |
 * | Hour        | HH    | 00 - 23 or 1 - 12          |
 * | Minute      | mm    | 00 - 59                    |
 * | Second      | ss    | 00 - 59                    |
 * | Millisecond | S     | 0 - 9                      |
 * |             | SS    | 00 - 99                    |
 * |             | SSS   | 000 - 999                  |
 * | AM/PM       | A     | AM or PM                   |
 * |             | a     | am or pm                   |
 * | TimeZone    | Z     | Z for UTC or +-HH:mm       |
 * | Predefined  | L     | Long date, MM/DD/YYYY      |
 * |             | LT    | Long time, HH:mm A         |
 *
 * For example:
 * ```
 * DateHelper.parse('2018-11-06', 'YYYY-MM-DD');
 * DateHelper.parse('13:14', 'HH:mm');
 * DateHelper.parse('6/11/18', 'DD/MM/YY');
 * ```
 *
 * ## Formatting dates
 * Use `DateHelper.format()` to create a string from a date using a format specifier. The format specifier is similar to
 * that used when parsing strings. It can use the following tokens (input used for output below is
 * `new Date(2018,8,9,18,7,8,145)`):
 *
 * | Unit                  | Token | Description & output                  |
 * |-----------------------|-------|---------------------------------------|
 * | Year                  | YYYY  | 2018                                  |
 * |                       | YY    | 18                                    |
 * |                       | Y     | 2018                                  |
 * | Quarter               | Q     | 3                                     |
 * |                       | Qo    | 3rd                                   |
 * | Month                 | MMMM  | September                             |
 * |                       | MMM   | Sep                                   |
 * |                       | MM    | 09                                    |
 * |                       | Mo    | 9th                                   |
 * |                       | M     | 9                                     |
 * | Week (iso)            | WW    | 36 (2 digit)                          |
 * |                       | Wo    | 36th                                  |
 * |                       | W     | 36                                    |
 * | Date                  | DDDD  | Day of year, 3 digits                 |
 * |                       | DDDo  | Day of year, ordinal                  |
 * |                       | DDD   | Day of year                           |
 * |                       | DD    | 09                                    |
 * |                       | Do    | 9th                                   |
 * |                       | D     | 9                                     |
 * | Weekday               | dddd  | Sunday                                |
 * |                       | ddd   | Sun                                   |
 * |                       | dd    | Su                                    |
 * |                       | do    | 0th                                   |
 * |                       | d     | 0                                     |
 * | Hour                  | HH    | 18 (00 - 23)                          |
 * |                       | H     | 18 (0 - 23)                           |
 * |                       | hh    | 06 (00 - 12)                          |
 * |                       | h     | 6 (0 - 12)                            |
 * |                       | KK    | 19 (01 - 24)                          |
 * |                       | K     | 19 (1 - 24)                           |
 * |                       | kk    | 06 or 18, locale determines           |
 * |                       | k     | 6 or 18, locale determines            |
 * | Minute                | mm    | 07                                    |
 * |                       | m     | 7                                     |
 * | Second                | ss    | 08                                    |
 * |                       | s     | 8                                     |
 * | Millisecond           | S     | 1                                     |
 * |                       | SS    | 14                                    |
 * |                       | SSS   | 145                                   |
 * | AM/PM                 | A     | AM or PM                              |
 * |                       | a     | am or pm                              |
 * | Predefined            | LT    | H: 2-digit (2d), m: 2d                |
 * | (uses browser locale) | LTS   | H: 2d, m: 2d, s : 2d                  |
 * |                       | L     | Y: numeric (n), M : 2d, D : 2d        |
 * |                       | l     | Y: n, M : n, D : n                    |
 * |                       | LL    | Y: n, M : long (l), D : n             |
 * |                       | ll    | Y: n, M : short (s), D : n            |
 * |                       | LLL   | Y: n, M : l, D : n, H: n, m: 2d       |
 * |                       | lll   | Y: n, M : s, D : n, H: n, m: 2d       |
 * |                       | LLLL  | Y: n, M : l, D : n, H: n, m: 2d, d: l |
 * |                       | llll  | Y: n, M : s, D : n, H: n, m: 2d, d: s |
 *
 * For example:
 *
 * ```javascript
 * DateHelper.format(new Date(2018,10,6), 'YYYY-MM-DD'); // 2018-11-06
 * DateHelper.format(new Date(2018,10,6), 'M/D/YY'); // 11/6/18
 * ```
 *
 * Arbitrary text can be embedded in the format string by wrapping it with {}:
 *
 * ```javascript
 * DateHelper.format(new Date(2019, 7, 16), '{It is }dddd{, yay!}') -> It is Friday, yay!
 * ```
 *
 * ## Unit names
 * Many DateHelper functions (for example add, as, set) accepts a unit among their params. The following units are
 * available:
 *
 * | Unit        | Aliases                       |
 * |-------------|-------------------------------|
 * | millisecond | millisecond, milliseconds, ms |
 * | second      | second, seconds, s            |
 * | minute      | minute, minutes, m            |
 * | hour        | hour, hours, h                |
 * | day         | day, days, d                  |
 * | week        | week, weeks, w                |
 * | month       | month, months, M              |
 * | quarter     | quarter, quarters, q          |
 * | year        | year, years, y                |
 *
 * For example:
 * ```javascript
 * DateHelper.add(date, 2, 'days');
 * DateHelper.as('hour', 7200, 'seconds');
 * ```
 */
class DateHelper extends Localizable() {
    //region Parse & format
    /**
     * Get/set the default format used by `format()` and `parse()`. Defaults to `'YYYY-MM-DDTHH:mm:ssZ'`
     * (~ISO 8601 Date and time, `'1962-06-17T09:21:34Z'`).
     * @member {String}
     */
    static set defaultFormat(format) {
        this._defaultFormat = format;
    }

    static get defaultFormat() {
        return this._defaultFormat || 'YYYY-MM-DDTHH:mm:ssZ';
    }

    static buildParser(format) {

        // Split input format by regexp, which includes predefined patterns. Normally format would have some
        // splitters, like 'YYYY-MM-DD' or 'D/M YYYY' so output will contain matched patterns as well as splitters
        // which would serve as anchors. E.g. provided format is 'D/M!YYYY' and input is `11/6!2019` algorithm would work like:
        // 1. split format by regexp                // ['', 'D', '/', 'M', '!', 'YYYY', '']
        // 2. find splitters                        // ['/', '!']
        // 3. split input by seps, step by step     // ['11', ['6', ['2019']]]

        // Inputs like 'YYYYY' (5*Y) means 'YYYY' + 'Y', because it matches patterns from longer to shorter,
        // but if few patterns describe same unit the last one is applied, for example
        // DH.parse('20182015', 'YYYYY') equals to new Date(2015, 0, 0)

        const
            parts  = format.split(parserRegexp),
            parser = [];

        // if length of the parts array is 1 - there are no regexps in the input string. thus - no parsers
        // do same if there are patterns matching locale strings (l, ll, LLLL etc.)
        // returning empty array to use new Date() as parser
        if (parts.length === 1 || localeStrRegExp.test(format)) {
            return [];
        }
        else {
            parts.reduce((prev, curr, index, array) => {

                // ignore first and last empty string
                if (index !== 0 || curr !== '') {

                    // if current element matches parser regexp store it as a parser
                    if (parserRegexp.test(curr)) {
                        const
                            localeParsers = this.L('parsers') !== 'parsers' && this.L('parsers') || {},
                            fn            = localeParsers[curr] || parsers[curr];

                        // Z should be last element in the string that matches regexp. Last array element is always either
                        // an empty string (if format ends with Z) or splitter (everything that doesn't match regexp after Z)
                        // If there is a pattern after Z, then Z index will be lower than length - 2
                        if (curr === 'Z' && index < array.length - 2) {
                            throw new Error(`Invalid format ${format} TimeZone (Z) must be last token`);
                        }

                        // If fn is a string, we found an alias (L, LLL, l etc.).
                        // Need to build parsers from mapped format and merge with existing
                        if (typeof fn === 'string') {

                            // we are going to merge nested parsers with current, some cleanup required:
                            // 1. last element is no longer last
                            // 2. need to pass last parser to the next step
                            const
                                nestedParsers = DateHelper.buildParser(fn),
                                lastItem      = nestedParsers.pop();
                            delete lastItem.last;

                            // elevate nested parsers
                            parser.push(...nestedParsers);

                            prev = lastItem;
                        }
                        else {
                            prev.pattern = curr;
                            prev.fn = parsers[curr];
                        }

                    }
                    // if it doesn't match - we've found a splitter
                    else {
                        prev.splitter = curr;
                        parser.push(prev);
                        prev = {};
                    }
                }
                else if (prev.hasOwnProperty('pattern')) {
                    parser.push(prev);
                }
                return prev;
            }, {});
        }

        parser[parser.length - 1].last = true;

        return parser;
    }

    /**
     * Returns a date created from the supplied string using the specified format. Will try to create even if format
     * is left out, by first using the default format (see {@link #property-defaultFormat-static}, by default
     * `YYYY-MM-DDTHH:mm:ssZ`) and then using `new Date(dateString)`.
     * Supported tokens:
     *
     * | Unit        | Token | Description                |
     * |-------------|-------|----------------------------|
     * | Year        | YYYY  | 2018                       |
     * |             | YY    | < 68 -> 2000, > 68 -> 1900 |
     * | Month       | MM    | 01 - 12                    |
     * | Date        | DD    | 01 - 31                    |
     * | Hour        | HH    | 00 - 23 or 1 - 12          |
     * | Minute      | mm    | 00 - 59                    |
     * | Second      | ss    | 00 - 59                    |
     * | Millisecond | S     | 0 - 9                      |
     * |             | SS    | 00 - 99                    |
     * |             | SSS   | 000 - 999                  |
     * | AM/PM       | A     | AM or PM                   |
     * |             | a     | am or pm                   |
     * | TimeZone    | Z     | Z for UTC or +-HH:mm       |
     * | Predefined  | L     | Long date, MM/DD/YYYY      |
     * |             | LT    | Long time, HH:mm A         |
     *
     * Predefined formats and functions used to parse tokens can be localized, see for example the swedish locale SvSE.js
     *
     * NOTE: If no date parameters are provided then `Jan 01 1970` is used as a default date
     *
     * @param {String} dateString Date string
     * @param {String} format Date format (or {@link #property-defaultFormat-static} if left out)
     * @returns {Date}
     * @category Parse & format
     */
    static parse(dateString, format = this.defaultFormat) {
        if (dateString instanceof Date) {
            return dateString;
        }

        if (typeof dateString !== 'string' || !dateString) {
            return null;
        }

        // // For ISO 8601 native is faster, but not very forgiving
        // if (format === defaultFormat) {
        //     const dt = new Date(dateString);
        //     if (!isNaN(dt)) {
        //         return dt;
        //     }
        // }

        const config = {
            year         : null,
            month        : null,
            date         : null,
            hours        : null,
            minutes      : null,
            seconds      : null,
            milliseconds : null
        };

        let parser = parserCache[format],
            result;

        if (!parser) {
            parser = parserCache[format] = DateHelper.buildParser(format);
        }

        // Each parser knows its pattern and splitter. It looks for splitter in the
        // input string, takes first substring and tries to process it. Remaining string
        // is passed to the next parser.
        parser.reduce((dateString, parser) => {
            if (parser.last) {
                Object.assign(config, parser.fn(dateString));
            }
            else {
                let splitAt;

                // ISO 8601 says that T symbol can be replaced with a space
                if (parser.splitter === 'T' && dateString.indexOf('T') === -1) {
                    splitAt = dateString.indexOf(' ');
                }
                else {
                    // If splitter specified find its position, otherwise try to determine pattern length
                    splitAt = parser.splitter !== '' ? dateString.indexOf(parser.splitter) : parser.pattern && parser.pattern.length || -1;
                }

                let part, rest;

                // If splitter is not found in the current string we may be dealing with
                // 1. partial input - in that case we just feed all string to current parser and move on
                // 2. time zone (ssZ - splitter is empty string) and pattern is not specified, see comment below
                if (splitAt === -1) {
                    // NOTE: parentheses are required here as + and - signs hold valuable information
                    // with parentheses we get array like ['00','+','01:00'], omitting them we won't get
                    // regexp match in result, loosing information
                    const chunks = dateString.split(/([Z\-+])/);

                    // If splitter is not found in the string, we may be dealing with string that contains info about TZ.
                    // For instance, if format contains Z as last arg which is not separated (normally it is not indeed),
                    // like 'YYYY-MM-DD HH:mm:ssZ', then second to last parser will have string that it cannot just parse, like
                    // '2010-01-01 10:00:00'        -> '00'
                    // '2010-01-01 10:00:00Z'       -> '00Z'
                    // '2010-01-01 10:00:00-01'     -> '00-01'
                    // '2010-01-01 10:00:00+01:30'  -> '00+01:30'
                    // this cannot be processed by date parsers, so we need to process that additionally. So we
                    // split string by symbols that can be found around timezone info: Z,-,+
                    if (chunks.length === 1) {
                        part = dateString;
                        rest = '';
                    }
                    else {
                        part = chunks[0];
                        rest = `${chunks[1]}${chunks[2]}`;
                    }
                }
                else {
                    part = dateString.substring(0, splitAt) || dateString;
                    rest = dateString.substring(splitAt + parser.splitter.length);
                }

                parser.fn && Object.assign(config, parser.fn(part));

                return rest;
            }
        }, dateString);

        // If year is specified date has to be greater than 0
        if (config.year && !config.date) {
            config.date = 1;
        }

        const date = this.create(config);

        if (date) {
            result = date;
        }
        else {
            // Last resort, try if native passing can do it
            result = new Date(dateString);
        }

        return result;
    }

    /**
     * Creates a date from a date definition object. The object can have the following properties:
     * - year
     * - month
     * - date (day in month)
     * - hours
     * - minutes
     * - seconds
     * - milliseconds
     * - amPm : 'am' or 'pm', implies 12 hour clock
     * - timeZone : offset from UTC in minutes
     * @param {Object} definition
     * @returns {Date}
     * @category Parse & format
     */
    static create(definition) {
        // Shallow clone to not alter input
        const def = Object.assign({}, definition);

        let invalid = isNaN(def.year),
            useUTC  = false;

        // Not much validation yet, only considered invalid if all properties are null
        if (!invalid) {
            let allNull = true;

            dateProperties.forEach(property => {
                if (!(property in def) || isNaN(def[property])) {
                    def[property] = 0;
                }
                allNull = allNull && def[property] === null;
            });

            invalid = allNull;
        }

        if (def.amPm === 'pm') {
            def.hours = (def.hours % 12) + 12;
        }

        if ('timeZone' in def) {
            useUTC = true;

            def.minutes -= def.timeZone;
        }

        if (invalid) {
            return null;
        }

        const
            args = [
                defaultValue(def.year, DEFAULT_YEAR),
                defaultValue(def.month, DEFAULT_MONTH),
                defaultValue(def.date, DEFAULT_DAY),
                def.hours,
                def.minutes,
                def.seconds,
                def.milliseconds
            ];

        return useUTC ? new Date(Date.UTC(...args)) : new Date(...args);
    }

    /**
     * Converts a date to string with the specified format. Formats heavily inspired by https://momentjs.com.
     * Available formats (input used for output below is `new Date(2018,8,9,18,7,8,145)`):
     *
     * | Unit                  | Token | Description & output                  |
     * |-----------------------|-------|---------------------------------------|
     * | Year                  | YYYY  | 2018                                  |
     * |                       | YY    | 18                                    |
     * |                       | Y     | 2018                                  |
     * | Quarter               | Q     | 3                                     |
     * |                       | Qo    | 3rd                                   |
     * | Month                 | MMMM  | September                             |
     * |                       | MMM   | Sep                                   |
     * |                       | MM    | 09                                    |
     * |                       | Mo    | 9th                                   |
     * |                       | M     | 9                                     |
     * | Week (iso)            | WW    | 36 (2 digit)                          |
     * |                       | Wo    | 36th                                  |
     * |                       | W     | 36                                    |
     * | Date                  | DDDD  | Day of year, 3 digits                 |
     * |                       | DDDo  | Day of year, ordinal                  |
     * |                       | DDD   | Day of year                           |
     * |                       | DD    | 09                                    |
     * |                       | Do    | 9th                                   |
     * |                       | D     | 9                                     |
     * | Weekday               | dddd  | Sunday                                |
     * |                       | ddd   | Sun                                   |
     * |                       | dd    | Su                                    |
     * |                       | do    | 0th                                   |
     * |                       | d     | 0                                     |
     * | Hour                  | HH    | 18 (00 - 23)                          |
     * |                       | H     | 18 (0 - 23)                           |
     * |                       | hh    | 06 (00 - 12)                          |
     * |                       | h     | 6 (0 - 12)                            |
     * |                       | KK    | 19 (01 - 24)                          |
     * |                       | K     | 19 (1 - 24)                           |
     * |                       | kk    | 06 or 18, locale determines           |
     * |                       | k     | 6 or 18, locale determines            |
     * | Minute                | mm    | 07                                    |
     * |                       | m     | 7                                     |
     * | Second                | ss    | 08                                    |
     * |                       | s     | 8                                     |
     * | Millisecond           | S     | 1                                     |
     * |                       | SS    | 14                                    |
     * |                       | SSS   | 145                                   |
     * | AM/PM                 | A     | AM or PM                              |
     * |                       | a     | am or pm                              |
     * | Predefined            | LT    | H: 2-digit (2d), m: 2d                |
     * | (uses browser locale) | LTS   | H: 2d, m: 2d, s : 2d                  |
     * |                       | L     | Y: numeric (n), M : 2d, D : 2d        |
     * |                       | l     | Y: n, M : n, D : n                    |
     * |                       | LL    | Y: n, M : long (l), D : n             |
     * |                       | ll    | Y: n, M : short (s), D : n            |
     * |                       | LLL   | Y: n, M : l, D : n, H: n, m: 2d       |
     * |                       | lll   | Y: n, M : s, D : n, H: n, m: 2d       |
     * |                       | LLLL  | Y: n, M : l, D : n, H: n, m: 2d, d: l |
     * |                       | llll  | Y: n, M : s, D : n, H: n, m: 2d, d: s |
     *
     * Some examples:
     *
     * ```
     * DateHelper.format(new Date(2019, 7, 16), 'dddd') -> Friday
     * DateHelper.format(new Date(2019, 7, 16, 14, 27), 'HH:mm') --> 14:27
     * DateHelper.format(new Date(2019, 7, 16, 14, 27), 'L HH') --> 2019-07-16 14
     * ```
     *
     * Arbitrary text can be embedded in the format string by wrapping it with {}:
     *
     * ```
     * DateHelper.format(new Date(2019, 7, 16), '{It is }dddd{, yay!}') -> It is Friday, yay!
     * ```
     *
     * @param {Date} date Date
     * @param {String} format Desired format (uses `defaultFormat` if left out)
     * @returns {String} Formatted string
     * @category Parse & format
     */
    static format(date, format = this.defaultFormat) {
        // Bail out if no date or invalid date
        if (!date || isNaN(date)) {
            return null;
        }

        let formatter = formatCache[format],
            output    = '';

        if (!formatter) {
            formatter = formatCache[format] = [];

            // Build formatter array with the steps needed to format the date
            for (let i = 0; i < format.length; i++) {
                // Matches a predefined format?
                const
                    formatMatch = format.substr(i).match(formatRegexp),
                    predefined  = formatMatch && formatMatch[0];

                if (predefined) {
                    const localeFormats = this.L('formats') !== 'formats' && this.L('formats') || {},
                        fn            = localeFormats[predefined] || formats[predefined];
                    formatter.push(fn);
                    i += predefined.length - 1;
                }
                // Start of text block? Append it
                else if (format[i] === '{') {
                    // Find closing brace
                    const index = format.indexOf('}', i + 1);

                    // No closing brace, grab rest of string
                    if (index === -1) {
                        formatter.push(format.substr(i + 1));
                        i = format.length;
                    }
                    // Closing brace found
                    else {
                        formatter.push(format.substring(i + 1, index));
                        // Carry on after closing brace
                        i = index;
                    }
                }
                // Otherwise append to output (for example - / : etc)
                else {
                    formatter.push(format[i]);
                }
            }
        }

        formatter.forEach(step => {
            if (typeof step === 'string') {
                output += step;
            }
            else {
                output += step(date);
            }
        });

        // MS inserts a Left-to-right control char between localized date parts, remove it to have the expected string
        // output. Otherwise comparision with typed strings will fail
        if (BrowserHelper.isEdge || BrowserHelper.isIE11) {
            output = output.replace(/\u200E/g, '');
        }

        return output;
    }

    /**
     * Converts the specified amount of desired unit into milliseconds. Can be called by only specifying a unit as the
     * first argument, it then uses amount = 1. For example: asMilliseconds('hour') == asMilliseconds(1, 'hour')
     * @param {Number|String} amount Amount, what of is decided by specifying unit (also takes a unit which implies an amount of 1)
     * @param {String} unit Time unit (s, hour, months etc.)
     * @returns {Number}
     * @category Parse & format
     */
    static asMilliseconds(amount, unit = null) {
        if (typeof amount === 'string') {
            unit = amount;
            amount = 1;
        }

        return this.as('millisecond', amount, unit);
    }

    /**
     * Converts a millisecond time delta to a human readable form. For example `1000 * 60 * 60 * 50`
     * milliseconds would be rendered as "2 days, 2 hours"
     * @param {Number} delta The millisecond delta value.
     * @param {Boolean} [abbrev] Pass `true` to use abbreviated unit names, eg "2d, 2h" for the above example.
     * @category Parse & format
     */
    static formatDelta(delta, abbrev = false) {
        const
            result  = [],
            getUnit = abbrev ? this.getShortNameOfUnit : this.getLocalizedNameOfUnit,
            sep     = abbrev ? '' : ' ';

        // Loop downwards through the magnitude of units from year -> ms
        for (const unitName of deltaUnits) {
            const d = Math.floor(this.as(unitName, delta));

            // If there's a non-zero integer quantity of this unit, add it to result
            // and subtract from the delta, then go round to next unit down.
            if (d) {
                result.push(`${d}${sep}${getUnit.call(this, unitName, d > 1)}`);
                delta -= this.as('ms', d, unitName);
            }
            if (!delta) {
                break;
            }
        }

        return result.join(', ');
    }

    /**
     * Converts the specified amount of one unit (fromUnit) into an amount of another unit (toUnit)
     * @param toUnit
     * @param amount
     * @param fromUnit
     * @returns {Number}
     * @category Parse & format
     */
    static as(toUnit, amount, fromUnit = 'ms') {
        if (toUnit === fromUnit) return amount;

        toUnit = this.normalizeUnit(toUnit);
        fromUnit = this.normalizeUnit(fromUnit);

        // validConversions[][] can be negative to signal that conversion is not exact, ignore sign here
        if (unitMagnitudes[fromUnit] > unitMagnitudes[toUnit]) {
            return amount * Math.abs(validConversions[fromUnit][toUnit]);
        }
        else {
            return amount / Math.abs(validConversions[toUnit][fromUnit]);
        }
    }

    static formatContainsHourInfo(format) {
        const
            stripEscapeRe = /(\\.)/g,
            hourInfoRe    = /([HhKkmSsAa]|LT|L{3,}|l{3,})/;

        return hourInfoRe.test(format.replace(stripEscapeRe, ''));
    }

    /**
     * Returns true for 24 hour format.
     * @param {String} format Date format
     * @returns {Boolean}
     * @category Parse & format
     */
    static is24HourFormat(format) {
        return this.format(this.getTime(13, 0, 0), format).includes('13');
    }

    //endregion

    //region Manipulate

    /**
     * Add days, hours etc. to a date. Always clones the date, original will be left unaffected.
     * @param {Date} date Original date
     * @param {Number} amount Amount of days, hours etc
     * @param {String} unit Unit for amount
     * @returns {Date} New calculated date
     * @category Manipulate
     */
    static add(date, amount, unit = 'ms') {
        const me = this;

        let d;

        if (typeof date === 'string') {
            d = me.parse(date);
        }
        else {
            d = new Date(date.getTime());
        }

        if (!unit || amount === 0) return d;

        unit = DateHelper.normalizeUnit(unit);

        switch (unit) {
            case 'millisecond':
                d = new Date(d.getTime() + amount);
                break;
            case 'second':
                d = new Date(d.getTime() + (amount * 1000));
                break;
            case 'minute':
                d = new Date(d.getTime() + (amount * 60000));
                break;
            case 'hour':
                d = new Date(d.getTime() + (amount * 3600000));
                break;
            case 'day':
                // Integer value added, do calendar calculation to correctly handle DST etc.
                if (amount % 1 === 0) {
                    d.setDate(d.getDate() + amount);
                }
                // No browsers support fractional values for dates any longer, do time based calculation
                else {
                    d = new Date(d.getTime() + (amount * 86400000));
                }

                if (d.getHours() === 23 && d.getHours() === 0) {
                    d = me.add(d, 1, 'hour');
                }
                break;
            case 'week':
                d.setDate(d.getDate() + amount * 7);
                break;
            case 'month': {
                let day = d.getDate();
                if (day > 28) {
                    day = Math.min(day, me.getLastDateOfMonth(me.add(me.getFirstDateOfMonth(d), amount, 'month')).getDate());
                }
                d.setDate(day);
                d.setMonth(d.getMonth() + amount);
                break;
            }
            case 'quarter':
                d = me.add(d, amount * 3, 'month');
                break;
            case 'year':
                d.setFullYear(d.getFullYear() + amount);
                break;
        }
        return d;
    }

    /**
     * Calculates the difference between two dates, in the specified unit.
     * @param {Date} start First date
     * @param {Date} end Second date
     * @param {String} unit Unit to calculate difference in
     * @param {Boolean} fractional Specify false to round result
     * @returns {Number} Difference in the specified unit
     * @category Manipulate
     */
    static diff(start, end, unit = 'ms', fractional = true) {
        unit = DateHelper.normalizeUnit(unit);

        if (!start || !end) return 0;

        let amount;

        switch (unit) {
            case 'year':
                amount = this.diff(start, end, 'month') / 12;
                break;

            case 'quarter':
                amount = this.diff(start, end, 'month') / 3;
                break;

            case 'month':
                amount = ((end.getFullYear() - start.getFullYear()) * 12) + (end.getMonth() - start.getMonth());
                break;

            case 'week':
                amount = this.diff(start, end, 'day') / 7;
                break;

            case 'day': {
                const dstDiff = start.getTimezoneOffset() - end.getTimezoneOffset();
                amount = (end - start + dstDiff * 60 * 1000) / 86400000;
                break;
            }

            case 'hour':
                amount = (end - start) / 3600000;
                break;

            case 'minute':
                amount = (end - start) / 60000;
                break;

            case 'second':
                amount = (end - start) / 1000;
                break;

            case 'millisecond':
                amount = (end - start);
                break;
        }

        return fractional ? amount : Math.round(amount);
    }

    /**
     * Sets the date to the start of the specified unit, by default returning a clone of the date instead of changing it
     * inplace.
     * @param {Date} date Original date
     * @param {String} unit Start of this unit, 'day', 'month' etc.
     * @param {Boolean} clone Manipulate a copy of the date
     * @returns {Date} Manipulated date
     * @category Manipulate
     */
    static startOf(date, unit = 'day', clone = true) {
        if (!date) {
            return null;
        }

        unit = this.normalizeUnit(unit);

        if (clone) date = this.clone(date);

        const toSet = {},
            index = unitMagnitudes[unit];

        for (let i = 0; i < index; i++) {
            const currentUnit = canonicalUnitNames[i];
            // Week and quarter are not part of the date
            if (currentUnit !== 'quarter' && currentUnit !== 'week') {
                toSet[currentUnit] = currentUnit === 'day' ? 1 : 0; // day is 1 based
            }
        }

        // Special handling of quarter and week
        if (unit === 'quarter') {
            toSet.month = (this.get(date, 'quarter') - 1) * 3;
        }
        else if (unit === 'week') {
            const delta = date.getDay() - this.weekStartDay;
            toSet.day = date.getDate() - delta;
        }

        return this.set(date, toSet);
    }

    /**
     * Creates a clone of the specified date
     * @param {Date} date Original date
     * @returns {Date} Cloned date
     * @category Manipulate
     */
    static clone(date) {
        return new Date(date.getTime());
    }

    /**
     * Removes time from a date (same as calling #startOf(date, 'day'))
     * @param {Date} date Date to remove time from
     * @param {Boolean} clone Manipulate a copy of the date
     * @returns {Date} Manipulated date
     * @category Manipulate
     */
    static clearTime(date, clone = true) {
        return DateHelper.startOf(date, 'day', clone);
    }

    /**
     * Sets a part of a date (in place)
     * @param {Date} date Date to manipulate
     * @param {String|Object} unit Part of date to set, for example 'minute'. Or an object like { second: 1, minute: 1 }
     * @param {Number} amount Value to set
     * @returns {Date} Modified date
     * @category Manipulate
     */
    static set(date, unit, amount) {
        if (!unit) {
            return date;
        }

        if (typeof unit === 'string') {
            switch (this.normalizeUnit(unit)) {
                case 'millisecond':
                    // Setting value to 0 when it is 0 at DST crossing messes it up
                    if (amount !== 0 || date.getMilliseconds() > 0) {
                        date.setMilliseconds(amount);
                    }
                    break;
                case 'second':
                    // Setting value to 0 when it is 0 at DST crossing messes it up
                    if (amount !== 0 || date.getSeconds() > 0) {
                        date.setSeconds(amount);
                    }
                    break;
                case 'minute':
                    // Setting value to 0 when it is 0 at DST crossing messes it up
                    if (amount !== 0 || date.getMinutes() > 0) {
                        date.setMinutes(amount);
                    }
                    break;
                case 'hour':
                    date.setHours(amount);
                    break;
                case 'day':
                case 'date':
                    date.setDate(amount);
                    break;
                case 'week':
                    throw new Error('week not implemented');
                case 'month':
                    date.setMonth(amount);
                    break;
                case 'quarter':
                    // Setting quarter = first day of first month of that quarter
                    date.setDate(1);
                    date.setMonth((amount - 1) * 3);
                    break;
                case 'year':
                    date.setFullYear(amount);
                    break;
            }
        }
        else {
            Object.entries(unit)
            // Make sure smallest unit goes first, to not change month before changing day
                .sort((a, b) => unitMagnitudes[a[0]] - unitMagnitudes[b[0]])
                .forEach(([unit, amount]) => {
                    this.set(date, unit, amount);
                });
        }

        return date;
    }

    /**
     * Constrains the date within a min and a max date
     * @param {Date} date The date to constrain
     * @param {Date} [min] Min date
     * @param {Date} [max] Max date
     * @return {Date} The constrained date
     * @category Manipulate
     */
    static constrain(date, min, max) {
        if (min != null) {
            date = this.max(date, min);
        }
        return max == null ? date : this.min(date, max);
    }

    /**
     * Returns time only (same as calling new Date(1970, 0, 1, hours, minutes, seconds))
     * @param {Number} hours Hours value
     * @param {Number} minutes Minutes value
     * @param {Number} seconds Seconds value
     * @param {Number} ms Milliseconds value
     * @returns {Date} Date value for input hours, minutes, seconds parameters
     * @category Manipulate
     */
    static getTime(hours, minutes = 0, seconds = 0, ms = 0) {
        return new Date(DEFAULT_YEAR, DEFAULT_MONTH, DEFAULT_DAY, hours, minutes, seconds, ms);
    }

    /**
     * Copies hours, minutes, seconds, milliseconds from one date to another
     *
     * @param {Date} targetDate The target date
     * @param {Date} sourceDate The source date
     * @return {Date} The adjusted target date
     * @category Manipulate
     * @static
     */
    static copyTimeValues(targetDate, sourceDate) {
        targetDate.setHours(sourceDate.getHours());
        targetDate.setMinutes(sourceDate.getMinutes());
        targetDate.setSeconds(sourceDate.getSeconds());
        targetDate.setMilliseconds(sourceDate.getMilliseconds());
        return targetDate;
    }

    //endregion

    //region Comparison

    static isDST(date) {
        // from https://stackoverflow.com/questions/11887934/how-to-check-if-the-dst-daylight-saving-time-is-in-effect-and-if-it-is-whats
        const jan = new Date(date.getFullYear(), 0, 1),
            jul = new Date(date.getFullYear(), 6, 1);
        return date.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    }

    /**
     * Determines if a date precedes another.
     * @param first First date
     * @param second Second date
     * @returns {Boolean} true if first precedes second, otherwise false
     * @category Comparison
     */
    static isBefore(first, second) {
        return first < second;
    }

    /**
     * Determines if a date succeeds another.
     * @param first First date
     * @param second Second date
     * @returns {Boolean} true if first succeeds second, otherwise false
     * @category Comparison
     */
    static isAfter(first, second) {
        return first > second;
    }

    /**
     * Checks if two dates are equal.
     * @param first First date
     * @param second Second date
     * @param unit If not given, the comparison will be done up to a millisecond
     * @returns {Boolean} true if the dates are equal
     * @category Comparison
     */
    static isEqual(first, second, unit = null) {
        if (unit === null) {
            // https://jsbench.me/3jk2bom2r3/1
            return first && second && first.getTime() === second.getTime();
        }

        return this.startOf(first, unit) - this.startOf(second, unit) === 0;
    }

    /**
     * Compares two dates using the specified precision
     * @param {Date} first
     * @param {Date} second
     * @param {String} unit
     * @returns {Number} 0 = equal, -1 first before second, 1 first after second
     * @category Comparison
     */
    static compare(first, second, unit = null) {
        const DH = this;

        // Unit specified, cut the rest out
        if (unit) {
            first = DH.startOf(first, unit);
            second = DH.startOf(second, unit);
        }

        // Comparision on ms level
        if (DH.isBefore(first, second)) return -1;
        if (DH.isAfter(first, second)) return 1;
        return 0;
    }

    /**
     * Checks if date is the start of specified unit
     * @param {Date} date
     * @param {String} unit
     * @returns {Boolean}
     * @category Comparison
     */
    static isStartOf(date, unit) {
        return this.isEqual(date, this.startOf(date, unit));
    }

    /**
     * Checks if this date is >= start and < end.
     * @param {Date} date The source date
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Boolean} true if this date falls on or between the given start and end dates.
     * @category Comparison
     */
    static betweenLesser(date, start, end) {
        //return start <= date && date < end;
        return start.getTime() <= date.getTime() && date.getTime() < end.getTime();
    }

    /**
     * Checks if this date is >= start and <= end.
     * @param {Date} date The source date
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Boolean} true if this date falls on or between the given start and end dates.
     * @category Comparison
     */
    static betweenLesserEqual(date, start, end) {
        return start.getTime() <= date.getTime() && date.getTime() <= end.getTime();
    }

    /**
     * Returns true if dates intersect
     * @param {Date} date1Start
     * @param {Date} date1End
     * @param {Date} date2Start
     * @param {Date} date2End
     * @return {Boolean} Returns true if dates intersect
     * @category Comparison
     */
    static intersectSpans(date1Start, date1End, date2Start, date2End) {
        return this.betweenLesser(date1Start, date2Start, date2End) ||
            this.betweenLesser(date2Start, date1Start, date1End);
    }

    /**
     * Returns 1 if first param is a greater unit than second param, -1 if the opposite is true or 0 if they're equal
     * @param {String} unit1 The 1st unit
     * @param {String} unit2 The 2nd unit
     * @category Comparison
     */
    static compareUnits(unit1, unit2) {
        return Math.sign(unitMagnitudes[unit1] - unitMagnitudes[unit2]);
    }

    /**
     * Returns true if the first time span completely 'covers' the second time span.
     * @example
     * DateHelper.timeSpanContains(new Date(2010, 1, 2), new Date(2010, 1, 5), new Date(2010, 1, 3), new Date(2010, 1, 4)) ==> true
     * DateHelper.timeSpanContains(new Date(2010, 1, 2), new Date(2010, 1, 5), new Date(2010, 1, 3), new Date(2010, 1, 6)) ==> false
     * @param {Date} spanStart The start date for initial time span
     * @param {Date} spanEnd The end date for initial time span
     * @param {Date} otherSpanStart The start date for the 2nd time span
     * @param {Date} otherSpanEnd The end date for the 2nd time span
     * @return {Boolean}
     * @category Comparison
     */
    static timeSpanContains(spanStart, spanEnd, otherSpanStart, otherSpanEnd) {
        return (otherSpanStart - spanStart) >= 0 && (spanEnd - otherSpanEnd) >= 0;
    }

    //endregion

    //region Query

    /**
     * Get the first day of week, 0-6 (Sunday-Saturday). This is determined by the used locale.
     * @readonly
     */
    static get weekStartDay() {
        // Try locale first
        const weekStartDay = this.L('weekStartDay');
        if (weekStartDay !== 'weekStartDay') {
            return weekStartDay;
        }

        // Default to 0, should not need to happen in real world scenarios when a locale is always loaded
        return 0;
    }

    /**
     * Get the specified part of a date
     * @param {Date} date
     * @param {String} unit Part of date, hour, minute etc.
     * @category Query
     */
    static get(date, unit) {
        switch (this.normalizeUnit(unit)) {
            case 'millisecond':
                return date.getMilliseconds();
            case 'second':
                return date.getSeconds();
            case 'minute':
                return date.getMinutes();
            case 'hour':
                return date.getHours();
            case 'date':
            case 'day': // Scheduler has a lot of calculations expecting this to work
                return date.getDate();
            case 'week':
                return formats.W(date);
            case 'month':
                return date.getMonth();
            case 'quarter':
                return Math.floor(date.getMonth() / 3) + 1;
            case 'year':
                return date.getFullYear();
        }

        return null;
    }

    /**
     * Get number of days in the current month for the supplied date
     * @param {Date} date Date which month should be checked
     * @returns {Number} Days in month
     * @category Query
     */
    static daysInMonth(date) {
        const d = this.clone(date);
        d.setDate(1);
        d.setMonth(date.getMonth() + 1);
        d.setDate(0);
        return d.getDate();
    }

    /**
     * Get the first date of the month for the supplied date
     * @param {Date} date
     * @returns {Date}
     * @category Query
     */
    static getFirstDateOfMonth(date) {
        return new Date(date.getFullYear(), date.getMonth(), 1);
    }

    /**
     * Get the last date of the month for the supplied date
     * @param {Date} date
     * @returns {Date}
     * @category Query
     */
    static getLastDateOfMonth(date) {
        return new Date(date.getFullYear(), date.getMonth() + 1, 0);
    }

    /**
     * Get the earliest of two dates
     * @param {Date} first
     * @param {Date} second
     * @returns {Date} Earliest date
     * @category Query
     */
    static min(first, second) {
        return first.getTime() < second.getTime() ? first : second;
    }

    /**
     * Get the latest of two dates
     * @param {Date} first
     * @param {Date} second
     * @returns {Date} Latest date
     * @category Query
     */
    static max(first, second) {
        return first.getTime() > second.getTime() ? first : second;
    }

    /**
     * Get an incremented date. Incrementation based on specified unit and optional amount
     * @param {Date} date
     * @param {String} unit
     * @param {Number} [increment]
     * @param {Number} [weekStartDay] Will default to what is set in locale
     * @returns {Date}
     * @category Query
     */
    static getNext(date, unit, increment = 1, weekStartDay = this.weekStartDay) {
        const me = this;

        if (unit === 'week') {
            let
                dt = me.clone(date);
            const
                day = dt.getDay();
            dt = me.startOf(dt, 'day');
            dt = me.add(dt, weekStartDay - day + 7 * (increment - (weekStartDay <= day ? 0 : 1)), 'day');

            // For south american timezones, midnight does not exist on DST transitions, adjust...
            if (dt.getDay() !== weekStartDay) me.add(dt, 1, 'hour');

            return dt;
        }

        return me.startOf(me.add(date, increment, unit), unit);
    }

    /**
     * Checks if date object is valid.
     *
     * For example:
     *
     * ```javascript
     * date = new Date('foo')
     * date instanceof Date // true
     * date.toString() // "Invalid Date"
     * isNaN(date) // true
     * DateHelper.isValidDate(date) // false
     *
     * date = new Date()
     * date instanceof Date // true
     * date.toString() // "Mon Jan 13 2020 18:27:38 GMT+0300 (GMT+03:00)"
     * isNaN(date) // false
     * DateHelper.isValidDate(date) // true
     * ```
     *
     * @param date
     * @returns {boolean}
     */
    static isValidDate(date) {
        return this.isDate(date) && !isNaN(date);
    }

    /**
     * Checks if value is a date object. Allows to recognize date object even from another context,
     * like the top frame when used in an iframe.
     *
     * @param value
     * @returns {boolean}
     */
    static isDate(value) {
        // By checking constructor name, it allows date instances from other contexts (frames etc). By using `instanceof`, it does not.
        return value && value.constructor && value.constructor.name === 'Date';
    }

    /**
     * Get the start of the next day
     * @param {Date} date
     * @param {Boolean} clone
     * @param {Boolean} noNeedToClearTime
     * @returns {Date}
     * @category Query
     */
    static getStartOfNextDay(date, clone, noNeedToClearTime) {
        let nextDay = DateHelper.add(noNeedToClearTime ? date : DateHelper.clearTime(date, clone), 1, 'day');

        // DST case
        if (nextDay.getDate() == date.getDate()) {
            const
                offsetNextDay = DateHelper.add(DateHelper.clearTime(date, clone), 'day', 2).getTimezoneOffset(),
                offsetDate    = date.getTimezoneOffset();

            nextDay = DateHelper.add(nextDay, offsetDate - offsetNextDay, 'minute');
        }

        return nextDay;
    }

    /**
     * Get the end of previous day
     * @param {Date} date
     * @param {Boolean} noNeedToClearTime
     * @returns {Date}
     * @category Query
     */
    static getEndOfPreviousDay(date, noNeedToClearTime) {
        const dateOnly = noNeedToClearTime ? date : DateHelper.clearTime(date, true);

        // dates are different
        if (dateOnly - date) {
            return dateOnly;
        }
        else {
            return this.add(dateOnly, -1, 'day');
        }
    }

    //endregion

    //region Unit helpers

    /**
     * Turns (10, 'day') into '10 days' etc.
     * @param {Number} count Amount of unit
     * @param {String} unit Unit, will be normalizes (days, d -> day etc.)
     * @returns {String}
     * @category Unit helpers
     */
    static formatCount(count, unit) {
        unit = DateHelper.normalizeUnit(unit);
        if (count !== 1) unit += 's';
        return count + ' ' + unit;
    }

    /**
     * Get the ratio between two units ( year, month -> 1/12 )
     * @param {String} baseUnit
     * @param {String} unit
     * @param {Boolean} acceptEstimate If true, process negative values of validConversions. Defaults to false.
     * @returns {Number} Ratio
     * @category Unit helpers
     */
    static getUnitToBaseUnitRatio(baseUnit, unit, acceptEstimate = false) {
        baseUnit = DateHelper.normalizeUnit(baseUnit);
        unit = DateHelper.normalizeUnit(unit);

        if (baseUnit === unit) return 1;

        // Some validConversions have negative sign to signal that it is not an exact conversion.
        // Ignore those here unless acceptEstimate is provided.
        if (validConversions[baseUnit] && validConversions[baseUnit][unit] && (acceptEstimate || validConversions[baseUnit][unit] > 0)) {
            return 1 / DateHelper.as(unit, 1, baseUnit);
        }

        if (validConversions[unit] && validConversions[unit][baseUnit] && (acceptEstimate || validConversions[unit][baseUnit] > 0)) {
            return DateHelper.as(baseUnit, 1, unit);
        }

        return -1;
    }

    /**
     * Get unit suitable to use in calculations (?)
     * @param unit
     * @returns {*}
     * @category Unit helpers
     */
    static getMeasuringUnit(unit) {
        if (unit === 'week') return 'day';
        return unit;
    }

    /**
     * Returns a localized abbreviated form of the name of the duration unit.
     * For example in the `EN` locale, for `"qrt"` it will return `"q"`.
     * @param {String} unit Duration unit
     * @return {String}
     * @category Unit helpers
     */
    static getShortNameOfUnit(unit) {
        const me = this;

        // Convert abbreviations to the canonical name.
        // See locale file and the applyLocale method below.
        unit = me.parseTimeUnit(unit);

        // unitLookup is keyed by eg 'DAY', 'day', 'MILLISECOND', 'millisecond' etc
        return me.unitLookup[unit].abbrev;
    }

    /**
     * Returns a localized full name of the duration unit.
     * For for example in the `EN` locale, for `"d"` it will return either
     * `"day"` or `"days"`, depending from the `plural` argument
     * @static
     * @param {String} unit Time unit
     * @param {Boolean} plural Whether to return a plural name or singular
     * @return {String}
     * @category Unit helpers
     */
    static getLocalizedNameOfUnit(unit, plural) {
        const me = this;

        // Normalize to not have to have translations for each variation used in code
        unit = me.normalizeUnit(unit);

        // Convert abbreviations to the canonical name.
        // See locale file and the applyLocale method below.
        unit = me.parseTimeUnit(unit);

        // unitLookup is keyed by eg 'DAY', 'day', 'MILLISECOND', 'millisecond' etc
        return me.unitLookup[unit][plural ? 'plural' : 'single'];
    }

    /**
     * Normalizes a unit for easier usage in conditionals. For example year, years, y -> year
     * @param {String} unit
     * @returns {String}
     * @category Unit helpers
     */
    static normalizeUnit(unit) {
        if (!unit) {
            return null;
        }

        if (unit.toLowerCase() === 'date') {
            return unit.toLowerCase();
        }

        return canonicalUnitNames.includes(unit.toLowerCase())
            // Already valid
            ? unit.toLowerCase()
            // Trying specified case first, since we have both "M" for month and "m" for minute
            : normalizedUnits[unit] || normalizedUnits[unit.toLowerCase()];
    }

    static getUnitByName(name) {
        // Allow either a canonical name to be passed, or, if that fails, parse it as a localized name or abbreviation.
        return DateHelper.normalizeUnit(name) || DateHelper.normalizeUnit(this.parseTimeUnit(name));
    }

    /**
     * Returns a duration of the timeframe in the given unit.
     * @param {Date} start The start date of the timeframe
     * @param {Date} end The end date of the timeframe
     * @param {String} unit Duration unit
     * @return {Number} The duration in the units
     * @category Unit helpers
     * @ignore
     */
    static getDurationInUnit(start, end, unit, doNotRound) {
        return this.diff(start, end, unit, doNotRound);
    }

    /**
     * Checks if two date units align
     * @private
     * @param {String} majorUnit
     * @param {String} minorUnit
     * @returns {Boolean}
     * @category Unit helpers
     */
    static doesUnitsAlign(majorUnit, minorUnit) {
        // TODO: probably needs some fleshing out to be generally useful, otherwise move to TimeAxisViewModel?
        // Maybe also use getUnitToBaseUnitRatio() for assertion?
        if (majorUnit !== minorUnit && minorUnit === 'week') return false;
        return true;
    }

    static getSmallerUnit(unit) {
        return canonicalUnitNames[unitMagnitudes[this.normalizeUnit(unit)] - 1] || null;
    }

    static getLargerUnit(unit) {
        return canonicalUnitNames[unitMagnitudes[this.normalizeUnit(unit)] + 1] || null;
    }

    //endregion

    //region Date picker format

    /**
     * Parses a typed duration value according to locale rules.
     *
     * The value is taken to be a string consisting of the numeric magnitude and the units.
     * The units may be a recognised unit abbreviation of this locale or the full local unit name.
     *
     * For example: "2d", "2 d", "2 day", "2 days" will be turned into `{ magnitude : 2, unit : "day" }`
     *
     * **NOTE:** Doesn't work with complex values like "2 days, 2 hours"
     *
     * @param {String} value The value to parse.
     * @param {Boolean} [allowDecimals=true] Decimals are allowed in the magnitude.
     * @param {String} [defaultUnit] Default unit to use if only magnitude passed.
     * @returns {Object} If successfully parsed, the result contains two properties,
     * `magnitude` being a number, and `unit` being the canonical unit name, *NOT*
     * a localized name. If parsing was unsuccessful, `null` is returned.
     * @category Parse & format
     */
    static parseDuration(value, allowDecimals = true, defaultUnit) {
        const
            me            = this,
            durationRegEx = allowDecimals ? withDecimalsDurationRegex : noDecimalsDurationRegex,
            match         = durationRegEx.exec(value);

        if (value == null || !match) {
            return null;
        }

        const
            magnitude = parseNumber(match[1]),
            unit      = me.parseTimeUnit(match[2]) || defaultUnit;

        if (!unit) {
            return null;
        }

        return {
            magnitude,
            unit
        };
    }

    /**
     * Parses a typed unit name, for example `"ms"` or `"hr"` or `"yr"` into the
     * canonical form of the unit name which may be passed to {@link #function-add-static}
     * or {@link #function-diff-static}
     * @param {*} unitName
     * @category Parse & format
     */
    static parseTimeUnit(unitName) {
        // NOTE: In case you get a crash here when running tests, it is caused by missing locale. Build locales
        // using `scripts/build.js locales` to resolve.
        const unitMatch = unitName == null ? null : this.durationRegEx.exec(unitName.toLowerCase());

        if (!unitMatch) {
            return null;
        }

        // See which group in the unitAbbrRegEx matched match[2]
        for (let unitOrdinal = 0; unitOrdinal < canonicalUnitNames.length; unitOrdinal++) {
            if (unitMatch[unitOrdinal + 1]) {
                return canonicalUnitNames[unitOrdinal];
            }
        }
    }

    //endregion

    static fillDayNames() {
        const
            me            = this,
            tempDate      = new Date('2000-01-01T12:00:00'),
            dayNames      = me._dayNames || [],
            dayShortNames = me._dayShortNames || [];

        dayNames.length = 0;
        dayShortNames.length = 0;

        for (let day = 2; day < 9; day++) {
            tempDate.setDate(day);
            dayNames.push(me.format(tempDate, 'dddd'));
            dayShortNames.push(me.format(tempDate, 'ddd'));
        }

        me._dayNames = dayNames;
        me._dayShortNames = dayShortNames;
    }

    static getDayNames() {
        return this._dayNames;
    }

    static getDayName(day) {
        return this._dayNames[day];
    }

    static getDayShortNames() {
        return this._dayShortNames;
    }

    static getDayShortName(day) {
        return this._dayShortNames[day];
    }

    static fillMonthNames() {
        const
            me              = this,
            tempDate        = new Date('2000-01-15T12:00:00'),
            monthNames      = me._monthNames || [],
            monthShortNames = me._monthShortNames || [];

        monthNames.length = 0;
        monthShortNames.length = 0;

        for (let month = 0; month < 12; month++) {
            tempDate.setMonth(month);
            monthNames.push(me.format(tempDate, 'MMMM'));
            monthShortNames.push(me.format(tempDate, 'MMM'));
        }

        me._monthNames = monthNames;
        me._monthShortNames = monthShortNames;
    }

    static getMonthShortNames() {
        return this._monthShortNames;
    }

    static getMonthShortName(month) {
        return this._monthShortNames[month];
    }

    static getMonthNames() {
        return this._monthNames;
    }

    static getMonthName(month) {
        return this._monthNames[month];
    }

    static set locale(name) {
        locale = name;
    }

    static get locale() {
        return locale;
    }

    static setupDurationRegEx(unitNames = [], unitAbbreviations = []) {
        const
            me         = this,
            unitLookup = {};

        let unitAbbrRegEx = '';

        for (let i = 0; i < unitAbbreviations.length; i++) {
            const
                // for example ['s', 'sec']
                abbreviations = unitAbbreviations[i],
                // for example { single : 'second', plural : 'seconds', abbrev : 's' }
                unitNamesCfg  = unitNames[i];

            unitNamesCfg.canonicalUnitName = canonicalUnitNames[i];

            // Create a unitLookup object keyed by unit full names
            // both lower and upper case to be able to look up plurals or abbreviations
            // also always include english names, since those are used in sources
            unitLookup[unitNamesCfg.single] =
                unitLookup[unitNamesCfg.single.toUpperCase()] =
                    unitLookup[unitNamesCfg.canonicalUnitName] =
                        unitLookup[unitNamesCfg.canonicalUnitName.toUpperCase()] = unitNamesCfg;

            unitAbbrRegEx += `${i ? '|' : ''}(`;

            for (let j = 0; j < abbreviations.length; j++) {
                unitAbbrRegEx += `${abbreviations[j]}|`;
            }

            locale = me.L('locale') || 'en-US';

            if (locale !== 'en-US') {
                // Add canonical values to be able to parse durations specified in configs
                const canonicalAbbreviations = canonicalUnitAbbreviations[i];

                for (let j = 0; j < canonicalAbbreviations.length; j++) {
                    unitAbbrRegEx += `${canonicalAbbreviations[j]}|`;
                }
            }

            unitAbbrRegEx += `${unitNamesCfg.single}|${unitNamesCfg.plural}|${unitNamesCfg.canonicalUnitName})`;
        }

        me.unitLookup = unitLookup;
        me.durationRegEx = new RegExp(`^(?:${unitAbbrRegEx})$`);
    }

    static applyLocale() {
        const
            me                = this,
            unitAbbreviations = me.L('unitAbbreviations'),
            unitNames         = me.unitNames = me.L('unitNames');

        // This happens when applying an incomplete locale, as done in Localizable.t.js.
        // Invalid usecase, but return to prevent a crash in that test.
        if (unitNames === 'unitNames') {
            return;
        }

        locale = me.L('locale') || 'en-US';

        if (locale === 'en-US') {
            // TODO: Include in En locale instead?
            ordinalSuffix = enOrdinalSuffix;
        }
        else if (me.L('ordinalSuffix') !== 'ordinalSuffix') {
            ordinalSuffix = me.L('ordinalSuffix');
        }

        formatCache = {};
        parserCache = {};
        intlFormatterCache = {};

        me.setupDurationRegEx(unitNames, unitAbbreviations);

        // rebuild day/month names cache
        me.fillDayNames();
        me.fillMonthNames();
    }
}

/*  */
DateHelper._$name = 'DateHelper';

// Update when changing locale
LocaleManagerSingelton.on({
    locale  : 'applyLocale',
    prio    : 1000,
    thisObj : DateHelper
});

// Apply default locale
if (LocaleManagerSingelton.locale) DateHelper.applyLocale();
DateHelper._$name = 'DateHelper';

/**
 * @module Core/helper/ObjectHelper
 */

const whiteSpaceRe = /\s+/,
    typeOf = value => {
        const baseType = typeof value;

        // If not atomic type, we handle date or null
        if (baseType === 'object') {
            if (value === null) {
                return 'null';
            }
            if (Object.prototype.toString.call(value) === '[object Date]') {
                return 'date';
            }
        }
        return baseType;
    };

// Detect if browser has bad implementation of toFixed()
const toFixedFix = (1.005).toFixed(2) === '1.01' ? null : function(number, fractionDigits) {
    const split = number.toString().split('.'),
        newNumber = +(!split[1] ? split[0] : split.join('.') + '1');

    return number.toFixed.call(newNumber, fractionDigits);
};

/**
 * Helper for Object manipulation.
 */
class ObjectHelper {
    /**
     * Checks if two values are equal. Basically === but special handling of dates.
     * @param a First value
     * @param b Second value
     * @returns {*} true if values are equal, otherwise false
     */
    static isEqual(a, b, useIsDeeply = false) {
        // Eliminate null vs undefined mismatch
        if (
            (a === null && b !== null) ||
            (a === undefined && b !== undefined) ||
            (b === null && a !== null) ||
            (b === undefined && a !== undefined)
        ) {
            return false;
        }

        // Covers undefined === undefined and null === null, since mismatches are elminated above
        if (a == null && b == null) {
            return true;
        }

        // The same instance should equal itself.
        if (a === b) {
            return true;
        }

        const
            typeA = typeof a,
            typeB = typeof b;

        if (typeA === typeB) {
            switch (typeA) {
                case 'number':
                case 'string':
                case 'boolean':
                    return a === b;
            }

            switch (true) {
                case a instanceof Date && b instanceof Date:
                    // faster than calling DateHelper.isEqual
                    // https://jsbench.me/3jk2bom2r3/1
                    return a.getTime() === b.getTime();

                case Array.isArray(a) && Array.isArray(b):
                    return a.length === b.length ? a.every((v, idx) => this.isEqual(v, b[idx], useIsDeeply)) : false;

                case typeA === 'object' && a.constructor.prototype === b.constructor.prototype:
                    return useIsDeeply ? this.isDeeplyEqual(a, b, useIsDeeply) : JSON.stringify(a) === JSON.stringify(b);
            }
        }

        return String(a) === String(b);
    }

    /**
     * Checks if two objects are deeply equal
     * @param {Object} a
     * @param {Object} b
     * @param {Object} [options] Additional comparison options
     * @param {Object} [options.ignore] Map of property names to ignore when comparing
     * @param {Function} [options.shouldEvaluate] Function used to evaluate if a property should be compared or not.
     * Return false to prevent comparision
     * @param {Function} [options.evaluate] Function used to evaluate equality. Return `true`/`false` as evaluation
     * result or anything else to let `isEqual` handle the comparision
     * @returns {Boolean}
     */
    static isDeeplyEqual(a, b, options = {}) {
        // TODO : When syncing to DOM, it first checks the outermost config for equality with the previously used one
        //  and then drills downs for each task. If lets say the third task was changed, the two prior have already been
        //  determined to be equal before drilling down. That check could be persisted on the incoming object (a) to
        //  skip comparing it again on the more detailed level. Since (a) in this case is regenerated on ech draw there
        //  is no risk of polluting the next render

        // Same object, equal :)
        if (a === b) {
            return true;
        }

        // Nothing to compare, not equal
        if (!a || !b) {
            return false;
        }

        // Property names excluding ignored
        const
            aKeys = this.keys(a, options.ignore),
            bKeys = this.keys(b, options.ignore);

        // Property count differs, not equal
        if (aKeys.length !== bKeys.length) {
            return false;
        }

        for (let i = 0; i < aKeys.length; i++) {
            const aKey = aKeys[i];
            const bKey = bKeys[i];

            // Property name differs, not equal
            if (aKey !== bKey) {
                return false;
            }

            const aVal = a[aKey];
            const bVal = b[bKey];

            // Allow caller to determine if property values should be evaluated or not
            // TODO: Not currently used
            if (options.shouldEvaluate) {
                if (options.shouldEvaluate(
                    aKey,
                    {
                        value  : aVal,
                        object : a
                    }, {
                        value  : bVal,
                        object : b
                    }
                ) === false) {
                    continue;
                }
            }

            // Allow caller to determine equality of properties
            if (options.evaluate) {
                const result = options.evaluate(aKey, {
                    value  : aVal,
                    object : a
                }, {
                    value  : bVal,
                    object : b
                });

                // Not equal
                if (result === false) {
                    return false;
                }

                // Equal, skip isEqual call below
                if (result === true) {
                    continue;
                }
            }

            // Values differ, not equal (also digs deeper)
            if (!this.isEqual(aVal, bVal, options)) {
                return false;
            }
        }

        // Found to be equal
        return true;
    }

    /**
     * Checks if value B is partially equal to value A.
     * @param a First value
     * @param b Second value
     * @returns {Boolean} true if values are partially equal, false otherwise
     */
    static isPartial(a, b) {
        a = String(a).toLowerCase();
        b = String(b).toLowerCase();

        return a.indexOf(b) != -1;
    }

    /**
     * Checks if value a is smaller than value b.
     * @param a First value
     * @param b Second value
     * @returns {Boolean} true if a < b
     */
    static isLessThan(a, b) {
        if (a instanceof Date && b instanceof Date) {
            return DateHelper.isBefore(a, b);
        }
        return a < b;
    }

    /**
     * Checks if value a is bigger than value b.
     * @param a First value
     * @param b Second value
     * @returns {Boolean} true if a > b
     */
    static isMoreThan(a, b) {
        if (a instanceof Date && b instanceof Date) {
            return DateHelper.isAfter(a, b);
        }
        return a > b;
    }

    /**
     * Used by the Base class to make deep copies of defaultConfig blocks
     * @private
     */
    static fork(obj) {
        var ret, key, value;

        if (obj && obj.constructor === Object) {
            ret = Object.setPrototypeOf({}, obj);

            for (key in obj) {
                value = obj[key];

                if (value) {
                    if (value.constructor === Object) {
                        ret[key] = this.fork(value);
                    }
                    else if (value instanceof Array) {
                        ret[key] = value.slice();
                    }
                }
            }
        }
        else {
            ret = obj;
        }

        return ret;
    }

    static assign(dest, ...sources) {
        var i = 0,
            ln = sources.length,
            source, key;

        for (; i < ln; i++) {
            source = sources[i];

            for (key in source) {
                dest[key] = source[key];
            }
        }
        return dest;
    }

    static clone(source) {
        if (source == null) {
            return source;
        }

        var type = source.constructor.name,
            result = source,
            i, key;

        // Date
        if (type === 'Date') {
            return new Date(source.getTime());
        }

        // Array
        if (type === 'Array') {
            i = source.length;

            result = [];

            while (i--) {
                result[i] = this.clone(source[i]);
            }
        }
        // Object
        else if (type === 'Object') {
            result = {};

            for (key in source) {
                result[key] = this.clone(source[key]);
            }
        }

        return result;
    }

    static merge(dest, ...sources) {
        var i = 0,
            ln = sources.length,
            source, key, value, sourceKey;

        for (; i < ln; i++) {
            source = sources[i];

            for (key in source) {
                value = source[key];
                if (value && value.constructor === Object) {
                    sourceKey = dest[key];
                    if (sourceKey && sourceKey.constructor.name === 'Object') {
                        this.merge(sourceKey, value);
                    }
                    else {
                        dest[key] = this.clone(value);
                    }
                }
                else {
                    dest[key] = value;
                }
            }
        }

        return dest;
    }

    /**
     * Copies the named properties from the `source` parameter into the `dest` parameter.
     * @param {Object} dest The destination into which properties are copied.
     * @param {Object} source The source from which properties are copied.
     * @param {String[]} props The list of property names.
     * @returns The `dest` object.
     */
    static copyProperties(dest, source, props) {
        let prop, i;
        for (i = 0; i < props.length; i++) {
            prop = props[i];
            if (prop in source) {
                dest[prop] = source[prop];
            }
        }
        return dest;
    }

    /**
     * Copies the named properties from the `source` parameter into the `dest` parameter
     * unless the property already exists in the `dest`.
     * @param {Object} dest The destination into which properties are copied.
     * @param {Object} source The source from which properties are copied.
     * @param {String[]} props The list of property names.
     * @returns The `dest` object.
     */
    static copyPropertiesIf(dest, source, props) {
        for (const prop of props) {
            if (!(prop in dest)) {
                dest[prop] = source[prop];
            }
        }
        return dest;
    }

    /**
     * Returns an array containing all enumerable property names from every prototype level for the object.
     * @param {Object} object Object to retrieve property names from
     * @param {Object} [ignore] Optional map of names to ignore
     * @returns {String[]} All keys from every prototype level.
     */
    static keys(object, ignore = null) {
        const result = [];

        for (const p in object) {
            if (!ignore || !ignore[p]) {
                result.push(p);
            }
        }
        return result;
    }

    /**
     * Tests whether a passed object has any enumerable properties.
     * @param {Object} object
     * @returns {Boolean} `true` if the passed object has no enumerable properties.
     */
    static isEmpty(object) {
        for (const p in object) { // eslint-disable-line no-unused-vars
            return false;
        }
        return true;
    }

    /**
     * Gathers the names of properties which have truthy values into an array.
     *
     * This is useful when gathering CSS class names for complex element production.
     * Instead of appending to an array or string which may already contain the
     * name, and instead of contending with space separation and concatenation
     * and conditional execution, just set the properties of an object:
     *
     *     cls = {
     *         [this.selectedCls] : this.isSelected(thing),
     *         [this.dirtyCls] : this.isDirty(thing)
     *     };
     *
     * @param {Object} source Source of keys to gather into an array.
     * @returns {String[]} The keys which had a truthy value.
     */
    static getTruthyKeys(source) {
        const keys = Object.keys(source);

        for (let i = 0; i < keys.length;) {
            if (source[keys[i]]) {
                i++;
            }
            else {
                keys.splice(i, 1);
            }
        }

        return keys;
    }

    /**
     * Gathers the values of properties which are truthy into an array.
     * @param {Object} source Source of values to gather into an array.
     * @returns {String[]} The truthy values from the passed object.
     */
    static getTruthyValues(source) {
        const keys = Object.keys(source);

        for (let i = 0; i < keys.length;) {
            if (source[keys[i]]) {
                keys[i] = source[keys[i++]];
            }
            else {
                keys.splice(i, 1);
            }
        }

        return keys;
    }

    /**
     * Converts a list of names, either an a space separated string, or
     * from an array, into a series of properties in an object with truthy
     * values. The Converse of {@link #function-getTruthyKeys-static}
     * @param {String|String[]} The list of names to convert to object form.
     */
    static createTruthyKeys(source) {
        if (typeof source === 'string') {
            source = source.split(whiteSpaceRe);
        }
        const result = {};

        for (const key of source) {
            if (key.length) {
                result[key] = 1;
            }
        }

        return result;
    }

    /**
     * Returns an array of a given object's properties names including properties in
     * all superclasses, in the same order as we get with a normal loop.
     * @param {Object} source An object which may have properties in a prototype
     * chain, such as a configuration (These are chained because of inheritance).
     * @returns {String[]} The property names.
     */
    static allKeys(object) {
        const result = [];

        for (object; object; object = Object.getPrototypeOf(object)) {
            result.push(...Object.keys(object));
        }

        return result;
    }

    /**
     * Checks if a given path exists in an object
     * @param {Object} object Object to check path on
     * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
     * @returns {Boolean} Returns `true` if path exists or `false` if it does not
     */
    static pathExists(object, path) {
        const properties = path.split('.');

        return properties.every(property => {
            if (!(property in object)) {
                return false;
            }
            object = object[property];
            return true;
        });
    }

    /**
     * Returns value for a given path in the object
     * @param {Object} object Object to check path on
     * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
     * @returns {*} Value associated with passed key
     */
    static getPath(object, path) {
        return path.split('.').reduce((result, key) => {
            return (result || {})[key];
        }, object);
    }

    /**
     * Sets value for a given path in the object
     * @param {Object} object Target object
     * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
     * @param {*} value Value for a given path
     * @returns {Object} Returns passed object
     */
    static setPath(object, path, value) {
        path.split('.').reduce((result, key, index, array) => {
            const isLast = index === array.length - 1;

            if (isLast) {
                return result[key] = value;
            }
            else if (!(result[key] instanceof Object)) {
                result[key] = {};
            }

            return result[key];
        }, object);
        
        return object;
    }
    
    /**
     * Removes value for a given path in the object. Doesn't cleanup empty objects.
     * @param {Object} object
     * @param {String} path Dot-separated path, e.g. `obj.child.someKey`
     * @internal
     */
    static deletePath(object, path) {
        path.split('.').reduce((result, key, index, array) => {
            if (result == null) {
                return null;
            }
            else if (Object.hasOwnProperty.call(result, key)) {
                if (index === array.length - 1) {
                    delete result[key];
                }
                else {
                    return result[key];
                }
            }
        }, object);
    }
    
    static coerce(from, to) {
        var fromType = typeOf(from),
            toType = typeOf(to),
            isString = typeof from === 'string';

        if (fromType !== toType) {
            switch (toType) {
                case 'string':
                    return String(from);
                case 'number':
                    return Number(from);
                case 'boolean':
                    // See http://ecma262-5.com/ELS5_HTML.htm#Section_11.9.3 as to why '0'.
                    // TL;DR => ('0' == 0), so if given string '0', we must return boolean false.
                    return isString && (!from || from === 'false' || from === '0') ? false : Boolean(from);
                case 'null':
                    return isString && (!from || from === 'null') ? null : false;
                case 'undefined':
                    return isString && (!from || from === 'undefined') ? undefined : false;
                case 'date':
                    return isString && isNaN(from) ? DateHelper.parse(from) : Date(Number(from));
            }
        }
        return from;
    }

    static wrapProperty(object, propertyName, newGetter, newSetter, deep = true) {
        const newProperty = {};

        let proto = Object.getPrototypeOf(object),
            existingProperty = Object.getOwnPropertyDescriptor(proto, propertyName);

        while (!existingProperty && proto && deep) {
            proto = Object.getPrototypeOf(proto);
            if (proto) {
                existingProperty = Object.getOwnPropertyDescriptor(proto, propertyName);
            }
        }

        if (existingProperty) {
            if (existingProperty.set) {
                newProperty.set = v => {
                    existingProperty.set.call(object, v);

                    // Must invoke the getter in case "v" has been transformed.
                    newSetter && newSetter.call(object, existingProperty.get.call(object));
                };
            }
            else {
                newProperty.set = newSetter;
            }
            if (existingProperty.get) {
                newProperty.get = () => {
                    let result = existingProperty.get.call(object);
                    if (newGetter) {
                        result = newGetter.call(object, result);
                    }
                    return result;
                };
            }
            else {
                newProperty.get = newGetter;
            }
        }
        else {
            newProperty.set = v => {
                object[`_${propertyName}`] = v;
                newSetter && newSetter.call(object, v);
            };
            newProperty.get = () => {
                let result = object[`_${propertyName}`];
                if (newGetter) {
                    result = newGetter.call(object, result);
                }
                return result;
            };
        }
        Object.defineProperty(object, propertyName, newProperty);
    }

    /**
     * Finds a property descriptor for the passed object from all inheritance levels.
     * @param {Object} object The Object whos property to find.
     * @param {String} propertyName The name of the property to find.
     * @returns {Object} An ECMA property descriptor is the property was found, otherwise `null`
     */
    static getPropertyDescriptor(object, propertyName) {
        let result = null;
        for (let obj = object; !result && obj !== Base; obj = Object.getPrototypeOf(obj)) {
            result = Object.getOwnPropertyDescriptor(obj, propertyName);
        }
        return result;
    }

    /**
     * Changes the passed object and removes all null and undefined properties from it
     * @param {Object} object Target object
     * @returns {Object} Passed object
     */
    static cleanupProperties(obj) {
        Object.entries(obj).forEach(([key, value]) => value == null && delete obj[key]);
        return obj;
    }

    /**
     * Checks that the supplied value is of the specified type. Throws if it is not
     * @param {Object} value Value to check type of
     * @param {String} type Expected type
     * @param {String} name Name of the value, used in error message
     */
    static assertType(value, type, name) {
        // eslint-disable-next-line valid-typeof
        if (value != null && typeof value !== type) {
            throw new Error(`Incorrect type "${typeof value}" for ${name}, expected "${type}"`);
        }
    }

    /**
     * Checks that the supplied value is a number.  Throws if it is not
     * @param {Object} value Value to check type of
     * @param {String} name Name of the value, used in error message
     */
    static assertNumber(value, name) {
        this.assertType(value, 'number', name);
    }

    /**
     * Checks that the supplied value is a boolean.  Throws if it is not
     * @param {Object} value Value to check type of
     * @param {String} name Name of the value, used in error message
     */
    static assertBoolean(value, name) {
        this.assertType(value, 'boolean', name);
    }

    /**
     * Number.toFixed(), with polyfill for browsers that needs it
     * @param {Number} number
     * @param {Number} digits
     * @returns {String} A fixed point string representation of the passed number.
     */
    static toFixed(number, digits) {
        if (toFixedFix) {
            return toFixedFix(number, digits);
        }

        return number.toFixed(digits);
    }

    /**
     * Round the passed number to closest passed step value.
     * @param {Number} number The number to round.
     * @param {Number} [step] The step value to round to.
     * @returns {Number} The number rounded to the closest step.
     */
    static roundTo(number, step = 1) {
        return Math.round(number / step) * step;
    }

    /**
     * Round the passed number to the passed number of decimals.
     * @param {Number} number The number to round.
     * @param {Number} digits The number of decimal places to round to.
     * @returns {Number} The number rounded to the passed number of decimal places.
     */
    static round(number, digits) {
        // Undefined or null means do not round. NOT round to no decimals.
        if (digits == null) {
            return number;
        }

        const factor = 10 ** digits;

        return Math.round(number * factor) / factor;
    }
}
ObjectHelper._$name = 'ObjectHelper';

/**
 * @module Core/helper/util/DomClassList
 */

/**
 * This class encapsulates a list of CSS classes which can be set as the `className`
 * on an `HTMLElement`.
 *
 * Properties names set on this class equate to *adding* a class if the property's value
 * is _truthy_, or removing a class if the value is _falsy_.
 *
 * ```javascript
 * const myClassList = new DomClassList('b-test-button');
 *
 * myClassList.add('test-class');
 * myClassList.important = 1;
 *
 * myHtmlElement.className = myClassList; // Sets it to "b-test-button test-class important"
 * ```
 */
class DomClassList {

    /**
     * Initializes a new DomClassList.
     * @param {String} classes CSS classes to create with
     * @function constructor
     */
    constructor(...classes) {
        if (typeof classes[0] === 'object') {
            Object.assign(this, classes[0]);
        }
        else {
            this.process(1, classes);
        }

        // String value needs recalculating
        this[dirtySymbol] = true;
    }

    /**
     * Returns a clone of this DomClassList with all the same keys set.
     * @returns {Core.helper.util.DomClassList} A clone of this DomClassList.
     */
    clone() {
        return new DomClassList(this);
    }

    /**
     * Returns a Boolean value, indicating whether this ClassList has the specified CSS class name.
     * @param {String} className CSS class name to check
     * @return {Boolean} true if this ClassList contains the passed CSS class name, false otherwise
     */
    contains(className) {
        if (typeof className === 'string' && className) {
            return Boolean(this[className]);
        }
        return false;
    }

    // An instance of this class may be assigned directly to an element's className
    // it will be coerced to a string value using this method.
    toString() {
        // Adding space at the end if there is content to make concatenation code simpler in renderers.
        return this.length ? `${this.value} ` : '';
    }
    
    toJSON() {
        return this.toString();
    }

    /**
     * Analogous to string.trim, returns the string value of this `DomClassList` with no trailing space.
     * @returns {String} A concatenated string value of all the class names in this `DomClassList`
     * separated by spaces.
     */
    trim() {
        return this.value;
    }

    /**
     * Compares this ClassList to another ClassList (or class name string of space separated classes).
     * If the *same class names, regardless of order* are present, the two are considered equal.
     *
     * So `new DomClassList('foo bar bletch').isEqual('bletch bar foo')` would return `true`
     * @param {Core.helper.util.DomClassList|String} other The `DomClassList` or string of classes to compare to.
     * @returns {Boolean} `true` if the two contain the same class names.
     */
    isEqual(other) {
        if (typeof other === 'string') {
            testClassList.value = other;
            other = testClassList;
        }

        if (this.length === other.length) {
            const otherClasses = ObjectHelper.getTruthyKeys(other);

            for (let i = 0, len = otherClasses.length; i < len; i++) {
                if (!this[otherClasses[i]]) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }

    /**
     * Get/set string value.
     * Class names separated with space.
     * @property {String}
     */
    get value() {
        const me = this;

        if (me[dirtySymbol]) {
            const keys = ObjectHelper.getTruthyKeys(me);
            me[lengthSymbol] = keys.length;
            me[valueSymbol] = keys.join(' ');
            me[dirtySymbol] = false;
        }
        return me[valueSymbol];
    }

    set value(value) {
        const
            me = this,
            keys = Object.keys(me),
            len = keys.length;

        for (let i = 0; i < len; i++) {
            delete me[keys[i]];
        }

        if (value) {
            me.process(1, [value]);
        }
        else {
            // String value needs recalculating
            me[dirtySymbol] = true;
        }
    }

    get length() {
        // Maintainer: We MUST access the value getter to force
        // the value to be calculated if it's currently dirty.
        return this.value ? this[lengthSymbol] : 0;
    }

    process(value, classes) {
        const len = classes.length;
        for (let i = 0; i < len; i++) {
            if (classes[i]) {
                const cls = classes[i],
                    splitClasses = cls.values ? Array.from(cls.values()) : (cls.item ? Array.from(cls) : cls.split(whiteSpaceRe$1)),
                    len = splitClasses.length;
                for (let i = 0; i < len; i++) {
                    if (splitClasses[i]) {
                        
                        this[splitClasses[i]] = value;
                    }
                }
            }
        }

        // String value needs recalculating
        this[dirtySymbol] = true;
    }

    /**
     * Add CSS class(es)
     * ```
     * myClassList.add('bold', 'small');
     * ```
     * @param {String} classes CSS classes to add
     */
    add(...classes) {
        this.process(1, classes);
    }

    /**
     * Remove CSS class(es)
     * ```
     * myClassList.remove('bold', 'small');
     * ```
     * @param {String} classes CSS classes to remove
     */
    remove(...classes) {
        this.process(0, classes);
    }

    /**
     * Analogous to the `String#split` method, but with no delimiter
     * parameter. This method returns an array containing the individual
     * CSS class names set.
     * @returns {String[]} The individual class names in this `DomClassList`
     */
    split() {
        return ObjectHelper.getTruthyKeys(this);
    }

    forEach(fn) {
        return ObjectHelper.getTruthyKeys(this).forEach(fn);
    }

    // To gain some speed in DomHelper.sync(), faster than instanceof etc
    get isDomClassList() {
        return true;
    }
}
const
    whiteSpaceRe$1  = /\s+/,
    valueSymbol   = Symbol('value'),
    lengthSymbol  = Symbol('length'),
    dirtySymbol   = Symbol('dirty'),
    testClassList = new DomClassList();
DomClassList._$name = 'DomClassList';

/* eslint-disable standard/no-callback-literal */
// Gives circular dependencies which I could not solve, called from global scope instead
//import GlobalEvents from '../GlobalEvents.js';

// https://app.assembla.com/spaces/bryntum/tickets/7903-rendering-fails
// HACK: this value is required to calculate width if it was configured relative to font size (em) but no element is set
const
    DEFAULT_FONT_SIZE = 14,
    t0t0              = { align : 't0-t0' };

// We only do the measurement once, if the value is null
let scrollBarWidth = null,
    idCounter      = 0,
    themeInfo      = null,
    host;

const
    // Transform matrix parse Regex. CSS transform computed style looks like this:
    // matrix(scaleX(), skewY(), skewX(), scaleY(), translateX(), translateY())
    // or
    // matrix3d(scaleX(), skewY(), 0, 0, skewX(), scaleY(), 0, 0, 0, 0, 1, 0, translateX(), translateY())
    // This is more reliable than using the style literal which may include
    // relative styles such as "translateX(-20em)", or not include the translation at all if it's from a CSS rule.
    // Use a const so as to only compile RexExp once
    translateMatrixRe        = /(?:matrix\((?:-?\d*\.?[0-9]*),\s?(?:-?\d*\.?[0-9]*),\s?(?:-?\d*\.?[0-9]*),\s?(?:-?\d*\.?[0-9]*),\s?(-?\d*\.?[0-9]*),\s?(-?\d*\.?[0-9]*))|(?:matrix3d\((?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(?:-?\d*),\s?(-?\d*),\s?(-?\d*))/,
    pxTtranslateXRe          = /translate(3d|X)?\((-?\d*\.?[0-9]*)px(?:,\s?(-?\d*\.?[0-9]*)px)?/,
    pxTtranslateYRe          = /translate(3d|Y)?\((-?\d*\.?[0-9]*)px(?:,\s?(-?\d*\.?[0-9]*)px)?/,
    domIdRe                  = /^[^a-z]+|[^\w:.-]+/gi,
    whiteSpaceRe$2             = /\s+/,

    // DomHelper#createElement properties which require special processing.
    // All other configs such as id and type are applied directly to the element.
    elementCreateProperties  = {
        tag          : 1,
        html         : 1,
        children     : 1,
        tooltip      : 1,
        style        : 1,
        dataset      : 1,
        parent       : 1,
        nextSibling  : 1,
        ns           : 1,
        reference    : 1,
        className    : 1,
        unmatched    : 1, // Used by syncId approach
        _element     : 1, // Used by sync to assign used element back to the config, for usage by the caller
        onlyChildren : 1, // Used by sync to not touch the target element itself,
        elementData  : 1,
        compareHtml  : 1, // Sync,
        syncOptions  : 1  // Sync
    },

    styleIgnoreProperties    = {
        length     : 1,
        parentRule : 1,
        style      : 1
    },

    styleDimensionProperties = {
        width     : 1,
        height    : 1,
        top       : 1,
        left      : 1,
        minWidth  : 1,
        minHeight : 1,
        maxWidth  : 1,
        maxHeight : 1,
        fontSize  : 1
    },

    nativeFocusableTags      = {
        BUTTON   : 1,
        IFRAME   : 1,
        EMBED    : 1,
        INPUT    : 1,
        OBJECT   : 1,
        SELECT   : 1,
        TEXTAREA : 1,
        HTML     : BrowserHelper.isIE11 ? 1 : 0,
        BODY     : BrowserHelper.isIE11 ? 0 : 1
    },
    win                      = window,
    doc                      = document,
    emptyObject              = {},
    emptyArray               = [],
    arraySlice               = Array.prototype.slice,
    immediatePromise         = new Promise((resolve) => resolve()),
    devicePixelRatio         = window.devicePixelRatio || 1,
    roundPx                  = devicePixelRatio === 1 ? Math.round : px => Math.round(px * devicePixelRatio) / devicePixelRatio,
    fontProps                = [
        'font-size',
        'font-size-adjust',
        'font-style',
        'font-weight',
        'font-family',
        'font-kerning',
        'font-stretch',
        'line-height',
        'text-transform',
        'text-decoration',
        'letter-spacing',
        'word-break'
    ],
    isHiddenWidget           = e => e._hidden,
    parentNode               = el => el.parentNode || el.host,
    isVisible                = e => {
        const style = e.ownerDocument.defaultView.getComputedStyle(e);

        return style.getPropertyValue('display') !== 'none' && style.getPropertyValue('visibility') !== 'hidden';
    },
    getRootNode              = document.documentElement.getRootNode ? el => el.getRootNode() : el => {
        while (el.parentNode) el = el.parentNode;
        return el;
    },
    // Check whether the element has an offsetParent.
    // Nodes such as SVG which do not expose such a property must have an ancestor which has an offsetParent.
    hasLayout                = el => el && (el === document.body || ('offsetParent' in el ? el.offsetParent : hasLayout(el.parentNode))),
    // Check for node being in document.
    // If part of shadow DOM, see if the root's host is in the DOM
    isInDocument             = el => el && (document.body.contains(el) || ((host = getRootNode(el).host) && isInDocument(host)));

let templateElement, htmlParser;

/**
 * @module Core/helper/DomHelper
 */

/**
 * Helps with dom querying and manipulation.
 * ```
 * DomHelper.createElement({
 *   tag: 'div',
 *   className: 'parent',
 *   style: 'background: red',
 *   children: [
 *      { tag: 'div', className: 'child' },
 *      { tag: 'div', className: 'child' }
 *   ]
 * });
 * ```
 */
class DomHelper {
    /**
     * Returns `true` if the passed element is focusable either programatically or through pointer gestures.
     * @param {HTMLElement} element The element to test.
     */
    static isFocusable(element, skipAccessibilityCheck = false) {
        if (!skipAccessibilityCheck) {
            // If element is hidden or in a hidden Widget, it's not focusable.
            if (!this.isVisible(element) || IdHelper.fromElement(element, isHiddenWidget)) {
                return false;
            }
        }

        const nodeName = element.nodeName;

        /*
         * An element is focusable if:
         *   - It is natively focusable, or
         *   - It is an anchor or link with href attribute, or
         *   - It has a tabIndex, or
         *   - It is an editing host (contenteditable="true")
         */
        return nativeFocusableTags[nodeName] ||
            ((nodeName === 'A' || nodeName === 'LINK') && !!element.href) ||
            element.getAttribute('tabIndex') != null ||
            element.contentEditable === 'true';
    }

    /**
     * Returns `true` if the passed element is currently visible in the browser viewport, i.e. user can find it on screen
     * @param {HTMLElement} element The element to test.
     * @param {Boolean} whole Whether to check that whole element is visible, not just part of it.
     */
    static isInView(el, whole = true) {
        let elRect = Rectangle.from(el),
            inView = true;

        const fullHeight = elRect.height,
            fullWidth  = elRect.width;

        while (inView && el.parentElement) {
            el = el.parentElement;
            elRect = elRect.intersect(Rectangle.from(el));
            inView = elRect && (!whole || (elRect.height >= fullHeight && elRect.width >= fullWidth));
        }

        return inView;
    }

    /**
     * Returns `true` if the passed element is deeply visible. Meaning it is not hidden using `display`
     * or `visibility` and no ancestor node is hidden.
     * @param {HTMLElement} element The element to test.
     * @returns {Boolean} `true` if deeply visible.
     */
    static isVisible(element) {
        const document = element.ownerDocument;

        // Use the parentNode function so that we can traverse upwards through shadow DOM
        // to correctly ascertain visibility of nodes in web components.
        for (; element; element = parentNode(element)) {
            // Visible if we've reached top of the owning document without finding a hidden Element.
            if (element === document) {
                return true;
            }
            // Must not evaluate a shadow DOM's root fragment.
            if (element.nodeType === 1 && !isVisible(element)) {
                return false;
            }
        }

        // We get here if the node is detached.
        return false;
    }

    static roundPx(v) {
        return roundPx(v);
    }

    /**
     * Returns true if element has opened shadow root
     * @param {HTMLElement} element Element to check
     * @returns {Boolean}
     */
    static isCustomElement(element) {
        return element && element.shadowRoot;
    }

    /**
     * Resolves element from point, checking shadow DOM if requried
     * @param {Number} x
     * @param {Number} y
     * @returns {HTMLElement}
     */
    static elementFromPoint(x, y) {
        let el = document.elementFromPoint(x, y);

        // Try to check shadow dom if it exists
        if (DomHelper.isCustomElement(el)) {
            el = el.shadowRoot.elementFromPoint(x, y) || el;
        }

        return el;
    }

    /**
     * Returns active element checking shadow dom too
     * @returns {HTMLElement}
     */
    static get activeElement() {
        let el = document.activeElement;

        while (el.shadowRoot) {
            el = el.shadowRoot.activeElement;
        }

        return el;
    }

    /**
     * Returns the `id` of the passed element. Generates a unique `id` if the element does not have one.
     * @param {HTMLElement} element The element to return the `id` of.
     */
    static getId(element) {
        return element.id || (element.id = 'b-element-' + (++idCounter));
    }

    //region Internal

    /**
     * Internal convenience fn to allow specifying either an element or a CSS selector to retrieve one
     * @private
     * @param {String|HTMLElement} elementOrSelector element or selector to lookup in DOM
     * @returns {HTMLElement}
     */
    static getElement(elementOrSelector) {
        // also used for SVG elements, so need to use more basic class, that is also returned by querySelector
        if (elementOrSelector instanceof Element) {
            return elementOrSelector;
        }

        return doc.querySelector(elementOrSelector);
    }

    /**
     * Sets attributes passed as object to given element
     * @private
     * @param {String|Element} elementOrSelector
     * @param {Object} attributes
     */
    static setAttributes(elementOrSelector, attributes) {
        const element = this.getElement(elementOrSelector);

        Object.entries(attributes).forEach(([key, value]) => element.setAttribute(key, value));
    }

    /**
     * Sets a CSS [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length) style value.
     * @param {String|HTMLElement} element The element to set the style in, or, if just the result is required,
     * the style magnitude to return with units added.
     * @param {String} [style] The name of a style property which specifies a [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length)
     * @param {Number|String} [value] The magnitude. If a number is used, the value will be set in `px` units.
     * @returns {String} The style value string.
     */
    static setLength(element, style, value) {
        if (arguments.length === 1) {
            return (typeof element === 'number') ? `${element}px` : element;
        }
        else {
            element = this.getElement(element);
            return element.style[style] = (typeof value === 'number') ? `${value}px` : value;
        }
    }

    //endregion

    //region Children, going down...

    /**
     * Gets the first direct child of `element` that matches `selector.
     * @param {HTMLElement} element Parent element
     * @param {String} selector CSS selector
     * @returns {HTMLElement}
     * @category Query children
     */
    static getChild(element, selector) {
        // TODO: Only IE11 doesn't support :scope
        if (BrowserHelper.supportsQueryScope) {
            selector = ':scope>' + selector;
        }
        else {
            const elId = element.id || (element.id = 'b-element-' + (++idCounter));
            selector = `#${elId} > ${selector}`;
        }
        return element.querySelector(selector);
    }

    /**
     * Checks if `element` has any child that matches `selector`.
     * @param {HTMLElement} element Parent element
     * @param {String} selector CSS selector
     * @returns {Boolean} true if any child matches selector
     * @category Query children
     */
    static hasChild(element, selector) {
        return DomHelper.getChild(element, selector) != null;
    }

    /**
     * Returns all child elements (not necessarily direct children) that matches `selector.
     * @param {HTMLElement} element Parent element
     * @param {String} selector CSS selector
     * @returns {HTMLElement[]} Matched elements, somewhere below `element
     * @category Query children
     */
    static children(element, selector) {
        return Array.from(element.querySelectorAll(selector));
    }

    /**
     * Looks at the specified `element` and all of its children for the one that first matches `selector.
     * @param {HTMLElement} element Parent element
     * @param {String} selector CSS selector
     * @returns {HTMLElement} Matched element, either element or an element below it
     * @category Query children
     */
    static down(element, selector) {
        if (!element) {
            return null;
        }

        if (element.matches && element.matches(selector)) {
            return element;
        }
        if (BrowserHelper.supportsQueryScope) {
            selector = ':scope ' + selector;
        }
        else {
            const elId = element.id || (element.id = 'b-element-' + (++idCounter));
            selector = `#${elId} ${selector}`;
        }
        return element.querySelector(selector);
    }

    /**
     * Checks if childElement is a descendant of parentElement (contained in it or a sub element)
     * @param {HTMLElement} parentElement Parent element
     * @param {HTMLElement} childElement Child element, at any level below parent
     * @returns {Boolean}
     * @category Query children
     */
    static isDescendant(parentElement, childElement) {
        // In case of IE11 and parentElement is <html>, HTMLDocument#contains is not supported - fallback to body
        if (!parentElement.contains) {
            parentElement = parentElement.body;
        }

        return parentElement.contains(childElement);
    }

    /**
     * Iterates over each result returned from `element.querySelectorAll(selector)`. First turns it into an array to
     * work in IE. Can also be called with only two arguments, in which case the first argument is used as selector and
     * document is used as the element.
     * @param {HTMLElement} element Parent element
     * @param {String} selector CSS selector
     * @param {Function} fn Function called for each found element
     * @category Query children
     */
    static forEachSelector(element, selector, fn) {
        if (typeof element === 'string') {
            fn = selector;
            selector = element;
            element = doc;
        }
        this.children(element, selector).forEach(fn);
    }

    /**
     * Iterates over the direct child elements of the specified element. First turns it into an array to
     * work in IE.
     * @param {HTMLElement} element Parent element
     * @param {Function} fn Function called for each child element
     * @category Query children
     */
    static forEachChild(element, fn) {
        Array.from(element.children).forEach(fn);
    }

    /**
     * Removes each element returned from `element.querySelectorAll(selector)`.
     * @param {HTMLElement} element
     * @param {String} selector
     * @category Query children
     */
    static removeEachSelector(element, selector) {
        this.forEachSelector(element, selector, child => child.remove());
    }

    static removeClsGlobally(element, ...classes) {
        classes.forEach(cls => this.forEachSelector(element, '.' + cls, child => child.classList.remove(cls)));
    }

    //endregion

    //region Parents, going up...

    /**
     * Looks at the specified element and all of its parents for the one that first matches selector.
     * @param {HTMLElement} element Element
     * @param {String} selector CSS selector
     * @returns {HTMLElement} Matched element, either the passed in element or an element above it
     * @category Query parents
     */
    static up(element, selector) {
        /*let parent = element;
        while (parent && !parent.matches(selector)) parent = parent.parentElement;
        return parent;*/
        return element && element.closest(selector);
    }

    static getAncestor(element, possibleAncestorParents, outerElement = null) {
        let found  = false,
            ancestor,
            parent = element;

        if (!Array.isArray(possibleAncestorParents)) possibleAncestorParents = [possibleAncestorParents];

        while ((parent = parent.parentElement)) {
            if (possibleAncestorParents.includes(parent)) {
                found = true;
                break;
            }
            if (outerElement && parent === outerElement) break;
            ancestor = parent;
        }

        if (!found) return null;
        return ancestor || element;
    }

    /**
     * Retrieves all parents to the specified element.
     * @param {HTMLElement} element Element
     * @returns {HTMLElement[]} All parent elements, bottom up
     * @category Query parents
     */
    static getParents(element) {
        const parents = [];

        while (element.parentElement) {
            parents.push(element.parentElement);
            element = element.parentElement;
        }

        return parents;
    }

    //endregion

    //region Creation

    /**
     * Converts the passed id to an id valid for usage as id on a DOM element.
     * @param {String} id
     * @returns {String}
     */
    static makeValidId(id) {
        if (id == null) return null;

        return String(id).replace(domIdRe, '');
    }

    /**
     * Creates an Element. Example usage:
     * @example
     * DomHelper.createElement({
     *   tag         : 'table', // defaults to 'div'
     *   cellSpacing : 0,
     *   className   : 'nacho',
     *   html        : 'I am a nacho',
     *   children    : [ { tag: 'tr', ... }, myDomElement ],
     *   parent      : myExistingElement // Or its id
     *   style       : 'font-weight: bold;color: red',
     *   dataset     : { index: 0, size: 10 },
     *   tooltip     : 'Yay!',
     *   ns          : 'http://www.w3.org/1999/xhtml'
     * });
     * @param {Object} config Element config, as in example
     * @param {Boolean} returnAll Specify true to return all elements & child elements created as an array
     * @returns {HTMLElement|HTMLElement[]|Object} Single element or array of elements `returnAll` was set to true.
     * If any elements had a `reference` property, this will be an object containing a reference to
     * all those elements, keyed by the reference name.
     * @category Creation
     */
    static createElement(config = {}, returnAll = false, refs = null, syncIdField = null) {
        if (typeof config.parent === 'string') {
            config.parent = document.getElementById(config.parent);
        }

        if (config.syncOptions && config.syncOptions.syncIdField) {
            syncIdField = config.syncOptions.syncIdField;
        }

        // nextSibling implies a parent
        const parent = config.parent || (config.nextSibling && config.nextSibling.parentNode);

        let element;

        if (config.ns) {
            element = doc.createElementNS(config.ns, config.tag || 'svg');
        }
        else {
            element = doc.createElement(config.tag || 'div');
        }

        if (config.html != null) {
            if (config.html instanceof DocumentFragment) {
                element.appendChild(config.html);
            }
            else {
                element.innerHTML = config.html;
            }
        }

        if (config.tooltip) {
            WidgetHelper.attachTooltip(element, config.tooltip);
        }

        if (config.style) {
            this.applyStyle(element, config.style);
        }

        if (config.dataset) {
            Object.assign(element.dataset, config.dataset);
        }

        if (parent) {
            parent.insertBefore(element, config.nextSibling);
        }

        if (config.reference) {
            (refs || (refs = {}))[config.reference] = element;
            element.setAttribute('reference', config.reference);
        }

        // Attach custom data to the element, not visible
        if (config.elementData) {
            element.elementData = config.elementData;
        }

        const { className } = config;

        if (className) {
            if (className.isDomClassList) {
                element.className = className.toString();
            }
            else if (typeof className === 'object') {
                element.className = new DomClassList(className);
            }
            else {
                element.className = className;
            }
        }

        // Handle things like id, className, type, rel, cellSpacing, href etc which just get assigned.
        for (const prop of Object.keys(config)) {
            if (!elementCreateProperties[prop]) {
                if (config.ns) {
                    element.setAttribute(prop, config[prop]);
                    //element.setAttributeNS(config.ns, prop, config[prop]);
                }
                else {
                    element[prop] = config[prop];
                }
            }
        }

        // if returnAll is true, use array
        if (returnAll === true) {
            returnAll = [element];
        }
        // if it already is an array, add to it (we are probably a child)
        else if (Array.isArray(returnAll)) {
            returnAll.push(element);
        }

        if (config.children) {

            if (syncIdField) {
                // Map syncId -> child element to avoid querying dom later on
                element.syncIdMap = {};
            }

            config.children.forEach(child => {
                // Skip null children, convenient to allow those for usage with Array.map()
                if (child) {
                    // Append string children as text nodes
                    if (typeof child === 'string') {
                        element.appendChild(document.createTextNode(child));
                    }
                    // Just append Elements directly.
                    else if (isNaN(child.nodeType)) {
                        child.parent = element;
                        if (!child.ns && config.ns) {
                            child.ns = config.ns;
                        }

                        const
                            childElement = DomHelper.createElement(child, returnAll, refs, syncIdField),
                            syncId       = child.dataset && child.dataset[syncIdField];

                        // syncId is used with DomHelper.sync to match elements. Populate a map here to make finding them faster
                        if (syncId != null) {
                            element.syncIdMap[syncId] = childElement;
                        }

                        // Do not want to alter the initial config
                        delete child.parent;
                    }
                    else {
                        element.appendChild(child);
                    }
                }
            });
        }

        // Store used config, to be able to compare on sync to determine if changed without hitting dom
        element.lastConfig = config;

        // Link element to config for easy retrieval
        config._element = element;

        // If references were used, return them in an object
        // If returnAll was specified, return the array
        // By default, return the root element
        return refs || returnAll || element;
    }

    /**
     * Create element(s) from a template (html string). Note that
     * `textNode`s are discarded unless the `raw` option is passed
     * as `true`.
     *
     * If the template has a single root element, then the single element will be returned
     * unless the `array` option is passed as `true`.
     *
     * If there are multiple elements, then an Array will be returned.
     *
     * @param {String} template The HTML string from which to create DOM content
     * @param {Object} [options] An object containing properties to modify how the DOM is created and returned.
     * @param {Boolean} [options.array] `true` to return an array even if there's only one resulting element.
     * @param {Boolean} [options.raw] Return all child nodes, including text nodes.
     * @param {Boolean} [options.fragment] Return a DocumentFragment.
     * @private
     */
    static createElementFromTemplate(template, options = emptyObject) {
        const { array, raw, fragment } = options;
        let result;

        // Use template by preference if it exists. It's faster on most supported platforms
        // https://jsperf.com/domparser-vs-template/
        if (DomHelper.supportsTemplate) {
            (templateElement || (templateElement = doc.createElement('template'))).innerHTML = template;

            result = templateElement.content;
            if (fragment) {
                // The template is reused, so therefore is its fragment.
                // If we release the fragment to a caller, it must be a clone.
                return result.cloneNode(true);
            }
        }
        else {
            (htmlParser || (htmlParser = new DOMParser())).parseFromString(template, 'text/html');

            result = htmlParser.parseFromString(template, 'text/html').body;

            // We must return a DocumentFragment.
            // myElement.append(fragment) inserts the contents of the fragment, not the fragment itself.
            if (fragment) {
                // Empty string results in *no document.body* on IE!
                const nodes = result ? result.childNodes : emptyArray;
                result = document.createDocumentFragment();
                while (nodes.length) {
                    result.appendChild(nodes[0]);
                }
                return result;
            }
            // Happens with empty template in IE11
            else if (!result) {
                result = { children : [], childNodes : [] };
            }
        }

        // Raw means all child nodes are returned
        if (raw) {
            result = result.childNodes;
        }
        // Otherwise, only element nodes
        else {
            result = result.children;
        }

        return result.length === 1 && !array ? result[0] : arraySlice.call(result);
    }

    /**
     * Inserts an `element` at first position in `into`.
     * @param {HTMLElement} into Parent element
     * @param {HTMLElement} element Element to insert, or an element config passed on to createElement()
     * @returns {HTMLElement}
     * @category Creation
     */
    static insertFirst(into, element) {
        if (element && element.nodeType !== Node.ELEMENT_NODE && element.tag) {
            element = DomHelper.createElement(element);
        }
        return into.insertBefore(element, into.firstElementChild);
    }

    /**
     * Inserts a `element` before `beforeElement` in `into`.
     * @param {HTMLElement} into Parent element
     * @param {HTMLElement} element Element to insert, or an element config passed on to createElement()
     * @param {HTMLElement} beforeElement Element before which passed element should be inserted
     * @returns {HTMLElement}
     * @category Creation
     */
    static insertBefore(into, element, beforeElement) {
        if (element && element.nodeType !== Node.ELEMENT_NODE && element.tag) {
            element = DomHelper.createElement(element);
        }
        return beforeElement ? into.insertBefore(element, beforeElement) : DomHelper.insertFirst(into, element);
    }

    /**
     * Appends element to parentElement.
     * @param {HTMLElement} parentElement Parent element
     * @param {HTMLElement|Object|String} elementOrConfig Element to insert, or an element config passed on to createElement(), or an html string passed to createElementFromTemplate
     * @returns {HTMLElement}
     * @category Creation
     */
    static append(parentElement, elementOrConfig) {
        if (elementOrConfig) {
            if (typeof elementOrConfig === 'string') {
                elementOrConfig = DomHelper.createElementFromTemplate(elementOrConfig);
            }
            else if (elementOrConfig.nodeType !== Node.ELEMENT_NODE && elementOrConfig.tag) {
                elementOrConfig = DomHelper.createElement(elementOrConfig);
            }
        }
        if (Array.isArray(elementOrConfig)) {
            return elementOrConfig.map(element => parentElement.appendChild(element));
        }
        else {
            return parentElement.appendChild(elementOrConfig);
        }
    }

    //endregion

    //region Get position

    /**
     * Returns the element's `transform translateX` value in pixels.
     * @param {HTMLElement} element
     * @returns {Number} X transform
     * @category Position, get
     */
    static getTranslateX(element) {
        const transformStyle = element.style.transform;
        let matches = pxTtranslateXRe.exec(transformStyle);

        // Use inline transform style if it contains "translate(npx, npx" or "translate3d(npx, npx" or "translateX(npx"
        if (matches) {
            return parseInt(matches[2]);
        }
        else {
            // If the inline style is the matrix() form, then use that, otherwise, use computedStyle
            matches =
                translateMatrixRe.exec(transformStyle) ||
                translateMatrixRe.exec(this.getStyleValue(this.getElement(element), 'transform'));
            return matches ? parseInt(matches[1] || matches[3]) : 0;
        }
    }

    /**
     * Returns the element's `transform translateY` value in pixels.
     * @param {HTMLElement} element
     * @returns {Number} Y coordinate
     * @category Position, get
     */
    static getTranslateY(element) {
        const transformStyle = element.style.transform;
        let matches = pxTtranslateYRe.exec(transformStyle);

        // Use inline transform style if it contains "translate(npx, npx" or "translate3d(npx, npx" or "translateY(npx"
        if (matches) {
            // If it was translateY(npx), use first item in the parens.
            const y = parseInt(matches[matches[1] === 'Y' ? 2 : 3]);
            // FF will strip `translate(x, 0)` -> `translate(x)`, so need to check for isNaN also
            return isNaN(y) ? 0 : y;
        }
        else {
            // If the inline style is the matrix() form, then use that, otherwise, use computedStyle
            matches =
                translateMatrixRe.exec(transformStyle) ||
                translateMatrixRe.exec(this.getStyleValue(this.getElement(element), 'transform'));
            return matches ? parseInt(matches[2] || matches[4]) : 0;
        }
    }

    /**
     * Gets both X and Y coordinates as an array [x, y]
     * @param {HTMLElement} element
     * @returns {Number[]} [x, y]
     * @category Position, get
     */
    static getTranslateXY(element) {
        return [this.getTranslateX(element), this.getTranslateY(element)];
    }

    /**
     * Get elements X offset within a containing element
     * @param {HTMLElement} element
     * @param {HTMLElement} container
     * @returns {Number} X offset
     * @category Position, get
     */
    static getOffsetX(element, container = null) {
        return container ? element.getBoundingClientRect().left - container.getBoundingClientRect().left : element.offsetLeft;
    }

    /**
     * Get elements Y offset within a containing element
     * @param {HTMLElement} element
     * @param {HTMLElement} container
     * @returns {Number} Y offset
     * @category Position, get
     */
    static getOffsetY(element, container = null) {
        return container ? element.getBoundingClientRect().top - container.getBoundingClientRect().top : element.offsetTop;
    }

    /**
     * Gets elemnts X and Y offset within containing element as an array [x, y]
     * @param {HTMLElement} element
     * @param {HTMLElement} container
     * @returns {Number[]} [x, y]
     * @category Position, get
     */
    static getOffsetXY(element, container = null) {
        return [this.getOffsetX(element, container), this.getOffsetY(element, container)];
    }

    /**
     * Focus element without scrolling the element into view.
     * @param {HTMLElement} element
     */
    static focusWithoutScrolling(element) {

        function resetScroll(scrollHierarchy) {
            scrollHierarchy.forEach(({ element, scrollLeft, scrollTop }) => {
                // Check first to avoid triggering unnecessary `scroll` events
                if (element.scrollLeft !== scrollLeft) {
                    element.scrollLeft = scrollLeft;
                }
                if (element.scrollTop !== scrollTop) {
                    element.scrollTop = scrollTop;
                }
            });
        }

        // Check browsers which do support focusOptions
        // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus
        const preventScrollSupported = BrowserHelper.chromeVersion >= 64 || BrowserHelper.fireFoxVersion >= 68;

        if (preventScrollSupported) {
            element.focus({ preventScroll : true });
        }
        else {
            // Examine every parentNode of the target and cache the scrollLeft and scrollTop,
            // and restore all values after the focus has taken place
            const
                parents         = DomHelper.getParents(element),
                scrollHierarchy = parents.map(parent => ({
                    element    : parent,
                    scrollLeft : parent.scrollLeft,
                    scrollTop  : parent.scrollTop
                }));

            element.focus();

            // Reset in sync on IE, async in others
            if (BrowserHelper.isIE11) {
                resetScroll(scrollHierarchy);
            }
            else {
                setTimeout(() => resetScroll(scrollHierarchy), 0);
            }
        }
    }

    /**
     * Get elements X position on page
     * @param {HTMLElement} element
     * @returns {Number}
     * @category Position, get
     */
    static getPageX(element) {
        return element.getBoundingClientRect().left + win.pageXOffset; // no window.scrollX in IE11
    }

    /**
     * Get elements Y position on page
     * @param {HTMLElement} element
     * @returns {Number}
     * @category Position, get
     */
    static getPageY(element) {
        return element.getBoundingClientRect().top + win.pageYOffset; // no window.scrollY in IE11
    }

    /**
     * Returns extremal (min/max) size (height/width) of the element in pixels
     * @param {HTMLElement} element
     * @param {String} style minWidth/minHeight/maxWidth/maxHeight
     * @returns {number}
     * @internal
     */
    static getExtremalSizePX(element, style) {
        const
            prop    = StringHelper.hyphenate(style),
            measure = prop.split('-')[1];

        let value   = this.getStyleValue(element, prop);

        if (/%/.test(value)) {
            // Element might be detached from DOM
            if (element.parentElement) {
                value = parseInt(this.getStyleValue(element.parentElement, measure), 10);
            }
            else {
                value = NaN;
            }
        }
        else {
            value = parseInt(value, 10);
        }

        return value;
    }

    //endregion

    //region Set position

    /**
     * Set element's `X` translation in pixels.
     * @param {HTMLElement} element
     * @param {Number} x The value by which the element should be translated from its default position.
     * @category Position, set
     */
    static setTranslateX(element, x) {
        const t = DomHelper.getStyleValue(element, 'transform').split(/,\s*/);

        // Avoid blurry text on non-retina displays
        x = roundPx(x);

        if (t.length > 1) {
            t[t[0].startsWith('matrix3d') ? 12 : 4] = x;
            element.style.transform = t.join(',');
        }
        else {
            element.style.transform = `translateX(${x}px)`;
        }
    }

    /**
     * Set element's `Y` translation in pixels.
     * @param {HTMLElement} element
     * @param {Number} y  The value by which the element should be translated from its default position.
     * @category Position, set
     */
    static setTranslateY(element, y) {
        const t = DomHelper.getStyleValue(element, 'transform').split(/,\s*/);

        // Avoid blurry text on non-retina displays
        y = roundPx(y);

        if (t.length > 1) {
            t[t[0].startsWith('matrix3d') ? 13 : 5] = y;
            element.style.transform = t.join(',') + ')';
        }
        else {
            element.style.transform = `translateY(${y}px)`;
        }
    }

    /**
     * Set element's style `top`.
     * @param {HTMLElement} element
     * @param {Number|String} y The top position. If numeric, `'px'` is used as the unit.
     * @category Position, set
     */
    static setTop(element, y) {
        this.setLength(element, 'top', y);
    }

    /**
     * Set element's style `left`.
     * @param {HTMLElement} element
     * @param {Number|String} x The top position. If numeric, `'px'` is used as the unit.
     * @category Position, set
     */
    static setLeft(element, x) {
        this.setLength(element, 'left', x);
    }

    /**
     * Set elements `X` and `Y` translation in pixels.
     * @param {HTMLElement} element
     * @param {Number} [x] The `X translation.
     * @param {Number} [y] The `Y translation.
     * @category Position, set
     */
    static setTranslateXY(element, x, y) {
        if (x == null) {
            return this.setTranslateY(element, y);
        }
        if (y == null) {
            return this.setTranslateX(element, x);
        }

        // Avoid blurry text on non-retina displays
        x = roundPx(x);
        y = roundPx(y);

        const
            t    = DomHelper.getStyleValue(element, 'transform').split(/,\s*/),
            is3d = t[0].startsWith('matrix3d');

        if (t.length > 1) {
            t[is3d ? 12 : 4] = x;
            t[is3d ? 13 : 5] = y;
            element.style.transform = t.join(',') + ')';
        }
        else {
            element.style.transform = `translateX(${x}px) translateY(${y}px)`;
        }
    }

    /**
     * Increase `X` translation
     * @param {HTMLElement} element
     * @param {Number} x The number of pixels by which to increase the element's `X` translation.
     * @category Position, set
     */
    static addTranslateX(element, x) {
        DomHelper.setTranslateX(element, DomHelper.getTranslateX(element) + x);
    }

    /**
     * Increase `Y` position
     * @param {HTMLElement} element
     * @param {Number} y The number of pixels by which to increase the element's `Y` translation.
     * @category Position, set
     */
    static addTranslateY(element, y) {
        DomHelper.setTranslateY(element, DomHelper.getTranslateY(element) + y);
    }

    /**
     * Increase X position
     * @param {HTMLElement} element
     * @param x
     * @category Position, set
     */
    static addLeft(element, x) {
        DomHelper.setLeft(element, DomHelper.getOffsetX(element) + x);
    }

    /**
     * Increase Y position
     * @param {HTMLElement} element
     * @param y
     * @category Position, set
     */
    static addTop(element, y) {
        DomHelper.setTop(element, DomHelper.getOffsetY(element) + y);
    }

    /**
     * Align the passed element with the passed target according to the align spec.
     * @param {HTMLElement} element The element to align.
     * @param {HTMLElement|Core.helper.util.Rectangle} target The target element or rectangle to align to
     * @param {Object} alignSpec See {@link Core.helper.util.Rectangle#function-alignTo} Defaults to `{ align : 't0-t0' }`
     */
    static alignTo(element, target, alignSpec = t0t0) {
        target = (target instanceof Rectangle) ? target : Rectangle.from(target, true);

        const
            elXY       = this.getTranslateXY(element),
            elRect     = Rectangle.from(element, true),
            targetRect = elRect.alignTo(Object.assign(alignSpec, {
                target
            }));

        this.setTranslateXY(element, elXY[0] + targetRect.x - elRect.x, elXY[1] + targetRect.y - elRect.y);
    }

    //endregion

    //region Styles & CSS

    /**
     * Returns a style value or values for the passed element.
     * @param {HTMLElement} element The element to read styles from
     * @param {String|String[]} propName The property or properties to read
     * @param {Boolean} [inline=false] Pass as `true` to read the element's inline style.
     * Note that this could return inaccurate results if CSS rules apply to this element.
     * @return {String|Object} The value or an object containing the values keyed by the requested property name.
     * @category CSS
     */
    static getStyleValue(element, propName, inline, pseudo) {
        const styles = inline ? element.style : element.ownerDocument.defaultView.getComputedStyle(element, pseudo);

        if (Array.isArray(propName)) {
            const result = {};

            for (const prop of propName) {
                result[prop] = styles.getPropertyValue(StringHelper.hyphenate(prop));
            }

            return result;
        }

        // Use the elements owning view to get the computed style.
        // Ensure the property name asked for is hyphenated.
        // getPropertyValue doesn't work with camelCase
        return styles.getPropertyValue(StringHelper.hyphenate(propName));
    }

    /**
     * Returns an object with the parse style values for the top, right, bottom, and left
     * components of the given edge style.
     *
     * The return value is an object with `top`, `right`, `bottom`, and `left` properties
     * for the respective components of the edge style, as well as `width` (the sum of
     * `left` and `right`) and `height` (the sum of `top` and `bottom`).
     *
     * @param {HTMLElement} element
     * @param {String} edgeStyle The element's desired edge style such as 'padding', 'margin',
     * or 'border'.
     * @param {String} [edges='trbl'] A string with one character codes for each edge. Only
     * those edges will be populated in the returned object. By default, all edges will be
     * populated.
     * @returns {Object}
     */
    static getEdgeSize(element, edgeStyle, edges) {
        const
            suffix = (edgeStyle === 'border') ? '-width' : '',
            ret = {
                raw : {}
            };

        for (const edge of ['top', 'right', 'bottom', 'left']) {
            if (!edges || edges.includes(edge[0])) {
                // This produces px units even if the provided style is em or other (i.e.,
                // getComputedStyle normalizes this):
                ret[edge] = parseFloat(
                    ret.raw[edge] = DomHelper.getStyleValue(element, `${edgeStyle}-${edge}${suffix}`)
                );
            }
        }

        // These may not even be requested (based on "edges") but conditional code here
        // would be wasted since the caller would still need to know not to use them...
        ret.width = ret.left + ret.right;
        ret.height = ret.top + ret.bottom;

        return ret;
    }

    /**
     * Applies specified style to the passed element. Style can be an object or a string.
     * @param {HTMLElement} element Target element
     * @param {String|Object} style Style to apply, 'border: 1px solid black' or { border: '1px solid black' }
     * @param {Boolean} [overwrite] Specify `true` to replace style instead of applying changes
     * @category CSS
     */
    static applyStyle(element, style, overwrite = false) {
        if (typeof style === 'string') {
            if (overwrite) {
                // Only assign if either end has any styles, do not want to add empty `style` tag on element
                if (style.length || element.style.cssText.length) {
                    element.style.cssText = style;
                }
            }
            else {
                // Add style so as not to delete configs in style such as width, height, flex etc.
                // If a style is already there, the newest, appended one will take precedence.
                element.style.cssText += style;
            }
        }
        else {
            if (overwrite) {
                element.style.cssText = '';
                //element.removeAttribute('style');
            }

            // Has a sub-style block?
            if (style.style) {
                if (typeof style.style === 'string') {
                    element.style.cssText = style.style;
                }
                else {
                    style = Object.assign({}, style.style, style);
                }
            }

            // Prototype chained objects may be passed, so use direct loop.
            for (const key in style) {
                // Ignore readonly properties of the CSSStyleDeclaration object:
                // https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration
                // Also ignores sub-style blocks, which are applied above
                if (!styleIgnoreProperties[key]) {
                    // Append 'px' for numeric dimensions
                    if (styleDimensionProperties[key] && typeof style[key] == 'number') {
                        element.style[StringHelper.hyphenate(key)] = style[key] + 'px';
                    }
                    else {
                        element.style[StringHelper.hyphenate(key)] = style[key];
                    }
                }
            }
        }
    }

    static getCSSText(style) {
        if (typeof style === 'string') {
            return style;
        }

        let cssText = '';

        for (const key in style) {
            // Ignore readonly properties of the CSSStyleDeclaration object:
            // https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration
            if (!styleIgnoreProperties[key]) {
                cssText += `${StringHelper.hyphenate(key)}:${style[key]};`;
            }
        }

        return cssText;
    }

    // For IE11, it doesn't support adding/removing multiple classes at once

    /**
     * Add multiple classes to elements classList. Helper for IE11 which does not support it directly
     * @param {HTMLElement} element
     * @param {String[]} classes
     * @category CSS
     */
    static addClasses(element, classes) {
        classes.forEach(cls => element.classList.add(cls));
    }

    /**
     * Remove multiple classes to elements classList. Helper for IE11 which does not support it directly
     * @param {HTMLElement} element
     * @param {String[]} classes
     * @category CSS
     */
    static removeClasses(element, classes) {
        classes.forEach(cls => element.classList.remove(cls));
    }

    /**
     * Toggle multiple classes in elements classList. Helper for IE11 which does not support toggling with force or for
     * multiple classes at once.
     * @param {HTMLElement} element
     * @param {String[]} classes
     * @param {Boolean} [force] Specify true to add classes, false to remove. Leave blank to toggle
     * @category CSS
     */
    static toggleClasses(element, classes, force = null) {
        if (!Array.isArray(classes)) {
            classes = [classes];
        }

        if (force === true) {
            this.addClasses(element, classes);
        }
        else if (force === false) {
            this.removeClasses(element, classes);
        }
        else {
            classes.forEach(cls => element.classList.toggle(cls));
        }
    }

    /**
     * Adds a CSS class to an element during the specified duration
     * @param {HTMLElement} element Target element
     * @param {String} cls CSS class to add temporarily
     * @param {Number} duration Duration in ms, 0 means cls will not be applied
     * @param {Core.mixin.Delayable} delayable The delayable to tie the setTimeout call to
     * @category CSS
     */
    static addTemporaryClass(element, cls, duration, delayable = window) {
        if (duration > 0) {
            element.classList.add(cls);

            delayable.setTimeout(() => element.classList.remove(cls), duration);
        }
    }

    /**
     * Reads computed style from the element and returns transition duration for a given property in milliseconds
     * @param {HTMLElement} el Target DOM element
     * @param {String} property Animatied property name
     * @returns {number/undefined} Duration in ms
     * @private
     */
    static getPropertyTransitionDuration(el, property) {
        const
            style      = window.getComputedStyle(el),
            properties = style.transitionProperty.split(', '),
            durations  = style.transitionDuration.split(', '),
            index      = properties.indexOf(property);

        let result;

        if (index !== -1) {
            // get floating value of transition duration in seconds and convert into milliseconds
            result = parseFloat(durations[index]) * 1000;
        }

        return result;
    }

    //endregion

    //region Effects

    /**
     * Highlights the passed element or Rectangle according to the theme's highlighting rules.
     * Usually an animated framing effect.
     * @param {HTMLElement|Core.helper.util.Rectangle} element The element or Rectangle to highlight.
     */
    static highlight(element, delayable = window) {
        if (element instanceof Rectangle) {
            return element.highlight();
        }
        return new Promise(resolve => {
            delayable.setTimeout(() => {
                element.classList.add('b-fx-highlight');
                delayable.setTimeout(() => {
                    element.classList.remove('b-fx-highlight');
                    resolve();
                }, 1000);
            }, 0);
        });
    }

    //endregion

    //region Measuring / Scrollbar

    /**
     * Measures the scrollbar width using a hidden div. Caches result
     * @returns {Number}
     * @readonly
     */
    static get scrollBarWidth() {
        // Ensure the measurement is only done once, when the value is null and body is available
        if (scrollBarWidth === null && doc.body) {
            const element = DomHelper.createElement({
                parent : doc.body,
                style  : 'position:absolute;top:-999px;width:100px;height:100px;overflow:scroll'
            });
            scrollBarWidth = element.offsetWidth - element.clientWidth;
            element.remove();
        }

        return scrollBarWidth;
    }

    /**
     * Resets DomHelper.scrollBarWidth cache, triggering a new measurement next time it is read
     */
    static resetScrollBarWidth() {
        scrollBarWidth = null;
    }

    /**
     * Measures the text width using a hidden div
     * @param {String} text
     * @param {HTMLElement} sourceElement
     * @returns {Number} width
     * @category Measure
     */
    static measureText(text, sourceElement, useHTML, parentElement) {
        const offScreenDiv = this.getMeasureElement(sourceElement, parentElement);

        offScreenDiv[useHTML ? 'innerHTML' : 'innerText'] = text;

        const result = offScreenDiv.clientWidth;
        offScreenDiv.className = '';

        return result;
    }

    /**
     * Measures a relative size, such as a size specified in `em` units for the passed element.
     * @param {String} size The CSS size value to measure.
     * @param {HTMLElement} sourceElement
     * @returns {Number} size The size in pixels of the passed relative measurement.
     * @category Measure
     */
    static measureSize(size, sourceElement) {
        if (!size) {
            return 0;
        }

        if (typeof size === 'number') {
            return size;
        }

        if (!size.length) {
            return 0;
        }

        if (/^\d+(px)?$/.test(size)) {
            return parseInt(size);
        }

        if (sourceElement) {
            const offScreenDiv = this.getMeasureElement(sourceElement);
            offScreenDiv.innerHTML = '';
            offScreenDiv.style.width = DomHelper.setLength(size);
            //const result = BrowserHelper.isIE11 ?  offScreenDiv.offsetWidth : offScreenDiv.clientWidth;
            const result = offScreenDiv.offsetWidth;
            offScreenDiv.style.width = offScreenDiv.className = '';
            return result;
        }

        if (/^\d+em$/.test(size)) {
            return parseInt(size) * DEFAULT_FONT_SIZE;
        }

        return isNaN(size) ? 0 : parseInt(size);
    }

    // parentElement allows measurement to happen inside a specific element, allowing scoped css rules to match
    static getMeasureElement(sourceElement, parentElement = doc.body) {
        const
            sourceElementStyle = win.getComputedStyle(sourceElement),
            offScreenDiv       = parentElement.offScreenDiv = parentElement.offScreenDiv || DomHelper.createElement({
                parent    : parentElement,
                style     : 'position:fixed;top:-10000px;left:-10000px;visibility:hidden;contain:strict',
                className : 'b-measure-element',
                children  : [{
                    style : 'white-space:nowrap;display:inline-block;will-change:contents;width:auto;contain:none'
                }]
            }, true)[1];

        fontProps.forEach(prop => {
            if (offScreenDiv.style[prop] !== sourceElementStyle[prop]) {
                offScreenDiv.style[prop] = sourceElementStyle[prop];
            }
        });
        offScreenDiv.className = sourceElement.className;

        // In case the measure element was moved/removed, re-add it
        if (offScreenDiv.parentElement.parentElement !== parentElement) {
            parentElement.appendChild(offScreenDiv.parentElement);
        }

        return offScreenDiv;
    }

    //endregion

    //region Sync

    /**
     * Sync one source element attributes, children etc. to a target element. Source element can be specified as a html
     * string or an actual HTMLElement.
     *
     * NOTE: This function is superseded by {@link Core/helper/DomSync#function-sync-static DomSync.sync()}, which works
     * with DOM configs. For most usecases, use it instead.
     *
     * @param {String|HTMLElement} sourceElement Source "element" to copy from
     * @param {HTMLElement} targetElement Target element to apply to, can also be specified as part of the config object
     * @returns {HTMLElement} Returns the updated targetElement (which is also updated in place)
     */
    static sync(sourceElement, targetElement) {
        if (typeof sourceElement === 'string') {
            if (sourceElement === '') {
                targetElement.innerHTML = '';
                return;
            }
            else {
                sourceElement = this.createElementFromTemplate(sourceElement);
            }
        }

        this.performSync(sourceElement, targetElement);

        return targetElement;
    }

    // Internal helper used for recursive syncing
    static performSync(sourceElement, targetElement) {
        // Syncing identical elements is a no-op
        if (sourceElement.outerHTML !== targetElement.outerHTML) {
            this.syncAttributes(sourceElement, targetElement);
            this.syncContent(sourceElement, targetElement);
            this.syncChildren(sourceElement, targetElement);

            return true;
        }
        return false;
    }

    // Attributes as map { attr : value, ... }, either from an html element or from a config
    static getSyncAttributes(element) {
        const
            attributes = {},
            // Attribute names, simplifies comparisons and calls to set/removeAttribute
            names      = [];

        // Extract from element
        for (let i = 0; i < element.attributes.length; i++) {
            const attr = element.attributes[i];
            if (attr.specified) {
                const name = attr.name.toLowerCase();
                attributes[name] = attr.value;
                names.push(name);
            }
        }

        return { attributes, names };
    }

    /**
     * Syncs attributes from sourceElement to targetElement.
     * @private
     * @param {HTMLElement} sourceElement
     * @param {HTMLElement} targetElement
     */
    static syncAttributes(sourceElement, targetElement) {
        const
            // Extract attributes from elements (sourceElement might be a config)
            {
                attributes : sourceAttributes,
                names      : sourceNames
            }          = this.getSyncAttributes(sourceElement),
            {
                attributes : targetAttributes,
                names      : targetNames
            }          = this.getSyncAttributes(targetElement),
            // Used to ignore data-xx attributes when we will be setting entire dataset
            hasDataset = sourceNames.includes('dataset'),
            // Intersect arrays to determine what needs adding, removing and syncing
            toAdd      = sourceNames.filter(attr => !targetNames.includes(attr)),
            toRemove   = targetNames.filter(attr => !sourceNames.includes(attr) && (!hasDataset || !attr.startsWith('data-'))),
            toSync     = sourceNames.filter(attr => targetNames.includes(attr));

        if (toAdd.length > 0) {
            for (let i = 0; i < toAdd.length; i++) {
                const attr = toAdd[i];

                // Style requires special handling
                if (attr === 'style') {
                    this.applyStyle(targetElement, sourceAttributes.style, true);
                }
                // So does dataset
                else if (attr === 'dataset') {
                    Object.assign(targetElement.dataset, sourceAttributes.dataset);
                }
                // Other attributes are set using setAttribute (since it calls toString() DomClassList works fine)
                else {
                    targetElement.setAttribute(attr, sourceAttributes[attr]);
                }
            }
        }

        if (toRemove.length > 0) {
            for (let i = 0; i < toRemove.length; i++) {
                targetElement.removeAttribute(toRemove[i]);
            }
        }

        if (toSync.length > 0) {
            for (let i = 0; i < toSync.length; i++) {
                const attr = toSync[i];
                // Set all attributes that has changed, with special handling for style
                if (attr === 'style') {
                    // TODO: Check for changes?
                    this.applyStyle(targetElement, sourceAttributes.style, true);
                }
                // And dataset
                else if (attr === 'dataset') {
                    // TODO: Any cost to assigning same values?
                    Object.assign(targetElement.dataset, sourceAttributes.dataset);
                }
                // And class, which might be a DomClassList or an config for a DomClassList
                else if (attr === 'class' && (sourceAttributes.class.isDomClassList || typeof sourceAttributes.class === 'object')) {
                    let classList;

                    if (sourceAttributes.class.isDomClassList) {
                        classList = sourceAttributes.class;
                    }
                    else {
                        // TODO : Reuse a single DomClassList?
                        classList = new DomClassList(sourceAttributes.class);
                    }

                    if (!classList.isEqual(targetAttributes.class)) {
                        targetElement.setAttribute('class', classList);
                    }
                }
                else if (targetAttributes[attr] !== sourceAttributes[attr]) {
                    targetElement.setAttribute(attr, sourceAttributes[attr]);
                }
            }
        }
    }

    /**
     * Sync content (innerText) from sourceElement to targetElement
     * @private
     * @param {HTMLElement} sourceElement
     * @param {HTMLElement} targetElement
     */
    static syncContent(sourceElement, targetElement) {
        if (sourceElement.childElementCount === 0) {
            targetElement.innerText = sourceElement.innerText;
        }
    }

    static setInnerText(targetElement, text) {
        // setting firstChild.data is faster than innerText (and innerHTML),
        // but in some cases the inner node is lost and needs to be recreated
        const firstChild = targetElement.firstChild;
        if (firstChild) {
            firstChild.data = text;
        }
        else {
            // textContent is supposed to be faster than innerText, since it does not trigger layout
            targetElement.textContent = text;
        }
    }

    /**
     * Sync traversing children
     * @private
     * @param {HTMLElement} sourceElement Source element
     * @param {HTMLElement} targetElement Target element
     * @param {String} syncIdField Field in dataset to use for element re-usage
     */
    static syncChildren(sourceElement, targetElement) {
        const
            me          = this,
            sourceNodes = arraySlice.call(sourceElement.childNodes),
            targetNodes = arraySlice.call(targetElement.childNodes);

        while (sourceNodes.length) {
            const
                sourceNode = sourceNodes.shift(),
                targetNode = targetNodes.shift();

            // only textNodes and elements allowed (no comments)
            if (sourceNode && sourceNode.nodeType !== Node.TEXT_NODE && sourceNode.nodeType !== Node.ELEMENT_NODE) {
                throw new Error(`Source node type ${sourceNode.nodeType} not supported by DomHelper.sync()`);
            }
            if (targetNode && targetNode.nodeType !== Node.TEXT_NODE && targetNode.nodeType !== Node.ELEMENT_NODE) {
                throw new Error(`Target node type ${targetNode.nodeType} not supported by DomHelper.sync()`);
            }

            if (!targetNode) {
                // out of target nodes, add to target
                targetElement.appendChild(sourceNode);
            }
            else {
                // match node

                if (sourceNode.nodeType === targetNode.nodeType) {
                    // same type of node, take action depending on which type
                    if (sourceNode.nodeType === Node.TEXT_NODE) {
                        // text
                        targetNode.data = sourceNode.data;
                    }
                    else {
                        if (sourceNode.tagName === targetNode.tagName) {
                            me.performSync(sourceNode, targetNode);
                        }
                        else {
                            // new tag, remove targetNode and insert new element
                            targetElement.insertBefore(sourceNode, targetNode);
                            targetNode.remove();
                        }
                    }
                }
                // Trying to set text node as element, use it as innerText
                // (we get this in FF with store mutations and List)
                else if (sourceNode.nodeType === Node.TEXT_NODE && targetNode.nodeType === Node.ELEMENT_NODE) {
                    targetElement.innerText = sourceNode.data.trim();
                }
                else {
                    throw new Error('Currently no support for transforming nodeType');
                }
            }
        }

        // Out of source nodes, remove remaining target nodes
        targetNodes.forEach(targetNode => {
            targetNode.remove();
        });
    }

    /**
     * Synchronizes the passed element's `classList` with the class names
     * passed in either Array or String format or Object. Avoiding mutating an element's
     * `classList` or `className` can avoid browser style recalculations.
     * @param {HTMLElement} element The element whose class list to synchronize.
     * @param {String[]|String|Object} newClasses The incoming class names to set on the element.
     * @category CSS
     */
    static syncClassList(element, newClasses) {
        const
            classList   = element.classList,
            isString    = typeof newClasses === 'string',
            newClsArray = isString
                ? newClasses.trim().split(whiteSpaceRe$2)
                : (Array.isArray(newClasses)
                    ? newClasses
                    : ObjectHelper.getTruthyKeys(newClasses)),
            classCount  = newClsArray.length;

        let changed = classList.length !== classCount,
            i;

        // If the incoming and existing class lists are the same length
        // then check that each contains the same names. As soon as
        // we find a non-matching name, we know we have to update the
        // className.
        for (i = 0; !changed && i < classCount; i++) {
            
            changed = !classList.contains(newClsArray[i]);
        }

        if (changed) {
            element.className = isString ? newClasses : newClsArray.join(' ');
        }
    }

    /**
     * Changes the theme to the passed theme name if possible.
     *
     * Theme names are case insensitive. The `href` used is all lower case.
     *
     * To use this method, the `<link rel="stylesheet">` _must_ use the default,
     * Bryntum-supplied CSS files where the `href` end with `<themeName>.css`, so that
     * it can be found in the document, and switched out for a new link with
     * the a modified `href`. The new `href` will use the same path, just
     * with the `themeName` portion subsituted for the new name.
     *
     * If no `<link>` with that name pattern can be found, an error will be thrown.
     *
     * If you use this method, you  must ensure that the theme files are
     * all accessible on your server.
     *
     * Because this is an asynchronous operation, a `Promise` is returned.
     * The theme change event is passed to the success function. If the
     * theme was not changed, because the theme name passed is the current theme,
     * nothing is passed to the success function.
     *
     * The theme change event contains two properties:
     *
     *  - `prev` The previous Theme name.
     *  - `theme` The new Theme name.
     *
     * @param {String} newThemeName
     * @returns {Promise} A promise who's success callback receives the theme change
     * event if the theme in fact changed. If the theme `href` could not be loaded,
     * the failure callback is called, passing the error event caught.
     */
    static setTheme(newThemeName) {
        newThemeName = newThemeName.toLowerCase();

        const
            oldThemeName = this.themeInfo.name.toLowerCase(),
            oldThemeLink =
                document.head.querySelector('#bryntum-theme') ||
                document.head.querySelector(`[href$="${oldThemeName}.css"]`);

        // Theme link href ends with <themeName>.css also there could be a query - css?11111...
        if (!oldThemeLink || !oldThemeLink.href.includes(`${oldThemeName}.css`)) {
            throw new Error(`Theme link for ${oldThemeName} not found`);
        }

        // Do not reapply same theme
        if (oldThemeLink.href.includes(newThemeName)) {
            return immediatePromise;
        }

        return new Promise((resolve, reject) => {
            const
                newThemeLink     = document.createElement('link'),
                nextSibling      = oldThemeLink.nextSibling,
                oldThemeName     = DomHelper.themeInfo.name.toLowerCase(),
                themeEvent       = {
                    theme : newThemeName,
                    prev  : oldThemeName
                },
                onThemeLoad      = () => {
                    themeInfo = null;
                    oldThemeLink.remove();
                    window.bryntum.GlobalEvents.trigger('theme', themeEvent);
                    resolve(themeEvent);
                },
                onThemeLoadError = e => {
                    reject(e);
                };

            newThemeLink.rel = 'stylesheet';
            newThemeLink.id = 'bryntum-theme';
            newThemeLink.addEventListener('load', onThemeLoad);
            newThemeLink.addEventListener('error', onThemeLoadError);
            newThemeLink.href = oldThemeLink.href.replace(oldThemeName, newThemeName);
            nextSibling.parentNode.insertBefore(newThemeLink, nextSibling);
        });
    }

    /**
     * A theme information object about the current theme.
     *
     * Currently this has only one property:
     *
     *   - `name` The current theme name.
     * @property {Object}
     * @readonly
     */
    static get themeInfo() {
        if (!themeInfo) {
            const
                testDiv   = this.createElement({
                    parent    : document.body,
                    className : 'b-theme-info'
                }),
                // Need to be a pseudo element for Edge to report content correctly
                themeData = this.getStyleValue(testDiv, 'content', false, ':before');

            if (themeData) {
                // themeData could be invalid JSON string in case there is no content rule
                try {
                    themeInfo = JSON.parse(themeData.replace(/^["']|["']$|\\/g, ''));
                }
                catch (e) {
                    themeInfo = null;
                }
            }

            testDiv.remove();
        }
        return themeInfo;
    }

    //endregion

    static isOrphaned(element) {
        return element !== document.body &&
            element !== document.documentElement &&
            element.nodeType === Node.ELEMENT_NODE &&
            element.offsetParent === null;
    }
}

let clearTouchTimer;
const
    clearTouchEvent = () => DomHelper.isTouchEvent = false,
    setTouchEvent   = () => {
        DomHelper.isTouchEvent = true;

        // Jump round the click delay
        clearTimeout(clearTouchTimer);
        clearTouchTimer = setTimeout(clearTouchEvent, 400);
    };

// Set event type flags so that mousedown and click handlers can know whether a touch gesture was used.
// This is used. This must stay until we have a unified DOM event system which handles both touch and mouse events.
doc.addEventListener('touchstart', setTouchEvent, true);
doc.addEventListener('touchend', setTouchEvent, true);

DomHelper.supportsTemplate = 'content' in doc.createElement('template');

//region Polyfills

// TODO: include babels polyfills instead of keeping own?

if (!('children' in Node.prototype)) {
    const elementFilter = node => node.nodeType === 1;
    Object.defineProperty(Node.prototype, 'children', {
        get : function() {
            return Array.prototype.filter.call(this.childNodes, elementFilter);
        }
    });
}

if (!Element.prototype.matches) {
    Element.prototype.matches =
        Element.prototype.matchesSelector ||
        Element.prototype.mozMatchesSelector ||
        Element.prototype.msMatchesSelector ||
        Element.prototype.oMatchesSelector ||
        Element.prototype.webkitMatchesSelector ||
        function(s) {
            const matches = (this.document || this.ownerDocument).querySelectorAll(s);
            let i = matches.length;
            while (--i >= 0 && matches.item(i) !== this) {}
            return i > -1;
        };
}

if (win.Element && !Element.prototype.closest) {
    Node.prototype.closest = Element.prototype.closest = function(s) {
        var el = this;
        if (!doc.documentElement.contains(el)) return null;

        do {
            if (el.matches(s)) return el;
            el = el.parentElement || el.parentNode;
        } while (el !== null && el.nodeType === 1);
        return null;
    };
}
else {
    // It's crazy that closest is not already on the Node interface!
    Node.prototype.closest = function(selector) {
        return this.parentNode.closest(selector);
    };
}

// from:https://github.com/jserz/js_piece/blob/master/DOM/ChildNode/remove()/remove().md
(function(arr) {
    arr.forEach(function(item) {
        if (Object.prototype.hasOwnProperty.call(item, 'remove')) {
            return;
        }
        Object.defineProperty(item, 'remove', {
            configurable : true,
            enumerable   : true,
            writable     : true,
            value        : function remove() {
                this.parentNode && this.parentNode.removeChild(this);
            }
        });
    });
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);

// IE11 polyfill
if (!SVGElement.prototype.contains) {
    SVGElement.prototype.contains = function(node) {
        do {
            if (this === node) {
                return true;
            }
            node = node.parentNode;
        } while (node);

        return false;
    };
}

// IE11 polyfill for Event constructors
if (typeof win.CustomEvent !== 'function') {
    let evt, constructor;

    win.CustomEvent = constructor = function(event, params = {
        bubbles    : false,
        cancelable : false,
        detail     : undefined
    }) {
        evt = doc.createEvent('CustomEvent');
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
    };
    constructor.prototype = win.Event.prototype;

    win.MouseEvent = constructor = function(event, params = {
        bubbles    : false,
        cancelable : false,
        detail     : undefined
    }) {
        evt = doc.createEvent('MouseEvents');
        evt.initMouseEvent(event, params.bubbles, params.cancelable, doc.defaultView || win, params.detail, params.screenX, params.screenY, params.clientX, params.clientY, false, false, false, false, 0, document);
        return evt;
    };
    constructor.prototype = win.Event.prototype;

    win.KeyboardEvent = constructor = function(event, params = {
        bubbles    : false,
        cancelable : false,
        detail     : undefined
    }) {
        const modifiers = `${params.shiftKey ? 'Shift ' : ''}${params.ctrlKey ? 'Control' : ''}`;

        evt = doc.createEvent('KeyboardEvent');
        evt.initKeyboardEvent(event, params.bubbles, params.cancelable, doc.defaultView || win, params.key, params.location, modifiers, false, '');
        return evt;
    };
    constructor.prototype = win.Event.prototype;
}

//endregion

// https://gist.github.com/brettz9/4093766
if (!Object.getOwnPropertyDescriptor(SVGElement.prototype, 'dataset') ||
    !Object.getOwnPropertyDescriptor(SVGElement.prototype, 'dataset').get) {
    var propDescriptor = {
        enumerable : true,
        get        : function() {
            var i,
                that        = this,
                map         = {},
                attrVal, attrName, propName,
                attribute,
                attributes  = this.attributes,
                attsLength  = attributes.length,
                toUpperCase = function(n0) {
                    return n0.charAt(1).toUpperCase();
                },
                getter      = function() {
                    return this;
                },
                setter      = function(attrName, value) {
                    return (typeof value !== 'undefined')
                        ? this.setAttribute(attrName, value)
                        : this.removeAttribute(attrName);
                };

            for (i = 0; i < attsLength; i++) {
                attribute = attributes[i];
                // Fix: This test really should allow any XML Name without
                //         colons (and non-uppercase for XHTML)
                if (attribute && attribute.name &&
                    (/^data-\w[\w-]*$/).test(attribute.name)) {
                    attrVal = attribute.value;
                    attrName = attribute.name;
                    // Change to CamelCase
                    propName = attrName.substr(5).replace(/-./g, toUpperCase);
                    Object.defineProperty(map, propName, {
                        enumerable : this.enumerable,
                        get        : getter.bind(attrVal || ''),
                        set        : setter.bind(that, attrName)
                    });
                }
            }
            return map;
        }
    };
    // FF enumerates over element's dataset, but not
    // SVGElement.prototype.dataset; IE9 iterates over both
    Object.defineProperty(SVGElement.prototype, 'dataset', propDescriptor);
}

// Polyfill to allow an array to be passed to classList.add/remove
const
    nativeAdd    = DOMTokenList.prototype.add,
    nativeRemove = DOMTokenList.prototype.remove;

DOMTokenList.prototype.add = function(cls) {
    if (Array.isArray(cls)) {
        nativeAdd.call(this, ...cls);
    }
    else {
        nativeAdd.call(this, ...arguments);
    }
};
DOMTokenList.prototype.remove = function(cls) {
    if (Array.isArray(cls)) {
        nativeRemove.call(this, ...cls);
    }
    else {
        nativeRemove.call(this, ...arguments);
    }
};
DomHelper._$name = 'DomHelper';

/**
 * @module Core/helper/util/Rectangle
 */

const allBorders        = ['border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width'],
    allPaddings       = ['padding-top', 'padding-right', 'padding-bottom', 'padding-left'],
    borderNames       = {
        t : 'border-top-width',
        r : 'border-right-width',
        b : 'border-bottom-width',
        l : 'border-left-width'
    },
    paddingNames      = {
        t : 'padding-top',
        r : 'padding-right',
        b : 'padding-bottom',
        l : 'padding-left'
    },
    zeroBased         = Object.freeze({
        x : 0,
        y : 0
    }),
    alignSpecRe       = /^([trblc])(\d*)-([trblc])(\d*)$/i,
    alignPointRe      = /^([trblc])(\d*)$/i,
    edgeNames         = [
        'top',
        'right',
        'bottom',
        'left'
    ],
    edgeIndices       = {
        t : 0,
        r : 1,
        b : 2,
        l : 3
    },
    defaultAlignments = [
        'b-t',
        'l-r',
        't-b',
        'r-l'
    ],
    zeroOffsets       = Object.freeze([0, 0]),
    matchDimensions   = ['width', 'height'];

// Parse a l0-r0 (That's how Menus align to their owning MenuItem) slign spec.
function parseAlign(alignSpec) {
    const parts        = alignSpecRe.exec(alignSpec),
        myOffset     = parseInt(parts[2] || 50),
        targetOffset = parseInt(parts[4] || 50);

    

    // Comments assume the Menu's alignSpec of l0-r0 is used.
    return {
        myAlignmentPoint     : parts[1] + myOffset,     // l0
        myEdge               : parts[1],                // l
        myOffset,                                       // 0
        targetAlignmentPoint : parts[3] + targetOffset, // r0
        targetEdge           : parts[3],                // r
        targetOffset,                                   // 0
        startZone            : edgeIndices[parts[3]]    // 1 - start trying zone 1 in TRBL order
    };
}

// Takes a result from the above function and flips edges for the axisLock config
function flipAlign(align) {
    return `${edgeNames[(edgeIndices[align.myEdge] + 2) % 4][0]}${align.myOffset}-${edgeNames[(edgeIndices[align.targetEdge] + 2) % 4][0]}${align.targetOffset}`;
}

function createOffsets(offset) {
    if (offset == null) {
        return zeroOffsets;
    }
    else if (typeof offset === 'number') {
        return [offset, offset];
    }
    
    return offset;
}

/**
 * Encapsulates rectangular areas for comparison, intersection etc.
 *
 * Note that the `right` and `bottom` properties are *exclusive*.
 *
 */
class Rectangle {
    /**
     * Returns the Rectangle in document based coordinates of the passed element.
     *
     * *Note:* If the element passed is the `document` or `window` the `window`'s
     * rectangle is returned which is always at `[0, 0]` and encompasses the
     * browser's entire document viewport.
     * @param {HTMLElement} element The element to calculate the Rectangle for.
     * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
     * @param {Boolean} [ignorePageScroll=false] Use browser viewport based coordinates.
     * @return {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
     */
    static from(element, relativeTo, ignorePageScroll) {
        if (element instanceof Rectangle) {
            return element;
        }

        if (ignorePageScroll === undefined && typeof relativeTo === 'boolean') {
            ignorePageScroll = relativeTo;
            relativeTo = null;
        }

        if (relativeTo) {
            // TODO: nige should figure out if there is a better solution
            let { scrollLeft, scrollTop } = relativeTo;
            if ((BrowserHelper.isEdge || BrowserHelper.isSafari) && relativeTo === document.body) {
                scrollLeft = scrollTop = 0;
            }
            relativeTo = Rectangle.from(relativeTo).translate(-scrollLeft, -scrollTop);
        }
        else {
            relativeTo = zeroBased;
        }

        // Viewport is denoted by requesting window or document.
        // document.body may overflow the viewport, so this must not be evaluated as the viewport.
        const
            isViewport   = element === document || element === window,
            viewRect     = isViewport ? new Rectangle(0, 0, window.innerWidth, window.innerHeight) : element.getBoundingClientRect(),
            scrollOffset = (ignorePageScroll || isViewport) ? [0, 0] : [window.pageXOffset, window.pageYOffset];

        return new Rectangle(viewRect.left + scrollOffset[0] - relativeTo.x, viewRect.top + scrollOffset[1] - relativeTo.y, viewRect.width, viewRect.height);
    }

    /**
     * Returns the inner Rectangle (within border) in document based coordinates
     * of the passed element.
     * @param element The element to calculate the Rectangle for.
     * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
     * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
     * @return {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
     */
    static inner(element, relativeTo, ignorePageScroll = false) {
        const result = this.from(element, relativeTo, ignorePageScroll);

        // Can only ask for the following styles if element is in the document.
        if (document.body.contains(element)) {
            const borders = DomHelper.getStyleValue(element, allBorders);

            result.x += parseInt(borders[borderNames.l]);
            result.y += parseInt(borders[borderNames.t]);
            result.right -= parseInt(borders[borderNames.r]);
            result.bottom -= parseInt(borders[borderNames.b]);
        }

        return result;
    }

    /**
     * Returns the content Rectangle (within border and padding) in document based coordinates
     * of the passed element.
     * @param element The element to calculate the Rectangle for.
     * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
     * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
     * @return {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
     */
    static content(element, relativeTo, ignorePageScroll = false) {
        const result = this.from(element, relativeTo, ignorePageScroll);

        // Can only ask for the following styles if element is in the document.
        if (document.body.contains(element)) {
            const borders = DomHelper.getStyleValue(element, allBorders),
                padding = DomHelper.getStyleValue(element, allPaddings);

            result.x += parseInt(borders[borderNames.l]) + parseInt(padding[paddingNames.l]);
            result.y += parseInt(borders[borderNames.t]) + parseInt(padding[paddingNames.t]);
            result.right -= parseInt(borders[borderNames.r]) + parseInt(padding[paddingNames.r]);
            result.bottom -= parseInt(borders[borderNames.b]) + parseInt(padding[paddingNames.b]);
        }

        return result;
    }

    /**
     * Returns the client Rectangle (within border and padding and scrollbars) in document based coordinates
     * of the passed element.
     * @param element The element to calculate the Rectangle for.
     * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
     * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
     * @return {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
     */
    static client(element, relativeTo, ignorePageScroll = false) {
        let result = this.content(element, relativeTo, ignorePageScroll),
            scrollbarWidth = DomHelper.scrollBarWidth,
            padding;

        if (scrollbarWidth) {
            // Capture width taken by any vertical scrollbar.
            // If there is a vertical scrollbar, shrink the box.
            // TODO: We may have to shrink from the left in RTL mode.
            if (element.scrollHeight > element.clientHeight && DomHelper.getStyleValue(element, 'overflow-y') !== 'hidden') {
                padding = parseInt(DomHelper.getStyleValue(element, 'padding-right'));
                result.right += padding - Math.max(padding, scrollbarWidth);
            }

            // Capture height taken by any horizontal scrollbar.
            // If there is a horizontal scrollbar, shrink the box.
            if (element.scrollWidth > element.clientWidth && DomHelper.getStyleValue(element, 'overflow-x') !== 'hidden') {
                padding = parseInt(DomHelper.getStyleValue(element, 'padding-bottom'));
                result.bottom += padding - Math.max(padding, scrollbarWidth);
            }
        }

        // The client region excluding any scrollbars.
        return result;
    }

    /**
     * Returns a new rectangle created as the union of all supplied rectangles.
     * @param {Core.helper.util.Rectangle[]} rectangles
     * @return {Core.helper.util.Rectangle}
     */
    static union(...rectangles) {
        let { x, y, right, bottom } = rectangles[0],
            current;

        if (rectangles.length > 1) {
            for (let i = 1; i < rectangles.length; i++) {
                current = rectangles[i];

                if (current.x < x) {
                    x = current.x;
                }

                if (current.y < y) {
                    y = current.y;
                }

                if (current.right > right) {
                    right = current.right;
                }

                if (current.bottom > bottom) {
                    bottom = current.bottom;
                }
            }
        }

        return new Rectangle(x, y, right - x, bottom - y);
    }

    /**
     * Rounds this Rectangle to the pixel resolution of the current display or to the nearest
     * passed unit which defaults to the current display's [`devicePixelRatio`](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio).
     */
    round(step = window.devicePixelRatio / 2 || 1) {
        const me = this;

        me._x = ObjectHelper.roundTo(me._x, step);
        me._y = ObjectHelper.roundTo(me._y, step);
        me._width = ObjectHelper.roundTo(me._width, step);
        me._height = ObjectHelper.roundTo(me._height, step);

        return me;
    }

    // This class doesn't extend Base and extending doesn't seem to be
    // the way to go. Instead we duplicate smallest piece of logic here
    static get $name() {
        return this.hasOwnProperty('_$name') && this._$name || this.name;
    }

    get $name() {
        return this.constructor.$name;
    }

    /**
     * Constructs a Rectangle
     * @param x The X coordinate
     * @param y The Y coordinate
     * @param width The width
     * @param height The height
     */
    constructor(x, y, width, height) {
        const me = this;

        me._x = x;
        me._y = y;
        me._width = width;
        me._height = height;
    }

    /**
     * Creates a copy of this Rectangle.
     */
    clone() {
        const me     = this,
            result = new Rectangle(me.x, me.y, me.width, me.height);

        result.minHeight = me.minHeight;
        result.minWidth = me.minWidth;

        return result;
    }

    /**
     * Returns `true` if this Rectangle wholly contains the passed rectangle.
     *
     * Note that a {@link Core.helper.util.Point} may be passed.
     * @param other The Rectangle to test for containment within this Rectangle
     * @return {Boolean} `true` if the other Rectangle is wholly contained within this Rectangle
     */
    contains(other) {
        const me = this;

        if (other instanceof Rectangle) {
            return other._x >= me._x &&
                other._y >= me._y &&
                other.right <= me.right &&
                other.bottom <= me.bottom;
        }
        else {
            return false;
        }
    }

    /**
     * Checks if this Rectangle intersects the passed Rectangle
     * @param {Core.helper.util.Rectangle} other The Rectangle to intersect with this.
     * @param {Boolean} useBoolean Specify `true` to return a boolean value instead of constructing a new Rectangle
     * @param {Boolean} allowZeroDimensions `true` to consider zero-width or zero-hight rectangles as intersecting if coordinates indicate the intersection
     * @return {Core.helper.util.Rectangle|Boolean} Returns the intersection Rectangle or `false` if there is no intersection.
     */
    intersect(other, useBoolean = false, allowZeroDimensions = false) {
        const
            me        = this,
            y         = Math.max(me.y, other.y),
            r         = Math.min(me.right, other.right),
            b         = Math.min(me.bottom, other.bottom),
            x         = Math.max(me.x, other.x),
            intersect = allowZeroDimensions ? (b >= y && r >= x) : (b > y && r > x);

        if (intersect) {
            return useBoolean ? true : new Rectangle(x, y, r - x, b - y);
        }
        else {
            return false;
        }
    }

    equals(other, round = false) {
        const processor = round ? x => Math.round(x) : x => x;

        return other instanceof Rectangle &&
            processor(other.x) === processor(this.x) &&
            processor(other.y) === processor(this.y) &&
            processor(other.width) === processor(this.width) &&
            processor(other.height) === processor(this.height);
    }

    /**
     * Translates this Rectangle by the passed vector. Size is maintained.
     * @param {Number} x The X translation vector.
     * @param {Number} y The Y translation vector.
     * @returns This Rectangle;
     */
    translate(x, y) {
        this._x += x || 0;
        this._y += y || 0;
        return this;
    }

    /**
     * Moves this Rectangle to the passed `x`, `y` position. Size is maintained.
     * @param {Number} x The new X position.
     * @param {Number} y The new Y position.
     * @returns This Rectangle;
     */
    moveTo(x, y) {
        if (x != null) {
            this._x = x;
        }
        if (y != null) {
            this._y = y;
        }
        return this;
    }

    /**
     * Returns the vector which would translate this Rectangle (or Point) to the same position as the other Rectangle (or point)
     * @param {Core.helper.util.Rectangle|Core.helper.util.Point} other The Rectangle or Point to calculate the delta to.
     */
    getDelta(other) {
        return [other.x - this.x, other.y - this.y];
    }

    /**
     * The center point of this rectangle.
     * @property {Core.helper.util.Point}
     */
    get center() {
        return new Rectangle.Point(this.x + this.width / 2, this.y + this.height / 2);
    }

    /**
     * Get/sets the X coordinate of the Rectangle. Note that this does *not* translate the
     * Rectangle. The requested {@link #property-width} will change.
     * @property {Number}
     */
    set x(x) {
        let xDelta = x - this._x;

        this._x = x;
        this._width -= xDelta;
    }

    get x() {
        return this._x;
    }

    /**
     * Alias for x. To match DOMRect.
     * @property {Number}
     */
    set left(x) {
        this.x = x;
    }

    get left() {
        return this.x;
    }

    /**
     * Alias for y. To match DOMRect.
     * @property {Number}
     */
    set top(y) {
        this.y = y;
    }

    get top() {
        return this.y;
    }

    /**
     * Get/sets the Y coordinate of the Rectangle. Note that this does *not* translate the
     * Rectangle. The requested {@link #property-height} will change.
     * @property {Number}
     */
    set y(y) {
        let yDelta = y - this._y;

        this._y = y;
        this._height -= yDelta;
    }

    get y() {
        return this._y;
    }

    /**
     * Get/sets the width of the Rectangle. Note that the requested {@link #property-right} will change.
     * @property {Number}
     */
    set width(width) {
        this._width = width;
    }

    get width() {
        return this._width;
    }

    /**
     * Get/sets the height of the Rectangle. Note that the requested {@link #property-bottom} will change.
     * @property {Number}
     */
    set height(height) {
        this._height = height;
    }

    get height() {
        return this._height;
    }

    /**
     * Get/sets the right edge of the Rectangle. Note that the requested {@link #property-width} will change.
     *
     * The right edge value is exclusive of the calculated rectangle width. So x=0 and right=10
     * means a width of 10.
     * @property {Number}
     */
    set right(right) {
        this._width = right - this._x;
    }

    get right() {
        return this._x + this._width;
    }

    /**
     * Get/sets the bottom edge of the Rectangle. Note that the requested {@link #property-height} will change.
     *
     * The bottom edge value is exclusive of the calculated rectangle height. So y=0 and bottom=10
     * means a height of 10.
     * @property {Number}
     */
    set bottom(bottom) {
        this._height = bottom - this._y;
    }

    get bottom() {
        return this._y + this._height;
    }

    get area() {
        return this.width * this.height;
    }

    set minWidth(minWidth) {
        const me = this;

        if (isNaN(minWidth)) {
            me._minWidth = null;
        }
        else {
            me._minWidth = Number(minWidth);
            me.width = Math.max(me.width, me._minWidth);
        }
    }

    get minWidth() {
        return this._minWidth;
    }

    set minHeight(minHeight) {
        const me = this;

        if (isNaN(minHeight)) {
            me._minHeight = null;
        }
        else {
            me._minHeight = Number(minHeight);
            me.height = Math.max(me.height, me._minHeight);
        }
    }

    get minHeight() {
        return this._minHeight;
    }

    /**
     * Modifies the bounds of this Rectangle by the specified deltas.
     * @param {Number} x How much to *add* to the x position.
     * @param {Number} y  How much to *add* to the y position.
     * @param {Number} width  How much to add to the width.
     * @param {Number} height  How much to add to the height.
     * @returns This Rectangle
     */
    adjust(x, y, width, height) {
        const me = this;
        me.x += x;
        me.y += y;
        me.width += width;
        me.height += height;
        return me;
    }

    /**
     * Modifies the bounds of this rectangle by moving them by the specified amount in all directions.
     * @param {Number} amount How much to inflate
     * @returns {Core.helper.util.Rectangle} This Rectangle
     */
    inflate(amount) {
        return this.adjust(-amount, -amount, amount, amount);
    }

    /**
     * Attempts constrain this Rectangle into the passed Rectangle. If the `strict` parameter is `true`
     * then this method will return `false` if constraint could not be acheived.
     *
     * If this Rectangle has a `minHeight` or `minWidth` property, size will be adjusted while attempting to constrain.
     *
     * Right and bottom are adjusted first leaving the top and bottom sides to "win" in the case that this Rectangle overflows
     * the constrainTo Rectangle.
     * @param {Core.helper.util.Rectangle} constrainTo The Rectangle to constrain this Rectangle into if possible.
     * @param {Boolean} strict Pass `true` to return false, and leave this Rectangle unchanged if constraint
     * could not be achieved.
     * @returns This Rectangle. If `strict` is true, and constraining was not successful, `false`.
     */
    constrainTo(constrainTo, strict) {
        const me        = this,
            originalHeight = me.height,
            originalY = me.y,
            minWidth  = me.minWidth || me.width,
            minHeight = me.minHeight || me.height;

        if (me.height >= constrainTo.height) {
            // If we're strict, fail if we could *never* fit into available height.
            if (strict && minHeight > constrainTo.height) {
                return false;
            }
            // If we are >= constrain height, we will have to be at top edge of constrainTo
            me._y = constrainTo.y;
            me.height = constrainTo.height;
        }

        if (me.width >= constrainTo.width) {
            // If we're strict, fail if we could *never* fit into available width.
            if (strict && minWidth > constrainTo.width) {
                // Could not be constrained; undo any previous attempt with height
                me.y = originalY;
                me.height = originalHeight;
                return false;
            }
            // If we are >= constrain width, we will have to be at left edge of constrainTo
            me._x = constrainTo.x;
            me.width = constrainTo.width;
        }

        let overflow = me.bottom - constrainTo.bottom;

        // Overflowing the bottom side, translate upwards.
        if (overflow > 0) {
            me.translate(0, -overflow);
        }

        overflow = me.right - constrainTo.right;

        // Overflowing the right side, translate leftwards.
        if (overflow > 0) {
            me.translate(-overflow);
        }

        overflow = constrainTo.y - me.y;

        // Now, after possible translation upwards, we overflow the top, translate downwards.
        if (overflow > 0) {
            me.translate(0, overflow);
        }

        overflow = constrainTo.x - me.x;

        // Now, after possible translation leftwards, we overflow the left, translate rightwards.
        if (overflow > 0) {
            me.translate(overflow);
        }

        return me;
    }

    /**
     * Returns a cloned version of this Rectangle aligned to a target Rectangle, or element or {@link Core.widget.Widget}.
     * @param {Object} spec Alignment specification.
     * @param {HTMLElement|Core.widget.Widget|Core.helper.util.Rectangle} spec.target The Widget or element or Rectangle to align to.
     * @param {Number[]} [spec.anchorSize] The `[width, height]` of the anchor pointer when in `top` position. The
     * width is the baseline length, and the height is the height of the arrow. If passed, the anchor position
     * will be calculated to be at the centre of the overlap of the two aligned edges and returned in the `anchor`
     * property of the resulting Rectangle:
     *
     *     {
     *         edge: 'top',         // or 'right' or 'bottom' or 'left'
     *         x/y: offset          // dimension to translate and value to translate by.
     *     }
     *
     * @param {Object} [spec.anchorPosition] an `{ x: n, y: n }` anchor translation to be used *if the requested alignment
     * succeeds without violating constraints*. If a fallback alignment is used, the anchor will be centered in the
     * overlap of the aligned edges as usual.
     * @param {Boolean} [spec.overlap] True to allow this to overlap the target.
     * @param {String} spec.align The edge alignment specification string, specifying two points to bring together.
     * The form is `[trblc][n]-[trblc][n]. The `n` is a percentage offset
     * along that edge which defines the alignment point. This is not valid for alignment point `c`.
     * For example `t0-b0' would align this Rectangle's top left corner with the bottom left corner of the `target`.
     * @param {HTMLElement|Core.widget.Widget|Core.helper.util.Rectangle} [spec.constrainTo] The Widget or Element or Rectangle to constrain to.
     * If the requested alignment cannot be constrained (it will first shrink the resulting Rectangle according
     * to the `minWidth` and `minHeight` properties of this rectangle), then it will try aligning at other edges
     * (honouring the `axisLock` option), and pick the fallback alignment which results in the shortest translation.
     * @param {Boolean} [spec.axisLock] Specify as a truthy value to fall back to aligning against the opposite
     * edge first if the requested alignment cannot be constrained into the `constrainTo` option. If specified
     * as `'flexible'`, then fallback will continue searching for solutions on the remaining two sides.
     * @param {Number|Number[]} [spec.offset] The 'x' and 'y' offset values to create an extra margin round the target
     * to offset the aligned widget further from the target. May be configured as -ve to move the aligned widget
     * towards the target - for example producing the effect of the anchor pointer piercing the target.
     * @returns {Core.helper.util.Rectangle} A new Rectangle aligned as requested if possible, but if the requested position violates
     * the `constrainTo` Rectangle, the shortest translation from the requested position which obeys constraints will be used.
     */
    alignTo(spec) {
        

        // The target and constrainTo may be passed as HtmlElements or Widgets.
        // If so, extract the Rectangles without mutating the incoming spec.
        let result = this.clone(),
            target = spec.target,
            constrainTo = spec.constrainTo,
            calculatedAnchorPosition, zone, resultZone, constrainingToViewport;

        if (target && !(target instanceof Rectangle)) {
            target = Rectangle.from(target.element ? target.element : target);
        }
        if (constrainTo && !(constrainTo instanceof Rectangle)) {
            // Viewport is denoted by requesting window or document.
            // document.body may overflow the viewport, so this must not be evaluated as the viewport.
            constrainingToViewport = constrainTo === window || constrainTo === document;
            constrainTo = Rectangle.from(constrainTo.element ? constrainTo.element : constrainTo, null, spec.ignorePageScroll);
        }
        const me                  = this,
            targetOffsets       = createOffsets(spec.offset),
            {
                align,
                axisLock,
                anchorSize,
                anchorPosition
            }                   = spec,
            alignSpec           = parseAlign(align),
            position            = spec.position || ((target && target.$name === 'Point') ? target : null),
            targetConstrainRect = constrainTo && constrainTo.clone(),
            constraintZones = [],
            zoneOrder = [{
                zone : zone = alignSpec.startZone,
                align
            }],
            matchDimension = spec.matchSize && matchDimensions[alignSpec.startZone & 1],
            originalSize   = me[matchDimension];

        // Match the size of the edge we are aligning against
        if (matchDimension && axisLock) {
            result[matchDimension] = target[matchDimension];
        }

        // Ensure we will fit before trying
        if (constrainTo) {
            result.constrainTo(constrainTo);
        }

        // If we are aligning edge-to-edge, then plan our fallback strategy when we are constrained.
        if (constrainTo && alignSpec.startZone != null) {
            // Create the list of zone numbers and alignments to try in the preferred order.
            //
            // In the case of axisLock, go through the zones by each axis.
            // So if they asked for t-b, which is zone 2,
            // the array will be [2, 0, 3, 1] (t-b, b-t, r-l, l-r)
            if (axisLock) {
                // First axis flip has to maintain the offset along that axis.
                // so align: l0-r0 has to flip to align: r0-l0. See submenu flipping when
                // constrained to the edge. It flips sides but maintains vertical position.
                zoneOrder.push({
                    zone  : zone = (zone + 2) % 4,
                    align : flipAlign(alignSpec)
                });

                // Only try the other axis is axisLock is 'flexible'
                if (axisLock === 'flexible') {
                    zoneOrder.push({
                        zone  : zone = (alignSpec.startZone + 1) % 4,
                        align : defaultAlignments[zone]
                    });
                    zoneOrder.push({
                        zone  : zone = (zone + 2) % 4,
                        align : defaultAlignments[zone]
                    });
                }
            }
            // Go through the zones in order from the requested start.
            // So if they asked for t-b, which is zone 2,
            // the array will be [2, 3, 0, 1] (t-b, r-l, b-t, l-r)
            else {
                for (let i = 1; i < 4; i++) {
                    zoneOrder.push({
                        zone  : zone = (zone + 1) % 4,
                        align : defaultAlignments[zone]
                    });
                }
            }
        }

        // Allow them to pass anchorPosition: {x: 10} to indicate that after a fully successful,
        // unconstrained align, the anchor should be 10px from the start.
        if (anchorPosition) {
            let pos = (alignSpec.startZone & 1) ? 'y' : 'x';
            calculatedAnchorPosition = {
                [pos] : anchorPosition[pos],
                edge  : edgeNames[(alignSpec.startZone + 2) % 4]
            };
        }

        // Keep the target within reach. If it's way outside, pull it back so that it's only just outside);
        if (targetConstrainRect && target) {
            targetConstrainRect.adjust(-target.width, -target.height, target.width, target.height);
            target.constrainTo(targetConstrainRect);
        }

        // As part of fallback process when fitting within constraints, result may shrink to our minima
        result.minWidth = me.minWidth;
        result.minHeight = me.minHeight;

        // We're being commanded to try to align at a position
        if (position) {
            result.moveTo(position.x, position.y);
            if (constrainTo) {
                result.constrainTo(constrainTo);
            }
        }

        // We're aligning to a Target Rectangle within a ConstrainTo Rectangle, taking into account
        // a possible anchor pointer, or x/y offsets. Here's the situation:
        //
        //                             <-- ConstrainTo Rectangle -->
        //  +-----------------------------------+--------------------+-------------------------+
        //  |                                   |                    |                         |
        //  |                                   |                    |                         |
        //  |                                   |                    |                         |
        //  |-----------------------------------+--------------------+-------------------------+
        //  |                                   |          ▼         |                         |
        //  |                                   | +----------------+ |                         |
        //  |                                   | |                | |                         |
        //  |                                   | |                | |                         |
        //  |                                   |▶|     Target     |◀|                         |
        //  |                                   | |                | |                         |
        //  |                                   | |                | |                         |
        //  |                                   | +----------------+ |                         |
        //  |                                   |          ▲         |                         |
        //  +-----------------------------------+--------------------+-------------------------|
        //  |                                   |                    |                         |
        //  |                                   |                    |                         |
        //  |                                   |                    |                         |
        //  +-----------------------------------+--------------------+-------------------------+
        //
        // Which results in the four possible constraint zones above, which we index in standard CSS order.
        //
        // Top    = 0
        // Right  = 1
        // Bottom = 2
        // Left   = 3
        //
        // If the initially requested alignment is not within the constrainTo rectangle
        // then, calculate these four, and then loop through them, beginning at the requested one,
        // quitting when we find a position which does not violate constraints. This includes
        // shrinking the aligning Rectangle towards its minima to attempt a fit.
        //
        // The final fallback, if there is no position which does not violate constraints
        // is to position in whichever of the four rectangles has the largest area shrinking overflowing
        // dimensions down to minima if specified.
        //
        else {
            // Offsets: If we are using an anchor to move away from the target, use anchor height in both dimensions.
            // It's rotated so that "height" always has the same meaning. It's the height of the arrow.
            const offsets     = anchorSize ? [anchorSize[1] + targetOffsets[0], anchorSize[1] + targetOffsets[1]] : targetOffsets,
                targetPoint = target.getAlignmentPoint(alignSpec.targetAlignmentPoint, offsets),
                myPoint     = result.getAlignmentPoint(alignSpec.myAlignmentPoint);

            result.translate(targetPoint[0] - myPoint[0], targetPoint[1] - myPoint[1]);

            // If an overlapping position was requested, then we are *not* trying out those four zones.
            // We just respect constraint, and that's it.
            const overlap = result.intersect(target, true);

            // If we are aligned over our target, we just obey that within any constraint.
            // No complex edge alignment attempts to fall back to.
            if (overlap) {
                if (constrainTo) {
                    result.constrainTo(constrainTo);
                }
                resultZone = alignSpec.startZone;
            }
            // Aligned to outside of our target, and we need to be constrained
            else if (constrainTo && !constrainTo.contains(result)) {
                let requestedResult = result.clone(),
                    solutions       = [],
                    zone, largestZone;

                // Any configured anchorPosition becomes invalid now that we're having to move the resulting zone
                // to some unpredictable new place where it fits. It will have to be calculated based upon where
                // we end up aligning.
                calculatedAnchorPosition = null;

                // Calculate the four constraint zones illustrated above.
                // Top
                constraintZones[0] = zone = constrainTo.clone();
                zone.bottom = target.y - offsets[1];

                // Right
                constraintZones[1] = zone = constrainTo.clone();
                zone.x = target.right + offsets[0];

                // Bottom
                constraintZones[2] = zone = constrainTo.clone();
                zone.y = target.bottom + offsets[1];

                // Left
                constraintZones[3] = zone = constrainTo.clone();
                zone.right = target.x - offsets[0];

                // Start from the preferred edge and see if we are able to constrain to within each rectangle
                for (let i = 0; i < zoneOrder.length; i++) {
                    // Revert to incoming dimension for fallback out of axisLock
                    if (matchDimension && i == 2) {
                        result[matchDimension] = originalSize;
                    }

                    zone = constraintZones[resultZone = zoneOrder[i].zone];

                    // Perform unconstrained alignment at the calculated alignment for the zone
                    result = result.alignTo({
                        target  : target,
                        offsets : offsets,
                        align   : zoneOrder[i].align
                    });

                    // If we are able to strictly constrain into this area, then it's one of the possible solutions.
                    // We choose the solution which result in the shortest translation from the initial position.
                    if (result.constrainTo(zone, true)) {
                        solutions.push({
                            result : result,
                            zone   : resultZone
                        });

                        // If this successful constraint is at the requested alignment, or at a fallback
                        // alignment which has used min size constraints, then that's the correct solution.
                        // If there's no size compromising, we have to pick the shortest translation.
                        if (!largestZone || result.width < me.width || result.height < me.height) {
                            result.align = zoneOrder[i].align;
                            break;
                        }
                    }

                    // Cache the largest zone we find in case we need the final fallback.
                    if (!largestZone || zone.area > largestZone.area) {
                        const r = result.clone();

                        // And just move the result clone into the edge zone
                        switch (resultZone) {
                            // Top
                            case 0:
                                r.moveTo(null, zone.bottom - r.height);
                                break;
                            // Right
                            case 1:
                                r.moveTo(zone.left);
                                break;
                            // Bottom
                            case 2:
                                r.moveTo(null, zone.top);
                                break;
                            // Left
                            case 3:
                                r.moveTo(zone.right - r.width);
                                break;
                        }

                        largestZone = {
                            area   : zone.area,
                            result : r,
                            zone   : resultZone
                        };
                    }
                }

                // The loop found at least one solution
                if (solutions.length) {
                    // Multiple fallbacks with no axisLock.
                    // Use the solution which resulted in the shortest translation distance from the requested alignment.
                    if (solutions.length > 1 && !axisLock) {
                        solutions.sort((s1, s2) => {
                            let s1TranslationDistance = Math.sqrt((requestedResult.x - s1.result.x) ** 2 + (requestedResult.y - s1.result.y) ** 2),
                                s2TranslationDistance = Math.sqrt((requestedResult.x - s2.result.x) ** 2 + (requestedResult.y - s2.result.y) ** 2);

                            return s1TranslationDistance - s2TranslationDistance;
                        });
                    }
                    // Initial success, or axisLock. Use first successful solution.
                    result = solutions[0].result;
                    resultZone = solutions[0].zone;
                }
                // No solutions found - use the largest rectangle.
                else {
                    result = largestZone.result;
                    resultZone = largestZone.zone;

                    // When we are constraining to the viewport, we must still must be constrained,
                    // even after we've given up making it align *and* constrain.
                    if (constrainingToViewport) {
                        result.constrainTo(constrainTo);
                    }
                }
            }
            else {
                resultZone = alignSpec.startZone;
            }

            result.zone = resultZone;

            // If they included an anchor, calculate its position along its edge.
            // TODO: Handle the edge overlap being less than anchor width.
            if (anchorSize) {
                // If we were passed an anchorPosition, and it has remnained valid (meaning the requested
                // alignment succeeded with no constraint), then anchorPosition will be set. If not,
                // we have to calculate it based upon the aligned edge.
                if (!calculatedAnchorPosition) {
                    let isLeftOrRight = resultZone & 1,
                        start         = isLeftOrRight ? 'y' : 'x',
                        end           = isLeftOrRight ? 'bottom' : 'right',
                        startValue    = Math.max(target[start], result[start]),
                        endValue      = Math.min(target[end], result[end]),
                        anchorStart   = (startValue + (endValue - startValue) / 2 - anchorSize[0] / 2),
                        anchorEnd     = anchorStart + anchorSize[0];

                    if (anchorEnd > result[end]) {
                        anchorStart -= (anchorEnd - result[end]);
                    }
                    if (anchorStart < result[start]) {
                        anchorStart += (result[start] - anchorStart);
                    }

                    // Return an anchor property which will have an x or y property and an edge name onto which the
                    // arrow should be aligned.
                    calculatedAnchorPosition = {
                        [start] : anchorStart - result[start],
                        edge    : edgeNames[(resultZone + 2) % 4]
                    };
                }

                result.anchor = calculatedAnchorPosition;
            }
        }

        return result;
    }

    /**
     * Returns the `[x, y]` position of the specified anchor point of this Rectangle in <edge><offset> format.
     * for example passing "t50" will return the centre point of the top edge, passing "r0" will return the start
     * position of the right edge (the top right corner).
     *
     * Note that the offset defaults to 50, so "t" means the centre of the top edge.
     * @param {String} alignmentPoint The alignment point to calculate. Must match the RegExp `[trbl]\d*`
     * @param {Number[]} margins The `[x, y]` margins to add from the left/right, top/bottom edge.
     */
    getAlignmentPoint(alignmentPoint, margins = zeroOffsets) {
        

        const
            me         = this,
            parts      = alignPointRe.exec(alignmentPoint),
            edge       = parts[1].toLowerCase(),
            edgeOffset = Math.min(Math.max(parseInt(parts[2] || 50), 0), 100) / 100;

        switch (edge) {
            case 't':
                return [me.x + me.width * edgeOffset, me.y - margins[1]];
            case 'r':
                return [me.right + margins[0], me.y + me.height * edgeOffset];
            case 'b':
                return [me.x + me.width * edgeOffset, me.bottom + margins[1]];
            case 'l':
                return [me.x - margins[0], me.y + me.height * edgeOffset];
            case 'c':
                const center = me.center;
                return [center.x + margins[0], center.y + margins[1]];
        }
    }

    /**
     * Highlights this Rectangle using the highlighting effect of {@link Core.helper.DomHelper}
     * on a transient element which encapsulates the region's area.
     */
    highlight() {
        const
            me               = this,
            highlightElement = DomHelper.createElement({
                parent : document.body,
                style  : `position:absolute;z-index:9999999;pointer-events:none;
                            left:${me.x}px;top:${me.y}px;width:${me.width}px;height:${me.height}px`
            });

        return DomHelper.highlight(highlightElement).then(() => highlightElement.remove());
    }

    
}
Rectangle._$name = 'Rectangle';

/**
 * @module Core/helper/util/Point
 */

/**
 * Encapsulates an X,Y coordinate point.
 * @extends Core/helper/util/Rectangle
 */
class Point extends Rectangle {
    /**
     * Creates a new Point encapsulating the event's page position.
     * @param {Event} event
     * @return {Core.helper.util.Point}
     * @typings ignore
     */
    static from(event) {
        const touchPoints = event.changedTouches;

        return new Point(touchPoints ? touchPoints[0].screenX : event.screenX, touchPoints ? touchPoints[0].screenY : event.pageY);
    }

    /**
     * Constructs a Point
     * @param x The X coordinate
     * @param y The Y coordinate
     */
    constructor(x, y) {
        super(x, y, 0, 0);
    }

    /**
     * Coerces this Point to be within the passed Rectangle. Translates it into the bounds.
     * @param {Core.helper.util.Rectangle} into The Rectangle into which to coerce this Point.
     */
    constrain(into) {
        this.x = Math.min(Math.max(this.x, into.x), into.right - 1);
        this.y = Math.min(Math.max(this.y, into.y), into.bottom - 1);
        return  this;
    }

    toArray() {
        return [this.x, this.y];
    }
}

// The Rectangle class uses the Point class, but cannot import it.
// TODO: find a better way of getting a reference to the Point class in Rectangle.

// #8224 - Gantt angular demo doesn't work in production
// eslint-disable-next-line no-proto
Point.__proto__.Point = Point;
Point._$name = 'Point';

/**
 * @module Core/helper/FunctionHelper
 */

/**
 * Provides functionality for working with functions
 * @internal
 */
class FunctionHelper {
    static curry(func) {
        return function curried(...args) {
            if (args.length >= func.length) {
                return func.apply(this, args);
            }
            else {
                return function(...args2) {
                    return curried.apply(this, args.concat(args2));
                };
            }
        };
    }

    static bindAll(obj) {
        for (let key in obj) {
            if (typeof obj[key] === 'function') {
                obj[key] = obj[key].bind(obj);
            }
        }
    }

    /**
     * Returns a function which calls the passed `interceptor` function first, and the passed `original` after
     * as long as the `interceptor` does not return `false`.
     * @param {Function} original The function to call second.
     * @param {Function} interceptor The function to call first.
     * @param {Object} [thisObj] The `this` reference when the functions are called.
     * @returns The return value from the `original` function **if it was called**, else `false`.
     */
    static createInterceptor(original, interceptor, thisObj) {
        return (...args) => {
            if (interceptor.call(thisObj, ...args) !== false) {
                return original.call(thisObj, ...args);
            }
            return false;
        };
    }

    /**
     * Returns a function which calls the passed `sequence` function after calling
     * the passed `original`.
     * @param {Function} original The function to call first.
     * @param {Function} sequence The function to call second.
     * @param {Object} [thisObj] The `this` reference when the functions are called.
     * @returns The value returned from the sequence if it returned a value, else the return
     * value from the original function.
     */
    static createSequence(original, sequence, thisObj) {
        return (...args) => {
            const origResult = original.call(thisObj, ...args),
                sequenceResult = sequence.call(thisObj, ...args);

            return (sequenceResult === void 0) ? origResult : sequenceResult;
        };
    }

    /**
     * Create a "debounced" function which will call on the "leading edge" of a timer period.
     * When first invoked will call immediately, but invocations after that inside its buffer
     * period will be rejected, and *one* invocation will be made after the buffer period has expired.
     *
     * This is useful for responding immediately to a first mousemove, but from then on, only
     * calling the action function on a regular timer while the mouse continues to move.
     *
     * @param {Function} fn The function to call.
     * @param {Number} buffer The milliseconds to wait after each execution before another execution takes place.
     * @param {Object} [thisObj] `this` reference for the function.
     * @param {Array} [extraArgs] The argument list to append to those passed to the function.
     * @param {Function} [alt] A function to call when the invocation is rejected due to buffer time not having expired.
     */
    static createThrottled(fn, buffer, thisObj, extraArgs, alt) {
        let lastCallTime = 0,
            callArgs,
            timerId,
            result;

        const invoke = () => {
            timerId = 0;
            lastCallTime = performance.now();
            callArgs.push.apply(callArgs, extraArgs);
            fn.apply(thisObj, callArgs);
        };

        result = function(...args) {
            let elapsed = performance.now() - lastCallTime;

            callArgs = args;

            // If it's been more then the buffer period since we invoked, we can call it now
            if (elapsed >= buffer) {
                clearTimeout(timerId);
                invoke();
            }
            // Otherwise, kick off a timer for the requested period.
            else {
                if (!timerId) {
                    timerId = setTimeout(invoke, buffer - elapsed);
                }
                if (alt) {
                    callArgs.push.apply(callArgs, extraArgs);
                    alt.apply(thisObj, callArgs);
                }
            }
        };

        result.cancel = () => clearTimeout(timerId);

        return result;
    }

    /**
     * Create a "debounced" function which will call on the "trailing edge" of a timer period.
     * When first invoked will wait until the buffer period has expired to call the function, and
     * more calls within that time will restart the timer.
     *
     * This is useful for responding to keystrokes, but deferring action until the user pauses typing.
     *
     * @param {Function} fn The function to call.
     * @param {Number} buffer The milliseconds to wait after each execution before another execution takes place.
     * @param {Object} [thisObj] `this` reference for the function.
     * @param {Array} [args] The argument list to append to those passed to the function.
     */
    static createBuffered(fn, buffer, thisObj, args) {
        let callArgs,
            timerId,
            result;

        const invoke = () => {
            timerId = 0;
            callArgs.push.apply(callArgs, args);
            fn.apply(thisObj, callArgs);
        };

        result = function(...args) {
            callArgs = args;

            // Cancel any impending invocation. It's pushed out for <buffer> ms from each call
            if (timerId) {
                clearTimeout(timerId);
            }

            timerId = setTimeout(invoke, buffer);
        };

        result.cancel = () => clearTimeout(timerId);

        return result;
    }

    static returnTrue() {
        return true;
    }

    static animate(duration, fn, thisObj, easing = 'linear') {
        let cancel = false;

        const result = new Promise(resolve => {
            const start = performance.now(),
                iterate = () => {
                    const progress = Math.min((performance.now() - start) / duration, 1),
                        delayable = thisObj && thisObj.setTimeout ? thisObj : window;

                    if (!cancel) {
                        if (fn.call(thisObj, this.easingFunctions[easing](progress)) === false) {
                            resolve();
                        }
                    }
                    if (cancel || progress === 1) {
                        // Push resolution into the next animation frame so that
                        // this frame completes before the resolution handler runs.
                        delayable.requestAnimationFrame(() => resolve());
                    }
                    else {
                        delayable.requestAnimationFrame(iterate);
                    }
                };

            iterate();
        });

        result.cancel = () => {
            cancel = true;
            return false;
        };

        return result;
    }
}

/* eslint-disable */
const half = 0.5, e1 = 1.70158, e2 = 7.5625, e3 = 1.525, e4 = 2/2.75, e5 = 2.25/2.75, e6 = 1/2.75, e7 = 1.5/2.75, e8 = 2.5/2.75, e9 = 2.625/2.75, e10 = 0.75, e11 = 0.9375, e12 = 0.984375;
FunctionHelper.easingFunctions = {
    linear         : t => t,
    easeInQuad     : t => Math.pow(t,2),
    easeOutQuad    : t => -(Math.pow((t-1),2)-1),
    easeInOutQuad  : t => (t/=half)<1 ? half*Math.pow(t,2) : -half*((t-=2)*t-2),
    easeInCubic    : t => Math.pow(t,3),
    easeOutCubic   : t => Math.pow((t-1),3)+1,
    easeInOutCubic : t => (t/=half)<1 ? half*Math.pow(t,3) : half*(Math.pow((t-2),3)+2),
    easeInQuart    : t => Math.pow(t,4),
    easeOutQuart   : t => -(Math.pow((t-1),4)-1),
    easeInOutQuart : t => (t/=half)<1 ? half*Math.pow(t,4) : -half*((t-=2)*Math.pow(t,3)-2),
    easeInQuint    : t => Math.pow(t,5),
    easeOutQuint   : t => (Math.pow((t-1),5)+1),
    easeInOutQuint : t => (t/=half)<1 ? half*Math.pow(t,5) : half*(Math.pow((t-2),5)+2),
    easeInSine     : t => -Math.cos(t*(Math.PI/2))+1,
    easeOutSine    : t => Math.sin(t*(Math.PI/2)),
    easeInOutSine  : t => -half*(Math.cos(Math.PI*t)-1),
    easeInExpo     : t => t===0 ? 0 : Math.pow(2,10*(t-1)),
    easeOutExpo    : t => t===1 ? 1 : -Math.pow(2,-10*t)+1,
    easeInOutExpo  : t => (t===0) ? 0 : (t===1) ? 1 : ((t/=half)<1) ? half*Math.pow(2,10*(t-1)) : half*(-Math.pow(2,-10*--t)+2),
    easeInCirc     : t => -(Math.sqrt(1-(t*t))-1),
    easeOutCirc    : t => Math.sqrt(1-Math.pow((t-1),2)),
    easeInOutCirc  : t => (t/=half)<1 ? -half*(Math.sqrt(1-t*t)-1) : half*(Math.sqrt(1-(t-=2)*t)+1),
    easeOutBounce  : t => ((t)<e6) ? (e2*t*t) : (t<e4) ? (e2*(t-=e7)*t+e10) : (t<e8) ? (e2*(t-=e5)*t+e11) : (e2*(t-=e9)*t+e12),
    easeInBack     : t => (t)*t*((e1+1)*t-e1),
    easeOutBack    : t => (t=t-1)*t*((e1+1)*t+e1)+1,
    easeInOutBack  : t => {
                        let s = 1.70158;
                        return ((t/=half)<1) ? half*(t*t*(((s*=(e3))+1)*t -s)) : half*((t-=2)*t*(((s*=(e3))+1)*t+s)+2);
                    },
    elastic        : t => -1*Math.pow(4,-8*t)*Math.sin((t*6-1)*(2*Math.PI)/2)+1,
    swingFromTo    : t => {
                        let s = 1.70158;
                        return ((t/=half)<1) ? half*(t*t*(((s*=(e3))+1)*t-s)) : half*((t-=2)*t*(((s*=(e3))+1)*t+s)+2);
                    },
    swingFrom      : t => t*t*((e1+1)*t-e1),
    swingTo        : t => (t-=1)*t*((e1+1)*t+e1)+1,
    bounce         : t => (t<e6) ? (e2*t*t) : (t<e4) ? (e2*(t-=e7)*t+e10) : (t<e8) ? (e2*(t-=e5)*t+e11) : (e2*(t-=e9)*t+e12),
    bouncePast     : t => (t<e6) ? (e2*t*t) : (t<e4) ? 2-(e2*(t-=e7)*t+e10) : (t<e8) ? 2-(e2*(t-=e5)*t+e11) : 2-(e2*(t-=e9)*t+e12),
    easeFromTo     : t => (t/=half)<1 ? half*Math.pow(t,4) : -half*((t-=2)*Math.pow(t,3)-2),
    easeFrom       : t => Math.pow(t,4),
    easeTo         : t => Math.pow(t,0.25)
};


FunctionHelper._$name = 'FunctionHelper';

/**
 * @module Core/helper/EventHelper
 */

const touchProperties = [
        'clientX',
        'clientY',
        'pageX',
        'pageY',
        'screenX',
        'screenY'
    ],
    isOption = {
        element    : 1,
        thisObj    : 1,
        once       : 1,
        delegate   : 1,
        delay      : 1,
        capture    : 1,
        passive    : 1,
        throttled  : 1,
        autoDetach : 1,
        expires    : 1
    },
    ctrlKeyProp = {
        get : () => true
    },
    normalizedKeyNames = {
        Spacebar : 'Space',
        Del      : 'Delete',
        Esc      : 'Escape',
        Left     : 'ArrowLeft',
        Up       : 'ArrowUp',
        Right    : 'ArrowRight',
        Down     : 'ArrowDown'
    },
    fixEvent = (event) => {
        const { type } = event;

        // Normalize key names
        if (type.startsWith('key')) {
            const normalizedKeyName = normalizedKeyNames[event.key];
            if (normalizedKeyName) {
                Object.defineProperty(event, 'key', {
                    get : () => normalizedKeyName
                });
            }

            // Polyfill the code property for SPACE because it is not set for synthetic events.
            if (event.key === ' ' && !event.code) {
                Object.defineProperty(event, 'code', {
                    get : () => 'Space'
                });
            }
        }

        // Sync OSX's meta key with the ctrl key. This will only happen on Mac platform.
        // It's read-only, so define a local property to return true for ctrlKey.
        if (event.metaKey && !event.ctrlKey) {
            Object.defineProperty(event, 'ctrlKey', ctrlKeyProp);
        }

        // When we listen to event on document and get event which bubbled from shadow dom, reading its target would
        // return shadow root element. We need actual element which started the event
        if (event.target && event.target.shadowRoot && event.composedPath && !BrowserHelper.isIE11 && !BrowserHelper.isEdge) {
            const
                targetElement  = event.composedPath()[0],
                originalTarget = event.target;

            // Can there be an event which actually originated from custom element, not its shadow dom?
            if (event.target !== targetElement) {
                Object.defineProperty(event, 'target', {
                    get : () => targetElement
                });

                // Save original target just in case
                Object.defineProperty(event, 'originalTarget', {
                    get : () => originalTarget
                });
            }
        }

        // Chrome 78 has a bug where moving out of the left edge of an element can report a mousemove
        // with that element as the target, but offsetX as -1 and moving out the right edge can report
        // that the element is the target but an offset of the offsetWidth. Patch the event until they fix it.
        // https://bugs.chromium.org/p/chromium/issues/detail?id=1010528
        if (BrowserHelper.isChrome && event.target) {
            const
                { target } = event,
                { offsetX, offsetY } = event,
                { offsetWidth, offsetHeight } = target,
                x = Math.min(Math.max(offsetX, 0), offsetWidth - 1),
                y = Math.min(Math.max(offsetY, 0), offsetHeight - 1);

            if (!Object.getOwnPropertyDescriptor(event, 'offsetX') && (offsetX < 0 || offsetX >= offsetWidth)) {
                Object.defineProperty(event, 'offsetX', {
                    get : () => x
                });
            }
            if (!Object.getOwnPropertyDescriptor(event, 'offsetY') && (offsetY < 0 || offsetY >= offsetHeight)) {
                Object.defineProperty(event, 'offsetY', {
                    get : () => y
                });
            }
        }

        // Firefox has a bug where it can report that the target is the #document when mouse is over a pseudo element
        if (event.target && event.target.nodeType === 9 && 'clientX' in event) {
            const targetElement = DomHelper.elementFromPoint(event.clientX, event.clientY);
            Object.defineProperty(event, 'target', {
                get : () => targetElement
            });
        }

        // Firefox has a bug where it can report a textNode as an event target/relatedTarget.
        // We standardize this to report the parentElement.
        if (event.target && event.target.nodeType === 3) {
            const targetElement = event.target.parentElement;
            Object.defineProperty(event, 'target', {
                get : () => targetElement
            });
        }
        if (event.relatedTarget && event.relatedTarget.nodeType === 3) {
            const relatedTargetElement = event.target.parentElement;
            Object.defineProperty(event, 'relatedTarget', {
                get : () => relatedTargetElement
            });
        }

        // If it's a touch event, move the positional details
        // of touches[0] up to the event.
        if (type.startsWith('touch') && event.touches.length) {
            EventHelper.normalizeEvent(event);
        }

        return event;
    };

/**
 * Utility methods for dealing with Events, normalizing Touch/Pointer/Mouse events.
 */
class EventHelper {
    static normalizeEvent(event) {
        return ObjectHelper.copyPropertiesIf(event, event.touches[0] || event.changedTouches[0], touchProperties);
    }

    /**
     * Returns the `[x, y]` coordinates of the event in the viewport coordinate system.
     * @param {Event} event The event
     * @return {Number[]} The coordinate.
     */
    static getXY(event) {
        if (event.touches) {
            event = event.touches[0];
        }
        return [event.clientX, event.clientY];
    }

    /**
     * Returns the pixel distance between two mouse/touch/pointer events.
     * @param {Event} event1 The first event.
     * @param {Event} event2 The second event.
     * @return {Number} The distance in pixels between the two events.
     */
    static getDistanceBetween(event1, event2) {
        const
            xy1 = this.getXY(event1),
            xy2 = this.getXY(event2);

        // No point in moving this to Point. We are dealing only with number values here.
        return Math.sqrt(Math.pow(xy1[0] - xy2[0], 2) + Math.pow(xy1[1] - xy2[1], 2));
    }

    /**
     * Returns a {@link Core.helper.util.Point} which encapsulates the `pageX/Y` position of the event.
     * May be used in {@link Core.helper.util.Rectangle} events.
     * @param {Event} event A browser mouse/touch/pointer event.
     * @return {Core.helper.util.Point} The page point.
     */
    static getPagePoint(event) {
        return new Point(event.pageX, event.pageY);
    }

    /**
     * Returns a {@link Core.helper.util.Point} which encapsulates the `clientX/Y` position of the event.
     * May be used in {@link Core.helper.util.Rectangle} events.
     * @param {Event} event A browser mouse/touch/pointer event.
     * @return {Core.helper.util.Point} The page point.
     */
    static getClientPoint(event) {
        return new Point(event.clientX, event.clientY);
    }

    /**
     * Add a listener or listeners to an element
     * @param {HTMLElement} element The element to add a listener/listeners to.
     * @param {String|Object} eventName Either a string, being the name of the event to listen for,
     * or an options object containing event names and options as keys. See the options parameter
     * for details, or the {@link #function-on-static} method for details.
     * @param {Function} [handler] If the second parameter is a string event name, this is the handler function.
     * @param {Object} [options] If the second parameter is a string event name, this is the options.
     * @param {HTMLElement} options.element The element to add the listener to.
     * @param {Object} options.thisObj The default `this` reference for all handlers added in this call.
     * @param {Boolean} [options.autoDetach=true] The listeners are automatically removed when the `thisObj` is destroyed.
     * @param {String} [options.delegate] A CSS selector string which only fires the handler when the event takes place in a matching element.
     * @param {Boolean} [options.once] Specify as `true` to have the listener(s) removed upon first invocation.
     * @param {Number} [options.delay] The number of milliseconds to delay the handler call after the event fires:
     *
     *     {
     *         once       : true,           // Removed upon first firing
     *         delegate   : this.iconCls,   // Only when clicking the icon
     *         thisObj    : this            // The this reference when the handler is called
     *                                      // Listener is removed when thisObj is destroyed
     *     }
     * @returns {Function} A detacher function which removes all the listeners when called.
     */
    static addListener(element, eventName, handler, options) {
        if (element.nodeType) {
            // All separate params, element, eventname and handler
            if (typeof eventName === 'string') {
                options = Object.assign({
                    element,
                    [eventName] : handler
                }, options);
            }
            // element, options
            else {
                options = Object.assign({
                    element
                }, eventName);
            }
        }
        // Just an options object passed
        else {
            options = element;
        }
        return this.on(options);
    }

    /**
     * Adds a listener or listeners to an element.
     * all property names other than the options listed below are taken to be event names,
     * and the values as handler specs.
     *
     * A handler spec is usually a function reference or the name of a function in the `thisObj`
     * option.
     *
     * But a handler spec may also be an options object containing a `handler` property which is
     * the function or function name, and local options, including `element` and `thisObj`
     * which override the top level options.
     *
     *  Usage example
     *
     * ```javascript
     * construct(config) {
     *     super.construct(config);
     *
     *     // Add auto detaching event handlers to this Widget's reference elements
     *     EventHelper.on({
     *         element : this.iconElement,
     *         click   : '_handleIconClick',
     *         thisObj : this,
     *         contextmenu : {
     *             element : document,
     *             handler : '_handleDocumentContextMenu'
     *         }
     *     });
     * }
     *```
     *
     * The `click` handler on the `iconElement` calls `this._handleIconClick`.
     *
     * The `contextmenu` handler is added to the `document` element, but the `thisObj`
     * is defaulted in from the top `options` and calls `this._handleDocumentContextMenu`.
     *
     * Note that on touch devices, `dblclick` and `contextmenu` events are synthesized.
     * Synthesized events contain a `browserEvent` property containing the final triggering
     * event of the gesture. For example a synthesized `dblclick` event would contain a
     * `browserEvent` property which is the last `touchend` event. A synthetic `contextmenu`
     * event will contain a `browserEvent` property which the longstanding `touchstart` event.
     *
     * @param {Object} options The full listener specification.
     * @param {HTMLElement} options.element The element to add the listener to.
     * @param {Object} options.thisObj The default `this` reference for all handlers added in this call.
     * @param {Boolean} [options.autoDetach=true] The listeners are automatically removed when the `thisObj` is destroyed.
     * @param {String} [options.delegate] A CSS selector string which only fires the handler when the event takes place in a matching element.
     * @param {Boolean} [options.once] Specify as `true` to have the listener(s) removed upon first invocation.
     * @param {Number} [options.delay] The number of milliseconds to delay the handler call after the event fires.
     * @param {Number} [options.throttled] For rapidly repeating events (Such as `wheel` or `scroll` or `mousemove`)
     * this is the number of milliseconds to delay subsequent handler calls after first invocation which happens immediately.
     * @returns {Function} A detacher function which removes all the listeners when called.
     */
    static on(options) {
        const EventHelper    = this,
            element        = options.element,
            thisObj        = options.thisObj,
            handlerDetails = [],
            keys           = ObjectHelper.allKeys(options);

        let len = keys.length,
            i, eventName;

        for (i = 0; i < len; i++) {
            eventName = keys[i];

            // Only treat it as an event name if it's not a supported option
            if (!isOption[eventName]) {
                let handlerSpec = options[eventName];
                if (typeof handlerSpec !== 'object') {
                    handlerSpec = {
                        handler : handlerSpec
                    };
                }
                const targetElement = handlerSpec.element || element;

                // If we need to convert taphold to an emulated contextmenu, add a wrapping function
                // in addition to the contextmenu listener. Platforms may support mouse *and* touch.
                if (BrowserHelper.isTouchDevice && !BrowserHelper.isAndroid) {
                    if (eventName === 'contextmenu') {
                        handlerDetails.push(EventHelper.addElementListener(targetElement, 'touchstart', {
                            handler : EventHelper.createContextMenuWrapper(handlerSpec.handler, handlerSpec.thisObj || thisObj)
                        }, options));
                    }
                }

                // Keep track of the real handlers added.
                // addElementLister returns [ element, eventName, addedfunction, capture ]
                handlerDetails.push(EventHelper.addElementListener(targetElement, eventName, handlerSpec, options));
            }
        }

        const detacher = () => {
            len = handlerDetails.length;
            for (i = 0; i < len; i++) {
                const handlerSpec = handlerDetails[i];
                handlerSpec[0].removeEventListener(handlerSpec[1], handlerSpec[2], handlerSpec[3]);
            }
            handlerDetails.length = 0;
        };

        // { autoDetach : true, thisObj : scheduler } means remove all listeners when the scheduler dies.
        if (thisObj && options.autoDetach !== false) {
            thisObj.doDestroy = FunctionHelper.createInterceptor(thisObj.doDestroy, detacher, thisObj);
        }

        return detacher;
    }

    /**
     * Used internally to add a single event handler to an element.
     * @param {HTMLElement} element The element to add the handler to.
     * @param {String} eventName The name of the event to add a handler for.
     * @param {Function|String|Object} handlerSpec Either a function to call, or
     * the name of a function to call in the `thisObj`, or an object containing
     * the handler local options.
     * @param {Function|String} [handlerSpec.handler] Either a function to call, or
     * the name of a function to call in the `thisObj`.
     * @param {HTMLElement} [handlerSpec.element] Optionally a local element for the listener.
     * @param {Object} [handlerSpec.thisObj] A local `this` specification for the handler.
     * @param {Object} defaults The `options` parameter from the {@link #function-addListener-static} call.
     * @private
     */
    static addElementListener(element, eventName, handlerSpec, defaults) {
        const handler           = this.createHandler(element, eventName, handlerSpec, defaults),
            handlerHasPassive = ('passive' in handlerSpec),
            expires           = handlerSpec.expires || defaults.expires,
            thisObj           = defaults.thisObj;

        let options = handlerSpec.capture || defaults.capture;

        // If we are passed the passive option and the browser supports it, then convert
        // The capture option into the object options form.
        if ((handlerHasPassive || ('passive' in defaults)) && BrowserHelper.supportsPassive) {
            options = {
                capture : !!options,
                passive : handlerHasPassive ? handlerSpec.passive : defaults.passive
            };
        }
        element.addEventListener(eventName, handler, options);
        if (expires) {
            const delayable = thisObj && thisObj.setTimeout ? thisObj : window;

            (typeof expires === 'number' ? delayable.setTimeout : delayable.requestAnimationFrame).call(delayable, () => element.removeEventListener(eventName, handler, options), expires);
        }

        return [element, eventName, handler, options];
    }

    static createHandler(element, eventName, handlerSpec, defaults) {
        const
            delay            = handlerSpec.delay || defaults.delay,
            throttled        = handlerSpec.throttled || defaults.throttled,
            once             = handlerSpec.once || defaults.once,
            thisObj          = handlerSpec.thisObj || defaults.thisObj,
            capture          = handlerSpec.capture || defaults.capture,
            delegate         = handlerSpec.delegate || defaults.delegate;

        //Capture initial conditions in case of destruction of thisObj.
        // Destruction completely wipes the object.
        

        let wrappedFn = handlerSpec.handler,
            // Innermost level of wrapping which calls the user's handler.
            // Normalize the event cross-browser, and attempt to normalize touch events.
            // Resolve named functions in the thisObj.
            handler = (event, ...args) => {
                // When playing a demo using DemoBot, only handle synthetic events
                if (this.playingDemo && event.isTrusted) {
                    return;
                }

                // If the thisObj is already destroyed, we cannot call the function.
                // If in dev mode, warn the developer with a JS error.
                if (thisObj && thisObj.isDestroyed) {
                    
                    // eslint-disable-next-line
                    return;
                }

                // Fix up events to handle various browser inconsistencies
                fixEvent(event);

                // delegate: '.b-field-trigger' only fires when click is in a matching el.
                // currentTarget becomes the delegate.
                if (delegate) {
                    // Maintainer: In Edge event.target can be an empty object for transitionend events
                    const delegatedTarget = event.target instanceof HTMLElement && event.target.closest(delegate);
                    if (!delegatedTarget) {
                        return;
                    }
                    // Allow this to be redefined as it bubbles through listeners up the parentNode axis
                    // which might have their own delegate settings.
                    Object.defineProperty(event, 'currentTarget', {
                        get          : () => delegatedTarget,
                        configurable : true
                    });
                }

                if (typeof wrappedFn === 'string') {
                    wrappedFn = thisObj[wrappedFn];
                }
                wrappedFn.call(thisObj, event, ...args);
            };

        // Go through options, each creates a new handler by wrapping the previous handler to implement the options.
        // Right now, we have delay. Note that it may be zero, so test != null
        if (delay != null) {
            const
                wrappedFn = handler,
                delayable = thisObj && thisObj.setTimeout ? thisObj : window;
            
            handler = (...args) => {
                delayable.setTimeout(() => {
                    wrappedFn(...args);
                }, delay);
            };
        }

        // If they specified the throttled option, wrap the handler in a createdThrottled
        // version. Allow the called to specify an alt function to call when the event
        // fires before the buffer time has expired.
        if (throttled != null) {
            let alt, buffer = throttled;

            if (throttled.buffer) {
                alt = e => throttled.alt.call(this, fixEvent(e));
                buffer = throttled.buffer;
            }
            
            if (thisObj && thisObj.isDelayable) {
                handler = thisObj.throttle(handler, buffer, thisObj, null, alt);
            }
            else {
                handler = FunctionHelper.createThrottled(handler, buffer, thisObj, null, alt);
            }
        }

        // This must always be the last option processed so that it is the outermost handler
        // which is the one added to the element and is called immediately so that the
        // handler is removed immediately.
        // TODO: Use the native once option when all browsers support it. Only IE11 doesn't.
        if (once) {
            const wrappedFn = handler;
            handler = (...args) => {
                element.removeEventListener(eventName, handler, capture);
                wrappedFn(...args);
            };
        }

        // Only autoDetach here if there's a local thisObj is in the handlerSpec for this one listener.
        // If it's in the defaults, then the "on" method will handle it.
        if (handlerSpec.thisObj && handlerSpec.autoDetach !== false) {
            thisObj.doDestroy = FunctionHelper.createInterceptor(thisObj.doDestroy, () => element.removeEventListener(eventName, handler), thisObj);
        }

        return handler;
    }
    
    static onTransitionEnd({ element, property, handler, timeout, thisObj = window }) {
        let timerId;
        
        const detacher = EventHelper.on({
            element,
            thisObj,
            transitionend(e) {
                if (e.propertyName === property) {
                    if (timerId) {
                        if (thisObj.isDelayable) {
                            thisObj.clearTimeout(timerId);
                        }
                        else {
                            clearTimeout(timerId);
                        }
                        
                        timerId = null;
                    }
                    
                    detacher();
                    
                    handler.call(thisObj);
                }
            }
        });
        
        if (timeout == null) {
            timeout = DomHelper.getPropertyTransitionDuration(element, property);
        }
    
        if (timeout != null) {
            if (thisObj.isDelayable) {
                timerId = thisObj.setTimeout(() => {
                    detacher();
            
                    handler.call(thisObj);
                }, timeout);
            }
            else {
                timerId = setTimeout(() => {
                    detacher();
            
                    handler.call(thisObj);
                }, timeout);
            }
        }
    }

    /**
     * Private function to wrap the passed function. The returned wrapper function to be used as
     * a `touchstart` handler which will call the passed function passing a fabricated `contextmenu`
     * event if there's no `touchend` or `touchmove` after a default of 400ms.
     * @param {String|Function} handler The handler to call.
     * @param {Object} thisObj The owner of the function.
     * @private
     */
    static createContextMenuWrapper(handler, me) {
        const EventHelper = this;

        return event => {
            // Only attempt conversion to contextmenu if it's a single touch start.
            if (event.touches.length === 1) {
                const tapholdStartTouch = event.touches[0],
                    // Dispatch a synthetic "contextmenu" event from the touchpoint in <longPressTime> milliseconds.
                    tapholdTimer = setTimeout(() => {
                        // Remove the gesture cancelling listeners
                        touchMoveRemover();

                        const contextmenuEvent = new MouseEvent('contextmenu', tapholdStartTouch);
                        Object.defineProperty(contextmenuEvent, 'target', {
                            get() {
                                return tapholdStartTouch.target;
                            }
                        });
                        if (typeof handler === 'string') {
                            handler = me[handler];
                        }

                        contextmenuEvent.browserEvent = event;

                        // Call the wrapped handler passing the fabricated contextmenu event
                        handler.call(me, contextmenuEvent);
                        EventHelper.contextMenuTouchId = tapholdStartTouch.identifier;
                    }, EventHelper.longPressTime),
                    // This is what gets called if the user moves their touchpoint,
                    // or releases the touch before <longPressTime>ms is up
                    cancelTapholdTimer = () => {
                        EventHelper.contextMenuTouchId = null;
                        touchMoveRemover();
                        clearTimeout(tapholdTimer);
                    },
                    // Touchmove or touchend before that timer fires cancels the timer and removes these listeners.
                    touchMoveRemover = EventHelper.on({
                        element     : document,
                        touchmove   : cancelTapholdTimer,
                        touchend    : cancelTapholdTimer,
                        pointermove : cancelTapholdTimer,
                        pointerup   : cancelTapholdTimer,
                        capture     : true
                    });
            }
        };
    }

    /**
     * Private function to wrap the passed function. The returned wrapper function to be used as
     * a `touchend` handler which will call the passed function passing a fabricated `dblclick`
     * event if there is a `click` within 300ms.
     * @param {String|Function} handler The handler to call.
     * @param {Object} thisObj The owner of the function.
     * @private
     */
    static createDblClickWrapper(element, handler, me) {
        const EventHelper = this;

        let startId, secondListenerDetacher, tapholdTimer;

        return () => {
            if (!secondListenerDetacher) {
                secondListenerDetacher = EventHelper.on({
                    element,

                    // We only get here if a touchstart arrives within 300ms of a click
                    touchstart : secondStart => {
                        startId = secondStart.changedTouches[0].identifier;
                        // Prevent zoom
                        secondStart.preventDefault();
                    },
                    touchend : secondClick => {
                        if (secondClick.changedTouches[0].identifier === startId) {
                            secondClick.preventDefault();

                            clearTimeout(tapholdTimer);
                            startId = secondListenerDetacher = null;

                            const targetRect          = Rectangle.from(secondClick.changedTouches[0].target, null, true),
                                offsetX             = secondClick.changedTouches[0].pageX - targetRect.x,
                                offsetY             = secondClick.changedTouches[0].pageY - targetRect.y,
                                dblclickEventConfig = Object.assign({
                                    browserEvent : secondClick
                                }, secondClick),
                                dblclickEvent       = new MouseEvent('dblclick', dblclickEventConfig);

                            Object.defineProperty(dblclickEvent, 'target', {
                                get() {
                                    return secondClick.target;
                                }
                            });

                            Object.defineProperty(dblclickEvent, 'offsetX', {
                                get() {
                                    return offsetX;
                                }
                            });

                            Object.defineProperty(dblclickEvent, 'offsetY', {
                                get() {
                                    return offsetY;
                                }
                            });

                            if (typeof handler === 'string') {
                                handler = me[handler];
                            }

                            // Call the wrapped handler passing the fabricated dblclick event
                            handler.call(me, dblclickEvent);
                        }
                    },
                    once : true
                });

                // Cancel the second listener is there's no second click within <dblClickTime> milliseconds.
                tapholdTimer = setTimeout(() => {
                    secondListenerDetacher();
                    startId = secondListenerDetacher = null;
                }, EventHelper.dblClickTime);
            }
        };
    }

    static lockComposedPath(event) {
        if (event.composedPath) {
            event.composedPath = ((path) => () => path)(event.composedPath());
        }
    }
}

/**
 * The time in milliseconds for a `taphold` gesture to trigger a `contextmenu` event.
 * @member {Number} [longPressTime=500]
 * @readonly
 * @static
 */
EventHelper.longPressTime = 500;

/**
 * The time in milliseconds within which a second touch tap event triggers a `dblclick` event.
 * @member {Number} [dblClickTime=300]
 * @readonly
 * @static
 */
EventHelper.dblClickTime = 300;

// Flag body if last user action used keyboard, used for focus styling etc.
EventHelper.on({
    element : document,
    mousedown() {
        if (!DomHelper.isTouchEvent) {
            DomHelper.usingKeyboard = false;
            document.body.classList.remove('b-using-keyboard');
        }
    },
    touchmove() {
        DomHelper.usingKeyboard = false;
        document.body.classList.remove('b-using-keyboard');
    },
    keydown() {
        DomHelper.usingKeyboard = true;
        document.body.classList.add('b-using-keyboard');
    }
});

// When dragging on a touch device, we need to prevent scrolling from happening.
// Dragging only starts on a touchmove event, by which time it's too late to preventDefault
// on the touchstart event which started it.
// To do this we need a capturing, non-passive touchmove listener at the document level so we can preventDefault.
// This is in lieu of a functioning touch-action style on iOS Safari. When that's fixed, this will not be needed.
if (BrowserHelper.isTouchDevice) {
    EventHelper.on({
        element   : document,
        touchmove : event => {
            // If we're touching a b-dragging event, then stop any panning by preventing default.
            if (event.target.closest('.b-dragging')) {
                event.preventDefault();
            }
        },
        passive : false,
        capture : true
    });
}
EventHelper._$name = 'EventHelper';

/* globals ResizeObserver: true */

let resizeFireTimer = null;

const resizedQueue = [],
    isAbsolutelyPositioned = n => n.nodeType === 1 && n.ownerDocument.defaultView.getComputedStyle(n).getPropertyValue('position') === 'absolute';

/**
 * @module Core/helper/ResizeMonitor
 */

/**
 * Allows size monitoring of elements.
 *
 * ```
 * ResizeMonitor.addResizeListener(
 *   myElement,
 *   element => {
 *      console.log(element, ' changed size');
 *   }
 * );
 * ```
 *
 * @internal
 */
class ResizeMonitor {
    /**
     * Adds a resize listener to the passed element which is called when the element
     * is resized by layout.
     * @param {HTMLElement} element The element to listen for resizing.
     * @param {Function} handler The handling function. Will be passed the element.
     */
    static addResizeListener(element, handler) {
        const me = this;

        if (element === document || element === window) {
            element = document.body;
        }

        if (!element.classList.contains('b-resize-monitored')) {
            element.classList.add('b-resize-monitored');
            element._bResizemonitor = {
                handlers : []
            };
        }

        // If we're looking at the document, or body, use a window resize listener.
        if (element === document.body) {
            if (!me.hasWindowResizeListener) {
                // Throttle the reaction to window resize to only fire once every 100ms
                window.addEventListener('resize', me.onWindowResize);
                me.hasWindowResizeListener = true;
            }
        }
        // Regular element - use ResizeObserver by preference
        else if (window.ResizeObserver) {
            if (!me.resizeObserver) {
                me.resizeObserver = new ResizeObserver(me.onElementResize);
            }
            me.resizeObserver.observe(element);
        }
        // Polyfill ResizeObesrver
        else {
            const [monitors, expand, shrink] = DomHelper.createElement({
                parent    : element,
                className : 'b-resize-monitors',
                children  : [{
                    className : 'b-resize-monitor-expand'
                }, {
                    className : 'b-resize-monitor-shrink'
                }]
            }, true);
            expand.scrollLeft = expand.scrollTop = shrink.scrollLeft = shrink.scrollTop = 1000000;
            expand.addEventListener('scroll', me.onSizeMonitorScroll, true);
            shrink.addEventListener('scroll', me.onSizeMonitorScroll, true);

            // Also need to fake a resize-scroll on DOM mutation
            (handler.targetMutationMonitor = new MutationObserver((m) => {
                const changedNodes = [];

                for (const mr of m) {
                    if (mr.type === 'childList') {
                        changedNodes.push.apply(changedNodes, mr.removedNodes);
                        changedNodes.push.apply(changedNodes, mr.addedNodes);
                    }
                }
                // If the changed nodes were absolutely positioned, then they won't
                // cause a resize, so return
                if (changedNodes.length > 0 && changedNodes.every(isAbsolutelyPositioned)) {
                    return;
                }
                // We only want the size monitor listener to trigger, so this event must NOT bubble
                // to any application or other framework listeners.
                expand.dispatchEvent(new CustomEvent('scroll', { bubbles : false }));
            })).observe(element, {
                childList : true,
                subtree   : true
            });

            // store reference for easier cleanup later
            handler.monitorElement = monitors;
        }
        element._bResizemonitor.handlers.push(handler);
    }

    /**
     * Removes a resize listener from the passed element.
     * @param {HTMLElement} element The element to listen for resizing.
     * @param {Function} handler The handling function to remove.
     */
    static removeResizeListener(element, handler) {
        if (element) {
            if (element === document || element === window) {
                element = document.body;
            }
            const resizeMonitor = element._bResizemonitor;

            let listenerCount = 0;

            if (resizeMonitor && resizeMonitor.handlers) {
                ArrayHelper.remove(resizeMonitor.handlers, handler);

                // See if we should unobserve the element
                listenerCount = resizeMonitor.handlers.length;
            }

            // Down to no listeners.
            if (!listenerCount) {
                element.classList.remove('b-resize-monitored');

                if (this.resizeObserver) {
                    this.resizeObserver.unobserve(element);
                }
                // Remove the polyfill resize listeners
                else {
                    // remove any added elements
                    if (handler.monitorElement) {
                        handler.monitorElement.remove();
                        handler.monitorElement = null;
                    }
                    // remove the DOM mutation observer
                    if (handler.targetMutationMonitor) {
                        handler.targetMutationMonitor.disconnect();
                    }
                }
            }
        }
    }

    static onElementResize(entries) {
        for (const resizeObserverEntry of entries) {
            const
                resizedElement = resizeObserverEntry.target,
                resizeMonitor  = resizedElement._bResizemonitor,
                newRect        = resizeObserverEntry.contentRect || resizedElement.getBoundingClientRect();

            if (resizedElement.offsetParent) {
                if (!resizeMonitor.rectangle || newRect.width !== resizeMonitor.rectangle.width || newRect.height !== resizeMonitor.rectangle.height) {
                    const oldRect = resizeMonitor.rectangle;
                    resizeMonitor.rectangle = newRect;
                    for (const resizeHandler of resizeMonitor.handlers) {
                        resizeHandler(resizedElement, oldRect, newRect);
                    }
                }
            }
        }
    }

    static onSizeMonitorScroll(e) {
        // If the element has gone, ignore the event; the listener will be removed automatically.
        if (document.body.contains(e.target)) {
            e.stopImmediatePropagation();

            const monitorNode    = e.target.parentNode,
                resizedElement = monitorNode.parentNode,
                resizeMonitor  = resizedElement._bResizemonitor,
                newRect        = resizedElement.getBoundingClientRect();

            if (!resizeMonitor.rectangle || newRect.width !== resizeMonitor.rectangle.width || newRect.height !== resizeMonitor.rectangle.height) {
                resizedQueue.push([resizedElement, resizeMonitor.rectangle, newRect]);
                resizeMonitor.rectangle = newRect;
                if (!resizeFireTimer) {
                    resizeFireTimer = requestAnimationFrame(ResizeMonitor.fireResizeEvents);
                }
            }
            monitorNode.firstChild.scrollLeft = monitorNode.firstChild.scrollTop = monitorNode.childNodes[1].scrollTop = monitorNode.childNodes[1].scrollLeft = 1000000;
        }
    }

    static onWindowResize(e) {
        const
            resizedElement = document.body,
            resizeMonitor  = resizedElement._bResizemonitor,
            oldRect        = resizeMonitor.rectangle;

        resizeMonitor.rectangle = document.documentElement.getBoundingClientRect();

        for (const resizeHandler of resizeMonitor.handlers) {
            resizeHandler(resizedElement, oldRect, resizeMonitor.rectangle);
        }
    }

    static fireResizeEvents() {
        for (const resizedEntry of resizedQueue) {
            for (const resizeHandler of resizedEntry[0]._bResizemonitor.handlers) {
                // Checking offsetParent to avoid resizing of elements which are not visible or exist in DOM
                if (resizedEntry[0].offsetParent) {
                    resizeHandler.apply(this, resizedEntry);
                }
            }
        }
        resizeFireTimer = null;
        resizedQueue.length = 0;
    }
}
ResizeMonitor._$name = 'ResizeMonitor';

/**
 * @module Core/mixin/Delayable
 */

// Global timeout collections for tests
let globalDelays = null;

if (VersionHelper.isTestEnv) {
    globalDelays = window.bryntum.globalDelays = {
        timeouts        : new Map(),
        intervals       : new Map(),
        animationFrames : new Map(),
        isEmpty(includeIntervals = false) {
            return globalDelays.timeouts.size + globalDelays.animationFrames.size + (includeIntervals ? globalDelays.intervals.size : 0) === 0;
        }
    };
}

/**
 * Tracks setTimeout, setInterval and requestAnimationFrame calls and clears them on destroy.
 *
 * @example
 * someClass.setTimeout(() => console.log('hi'), 200);
 * someClass.setInterval(() => console.log('annoy'), 100);
 * // can also use named timeouts for easier tracking
 * someClass.setTimeout(() => console.log('named'), 300, 'named');
 * someClass.clearTimeout('named');
 *
 * @mixin
 */
var Delayable = Target => class Delayable extends (Target || Base) {
    get isDelayable() {
        return true;
    }
    
    doDestroy() {
        const me = this;

        if (me.timeoutIds) {
            me.timeoutIds.forEach((fn, id) => {
                if (typeof fn === 'function') {
                    fn();
                }

                clearTimeout(id);

                if (globalDelays) {
                    globalDelays.timeouts.delete(id);
                }
            });
            me.timeoutIds = null;
        }

        if (me.timeoutMap) {
            me.timeoutMap.forEach((name, id) => clearTimeout(id));
            me.timeoutMap = null;
        }

        if (me.intervalIds) {
            me.intervalIds.forEach(id => {
                clearInterval(id);

                if (globalDelays) {
                    globalDelays.intervals.delete(id);
                }
            });
            me.intervalIds = null;
        }

        if (me.animationFrameIds) {
            me.animationFrameIds.forEach(id => {
                cancelAnimationFrame(id);

                if (globalDelays) {
                    globalDelays.animationFrames.delete(id);
                }
            });
            me.animationFrameIds = null;
        }

        super.doDestroy();
    }

    /**
     * Check if a named timeout is active
     * @param name
     * @internal
     */
    hasTimeout(name) {
        return !!(this.timeoutMap && this.timeoutMap.has(name));
    }

    /**
     * Same as native setTimeout, but will be cleared automatically on destroy. If a propertyName is supplied it will
     * be used to store the timeout id.
     * @param {Object} timeoutSpec An object containing the details about that function, and the time delay.
     * @param {Function|String} timeoutSpec.fn The function to call, or name of function in this object to call. Used as the `name` parameter if a string.
     * @param {Number} timeoutSpec.delay The milliseconds to delay the call by.
     * @param {Object[]} timeoutSpec.args The arguments to pass.
     * @param {String} [timeoutSpec.name] The name under which to register the timer. Defaults to `fn.name`.
     * @param {Boolean} [timeoutSpec.runOnDestroy] Pass `true` if this function should be executed if the Delayable instance is destroyed while function is scheduled.
     * @param {Boolean} [timeoutSpec.cancelOutstanding] Pass `true` to cancel any outstanding invocation of the passed function.
     * @returns {Number}
     * @internal
     */
    setTimeout({ fn, delay, name, runOnDestroy, cancelOutstanding, args }) {
        if (arguments.length > 1 || typeof arguments[0] === 'function') {
            [fn, delay, name, runOnDestroy] = arguments;
        }
        if (typeof fn === 'string') {
            name = fn;
        }
        else if (!name) {
            name = fn.name;
        }

        if (cancelOutstanding) {
            this.clearTimeout(name);
        }

        const
            me         = this,
            timeoutIds = me.timeoutIds || (me.timeoutIds = new Map()),
            timeoutMap = me.timeoutMap || (me.timeoutMap = new Map()),
            timeoutId  = setTimeout(() => {
                if (typeof fn === 'string') {
                    fn = me[name];
                }

                // Cleanup before invocation in case fn throws
                timeoutIds && timeoutIds.delete(timeoutId);
                timeoutMap && timeoutMap.delete(name);
                globalDelays && globalDelays.timeouts.delete(timeoutId);

                fn.apply(me, args);

            }, delay);

        timeoutIds.set(timeoutId, runOnDestroy ? fn : true);

        if (globalDelays) {
            globalDelays.timeouts.set(timeoutId, { fn, delay, name });
        }

        if (name) {
            timeoutMap.set(name, timeoutId);
        }

        return timeoutId;
    }

    /**
     * clearTimeout wrapper, either call with timeout id as normal clearTimeout or with timeout name (if you specified
     * a name to setTimeout())
     * property to null.
     * @param {Number|String} idOrName timeout id or name
     * @internal
     */
    clearTimeout(idOrName) {
        let id = idOrName;

        if (typeof id === 'string') {
            if (this.timeoutMap) {
                id = this.timeoutMap.get(idOrName);
                this.timeoutMap.delete(idOrName);
            }
            else {
                return;
            }
        }

        clearTimeout(id);

        this.timeoutIds && this.timeoutIds.delete(id);
        globalDelays && globalDelays.timeouts.delete(id);
    }

    /**
     * clearInterval wrapper
     * @param {Number} id
     * @internal
     */
    clearInterval(id) {
        clearInterval(id);

        this.intervalIds && this.intervalIds.delete(id);

        globalDelays && globalDelays.intervals.delete(id);
    }

    /**
     * Same as native setInterval, but will be cleared automatically on destroy
     * @param fn
     * @param delay
     * @returns {Number}
     * @internal
     */
    setInterval(fn, delay) {
        const intervalId = setInterval(fn, delay);

        (this.intervalIds || (this.intervalIds = new Set())).add(intervalId);

        globalDelays && globalDelays.intervals.set(intervalId, { fn, delay });

        return intervalId;
    }

    /**
     * Relays to native requestAnimationFrame and adds to tracking to have call automatically canceled on destroy.
     * @param {Function} fn
     * @param {Object[]} [extraArgs] The argument list to append to those passed to the function.
     * @param {Object} [thisObj] `this` reference for the function.
     * @returns {Number}
     * @internal
     */
    requestAnimationFrame(fn, extraArgs = [], thisObj = this) {
        const
            animationFrameIds = this.animationFrameIds || (this.animationFrameIds = new Set()),
            frameId           = requestAnimationFrame(() => {
                globalDelays && globalDelays.animationFrames.delete(frameId);
                animationFrameIds.delete(frameId);
                return fn.apply(thisObj, extraArgs);
            });

        animationFrameIds.add(frameId);

        globalDelays && globalDelays.animationFrames.set(frameId, { fn, extraArgs, thisObj });

        return frameId;
    }

    /**
     * Creates a function which will execute once, on the next animation frame. However many time it is
     * called in one event run, it will only be scheduled to run once.
     * @param {Function|String} fn The function to call, or name of function in this object to call.
     * @param {Object[]} [args] The argument list to append to those passed to the function.
     * @param {Object} [thisObj] `this` reference for the function.
     * @param {Boolean} [cancelOutstanding] Cancel any outstanding queued invocation upon call.
     * @internal
     */
    createOnFrame(fn, extraArgs = [], thisObj = this, cancelOutstanding) {
        let rafId;
        
        const result = (...args) => {
            // Cancel if outstanding if requested
            if (rafId && cancelOutstanding) {
                this.cancelAnimationFrame(rafId);
                rafId = null;
            }
            if (!rafId) {
                rafId = this.requestAnimationFrame(() => {
                    if (typeof fn === 'string') {
                        fn = thisObj[fn];
                    }
                    rafId = null;
                    args.push(...extraArgs);
                    fn.apply(thisObj, args);
                });
            }
        };

        result.cancel = () => this.cancelAnimationFrame(rafId);

        return result;
    }

    /**
     * Relays to native cancelAnimationFrame and removes from tracking.
     * @param {Number} handle
     * @internal
     */
    cancelAnimationFrame(handle) {
        cancelAnimationFrame(handle);

        this.animationFrameIds && this.animationFrameIds.delete(handle);

        globalDelays && globalDelays.animationFrames.delete(handle);
    }

    /**
     * Wraps a function with another function that delays it specified amount of time, repeated calls to the wrapper
     * resets delay.
     * @param {Function|String} fn Function to buffer, or name of function in this object to call.
     * @param {Number} delay Delay in ms
     * @param {Object} [thisObj] `this` reference for the function.
     * @returns {Function} Wrapped function, call this
     * @internal
     */
    buffer(fn, delay, thisObj = this) {
        let timeoutId = null;

        if (typeof fn === 'string') {
            fn = thisObj[fn];
        }

        const func = (...params) => {
            func.called = false;

            if (timeoutId !== null) {
                this.clearTimeout(timeoutId);
            }

            timeoutId = this.setTimeout(() => {
                fn.call(thisObj, ...params); // this will be instance of class that we are mixed into.
                func.called = true;
            }, delay);
        };

        return func;
    }

    /**
     * Create a "debounced" function which will call on the "leading edge" of a timer period.
     * When first invoked will call immediately, but invocations after that inside its buffer
     * period will be rejected, and *one* invocation will be made after the buffer period has expired.
     *
     * This is useful for responding immediately to a first mousemove, but from then on, only
     * calling the action function on a regular timer while the mouse continues to move.
     *
     * @param {Function} fn The function to call.
     * @param {Number} buffer The milliseconds to wait after each execution before another execution takes place.
     * @param {Object} [thisObj] `this` reference for the function.
     * @param {Array} [extraArgs] The argument list to append to those passed to the function.
     * @param {Function} [alt] A function to call when the invocation is rejected due to buffer time not having expired.
     * @internal
     */
    throttle(fn, buffer, thisObj = this, extraArgs, alt) {
        const me = this;
        
        let lastCallTime = 0,
            callArgs,
            timerId;

        const invoke = () => {
            timerId = 0;
            lastCallTime = performance.now();
            callArgs.push.apply(callArgs, extraArgs);
            fn.apply(thisObj, callArgs);
            result.called = true;
        };

        const result = (...args) => {
            const elapsed = performance.now() - lastCallTime;

            callArgs = args;

            // If it's been more then the buffer period since we invoked, we can call it now
            if (elapsed >= buffer) {
                me.clearTimeout(timerId);
                invoke();
            }
            // Otherwise, kick off a timer for the requested period.
            else {
                if (!timerId) {
                    timerId = me.setTimeout(invoke, buffer - elapsed);
                    result.called = false;
                }
                if (alt) {
                    callArgs.push.apply(callArgs, extraArgs);
                    alt.apply(thisObj, callArgs);
                }
            }
        };

        result.cancel = () => me.clearTimeout(timerId);

        return result;
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

/**
 * @module Core/util/CollectionFilter
 */

/**
 * A class which encapsulates a single filter operation which may be applied to any object to decide whether to
 * include or exclude it from a set.
 *
 * A CollectionFilter generally has at least three main properties:
 *
 * * `property` - The name of a property in candidate objects from which to extract the value to test
 * * `value` - The value which  this filter uses to test against.
 * * `operator` - The comparison operator, eg: `'='` or `'>'` etc.
 *
 * Given these three essential values, further configurations may affect how the filter is applied:
 *
 * * `caseSensitive` - If configured as `false`, string comparisons are case insensitive.
 * * `convert` - A function which, when passed the extracted value from the candidate object, returns the value to test.
 *
 * A filter may also be configured with a single `filterBy` property. This function is just passed the raw
 * candidate object and must return `true` or `false`.
 *
 * A CollectionFilter may be configured to encapsulate a single filtering function by passing that function as the sole
 * parameter to the constructor:
 *
 *     new CollectionFilter(candidate => candidate.title.contains('search string'));
 *
 */
class CollectionFilter extends Base {
    static get defaultConfig() {
        return {
            /**
             * The name of a property of candidate objects which yields the value to compare against this CollectionFilter's {@link #config-value}.
             * @config {String}
             */
            property : null,

            /**
             * The value against which to compare the {@link #config-property} of candidate objects.
             * @config {*}
             */
            value : null,

            /**
             * The operator to use when comparing a candidate object's {@link #config-property} with this CollectionFilter's {@link #config-value}.
             * May be: `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`, `'startsWith'`, `'endsWith'`
             * @config {String}
             */
            operator : null,

            /**
             * May be used in place of the {@link #config-property}, {@link #config-value} and {@link #config-property} configs. A function which
             * accepts a candidate object and returns `true` or `false`
             * @config {Function}
             */
            filterBy : null,

            /**
             * A function which accepts a value extracted from a candidate object using the {@link #config-property} name, and
             * returns the value which the filter should use to compare against its {@link #config-value}.
             * @config {Function}
             */
            convert : null,

            /**
             * Configure as `false` to have string comparisons case insensitive.
             * @config {Boolean}
             */
            caseSensitive : true,

            /**
             * The `id` of this Filter for when used by a {@link Core.util.Collection} Collection.
             * By default the `id` is the {@link #config-property} value.
             * @config {String}
             */
            id : null
        };
    }

    construct(config) {
        if (typeof config === 'function') {
            config = {
                filterBy : config
            };
        }

        super.construct(config);

        
    }

    /**
     * When in a Collection (A Collection holds its Filters in a Collection), we need an id.
     * @property {String}
     * @private
     */
    get id() {
        return this._id || (this._id = this.property || IdHelper.generateId('b-filter'));
    }

    set id(id) {
        this._id = id;
    }

    onChange(propertyChanged) {
        const me = this;

        // Inform any owner (eg a Store), that it has to reassess its CollectionFilters
        if (!me.isConfiguring && me.owner && !me.owner.isConfiguring && me.owner.onFilterChanged) {
            me.owner.onFilterChanged(me, propertyChanged);
        }
    }

    get filterBy() {
        return this._filterBy || this.defaultFilterBy;
    }

    /**
     * May be used in place of the {@link #config-property}, {@link #config-value} and {@link #config-property} configs. A function which
     * accepts a candidate object and returns `true` or `false`
     * @type {Function}
     */
    set filterBy(filterBy) {
        this._filterBy = filterBy;
    }

    defaultFilterBy(candidate) {
        return this[this.operator](this.convert(candidate[this.property]));
    }

    /**
     * The name of a property of candidate objects which yields the value to compare against this CollectionFilter's {@link #config-value}.
     * @type {String}
     */
    set property(property) {
        this._property = property;

        // Signal to owner about filter change
        this.onChange('property');
    }

    get property() {
        return this._property;
    }

    /**
     * The value against which to compare the {@link #config-property} of candidate objects.
     * @type {*}
     */
    set value(value) {
        this._value = !this.caseSensitive && (typeof value === 'string') ? value.toLowerCase() : value;

        // Signal to owner about filter change
        this.onChange('value');
    }

    get value() {
        return this._value;
    }

    /**
     * The operator to use when comparing a candidate object's {@link #config-property} with this CollectionFilter's {@link #config-value}.
     * May be: `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`, `'startsWith'`, `'endsWith'`
     * @type {String}
     */
    set operator(operator) {
        this._operator = operator;

        // Signal to owner about filter change
        this.onChange('operator');
    }

    get operator() {
        return this._operator || ((typeof this.value === 'string') ? '*' : '=');
    }

    convert(value) {
        return !this.caseSensitive && (typeof value === 'string') ? value.toLowerCase() : value;
    }

    filter(candidate) {
        return this.filterBy(candidate);
    }

    startsWith(v) {
        return String(v).startsWith(this.value);
    }

    endsWith(v) {
        return String(v).endsWith(this.value);
    }

    '='(v) {
        return ObjectHelper.isEqual(v, this.value);
    }

    '!='(v) {
        return !ObjectHelper.isEqual(v, this.value);
    }

    '>'(v) {
        return ObjectHelper.isMoreThan(v, this.value);
    }

    '>='(v) {
        return ObjectHelper.isMoreThan(v, this.value) || ObjectHelper.isEqual(v, this.value);
    }

    '<'(v) {
        return ObjectHelper.isLessThan(v, this.value);
    }

    '<='(v) {
        return ObjectHelper.isLessThan(v, this.value) || ObjectHelper.isEqual(v, this.value);
    }

    '*'(v) {
        return ObjectHelper.isPartial(v, this.value);
    }

    // Accepts an array or a Collection
    static generateFiltersFunction(filters) {
        if (!filters || (!filters.length && !filters.count)) {
            return FunctionHelper.returnTrue;
        }

        return function(candidate) {
            let match = true;

            for (const filter of filters) {
                // Skip disabled filters
                if (!filter.disabled) {
                    match = filter.filter(candidate);
                }
                if (!match) {
                    break;
                }
            }

            return match;
        };
    }
}
CollectionFilter._$name = 'CollectionFilter';

/**
 * @module Core/util/CollectionSorter
 */

/**
 * A class which encapsulates a single sorter operation which may be applied to any object to decide whether to
 * include or exclude it from a set.
 *
 * A CollectionSorter generally has two properties:
 *
 * * `property` - The name of a property in collection objects by which to sort
 * * `direction` - The sort direction, `'ASC'` or `'DESC'`.
 *
 * It may also be configured with just a {@link #config-sortFn} function which returns the desired comparison
 * result when passed two objects to compare. Note that this does *not* require or use the
 * {@link #config-property} config. Two collection items are passed for comparison.
 *
 * Further configurations may affect how the sorter is applied:
 *
 * * `convert` - A function which, when passed the {@link #config-property} value from
 * a collection object, returns the value to sort by.
 *
 * A CollectionSorter may be configured to encapsulate a {@link #config-sortFn} by passing that function as the sole
 * parameter to the constructor:
 *
 *     new CollectionSorter((lhs, rhs) => {
 *         lhs = lhs.customerDetails.companyName.toLowerCase();
 *         rhs = rhs.customerDetails.companyName.toLowerCase();
 *
 *         if (lhs < rhs) {
 *             return -1;
 *         }
 *         else if (lhs > rhs) {
 *             return 1;
 *         }
 *         else {
 *             return 0;
 *         }
 *     });
 *
 */
class CollectionSorter extends Base {
    static get defaultConfig() {
        return {
            /**
             * The name of a property of collection objects which yields the value to sort by.
             * @config {String}
             */
            property : null,

            /**
             * The direction to sort in, `'ASC'` or `'DESC'`
             * @config {String}
             * @default
             */
            direction : 'ASC',

            /**
             * A function which takes the place of using {@link #config-property} and {@link #config-direction}.
             * The function is passed two objects from the collection to compare andmiust return the comparison result.
             * @config {Function}
             */
            sortFn : null,

            /**
             * When using {@link #config-property}, this may be specified as a function which takes the raw
             * property value and returns the value to actually sort by.
             * @config {Function}
             */
            convert : null,

            /**
             * The `id` of this Sorter for when used by a {@link Core.util.Collection} Collection.
             * By default the `id` is the {@link #config-property} value.
             * @config {String}
             */
            id : null,

            /**
             * Use `localeCompare()` when sorting, which lets the browser sort in a locale specific order. Set to `true`,
             * a locale string or a locale config to enable.
             *
             * Enabling this has big negative impact on sorting
             * performance. For more info on `localeCompare()`, see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).
             *
             * ```javascript
             * collection.addSorter({ field: 'name', useLocaleSort : 'sv-SE' });
             * ```
             *
             * @config {Boolean|String|Object}
             * @default false
             */
            useLocaleSort : null
        };
    }

    construct(config) {
        if (typeof config === 'function') {
            config = {
                sortFn : config
            };
        }

        

        super.construct(config);
    }

    /**
     * When in a Collection (A Collection holds its Sorters in a Collection), we need an id.
     * @property {String}
     * @private
     */
    get id() {
        return this._id || (this._id = this.property || IdHelper.generateId('b-sorter'));
    }

    set id(id) {
        this._id = id;
    }

    set sortFn(sortFn) {
        this._sortFn = sortFn;
    }

    get sortFn() {
        if (this._sortFn) {
            return this._sortFn;
        }
        return this.defaultSortFn;
    }

    /**
     * Default sortFn used when no sortFn specified. Uses the {@link #config-property},
     * {@link #config-direction}, and {@link #config-convert}.
     * @private
    */
    defaultSortFn(lhs, rhs) {
        const me = this, { convert, property, useLocaleSort } = me,
            multiplier = me.direction.toLowerCase() === 'desc' ? -1 : 1;

        lhs = lhs[property];
        rhs = rhs[property];

        if (convert) {
            lhs = convert(lhs);
            rhs = convert(rhs);
        }

        if (useLocaleSort && lhs != null && rhs != null) {
            // Use systems locale
            if (useLocaleSort === true) {
                return String(lhs).localeCompare(rhs);
            }

            // Use specified locale
            if (typeof useLocaleSort === 'string') {
                return String(lhs).localeCompare(rhs, useLocaleSort);
            }

            // Use locale config
            if (typeof useLocaleSort === 'object') {
                return String(lhs).localeCompare(rhs, useLocaleSort.locale, useLocaleSort);
            }
        }

        return ((lhs > rhs) ? 1 : (lhs < rhs ? -1 : 0)) * multiplier;
    }

    static generateSortFunction(sorters, tieBreaker) {
        const items = sorters.isCollection ? sorters.values : sorters,
            n = items.length;

        return (lhs, rhs) => {
            let comp, i;

            for (i = 0; i < n; ++i) {
                comp = items[i].sortFn(lhs, rhs);
                if (comp) {
                    return comp;
                }
            }

            return tieBreaker ? tieBreaker(lhs, rhs) : 0;
        };
    }
}
CollectionSorter._$name = 'CollectionSorter';

/**
 * @module Core/util/Collection
 */

const return0 = () => 0,
    reverseNumericSortFn = (a, b) => b - a,
    filteredIndicesProperty = Symbol('filteredIndicesProperty'),
    emptyArray$1 = Object.freeze([]),
    sortEvent = Object.freeze({
        action   : 'sort',
        added    : emptyArray$1,
        removed  : emptyArray$1,
        replaced : emptyArray$1
    }),
    filterEvent = Object.freeze({
        action   : 'filter',
        added    : emptyArray$1,
        removed  : emptyArray$1,
        replaced : emptyArray$1
    }),
    keyTypes = {
        string : 1,
        number : 1
    },
    nonPrimitives = new WeakMap(),
    safeIndexKey = (value) => {
        if (value && typeof value === 'object') {
            let substitute = nonPrimitives.get(value);
            if (substitute === undefined) {
                substitute = Symbol('bscik'); // Bryntum safe collection index key
                nonPrimitives.set(value, substitute);
            }
            value = substitute;
        }

        return value;
    };

/**
 * A class which encapsulates a {@link #function-get keyed},
 * {@link #function-addFilter filterable}, {@link #function-addSorter sortable}
 * collection of objects. Entries may not be atomic data types such as `string` or `number`.
 *
 * The entries are keyed by their `id` which is determined by interrogating the {@link #config-idProperty}.
 *
 * To filter a Collection, add a {@link Core.util.CollectionFilter CollectionFilter}
 * using the {@link #function-addFilter} method. A Filter config object may be specified here
 * which will be promoted to a CollectionFilter instance.
 *
 * To sort a Collection, add a {@link Core.util.CollectionSorter CollectionSorter}
 * using the {@link #function-addSorter} method. A Sorter config object may be specified here
 * which will be promoted to a CollectionSorter instance.
 */
class Collection extends Events(Base) {
    static get defaultConfig() {
        return {
            /**
             * Specify the name of the property of added objects which provides the lookup key
             * @config {String}
             * @default
             */
            idProperty : 'id',

            /**
             * Specify the names of properties which are to be indexed for fast lookup.
             * @config {String[]}
             */
            extraKeys : null,

            /**
             * Automatically apply filters on item add.
             * @config {String[]}
             * @default
             */
            autoFilter : true
        };
    }

    construct(config) {
        /**
         * A counter which is incremented whenever the Collection is mutated in a meaningful way.
         *
         * If a {@link #function-splice} call results in no net replacement, removal or addition,
         * then the `generation` will not be incremented.
         * @property {Number}
         * @readonly
         */
        this.generation = 0;
        this._values = [];

        super.construct(config);
    }

    doDestroy() {
        super.doDestroy();

        this._values.length = 0;

        if (this.isFiltered) {
            this._filteredValues.length = 0;
            this.filters.destroy();
        }

        this._sorters && this._sorters.destroy();
    }

    get isCollection() {
        return true;
    }

    /**
     * Clears this collection.
     */
    clear() {
        const me = this,
            removed = this._values.slice();

        if (me.totalCount) {
            me._values.length = 0;
            if (me._filteredValues) {
                me._filteredValues.length = 0;
            }
            me._indicesInvalid = true;

            // Indicate to obervers that data has changed.
            me.generation++;
            me.trigger('change', {
                action : 'clear',
                removed
            });
        }
    }

    /**
     * Replaces the internal values array with the passed array. Note that this takes ownership of the array, and the array
     * must not be mutated by outside code.
     *
     * This is an internal utility method, not designed for use by application code.
     * @internal
     * @param {Object[]} values The new values array
     */
    replaceValues(values, silent, isNewDataset) {
        const me = this;

        let removed;

        // The isNewDataset flag is passed by store#loadData to indicate that it's
        // a new data load, and that local filters can be applied.
        // Other use cases are for purely local updates of an existing dataset such as
        // refreshing the visible data with a values array containing group headers.
        if (me.isFiltered && !isNewDataset) {
            removed = me._filteredValues;
            me._filteredValues = values.slice();
        }
        else {
            removed = me._values;
            me._values = values;

            if (me.isFiltered && isNewDataset && me.autoFilter) {
                me._filterFunction = null;
                me._filteredValues = me._values.filter(me.filterFunction);
                me._indicesInvalid = true;
            }
            else {
                if (me._filteredValues) {
                    me._filteredValues.length = 0;
                }
            }
        }
        me._indicesInvalid = true;

        // Indicate to obervers that data has changed.
        me.generation++;

        if (!silent) {
            me.trigger('change', {
                action   : 'replaceValues',
                removed,
                values,
                replaced : []
            });
        }
    }

    set values(values) {
        this.splice(0, this._values.length, values);
    }

    /**
     * The set of values of this Collection. If this Collection {@link #property-isFiltered},
     * this yields the filtered data set.
     *
     * Setting this property replaces the data set.
     * @property {Object[]}
     */
    get values() {
        return this.isFiltered ? this._filteredValues : this._values;
    }

    /**
     * Iterator that allows you to do for (let item of collection)
     */
    [Symbol.iterator]() {
        return this.values[Symbol.iterator]();
    }

    /**
     * Executes the passed function for each item in this Collection, passing in the item,
     * ths index, and the full item array.
     * @param {Function} fn The function to execute.
     * @param {Boolean} [ignoreFilters=false] Pass `true` to include all items, bypassing filters.
     */
    forEach(fn, ignoreFilters = false) {
        (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).forEach(fn);
    }

    /**
     * Extracts ths content of this Collection into an array based upon the passed
     * value extraction function.
     * @param {Function} fn A function, which, when passed an item, returns a value to place into the resulting array.
     * @param {Boolean} [ignoreFilters=false] Pass `true` to process an item even if it is filtered out.
     * @returns {Object[]} An array of values extracted from this Collection.
     */
    map(fn, ignoreFilters = false) {
        return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).map(fn);
    }

    /**
     * Returns the first item in this Collection which elicits a *truthy* return value from the passed funtion.
     * @param {Function} fn A function, which, when passed an item, returns `true` to select it as the item to return.
     * @param {Boolean} [ignoreFilters=false] Pass `true` to include filtered out items.
     * @returns {Object} The matched item, or `undefined`.
     */
    find(fn, ignoreFilters = false) {
        return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).find(fn);
    }

    get first() {
        return this.values[0];
    }

    get last() {
        return this.values[this.count - 1];
    }

    /**
     * The set of all values of this Collection regardless of filters applied.
     * @readonly
     * @property {Object[]}
     */
    get allValues() {
        return this._values;
    }

    /**
     * Adds items to this Collection. Multiple new items may be passed.
     *
     * By default, new items are appended to the existing values.
     *
     * Any {@link #property-sorters} {@link #property-sorters} present are re-run.
     *
     * Any {@link #property-filters} {@link #property-filters} present are re-run.
     *
     * *Note that if application functionality requires add and remove, the
     * {@link #function-splice} operation is preferred as it performs both
     * operations in an atomic manner*
     * @param  {...Object} items The item(s) to add.
     */
    add(...items) {
        if (items.length === 1) {
            this.splice(this._values.length, null, ...items);
        }
        else {
            this.splice(this._values.length, null, items);
        }
    }

    /**
     * Removes items from this Collection. Multiple items may be passed.
     *
     * Any {@link #property-sorters} {@link #property-sorters} present are re-run.
     *
     * Any {@link #property-filters} {@link #property-filters} present are re-run.
     *
     * *Note that if application functionality requires add and remove, the
     * {@link #function-splice} operation is preferred as it performs both
     * operations in an atomic manner*
     * @param  {...Object} items The item(s) to remove.
     */
    remove(...items) {
        if (items.length === 1) {
            this.splice(0, ...items);
        }
        else {
            this.splice(0, items);
        }
    }

    /**
     * Moves an individual item to another location.
     * @param {Object} item The item to move.
     * @param {Object} [beforeItem] the item to insert the first item before. If omitted, the `item`
     * is moved to the end of the Collection.
     * @returns {Number} The new index of the `item`.
     */
    move(item, beforeItem) {
        const me = this,
            { _values } = me,
            itemIndex = me.indexOf(item, true);

        let beforeIndex = beforeItem ? me.indexOf(beforeItem, true) : _values.length;

        if (itemIndex === -1 || beforeIndex === -1) {
            throw new Error('Collection move parameters must be present in Collection');
        }

        if (itemIndex !== beforeIndex && itemIndex !== beforeIndex - 1) {
            if (itemIndex < beforeIndex) {
                beforeIndex--;
            }
            _values.splice(itemIndex, 1);
            _values.splice(beforeIndex, 0, item);
            me._indicesInvalid = true;

            me.trigger('change', {
                action : 'move',
                item,
                from   : itemIndex,
                to     : beforeIndex
            });
        }
        return beforeIndex;
    }

    /**
     * The core data set mutation method. Removes and adds at the same time. Analogous
     * to the `Array` `splice` method.
     *
     * Note that if items that are specified for removal are also in the `toAdd` array,
     * then those items are *not* removed then appended. They remain in the same position
     * relative to all remaning items.
     *
     * @param {Number} index Index at which to remove a block of items. Only valid if the
     * second, `toRemove` argument is a number.
     * @param {Object[]|Number} [toRemove] Either the number of items to remove starting
     * at the passed `index`, or an array of items to remove (If an array is passed, the `index` is ignored).
     * @param  {Object[]|Object} [toAdd] An item, or an array of items to add.
     */
    splice(index = 0, toRemove, ...toAdd) {
        const me = this,
            idProperty = me.idProperty,
            values = me._values,
            newIds = {},
            removed = [],
            replaced = [],
            oldCount = me.totalCount;

        let added,
            mutated;

        // Create an "newIds" map of the new items so remove ops know if it's really a replace
        // {
        //     1234 : true
        // }
        // And an "added" array of the items that need adding (there was not already an entry for the id)
        //
        if (toAdd) {
            if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
                toAdd = toAdd[0];
            }

            // Check for replacements if we contain any data
            if (oldCount && toAdd.length) {
                // Only risk rebuilding the indices if we are adding
                const idIndex = me.indices[idProperty];

                added = [];

                for (let i = 0; i < toAdd.length; i++) {
                    const newItem = toAdd[i],
                        id = safeIndexKey(newItem[idProperty]),
                        existingIndex = idIndex[id];

                    // Register incoming id so that removal leaves it be
                    newIds[id] = true;

                    // Incoming id is already present.
                    // Replace it in place.
                    if (existingIndex != null) {
                        // If incoming is the same object, it's a no-op
                        if (values[existingIndex] !== newItem) {
                            replaced.push([values[existingIndex], newItem]);
                            values[existingIndex] = newItem;
                        }
                    }
                    else {
                        added.push(newItem);
                    }
                }
            }
            // Empty Collection, we simply add what we're passed
            else {
                added = toAdd;
            }
        }

        if (toRemove) {
            // We're removing a chunk starting at index
            if (typeof toRemove === 'number') {
                for (let removeIndex = index; toRemove; --toRemove) {
                    const id = safeIndexKey(values[removeIndex][idProperty]);

                    // If the entry here is being replaced, skip the insertion index past it
                    if (newIds[id]) {
                        index++;
                        removeIndex++;
                    }
                    // If the id is not among incoming items, remove it
                    else {
                        removed.push(values[removeIndex]);
                        values.splice(removeIndex, 1);
                        me._indicesInvalid = mutated = true;
                    }
                }
            }
            // We are removing an item/items
            else {
                let contiguous = added.length === 0,
                    lastIdx;

                if (!Array.isArray(toRemove)) {
                    toRemove = [toRemove];
                }
                // Create array of index points to remove.
                // They must be in reverse order so that removal leaves following remove indices stable
                const removeIndices = toRemove.reduce((result, item) => {
                    const isNumeric = typeof item === 'number',
                        idx = isNumeric ? item : me.indexOf(item, true);

                    // Drop out of contiguous mode if we find a non-contiguous record, or a remove *index*
                    if (contiguous && (lastIdx != null && idx !== lastIdx + 1 || isNumeric)) {
                        contiguous = false;
                    }

                    // Do not include indices out of range in our removeIndices
                    if (idx >= 0 && idx < oldCount) {
                        result.push(idx);
                    }
                    lastIdx = idx;
                    return result;
                }, []).sort(reverseNumericSortFn);

                // If it's a pure remove of contiguous items with no adds, fast track it.
                if (contiguous) {
                    // If reduced to zero by being asked to remove items we do not contain
                    // then this is a no-op
                    if (removeIndices.length) {
                        removed.push.apply(removed, toRemove);
                        values.splice(removeIndices[removeIndices.length - 1], removeIndices.length);
                        me._indicesInvalid = mutated = true;
                    }
                }
                else {
                    // Loop through removeIndices splicing each index out of the values
                    // unless there's an incoming identical id.
                    for (let i = 0; i < removeIndices.length; i++) {
                        const removeIndex = removeIndices[i];

                        if (removeIndex !== -1) {
                            const id = safeIndexKey(values[removeIndex][idProperty]);

                            // If the id is not among incoming items, remove it
                            if (!newIds[id]) {
                                removed.unshift(values[removeIndex]);
                                values.splice(removeIndex, 1);
                                me._indicesInvalid = mutated = true;
                            }
                        }
                    }
                }
            }
        }

        // If we collected genuinely new entries, insert them at the splice index
        if (added.length) {
            values.splice(Math.min(index, values.length), 0, ...added);
            me._indicesInvalid = mutated = true;
        }

        // Ensure order of values matches the sorters
        if (me.isSorted) {
            me.onSortersChanged();
        }
        // The sort will also recreate the filteredValues so that it can be in correct sort order
        else if (me.isFiltered) {
            if (me.autoFilter) {
                me.onFiltersChanged();
            }
            else {
                me._filteredValues.push(...added);
            }
        }

        // If we either added or removed items, or we did an in-place replace operation
        // then inform all interested parties.
        if (mutated || replaced.length) {
            // Indicate to obervers that data has changed.
            me.generation++;

            /**
             * Fired when items are added, replace or removed
             * @event change
             * @param {String} action The underlying operation which caused data change.
             * May be `'splice'` (meaning an atomic add/remove operation, `'sort'` or `'filter'`)
             * @param {Core.util.Collection} source This Collection.
             * @param {Object[]} removed An array of removed items.
             * @param {Object[]} added An array of added items.
             * @param {Object[]} replaced An array of replacements, each entry of which contains `[oldValue, newValue]`.
             * @param {Number} oldCount The number of items in the full, untiltered collection prior to the splice operation.
             */
            me.trigger('change', {
                action : 'splice',
                removed,
                added,
                replaced,
                oldCount
            });
        }
        else {
            /**
             * Fired when a {@link #function-splice} operation is requested but the operation
             * is a no-op and has caused no change to this Collection's dataset. The splice
             * method's parameters are passed for reference.
             * @event noChange
             * @param {Number} index Index at which to remove a block of items.
             * @param {Object[]|Number} [toRemove] Either the number of items to remove starting
             * at the passed `index`, or an array of items to remove (If an array is passed, the `index` is ignored).
             * @param  {Object[]|Object} [toAdd] An item, or an array of items to add.
             */
            me.trigger('noChange', {
                index,
                toRemove,
                toAdd
            });
        }
    }

    /**
     * Change the id of an existing member by mutating its {@link #config-idProperty}.
     * @param {String|Number|Object} item The item or id of the item to change.
     * @param {String|Number} newId The id to set in the existing member.
     */
    changeId(item, newId) {
        const me           = this,
            { idProperty } = me,
            oldId          = keyTypes[typeof item] ? item : item[idProperty],
            member         = me.get(oldId);

        if (member) {
            const existingMember = me.get(newId);

            if (existingMember && member !== existingMember) {
                throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
            }

            member[idProperty] = newId;

            // If indices are valid, keep the id index correct
            if (!me._indicesInvalid) {
                const idIndex = me.indices.id,
                    memberIndex = idIndex[oldId];

                delete idIndex[oldId];
                idIndex[newId] = memberIndex;
            }
        }
    }

    /**
     * Returns the item with the passed `id`. By default, filtered are honoured, and
     * if the item with the requested `id` is filtered out, nothing will be returned.
     *
     * To return the item even if it has been filtered out, pass the second parameter as `true`.
     * @param {*} id The `id` to find.
     * @param {Boolean} [ignoreFilters=false] Pass `true` to return an item even if it is filtered out.
     * @returns {Object} The found item, or `undefined`.
     */
    get(id, ignoreFilters = false) {
        return this.getBy(this.idProperty, id, ignoreFilters);
    }

    getAt(index, ignoreFilters = false) {
        if (this.isFiltered && !ignoreFilters) {
            return this._filteredValues[index];
        }
        else {
            return this._values[index];
        }
    }

    /**
     * Returns the item with passed property name equal to the passed value. By default,
     * filtered are honoured, and if the item with the requested `id` is filtered out,
     * nothing will be returned.
     *
     * To return the item even if it has been filtered out, pass the third parameter as `true`.
     * @param {String} propertyName The property to test.
     * @param {*} value The value to find.
     * @param {Boolean} [ignoreFilters=false] Pass `true` to return an item even if it is filtered out.
     * @returns {Object} The found item, or `undefined`.
     */
    getBy(propertyName, value, ignoreFilters = false) {
        const me = this;

        if (me.isFiltered && ignoreFilters) {
            const index = me.findIndex(propertyName, value, true);
            if (index !== -1) {
                return me._values[index];
            }
        }
        else {
            const index = me.findIndex(propertyName, value);
            if (index !== -1) {
                return me.values[index];
            }
        }
    }

    /**
     * The number of items in this collection. Note that this honours filtering.
     * See {@link #property-totalCount};
     * @property {Number}
     * @readonly
     */
    get count() {
        return this.values.length;
    }

    /**
     * The number of items in this collection regardless of filtering.
     * @property {Number}
     * @readonly
     */
    get totalCount() {
        return this._values.length;
    }

    set idProperty(idProperty) {
        this._idProperty = idProperty;
        this.addIndex(idProperty);
    }

    /**
     * The property name used to extract item `id`s from added objects.
     * @property {String}
     */
    get idProperty() {
        return this._idProperty;
    }

    set extraKeys(extraKeys) {
        if (!Array.isArray(extraKeys)) {
            extraKeys = [extraKeys];
        }
        for (let i = 0; i < extraKeys.length; i++) {
            this.addIndex(extraKeys[i]);
        }
    }

    /**
     * The Collection of {@link Core.util.CollectionSorter Sorters} for this Collection.
     * @property {Core.util.Collection}
     * @readonly
     */
    get sorters() {
        if (!this._sorters) {
            this._sorters = new Collection({
                listeners : {
                    change  : 'onSortersChanged',
                    thisObj : this
                }
            });
        }
        return this._sorters;
    }

    /**
     * Adds a Sorter to the Collection of Sorters which are operating on this Collection.
     *
     * A Sorter may be an specified as an instantiated {@link Core.util.CollectionSorter
     * CollectionSorter}, or a config object for a CollectionSorter of the form
     *
     *     {
     *         property  : 'age',
     *         direction : 'desc'
     *     }
     *
     * Note that by default, a Sorter *replaces* a Sorter with the same `property` to make
     * it easy to change existing Sorters. A Sorter's `id` is its `property` by default. You
     * can avoid this and add multiple Sorters for one property by configuring Sorters with `id`s.
     *
     * A Sorter may also be specified as a function which compares two objects eg:
     *
     *     (lhs, rhs) => lhs.customerDetails.age - rhs.customerDetails.age
     *
     * @param {Object} sorter A Sorter of Sorter configuration object to add to the Collection
     * of Sorters operating on this Collection.
     * @returns {Core.util.CollectionSorter} The resulting Sorter to make it easy to remove Sorters.
     */
    addSorter(sorter) {
        const result = (sorter instanceof CollectionSorter) ? sorter : new CollectionSorter(sorter);

        this.sorters.add(result);

        return result;
    }

    /**
     * A flag which is `true` if this Collection has active {@link #property-sorters}.
     * @property {Boolean}
     * @readonly
     */
    get isSorted() {
        return Boolean(this._sorters && this._sorters.count);
    }

    onSortersChanged() {
        const me = this;

        delete me._sortFunction;

        me._values.sort(me.sortFunction);
        me._indicesInvalid = true;

        me.trigger('change', sortEvent);
    }

    /**
     * A sorter function which encapsulates the {@link Core.util.CollectionSorter Sorters}
     * for this Collection.
     * @property {Function}
     * @readonly
     */
    get sortFunction() {
        if (!this._sortFunction) {
            if (this.isSorted) {
                this._sortFunction = CollectionSorter.generateSortFunction(this.sorters.values);
            }
            else {
                this._sortFunction = return0;
            }
        }

        return this._sortFunction;
    }

    /**
     * The Collection of {@link Core.util.CollectionFilter Filters} for this Collection.
     * @property {Core.util.Collection}
     * @readonly
     */
    get filters() {
        if (!this._filters) {
            this._filters = new Collection({
                listeners : {
                    change  : 'onFiltersChanged',
                    thisObj : this
                }
            });
        }
        return this._filters;
    }

    /**
     * Adds a Filter to the Collection of Filters which are operating on this Collection.
     *
     * A Filter may be an specified as an instantiated {@link Core.util.CollectionFilter
     * CollectionFilter}, or a config object for a CollectionFilter of the form
     *
     *     {
     *         property : 'age',
     *         operator : '>=',
     *         value    : 21
     *     }
     *
     * Note that by default, a Filter *replaces* a Filter with the same `property` to make
     * it easy to change existing Filters. A Filter's `id` is its `property` by default. You
     * can avoid this and add multiple Filters for one property by configuring Filters with `id`s.
     *
     * A Filter may also be specified as a function which filters candidate objects eg:
     *
     *     candidate => candidate.customerDetails.age >= 21
     *
     * @param {Object} filter A Filter or Filter configuration object to add to the Collection
     * of Filters operating on this Collection.
     * @returns {Core.util.CollectionFilter} The resulting Filter to make it easy to remove Filters.
     */
    addFilter(filter) {
        const result = (filter instanceof CollectionFilter) ? filter : new CollectionFilter(filter);

        this.filters.add(result);

        return result;
    }

    /**
     * A flag which is `true` if this Collection has active {@link #property-filters}.
     * @property {Boolean}
     * @readonly
     */
    get isFiltered() {
        return Boolean(this._filters && this._filters.count);
    }

    onFiltersChanged() {
        const me = this;

        me._filterFunction = null;
        me._filteredValues = me._values.filter(me.filterFunction);
        me._indicesInvalid = true;

        me.trigger('change', filterEvent);
    }

    /**
     * A filter function which encapsulates the {@link Core.util.CollectionFilter Filters}
     * for this Collection.
     * @property {Function}
     * @readonly
     */
    get filterFunction() {
        if (!this._filterFunction) {
            if (this.isFiltered) {
                this._filterFunction = CollectionFilter.generateFiltersFunction(this.filters.values);
            }
            else {
                this._filterFunction = FunctionHelper.returnTrue;
            }
        }

        return this._filterFunction;
    }

    /**
     * Adds a lookup index for the passed property name. The index is built lazily when
     * an index is serched,
     * @internal
     * @param {String} indexProperty The property name to add an index for.
     */
    addIndex(indexProperty) {
        (this._indices || (this._indices = {}))[indexProperty] = {};

        // Indices need a rebuild now.
        this._indicesInvalid = true;

        /**
         * this.indices is keyed by the property name, and contains the keys linked to the index in the _values array.
         * So collection.add({id : foo, name : 'Nige'}, {id : 'bar', name : 'Faye'}) where collection has had an index
         * added for the "name" property would result in:
         *
         * {
         *     id : {
         *         foo : 0,
         *         bar : 1
         *     },
         *     name : {
         *         Nige : 0,
         *         Faye : 1
         *     }
         * }
         */
    }

    /**
     * Return the index of the item with the specified key having the specified value.
     * By default, filtering is taken into account and this returns the index in the filtered
     * dataset if present. To bypass this, pass the third parameter as `true`.
     * @param {String} propertyName The name of the property to test.
     * @param {*} value The value to test for.
     * @param {Boolean} [ignoreFilters=false] Pass `true` to return the index in
     * the original data set if the item is filtered out.
     * @returns {Number} The index of the item, or `-1` if not found.
     */
    findIndex(propertyName, value, ignoreFilters = false) {
        const me = this,
            isFiltered = me.isFiltered,
            index = isFiltered && !ignoreFilters ? me.indices[filteredIndicesProperty][propertyName] : me.indices[propertyName];

        if (index) {
            const itemIndex = index[safeIndexKey(value)];

            if (itemIndex != null) {
                return itemIndex;
            }
        }
        else {
            // Search the filtered values if we are filtered and not ignoreing filters
            const values = isFiltered && !ignoreFilters ? me._filteredValues : me._values,
                count = values.length;

            for (let i = 0; i < count; i++) {
                if (values[i][propertyName] == value) {
                    return i;
                }
            }
        }

        // Not found
        return -1;
    }

    /**
     * Returns the index of the item with the same `id` as the passed item.
     *
     * By default, filtering is honoured, so if the item in question has been added,
     * but is currently filtered out of visibility, `-1` will be returned.
     *
     * To find the index in the master, unfiltered dataset, pass the second parameter as `true`;
     * @param {Object|String|Number} item The item to find, or an `id` to find.
     * @param {Boolean} [ignoreFilters=false] Pass `true` to find the index in the master, unfiltered data set.
     * @returns {Number} The index of the item, or `-1` if not found.
     */
    indexOf(item, ignoreFilters = false) {
        return this.findIndex(this.idProperty, keyTypes[typeof item] ? item : item[this.idProperty], ignoreFilters);
    }

    /**
     * Returns `true` if this Collection includes an item with the same `id` as the passed item.
     *
     * By default, filtering is honoured, so if the item in question has been added,
     * but is currently filtered out of visibility, `false` will be returned.
     *
     * To query inclusion in the master, unfiltered dataset, pass the second parameter as `true`;
     * @param {Object|String|Number} item The item to find, or an `id` to find.
     * @param {Boolean} [ignoreFilters=false] Pass `true` to find the index in the master, unfiltered data set.
     * @returns {Boolean} True if the passed item is found.
     */
    includes(item, ignoreFilters = false) {
        return this.indexOf(item, ignoreFilters) !== -1;
    }

    get indices() {
        if (this._indicesInvalid) {
            this.rebuildIndices();
        }
        return this._indices;
    }

    /**
     * Called when the Collection is mutated and the indices have been flagged as invalid.
     *
     * Rebuilds the indices object to allow lookup by keys.
     * @internal
     */
    rebuildIndices() {
        const me = this,
            isFiltered = me.isFiltered,
            indices = (me._indices || (me._indices = {})),
            keyProps = Object.keys(indices),
            indexCount = keyProps.length,
            values = me._values,
            count = values.length;

        let i, j;

        // First, clear indices.
        if (isFiltered) {
            indices[filteredIndicesProperty] = {};
        }
        for (i = 0; i < indexCount; i++) {
            indices[keyProps[i]] = {};
            if (isFiltered) {
                indices[filteredIndicesProperty][keyProps[i]] = {};
            }
        }

        /*
         * Rebuild the indices object.
         * Loop through all items adding an entry for each one to each index.
         * So collection.add({id : foo, name : 'Nige'}, {id : 'bar', name : 'Faye'}) where collection has had an index
         * added for the "name" property would result in:
         *
         * {
         *     id : {
         *         foo : 0,
         *         bar : 1
         *     },
         *     name : {
         *         Nige : 0,
         *         Faye : 1
         *     }
         * }
         */
        for (i = 0; i < count; i++) {
            const item = values[i];

            for (j = 0; j < indexCount; j++) {
                const keyProp = keyProps[j];
                // This does indices.name['Nige'] = 0
                indices[keyProp][safeIndexKey(item[keyProp])] = i;
            }
        }

        // Create a parallel lookup structure into the _filteredValues
        if (isFiltered) {
            const values = me._filteredValues,
                count = values.length,
                indices = me._indices[filteredIndicesProperty];

            for (i = 0; i < count; i++) {
                const item = values[i];

                for (j = 0; j < indexCount; j++) {
                    const keyProp = keyProps[j];
                    // This does indices[filteredIndicesProperty].name['Nige'] = 0
                    indices[keyProp][safeIndexKey(item[keyProp])] = i;
                }
            }
        }

        me._indicesInvalid = false;
    }
}
Collection._$name = 'Collection';

/**
 * @module Core/helper/util/Scroller
 */

const scrollLiterals = {
        true            : 'auto',
        false           : 'hidden',
        'hidden-scroll' : 'auto'
    },
    scrollerCls = 'b-widget-scroller',
    defaultScrollOptions = {
        block : 'nearest'
    },
    immediatePromise$1 = new Promise((resolve) => resolve()),
    scrollPromise = (element) => new Promise(resolve => EventHelper.on({
        element,
        scroll : resolve,
        once   : true
    })),
    xAxis = {
        x : 1
    };

/**
 * Encapsulates scroll functionality for a Widget. All requests for scrolling and scrolling information
 * must go through a Widget's {@link Core.widget.Widget#config-scrollable} property.
 * @mixes Core/mixin/Events
 * @mixes Core/mixin/Delayable
 * @extends Core/Base
 */
class Scroller extends Delayable(Events(Base)) {
    static get defaultConfig() {
        return {
            /**
             * The element which is to scroll.
             * @config {HTMLElement}
             */
            element : null,

            /**
             * How to handle overflowing in the `X` axis.
             * May be:
             * * `'auto'`
             * * `'visible'`
             * * `'hidden'`
             * * `'scroll'`
             * * `'hidden-scroll'` Meaning scrollable from the UI but with no scrollbar,
             * for example a grid header. Only on platforms which support this feature.
             * * `true` - meaning `'auto'`
             * * `false` - meaning `'hidden'`
             * @config {String|Boolean}
             */
            overflowX : null,

            /**
             * How to handle overflowing in the `Y` axis.
             * May be:
             * * `'auto'`
             * * `'visible'`
             * * `'hidden'`
             * * `'scroll'`
             * * `'hidden-scroll'` Meaning scrollable from the UI but with no scrollbar.
             * Only on platforms which support this feature.
             * * `true` - meaning `'auto'`
             * * `false` - meaning `'hidden'`
             * @config {String|Boolean}
             */
            overflowY : null,

            /**
             * If configured as `true`, the {@link #config-element} is not scrolled
             * but is translated using CSS transform when controlled by this class's API.
             * Scroll events are fired when the element is translated.
             * @default
             * @config {Boolean}
             */
            translate : null,

            _x : 0,
            _y : 0,

            scrollEndBuffer : 100
        };
    }

    /**
     * Fired when scrolling happens on this Scroller's element. The event object is a native `scroll` event
     * with the described extra properties injected.
     * @event scroll
     * @param {Core.widget.Widget} widget The owning Widget which has been scrolled.
     * @param {Core.helper.util.Scroller} source This Scroller
     */

    /**
     * Fired when scrolling finished on this Scroller's element. The event object is the last native `scroll` event
     * fires by the element with the described extra properties injected.
     * @event scrollend
     * @param {Core.widget.Widget} widget The owning Widget which has been scrolled.
     * @param {Core.helper.util.Scroller} source This Scroller
     */

    /**
     * Partners this Scroller with the passed scroller in order to sync the scrolling position in the passed axes
     * @param {Core.helper.util.Scroller} otherScroller
     * @param {String|Object} [axes='x'] `'x'` or `'y'` or `{x: true/false, y: true/false}` axes to sync
     */
    addPartner(otherScroller, axes = xAxis) {
        
        if (typeof axes === 'string') {
            axes = {
                [axes] : 1
            };
        }

        (this.partners || (this.partners = new Collection())).add({
            id       : otherScroller.id,
            scroller : otherScroller,
            axes
        });

        // It's a mutual relationship - the other scroller partners with us.
        if (!otherScroller.partners || !otherScroller.partners.includes(this.id)) {
            otherScroller.addPartner(this, axes);
        }
    }

    /**
     * Breaks the link between this Scroller and the passed Scroller set up by the
     * {@link #function-addPartner} method.
     * @param {Core.helper.util.Scroller} otherScroller The Scroller to unlink from.
     */
    removePartner(otherScroller) {
        if (this.partners && this.partners.includes(otherScroller)) {
            this.partners.remove(otherScroller);
            otherScroller.removePartner(this);
        }
    }

    /**
     * Scrolls the passed element or {@link Core.helper.util.Rectangle} into view according to the passed options.
     * @param {HTMLElement|Core.helper.util.Rectangle} element The element or a Rectangle in document space to scroll into view.
     * @param {Object} [options] How to scroll.
     * @param {String} [options.block] How far to scroll the element: `start/end/center/nearest`.
     * @param {Number} [options.edgeOffset] edgeOffset A margin around the element or rectangle to bring into view.
     * @param {Object|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
     * or the number of milliseconds to animate over, or an animation config object.
     * @param {Number} [options.animate.duration] The number of milliseconds to animate over.
     * @param {String} [options.animate.easing] The name of an easing function.
     * @param {Boolean} [options.highlight] Set to `true` to highlight the element when it is in view.
     * @param {Boolean} [options.focus] Set to `true` to focus the element when it is in view.
     * @param {Boolean} [options.x] Pass as `false` to disable scrolling in the `X` axis.
     * @param {Boolean} [options.y] Pass as `false` to disable scrolling in the `Y` axis.
     * @returns {Promise} A promise which is resolved when the element has been scrolled into view.
     */
    scrollIntoView(element, options = defaultScrollOptions) {
        const isRectangle = element instanceof Rectangle,
            originalRect = isRectangle ? element : Rectangle.from(element),
            { xDelta, yDelta } = this.getDeltaTo(element, options),
            result = this.scrollBy(xDelta, yDelta, options);

        if (options.highlight || options.focus) {
            result.then(() => {
                if (isRectangle) {
                    element = originalRect.translate(-xDelta, -yDelta);
                }
                if (options.highlight) {
                    DomHelper.highlight(element, this);
                }
                if (options.focus) {
                    element.focus();
                }
            });
        }
        return result;
    }

    /**
     * Scrolls by the passed deltas according to the passed options.
     * @param {Number} [xDelta=0] How far to scroll in the X axis.
     * @param {Number} [yDelta=0] How far to scroll in the Y axis.
     * @param {Object|Boolean} [options] How to scroll. May be passed as `true` to animate.
     * @param {Boolean} [options.silent] Set to `true` to suspend `scroll` events during scrolling.
     * @param {Object|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
     * or the number of milliseconds to animate over, or an animation config object.
     * @param {Number} [options.animate.duration] The number of milliseconds to animate over.
     * @param {String} [options.animate.easing] The name of an easing function.
     * @returns {Promise} A promise which is resolved when the scrolling has fnished.
     */
    scrollBy(xDelta = 0, yDelta = 0, options = defaultScrollOptions) {
        const me      = this,
            animate = (typeof options === 'object') ? options.animate : options,
            absX    = Math.abs(xDelta),
            absY    = Math.abs(yDelta);

        if (me.scrollAnimation) {
            me.scrollAnimation.cancel();
            me.scrollAnimation = null;
        }

        // Only set the flag if there is going to be scrolling done.
        // It is cleared by the scrollEnd handler, so there must be scrolling.
        if (xDelta || yDelta) {
            me.silent = options.silent;
        }

        let duration = animate && (typeof animate === 'number' ? animate : (typeof animate.duration === 'number' ? animate.duration : 300));

        // Only go through animation if there is significant scrolling to do.
        if (duration && (absX > 10 || absY > 10)) {
            const { x, y } = me;
            let lastX = x,
                lastY = y;

            // For small distances, constrain duration
            if (Math.max(absX, absY) < 50) {
                duration = Math.min(duration, 500);
            }

            me.scrollAnimation = FunctionHelper.animate(duration, progress => {
                const isEnd = progress === 1;
                if (xDelta) {
                    // If the user, or another process has changed the position since last time, abort.
                    // Unless called with the force option to proceed regardless.
                    if (me.x !== lastX && !options.force) {
                        return me.scrollAnimation && me.scrollAnimation.cancel();
                    }
                    me.x = Math.max(x + (isEnd ? xDelta : Math.round(xDelta * progress)), 0);
                }
                if (yDelta) {
                    // If the user, or another process has changed the position since last time, abort.
                    // Unless called with the force option to proceed regardless.
                    if (me.y !== lastY && !options.force) {
                        return me.scrollAnimation && me.scrollAnimation.cancel();
                    }
                    me.y = Math.max(y + (isEnd ? yDelta : Math.round(yDelta * progress)), 0);
                }
                // Store actual position from DOM
                lastX = me.x;
                lastY = me.y;
            }, me, animate.easing);

            me.element.classList.add('b-scrolling');

            me.scrollAnimation.then(() => {
                if (!me.isDestroyed) {
                    me.element.classList.remove('b-scrolling');
                    me.scrollAnimation = null;
                }
            });
            return me.scrollAnimation;
        }
        else {
            if (xDelta | yDelta) {
                me.x += xDelta;
                me.y += yDelta;
                return scrollPromise(me.element);
            }
            else {
                return immediatePromise$1;
            }
        }
    }

    /**
     * Scrolls to the passed position according to the passed options.
     * @param {Number} [toX=0] Where to scroll to in the X axis.
     * @param {Number} [toY=0] Where to scroll to in the Y axis.
     * @param {Object|Boolean} [options] How to scroll. May be passed as `true` to animate.
     * @param {Object|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
     * or the number of milliseconds to animate over, or an animation config object.
     * @param {Number} [options.animate.duration] The number of milliseconds to animate over.
     * @param {String} [options.animate.easing] The name of an easing function.
     * @returns {Promise} A promise which is resolved when the scrolling has finished.
     */
    scrollTo(toX, toY, options) {
        const { x, y } = this,
            xDelta = toX == null ? 0 : toX - x,
            yDelta = toY == null ? 0 : toY - y;

        return this.scrollBy(xDelta, yDelta, options);
    }

    doDestroy() {
        const me = this;

        if (me._element) {
            me._element.removeEventListener('scroll', me.scrollHandler);
            me.wheelListenerRemover && me.wheelListenerRemover();
        }
        if (me.scrollAnimation) {
            me.scrollAnimation.cancel();
        }

        me.partners && me.partners.forEach(partner => partner.scroller.removePartner(me));

        super.doDestroy();
    }

    /**
     * Respond to style changes to monitor scroll *when this Scroller is in `translate: true` mode.*
     * @param {Object[]} mutations The ElementMutation records.
     * @private
     */
    onElMutation(mutations) {
        const me = this,
            [x, y] = DomHelper.getTranslateXY(me.element);

        // If the mutation was due to a change in the translateX/Y styles, this is
        // a scroll event, so inform observers and partners
        if (me._x !== -x || me.y !== -y) {
            const scrollEvent = new CustomEvent('scroll', { bubbles : true });

            Object.defineProperty(scrollEvent, 'target', {
                get : () => me.element
            });

            me.onScroll(scrollEvent);
        }
    }

    onScroll(e) {
        const me = this;

        if (!me.widget || !me.widget.isDestroyed) {
            // Don't read the value until we have to. The x & y getters will check this flag
            me.positionDirty = true;

            if (!me.element.classList.contains('b-scrolling')) {
                me.element.classList.add('b-scrolling');
            }

            e.widget = me.widget;

            // If we have the scroll silent flag, do not fire the event.
            if (!me.silent) {
                me.trigger('scroll', e);
            }

            // Keep partners in sync
            me.syncPartners();

            // If this scroll impulse was from a controlling partner, clear that now
            me.controllingPartner = null;

            // Will fire in 100ms, unless another scroll event comes round.
            // In which case execution will be pushed out by another 100ms.
            me.scrollEndHandler(e);
        }
    }

    syncPartners() {
        const me = this;

        // Keep partners in sync
        if (me.partners) {
            me.partners.forEach(({ axes, scroller }) => {
                // Don't feed back to the one who's just told us to scroll here.
                if (scroller !== me.controllingPartner) {
                    scroller.sync(me, axes);
                }
            });
        }
    }

    onScrollEnd(e) {
        if (this.silent) {
            this.silent = false;
        }
        this.trigger('scrollEnd', e);
        this.element.classList.remove('b-scrolling');
    }

    /**
     * Returns the xDelta and yDelta values in an object from the current scroll position to the
     * passed element or Rectangle.
     * @param {HTMLElement|Core.helper.util.Rectangle} element The element or a Rectangle to calculate deltas for.
     * @param {Object} [options] How to scroll.
     * @param {String} [options.block] How far to scroll the element: `start/end/center/nearest`.
     * @param {Number} [options.edgeOffset] A margin around the element or rectangle to bring into view.
     * @param {Boolean} [options.x] Pass as `false` to disable scrolling in the `X` axis.
     * @param {Boolean} [options.y] Pass as `false` to disable scrolling in the `Y` axis.
     * @returns {Object} `{ xDelta, yDelta }`
     * @internal
     */
    getDeltaTo(element, options) {
        const me = this;

        // scroller may belong to a collapsed subgrid widget
        if (!me.viewport) {
            return {
                xDelta : 0,
                yDelta : 0
            };
        }

        if (!(element instanceof Rectangle)) {
            element = Rectangle.from(element);
        }

        // We must round when scrolling so that we do not overscroll leading to
        // unwanted mouseovers.
        element.round();

        const
            block = options.block || 'nearest',
            scrollerRect = me.viewport.round(),
            edgeOffset = options.edgeOffset || 0,
            // Only include the offset round the target is the viewport is big enough to accommodate it.
            xOffset = scrollerRect.width >= element.width + (edgeOffset * 2) ? edgeOffset : 0,
            yOffset = scrollerRect.height >= element.height + (edgeOffset * 2) ? edgeOffset : 0,
            elRect = element.clone().adjust(-xOffset, -yOffset, xOffset, yOffset).constrainTo(new Rectangle(scrollerRect.x - me.x, scrollerRect.y - me.y, me.scrollWidth, me.scrollHeight)),
            targetRect = elRect.clone();

        let xDelta = 0,
            yDelta = 0;

        if (block === 'start') {
            targetRect.moveTo(scrollerRect.x, scrollerRect.y);
            xDelta = elRect.x - targetRect.x;
            yDelta = elRect.y - targetRect.y;
        }
        else if (block === 'end') {
            targetRect.translate(scrollerRect.right - targetRect.right, scrollerRect.bottom - targetRect.bottom);
            xDelta = elRect.x - targetRect.x;
            yDelta = elRect.y - targetRect.y;
        }
        else {
            // Calculate deltas unless the above has done that for non-fitting target
            if (block === 'center') {
                const center = scrollerRect.center;

                targetRect.moveTo(center.x - targetRect.width / 2, center.y - targetRect.height / 2);
                xDelta = xDelta || elRect.x - targetRect.x;
                yDelta = yDelta || elRect.y - targetRect.y;
            }
            // Use "nearest"
            else {
                // Can't fit width in, scroll what is possible into view so that start is visible.
                if (targetRect.width > scrollerRect.width) {
                    xDelta = targetRect.x - scrollerRect.x;
                }
                // If it's *possible* to scroll to nearest x, calculate the delta
                else {
                    if (targetRect.right > scrollerRect.right) {
                        xDelta = targetRect.right - scrollerRect.right;
                    }
                    else if (targetRect.x < scrollerRect.x) {
                        xDelta = targetRect.x - scrollerRect.x;
                    }
                }

                // Can't fit height in, scroll what is possible into view so that start is visible.
                if (targetRect.height > scrollerRect.height) {
                    yDelta = targetRect.y - scrollerRect.y;
                }
                // If it's *possible* to scroll to nearest y, calculate the delta
                else {
                    if (targetRect.bottom > scrollerRect.bottom) {
                        yDelta = targetRect.bottom - scrollerRect.bottom;
                    }
                    else if (targetRect.y < scrollerRect.y) {
                        yDelta = targetRect.y - scrollerRect.y;
                    }
                }
            }
        }

        // Do not allow deltas which would produce -ve scrolling or scrolling past the maxX/Y
        return {
            // When calculating how much delta is necessary to scroll the targetRect to the center
            // constrain that to what is *possible*. If what you are trying to scroll into the
            // center is hard against the right edge of the scroll range, then it cannot scroll
            // to the center, and the result must reflect that even though scroll is self limiting.
            // This is because highlighting the requested "element", if that element is in fact
            // a Rectangle, uses a temporary element placed at the requested region which
            // MUST match where the actual scroll has moved the requested region.
            xDelta : options.x === false ? 0 : Math.max(Math.min(xDelta, me.maxX - me.x), -me.x),
            yDelta : options.y === false ? 0 : Math.max(Math.min(yDelta, me.maxY - me.y), -me.y)
        };
    }

    /**
     * A {@link Core.helper.util.Rectangle Rectangle} describing the bounds of the scrolling viewport.
     * @property {Core.helper.util.Rectangle}
     */
    get viewport() {
        return Rectangle.client(this.element);
    }

    get element() {
        return this._element;
    }

    set element(element) {
        const
            me            = this,
            scrollHandler = me.scrollHandler || (me.scrollHandler = me.onScroll.bind(me));

        if (!me.scrollEndHandler) {
            me.scrollEndHandler = me.buffer(me.onScrollEnd, me.scrollEndBuffer);
        }

        if (me._element) {
            if (me.translate) {
                me.mutationObserver && me.mutationObserver.disconnect(me._element);
            }
            else {
                me._element.removeEventListener('scroll', scrollHandler);
                me._element.classList.remove(scrollerCls);
            }
        }
        me._element = element;

        if (me.translate) {
            if (!me.mutationObserver) {
                me.mutationObserver = new MutationObserver(mutations => me.onElMutation(mutations));
            }
            me.mutationObserver.observe(element, { attributes : true });

            me._x = me._y = 0;
            if (document.contains(element)) {
                const [x, y] = DomHelper.getTranslateXY(element);
                me._x = -x;
                me._y = -y;
            }
        }
        else {
            element.addEventListener('scroll', scrollHandler);
            element.classList.add(scrollerCls);
        }

        // Ensure the overflow configs, which are unable to process themselves
        // in the absence of the element get applied to the newly arrived element.
        me.updateOverflowX(me.overflowX);
        me.updateOverflowY(me.overflowY);
    }

    /**
     * The horizontal scroll position of the widget.
     * @property {Number}
     */
    get x() {
        const me = this,
            { element } = me;

        if (element && me.positionDirty) {
            if (me.translate) {
                const [x, y] = DomHelper.getTranslateXY(element);
                me._x = -x;
                me._y = -y;
            }
            else {
                me._x = element.scrollLeft;
                me._y = element.scrollTop;
            }
            me.positionDirty = false;
        }
        return me._x;
    }

    set x(x) {
        const { element, widget } = this;

        // When element is outside of DOM, this can have no effect
        if (widget && widget.isConfiguring) {
            return;
        }

        this._x = x;

        if (element) {
            this.trigger('scrollStart', { x });

            if (this.translate) {
                DomHelper.setTranslateX(element, -x);
            }
            else {
                element.scrollLeft = x;
            }

            // The scroll position will need to be read before we can return it.
            // Do not read it back now, that would cause a forced synchronous layout.
            this.positionDirty = true;
        }
    }

    sync(controllingPartner, axes) {
        const { x, y } = axes;

        this.controllingPartner = controllingPartner;

        if (x != null) {
            this.x = controllingPartner.x;
        }
        if (y != null) {
            this.y = controllingPartner.y;
        }
    }

    /**
     * The vertical scroll position of the widget.
     * @property {Number}
     */
    get y() {
        const me = this,
            { element } = me;

        if (element && me.positionDirty) {
            if (me.translate) {
                const [x, y] = DomHelper.getTranslateXY(element);
                me._x = -x;
                me._y = -y;
            }
            else {
                me._x = element.scrollLeft;
                me._y = element.scrollTop;
            }
            me.positionDirty = false;
        }
        return me._y;
    }

    set y(y) {
        const { element, widget } = this;

        // When element is outside of DOM, this can have no effect
        if (widget && widget.isConfiguring) {
            return;
        }

        this._y = y;

        if (element) {
            this.trigger('scrollStart', { y });

            if (this.translate) {
                DomHelper.setTranslateY(element, -y);
            }
            else {
                element.scrollTop = y;
            }

            // The scroll position will need to be read before we can return it.
            // Do not read it back now, that would cause a forced synchronous layout.
            this.positionDirty = true;
        }
    }

    /**
     * The maximum `X` scrollable position of the widget.
     * @property {Number}
     * @readonly
     */
    get maxX() {
        return this.scrollWidth - this.clientWidth;
    }

    /**
     * The maximum `Y` scrollable position of the widget.
     * @property {Number}
     * @readonly
     */
    get maxY() {
        return this.scrollHeight - this.clientHeight;
    }

    /**
     * The `overflow-x` setting for the widget. `true` means `'auto'`.
     * @property {Boolean|String}
     */
    get overflowX() {
        return this._overflowX;
    }

    set overflowX(overflowX) {
        this._overflowX = overflowX;

        if (this.element) {
            this.updateOverflowX(overflowX);
        }
    }

    updateOverflowX(overflowX) {
        const { element, translate } = this;

        // Scroll, but without showing scrollbars.
        // For example a grid header. Only works on platforms which
        // support suppression of scrollbars through CSS.
        if (overflowX === 'hidden-scroll' && !translate) {
            element.classList.add('b-hide-scroll');

            // Adds a wheel listener if needed - there is scrollbar width
            // and we don't already have one.
            this.enableWheel();
        }
        if (!translate) {
            element.style.overflowX = scrollLiterals[overflowX] || overflowX;
        }
        this.positionDirty = !this.isConfiguring;
    }

    /**
     * The `overflow-y` setting for the widget. `true` means `'auto'`.
     * @property {Boolean|String}
     */
    get overflowY() {
        return this._overflowY;
    }

    set overflowY(overflowY) {
        this._overflowY = overflowY;

        if (this.element) {
            this.updateOverflowY(overflowY);
        }
    }

    updateOverflowY(overflowY) {
        const { element, translate } = this;

        // Scroll, but without showing scrollbars.
        // For example a grid header. Only works on platforms which
        // support suppression of scrollbars through CSS.
        if (overflowY === 'hidden-scroll' && !translate) {
            element.classList.add('b-hide-scroll');

            // Adds a wheel listener if needed - there is scrollbar width
            // and we don't already have one.
            this.enableWheel();
        }
        if (!translate) {
            element.style.overflowY = scrollLiterals[overflowY] || overflowY;
        }
        this.positionDirty = !this.isConfiguring;
    }

    enableWheel() {
        if (!BrowserHelper.isChrome && !BrowserHelper.isSafari && !this.wheelListenerRemover) {
            this.wheelListenerRemover = EventHelper.on({
                element : this.element,
                wheel   : 'onWheel',
                thisObj : this
            });
        }
    }

    onWheel(e) {
        if (e.deltaX > e.deltaY && this.overflowX !== false) {
            this.x += e.deltaX;
        }
        else if (this.overflowY !== false) {
            this.y += e.deltaY;
        }
    }

    /**
     * The horizontal scroll range of the widget.
     * @property {Number}
     * @readonly
     */
    get scrollWidth() {
        return this.element ? this.element.scrollWidth : 0;
    }

    set scrollWidth(scrollWidth) {
        const me = this;
        let stretcher = me.widthStretcher;

        // "Unsetting" scrollWidth removes the stretcher
        if (stretcher && scrollWidth == null) {
            stretcher.remove();
            me.widthStretcher = null;
        }
        else if (scrollWidth) {
            if (!stretcher) {
                stretcher = me.widthStretcher = DomHelper.createElement({
                    className : 'b-scroller-stretcher'
                });
            }

            stretcher.style.transform = `translateX(${scrollWidth - 1}px)`;

            if (me.element && me.element.lastChild !== stretcher) {
                me.element.appendChild(stretcher);
            }
        }
    }

    get scrollHeight() {
        return this.element ? this.element.scrollHeight : 0;
    }

    /**
     * The vertical scroll range of the widget. May be set to larger than the actual data
     * height to enable virtual scrolling. This is how the grid extends its scroll range
     * while only rendering a small subset of the dataset.
     * @property {Number}
     */
    set scrollHeight(scrollHeight) {
        const me = this,
            stretcher = me.stretcher || (me.stretcher = DomHelper.createElement({
                className : 'b-scroller-stretcher'
            }));

        stretcher.style.transform = `translateY(${scrollHeight - 1}px)`;
        if (me.element && me.element.lastChild !== stretcher) {
            me.element.appendChild(stretcher);
        }
    }

    /**
     * The client width of the widget.
     * @property {Number}
     * @readonly
     */
    get clientWidth() {
        return this.element ? this.element.clientWidth : 0;
    }

    /**
     * The client height of the widget.
     * @property {Number}
     * @readonly
     */
    get clientHeight() {
        return this.element ? this.element.clientHeight : 0;
    }

    /**
     * The unique ID of this Scroller
     * @property {String}
     * @readonly
     */
    get id() {
        if (!this._id) {
            if (this.widget) {
                this._id = `${this.widget.id}-scroller`;
            }
            else {
                this._id = IdHelper.generateId('scroller-');
            }
        }
        return this._id;
    }
}
Scroller._$name = 'Scroller';

const
    localeName = 'En',
    localeDesc = 'English';

const locale$1 = {

    localeName,
    localeDesc,

    // Translations for common words and phrases which are used by all classes.
    Object : {
        Yes    : 'Yes',
        No     : 'No',
        Cancel : 'Cancel',
        Custom : 'Custom'
    },

    //region Mixins

    InstancePlugin : {
        fnMissing         : data => `Trying to chain fn ${data.plugIntoName}#${data.fnName}, but plugin fn ${data.pluginName}#${data.fnName} does not exist`,
        overrideFnMissing : data => `Trying to override fn ${data.plugIntoName}#${data.fnName}, but plugin fn ${data.pluginName}#${data.fnName} does not exist`
    },

    //endregion

    //region Widgets

    Field : {
        invalidValue          : 'Invalid field value',
        minimumValueViolation : 'Minimum value violation',
        maximumValueViolation : 'Maximum value violation',
        fieldRequired         : 'This field is required',
        validateFilter        : 'Value must be selected from the list'
    },

    DateField : {
        invalidDate : 'Invalid date input'
    },

    TimeField : {
        invalidTime : 'Invalid time input'
    },

    //endregion

    //region Others

    DateHelper : {
        locale       : 'en-US',
        shortWeek    : 'W',
        shortQuarter : 'q',
        week         : 'Week',
        weekStartDay : 0,
        unitNames    : [
            { single : 'millisecond', plural : 'ms',       abbrev : 'ms' },
            { single : 'second',      plural : 'seconds',  abbrev : 's' },
            { single : 'minute',      plural : 'minutes',  abbrev : 'min' },
            { single : 'hour',        plural : 'hours',    abbrev : 'h' },
            { single : 'day',         plural : 'days',     abbrev : 'd' },
            { single : 'week',        plural : 'weeks',    abbrev : 'w' },
            { single : 'month',       plural : 'months',   abbrev : 'mon' },
            { single : 'quarter',     plural : 'quarters', abbrev : 'q' },
            { single : 'year',        plural : 'years',    abbrev : 'yr' }
        ],
        // Used to build a RegExp for parsing time units.
        // The full names from above are added into the generated Regexp.
        // So you may type "2 w" or "2 wk" or "2 week" or "2 weeks" into a DurationField.
        // When generating its display value though, it uses the full localized names above.
        unitAbbreviations : [
            ['mil'],
            ['s', 'sec'],
            ['m', 'min'],
            ['h', 'hr'],
            ['d'],
            ['w', 'wk'],
            ['mo', 'mon', 'mnt'],
            ['q', 'quar', 'qrt'],
            ['y', 'yr']
        ],
        parsers : {
            L  : 'MM/DD/YYYY',
            LT : 'HH:mm A'
        },
        ordinalSuffix : number => number + ({ 1 : 'st', 2 : 'nd', 3 : 'rd' }[number[number.length - 1]] || 'th')
    },

    PagingToolbar : {
        firstPage         : 'Go to first page',
        prevPage          : 'Go to previous page',
        page              : 'Page',
        nextPage          : 'Go to next page',
        lastPage          : 'Go to last page',
        reload            : 'Reload current page',
        noRecords         : 'No records to display',
        pageCountTemplate : data => `of ${data.lastPage}`,
        summaryTemplate   : data => `Displaying records ${data.start} - ${data.end} of ${data.allCount}`
    },

    List : {
        loading : 'Loading...'
    }

    //endregion
};

LocaleManagerSingelton.registerLocale(localeName, { desc : localeDesc, locale : locale$1 });

// TODO: Needs more docs

/**
 * @module Core/widget/Widget
 */

const
    isTransparent      = /transparent|rgba\(0,\s*0,\s*0,\s*0\)/,
    textInputTypes     = {
        INPUT    : 1,
        TEXTAREA : 1
    },
    // Need braces here. MUST NOT return false
    widgetTriggerPaint = w => {
        w.isVisible && w.triggerPaint();
    },
    negationPseudo     = /^:not\((.+)\)$/,
    dragGhost          = DomHelper.createElement({
        // Safari won't allow dragging an empty node
        html  : '\xa0',
        style : 'position:absolute;top:-10000em;left:-10000em'
    });

/**
 * Base class for other widgets. The Widget base class simply encapsulates an element, and may optionally contain some
 * specified {@link #config-html}.
 *
 * Subclasses should at override the {@link #function-template} member function to return an HTML string to create their own encapsulating element
 * and internal structure.
 *
 * @mixes Core/mixin/Events
 * @mixes Core/localization/Localizable
 * @extends Core/Base
 * @classType widget
 */
class Widget extends Delayable(Events(Localizable(Base))) {
    //region Config

    static get $name() {
        return 'Widget';
    }

    static get defaultConfig() {
        return {
            /**
             * A {@link Core.helper.DomHelper#function-createElement-static} config object or HTML string from which to
             * create the Widget's element.
             * @private
             * @config {Object|String}
             * @category DOM
             */
            element : true,

            callOnFunctions : true,

            /**
             * Widget id, if not specified one will be generated. Also used for lookups through WidgetHelper
             * @config {String}
             * @category DOM
             */
            id : '',

            /**
             * Html to display initially
             * @config {String}
             * @category DOM
             */
            html : null,

            /**
             * true if no id was set, will use generated id instead (widget1, ...). Toggle automatically on creation
             * @default false
             * @type {Boolean}
             * @private
             * @category Misc
             */
            hasGeneratedId : null,

            /**
             * Custom CSS class to add to element
             * @config {String}
             * @category CSS
             */
            cls : null,

            /**
             * Custom style spec to add to element
             * @config {String}
             * @category CSS
             */
            style : null,

            /**
             * Disabled or enabled
             * @default false
             * @config {Boolean}
             * @category Misc
             */
            disabled : null,

            /**
             * Element (or element id) to adopt as this Widget's encapsulating element. The widget's
             * content will be placed inside this element.
             *
             * If this widget has not been configured with an id, it will adopt the id of the element
             * in order to preserve CSS rules which may apply to the id.
             * @config {HTMLElement|String}
             * @default
             * @category DOM
             */
            adopt : null,

            /**
             * Element (or element id) to append this widgets element to
             * @config {HTMLElement|String}
             * @default
             * @category DOM
             */
            appendTo : null,

            /**
             * Element (or element id) to insert this widget before. If provided, {@link #config-appendTo} config is ignored.
             * @config {HTMLElement|String}
             * @category DOM
             */
            insertBefore : null,

            /**
             * Element (or element id) to append this widget element to, as a first child. If provided, {@link #config-appendTo} config is ignored.
             * @config {HTMLElement|String}
             * @category DOM
             */
            insertFirst : null,

            /**
             * Object to apply to elements dataset (each key will be used as a data-attribute on the element)
             * @config {Object}
             * @category DOM
             */
            dataset : null,

            /**
             * Tooltip for the widget, either as a string or as a Tooltip config object
             * @config {String|Object}
             * @category Misc
             */
            tooltip : null,

            /**
             * Prevent tooltip from being displayed on touch devices. Useful for example for buttons that display a
             * menu on click etc, since the tooltip would be displayed at the same time.
             * @config {Boolean}
             * @default false
             * @category Misc
             */
            preventTooltipOnTouch : null,

            /**
             * Specify true to have widget monitoring window resize.
             * @config {Boolean}
             * @default false
             * @category Misc
             */
            monitorResize : null,

            cache : {},

            /**
             * Set to `true` to move the widget out of the document flow and position it
             * absolutely in browser viewport space.
             * @config {Boolean}
             * @default
             * @category Float & align
             */
            floating : null,

            /**
             * Set to `true` when a widget is rendered into another widget's  {@link #property-contentElement}, but must not
             * participate in the standard layout of that widget, and must be positioned relatively to that
             * widget's {@link #property-contentElement}.
             *
             * {@link Core.widget.Editor Editor}s are positioned widgets.
             * @config {Boolean}
             * @default
             * @category Float & align
             */
            positioned : null,

            /**
             * Only valid if this Widget is {@link #config-floating}
             * Set to `true` to be able to drag a widget freely on the page. Or set to an object with a ´handleSelector´ property which controls when a drag
             * should start.
             *
             * ```javascript
             *
             * draggable : {
             *     handleSelector : ':not(button)'
             * }
             *
             * ```
             *
             * @config {Boolean|Object}
             * @default false
             * @category Float & align
             */
            draggable : null,

            /**
             * Only valid if this Widget is {@link #config-floating}
             * The edge alignment spec to use by default when {@link #function-showBy} or {@link #function-alignTo} is used.
             * Format is `'[trbl]n-[trbl]n'` and it specifies our edge and the target edge plus optional
             * offsets from 0 to 100 along the edges to align to. See the {@link #function-showBy} function for more details.
             * @default
             * @config {String}
             * @category Float & align
             */
            align : 't-b',

            /**
             * Only valid if this Widget is {@link #config-floating}
             * Set to `true` to centre the Widget in browser viewport space.
             * @config {Boolean}
             * @default
             * @category Float & align
             */
            centered : null,

            /**
             * Only valid if this Widget is {@link #config-floating} and being shown through {@link #function-showBy}.
             * Element, Widget or Rectangle to which this Widget is constrained.
             * @config {HTMLElement|Core.widget.Widget|Core.helper.util.Rectangle}
             * @default document.body
             * @category Float & align
             */
            constrainTo : null,

            /**
             * Only valid if this Widget is {@link #config-floating} and being shown through {@link #function-showBy}.
             * `true` to show a connector arrow pointing to the align target.
             * @config {Boolean}
             * @default false
             * @category Float & align
             */
            anchor : null,

            /**
             * Defines what to do if document is scrolled while Widget is visible (only relevant when floating is set to true).
             * Valid values: ´null´: do nothing, ´hide´: hide the widget or ´realign´: realign to the target if possible.
             * @config {String}
             * @default
             * @category Float & align
             */
            scrollAction : null,

            /**
             * Only valid if this Widget is {@link #config-floating}. An object which defined which CSS style
             * property should be animated upon hide, and how it should be animated eg:
             *
             * ```javascript
             * {
             *    opacity: {
             *        to : 0,
             *        duration: '10s',
             *        delay: '0s'
             *    }
             * }
             * ```
             *
             * Set to `'false'` to disable animation.
             *
             * @config {Boolean|Object}
             * @default
             * @category Float & align
             */
            hideAnimation : null,

            /**
             * Only valid if this Widget is {@link #config-floating}. An object which defined which CSS style
             * property should be animated upon show, and how it should be animated eg:
             *
             * ```javascript
             * {
             *    opacity: {
             *        to : 1,
             *        duration: '10s',
             *        delay: '0s'
             *    }
             * }
             * ```
             *
             * Set to `'false'` to disable animation.
             *
             * @config {Boolean|Object}
             * @category Float & align
             */
            showAnimation : null,

            /**
             * Only valid if this Widget is {@link #config-floating}. The x position for the widget.
             *
             * @config {Number}
             * @default
             * @category Float & align
             */
            x : null,

            /**
             * Only valid if this Widget is {@link #config-floating}. The y position for the widget.
             *
             * @config {Number}
             * @default
             * @category Float & align
             */
            y : null,

            /**
             * Specifies whether (and optionally in which axes) a Widget may scroll. `true` means this widget
             * may scroll in both axes. May be an object containing boolean `overflowX` and `overflowY` properties which are applied
             * to CSS style properties `overflowX` and `overflowY`. If they are boolean, they are translated
             * to CSS overflow properties thus:
             *
             * *`true` -> `'auto'`
             * *`false` -> `'hidden'`
             *
             * After initialization, this property yields a {@link Core.helper.util.Scroller} which may be used
             * to both set and read scroll information.
             *
             * A Widget uses its `get overflowElement` property to select which element is to be scrollable.
             * By default, in the base `Widget` class, this is the Widget's encapsulating element. Subclasses
             * may implement `get overflowElement` to scroll inner elements.
             * @config {Boolean|Object|Core.helper.util.Scroller}
             * @default false
             * @category Scrolling
             */
            scrollable : null,

            /**
             * The class to instantiate to use as the {@link #config-scrollable}. Defaults to {@link Core.helper.util.Scroller}.
             * @internal
             * @config {Core.helper.util.Scroller}
             * @category Scrolling
             */
            scrollerClass : Scroller,

            /**
             * The name of the property to set when a single value is to be applied to this Widget. Such as when used
             * in a grid WidgetColumn, this is the property to which the column's `field` is applied.
             * @config {String}
             * @default 'html'
             * @category Misc
             */
            defaultBindProperty : 'html',

            /**
             * Event that should be considered the default action of the widget. When that event is triggered the
             * widget is also expected to trigger an `action` event. Purpose is to allow reacting to most widgets in
             * a coherent way.
             * @private
             * @config {String}
             * @category Misc
             */
            defaultAction : null,

            /**
             * Widget's width, used to set element style.width. Either specify a valid width string or a number, which
             * will get 'px' appended. We recommend using CSS as the primary way to control width, but in some cases
             * this config is convenient.
             * @config {String|Number}
             * @category Layout
             */
            width : null,

            /**
             * Widget's height, used to set element style.height. Either specify a valid height string or a number, which
             * will get 'px' appended. We recommend using CSS as the primary way to control height, but in some cases
             * this config is convenient.
             * @config {String|Number}
             * @category Layout
             */
            height : null,

            // not public, only used by us in docs
            scaleToFitWidth : null,
            allowGrowWidth  : true, // only used if scaleToFitWidth is true

            /**
             * Widget's margin. This may be configured as a single number or a `TRBL` format string.
             * numeric-only values are interpreted as pixels.
             * @config {Number|String}
             * @category Layout
             */
            margin : null,

            /**
             * When this widget is a child of a {@link Core.widget.Container},
             * it will by default be participating in a flexbox layout. This config
             * allows you to set this widget's <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex">flex</a> style.
             * This may be configured as a single number or a `<flex-grow> <flex-shrink> <flex-basis>` format string.
             * numeric-only values are interpreted as the `flex-grow` value.
             * @config {Number|String}
             * @category Layout
             */
            flex : null,

            /**
             * When this widget is a child of a {@link Core.widget.Container},
             * it will by default be participating in a flexbox layout. This config
             * allows you to set this widget's <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-self">align-self</a> style.
             * @config {String}
             * @category Layout
             */
            alignSelf : null,

            /**
             * Configure as `true` to have the component display a translucent ripple when its
             * {@link #property-focusElement}, or {@link #property-element} is tapped *if the
             * current theme supports ripples*. Out of the box, only the Material theme supports ripples.
             *
             * This may also be a config object containing the following properties:
             *
             *  - `delegate  ` Optional. A CSS selector to filter which child elements trigger ripples. By default
             * the ripple is clipped to the triggering element.
             *  - `color     ` Optional, default = `#000`. A CSS color name or specification.
             *  - `radius    ` Optional, default is 100. The ending radius of the ripple.
             * Note that it will be clipped by the target element by default.
             *  - `clip      ` A string which describes how to clip the ripple if it is not to be clipped to the default
             * element. Either the property of the widget to use as the clipping element, or a selector to
             * allow clipping to the closest matching ancestor to the target element.
             *
             * eg:
             *```
             *    columns  : [{}...],
             *    ripple   : {
             *        color : 'red',
             *        clip  : '.b-grid-row'
             *    },
             *    ...
             *```
             * @config {Boolean|Object}
             * @category Misc
             */
            ripple : null,

            /**
             * A title to display for the widget. Only in effect when inside a container that uses it (such as TabPanel)
             * @default
             * @config {String}
             */
            title : null,

            localizableProperties : ['title'],

            // Set this flag to require element to have a size to be considered visible
            requireSize : false,

            /**
             * An identifier by which this widget will be registered in the {@link Core.widget.Container#property-widgetMap}
             * of all ancestor containers.
             *
             * If omitted, this widget will be registered using its {@link #config-id}. In most cases `ref` is
             * preferable over `id` since `id` is required to be globally unique while `ref` is not.
             *
             * The `ref` value is also added to the elements dataset, to allow targeting it using CSS etc.
             * @default
             * @config {String}
             */
            ref : null,

            /**
             * Configure with true to make widget initially hidden
             * @default false
             * @config {Boolean}
             */
            hidden : null
        };
    }

    //endregion

    //region Init & destroy

    construct(config = {}, ...args) {
        const me = this;

        // Flag so we know when our dimensions have been constrained during alignment
        me.alignConstrained = 0;

        me.afterHideShowAnimate = me.afterHideShowAnimate.bind(me);
        me.callRealign = me.realign.bind(me);
        me.doHideOrRealign = me.doHideOrRealign.bind(me);

        me.initialRender = true;
        me._isUserAction = false;

        // Base class applies configs.
        super.construct(config, args);

        me.finalizeInit();
    }

    isType(type, deep) {
        return IdHelper.isType(this, type, deep);
    }

    startConfigure(config) {
        const
            me                 = this,
            { adopt, element } = me;

        // Adopt the preexisting element as our element before configuration proceeds.
        if (adopt) {
            const
                adoptElement   = typeof adopt === 'string' ? document.getElementById(adopt) : adopt,
                previousHolder = IdHelper.fromElement(adoptElement);

            // If we are taking it over from a previous iteration, destroy the previous holder.
            if (previousHolder) {
                previousHolder.destroy();
            }

            // On destroy, leave these
            me.preExistingElements = Array.from(adoptElement.childNodes);
            me.adoptedElementClassName = adoptElement.className;
            me.adoptedElementCssText = adoptElement.style.cssText;

            // Adopt the host element's id if we don't have one so that we do not override
            // it and invalidate any ad-based CSS rules.
            if (adoptElement.id && !config.id) {
                me.id = element.id = adoptElement.id;
            }
            DomHelper.syncAttributes(element, adoptElement);
            for (let i = 0, { length } = element.childNodes; i < length; i++) {
                adoptElement.appendChild(element.childNodes[0]);
            }
            me._element = adoptElement;

            delete me._contentRange;
        }

        super.startConfigure(config);
    }

    set title(title) {
        if (this._title !== title) {
            this._title = title;
            if (this.titleElement) {
                this.titleElement.innerHTML = title;
            }
        }
    }

    get title() {
        return this._title;
    }

    /**
     * Get this widget's encapsulating HTMLElement, which is created along with the widget but added to DOM at render time
     * @property {HTMLElement}
     * @readonly
     * @category DOM
     */
    get element() {
        return this._element;
    }

    set element(element) {
        const me = this;

        if (typeof element === 'string') {
            element = DomHelper.createElementFromTemplate(element);
        }
        else if (element.constructor.name === 'Object') {
            element = DomHelper.createElement(element);
        }
        else if (element.nodeType !== 1) {
            element = DomHelper.createElementFromTemplate(me.template(me));
        }
        me._element = element;
        const classList = element.classList;

        element.id = me.id;

        // Add the hierarchy, eg ['b-combo b-pickerfield b-textfield b-widget']
        // TODO: apply not needed when IE11 not supported, classList.add takes multiple classes
        //classList.add(...me.widgetClassList);
        element.className += ' ' + me.widgetClassList.join(' ');

        if (me._hidden) {
            classList.add('b-hidden');
        }

        // The environmental classes only need to be added to a naked Widget.
        // If we have a parent container, that will have them.
        if (!me.parent) {
            if (!me.floating && !me.owner) {
                classList.add('b-outer');
            }
            if (BrowserHelper.isTouchDevice) {
                classList.add('b-touch-events');
            }
            if (DomHelper.scrollBarWidth) {
                classList.add('b-visible-scrollbar');
            }
            else {
                classList.add('b-overlay-scrollbar');
            }
            if (BrowserHelper.isChrome) {
                classList.add('b-chrome');
            }
            else if (BrowserHelper.isSafari) {
                classList.add('b-safari');
            }
            else if (BrowserHelper.isFirefox) {
                classList.add('b-firefox');
            }
            else if (BrowserHelper.isIE11) {
                classList.add('b-ie');
            }
            else if (BrowserHelper.isEdge) {
                classList.add('b-edge');
            }
        }

        const namedElements = element.querySelectorAll('[reference]');

        for (const el of namedElements) {
            const name = el.getAttribute('reference');
            el.removeAttribute('reference');

            // Set a reference directly to significant elements.
            // For example the 'input' element of a field.
            me[name] = el;

            // Key elements contain owner pointer if data is supported (Not on IE SVG).
            el.dataset && (el.dataset.ownerCmp = me.id);
        }
    }

    set constrainTo(constrainTo) {
        this._constrainTo = constrainTo;
    }

    get constrainTo() {
        return '_constrainTo' in this ? this._constrainTo : window;
    }

    set centered(value) {
        this._centered = value;

        if (value && !this.floating) {
            throw new Error('`centered` is only relevant when a Widget is `floating`');
        }

        if (value) {
            this.element.classList.add('b-centered');
        }
        else {
            this.element.classList.remove('b-centered');
        }
    }

    get centered() {
        return this._centered;
    }

    /**
     * The child element into which content should be placed. This means where {@link #config-html} should be put,
     * or, for {@link Core.widget.Container Container}s, where child items should be rendered.
     * @property {HTMLElement}
     * @category DOM
     */
    get contentElement() {
        return this.element;
    }

    get contentRange() {
        const
            me                 = this,
            { contentElement } = me,
            contentRange       = me._contentRange || (me._contentRange = BrowserHelper.isIE11 ? document.createRange() : new Range());

        // Initialize the contentRange if it's collapsed.
        // It gets collapsed if the widget's element is removed from the DOM.
        if (contentRange.collapsed) {
            contentRange.setStart(contentElement, me.contentRangeStartOffset || 0);
            contentRange.setEnd(contentElement, me.contentRangeEndOffset || contentElement.childNodes.length);
        }

        return contentRange;
    }

    /**
     * Get/set widgets id
     * @property {String}
     * @category DOM
     */
    get id() {
        return this._id;
    }

    set id(id) {
        const
            me    = this,
            oldId = me._id;

        if (id) {
            me.hasGeneratedId = false;
        }
        else {
            id = IdHelper.generateId(`b-${me.$name.toLowerCase()}-`);
            me.hasGeneratedId = true;
        }

        if (oldId) {
            const refEls = me.element.querySelectorAll(`[data-owner-cmp="${oldId}"]`);

            IdHelper.unregister(me);

            for (let i = 0, { length } = refEls; i < length; i++) {
                refEls[i].dataset.ownerCmp = id;
            }
            me.element.id = id;
        }
        me._id = id;
        IdHelper.register(me);
    }

    /**
     * Get/set widgets elements style. The setter accepts a cssText string or a style config object, the getter always
     * returns a CSSStyleDeclaration
     * @property {String|Object|CSSStyleDeclaration}
     * @category DOM
     */
    get style() {
        return this.element ? this.element.ownerDocument.defaultView.getComputedStyle(this.element) : this._style;
    }

    set style(style) {
        this._style = style;
        this.element && DomHelper.applyStyle(this.element, this._style);
    }

    /**
     * Get widgets elements dataset or assign to it
     * @property {Object}
     * @category DOM
     */
    get dataset() {
        return this.element.dataset;
    }

    set dataset(dataset) {
        Object.assign(this.dataset, dataset);
    }

    /**
     * Called by the Base constructor after all configs have been applied.
     * @internal
     * @category Lifecycle
     */
    finalizeInit() {
        if (this.insertBefore || this.appendTo || this.insertFirst || this.adopt) {
            this.render();
        }
    }

    doDestroy() {
        const
            me                               = this,
            element                          = me._element,
            { tooltip, preExistingElements } = me;

        me.scrollable && me.scrollable.destroy();

        if (tooltip) {
            // If it's our own "newInstance", then destroy it.
            if (me._tooltip) {
                tooltip.destroy();
            }
            // The singleton is active for this element and visible, so hide it
            else if (tooltip.activeTarget === element && tooltip.isVisible) {
                tooltip.hide();
            }
        }

        me.unmask();

        if (element) {
            // Remove listeners which are only added during the visible phase.
            // In its own method because it's called on hide and destroy.
            me.removeTransientListeners();

            if (me.floating || me.positioned) {
                me.hide();
            }
            else {
                me.revertFocus();
            }

            ResizeMonitor.removeResizeListener(element.parentElement, me.onParentElementResize);
            ResizeMonitor.removeResizeListener(element, me.onElementResize);

            // Remove elements *which we own* on destroy,
            if (me.adopt) {
                for (let nodes = Array.from(element.childNodes), i = 0, { length } = nodes; i < length; i++) {
                    const el = nodes[i];

                    // If it's not preexisting, and not the floatRoot, remove it
                    if (!preExistingElements.includes(el) && el !== Widget.floatRoot) {
                        el.remove();
                    }
                }
                element.className = me.adoptedElementClassName;
                element.style.cssText = me.adoptedElementCssText;
            }
            else {
                element.remove();
            }

            me.dragEventDetacher && me.dragEventDetacher();
            me.dragOverEventDetacher && me.dragOverEventDetacher();
            dragGhost.remove();
        }

        IdHelper.unregister(me);

        super.doDestroy();
    }

    //endregion

    //region Render

    render(appendToElement, triggerPaint = true) {
        const
            me          = this,
            { element } = me;

        ResizeMonitor.removeResizeListener(element.parentElement, me.onParentElementResize);
        ResizeMonitor.removeResizeListener(element, me.onElementResize);

        me.emptyCache();

        if (me.syncElement && me.currentElement) {
            DomHelper.sync(element, me.currentElement);
        }
        else {
            // Use passed element to insert this widget directly
            if (appendToElement) {
                me.appendTo = typeof appendToElement === 'string' ? document.getElementById(appendToElement) : appendToElement;
                me.appendTo.appendChild(element);
            }
            // If nothing was passed directly, try to use configs preferring `insertBefore` first
            else if (me.insertBefore) {
                me.insertBefore = typeof me.insertBefore === 'string' ? document.getElementById(me.insertBefore) : me.insertBefore;
                me.insertBefore.parentElement.insertBefore(element, me.insertBefore);
            }
            else if (me.insertFirst) {
                me.insertFirst = typeof me.insertFirst === 'string' ? document.getElementById(me.insertFirst) : me.insertFirst;

                // Try to insert as a first child
                if (me.insertFirst.firstChild) {
                    me.insertFirst.insertBefore(element, me.insertFirst.firstChild);
                }
                // insertBefore will throw exceptions if firstChild element not exists. Add as only child then.
                else {
                    me.insertFirst.appendChild(element);
                }
            }
            else if (me.appendTo) {
                me.appendTo = typeof me.appendTo === 'string' ? document.getElementById(me.appendTo) : me.appendTo;
                me.appendTo.appendChild(element);
            }

            me.currentElement = element;
        }

        me.rendered = true;

        if (triggerPaint) {
            me._thisIsAUsedExpression(me.contentRange);
            me.triggerPaint();
        }
    }

    /**
     * A function which, when passed an instance of this Widget, produces a valid HTML string which is compiled
     * to create the encapsulating element for this Widget, and its own internal DOM structure.
     *
     * Note that this just creates the DOM structure that *this* Widget owns. If it contains child widgets
     * (Such as for example a grid), this is not included. The template creates own structure.
     *
     * Certain elements within the generated element can be identified as special elements with a `reference="name"`
     * property. These will be extracted from the element upon creation and injected as the named property into
     * the Widget. For example, a {@link Core.widget.TextField} will have an `input` property which is its
     * `<input>` element.
     * @param {Core.widget.Widget} me The widget for which to produce the initial HTML structure.
     * @internal
     */
    template(me) {
        return `<div class="${me.html ? 'b-html' : ''}" ${me.name ? `data-name="${me.name}"` : ''}>${me.html || ''}</div>`;
    }

    //endregion

    //region floating

    /**
     * If this Widget is {@link #config-floating} or {@link #config-positioned}, and visible,
     * aligns the widget according to the passed specification.
     * For details, see the {@link #function-showBy} method.
     * @param {Object} spec Alignment options. May be an object as processed by the {@link #function-showBy} method,
     * or an `HTMLElement` to align to using this Widget's {@link #config-align} configuration.
     * @category Float & align
     */
    alignTo(spec) {
        

        // You can "alignTo" an element or a Widget or a Point, and allow our align config.
        // property to specify how.
        if (spec.nodeType === 1 || spec instanceof Widget || (spec instanceof Point)) {
            spec = {
                target : spec
            };
        }

        // Release size constraints so we can align from scratch each time.
        this.releaseSizeConstraints();

        const
            me                = this,
            {
                scrollable,
                element
            }                 = me,
            passedTarget      = spec.target,
            target            = passedTarget && ((passedTarget instanceof Rectangle) ? passedTarget : (passedTarget.element || passedTarget)),
            myPosition        = Rectangle.from(element, me.positioned ? element.offsetParent : null, true),
            aligningToElement = target && target.nodeType === 1;

        spec = Object.assign({
            // Constraining is a viewport coordinate based thing. not relevant to positioned
            // Widgets which are within their owning Widget and thereby constrained anyway.
            constrainTo : me.positioned ? null : me.constrainTo,
            axisLock    : me.axisLock,
            anchor      : me.anchor
        }, typeof me.align === 'object' ? me.align : { align : me.align }, spec);

        // As part of fallback process when fitting within constraints, this may shrink to minima specified
        // either on the align spec or the widget itself.
        myPosition.minWidth = spec.minWidth || me.minWidth;
        myPosition.minHeight = spec.minHeight || me.minHeight;

        // This is used by the realign call which may be called either when a global scroll is detected
        // or the constraining element is resized.
        me.lastAlignSpec = spec;

        if (aligningToElement && target.offsetParent) {
            // Translate the element into a browser viewport based Rectangle. Rectangle
            // Doesn't have the knowledge that we do to make this decision. Floating
            // alignment all takes place within browser viewport space, not document space.
            // Don't destroy the spec which was cached above with the element in it.
            spec = Object.setPrototypeOf({}, spec);
            spec.target = Rectangle.from(target, me.positioned ? element.offsetParent : null, !me.positioned);

            // Force the target to have an area so that intersect works.
            spec.target.height = Math.max(spec.target.height, 1);
            spec.target.width = Math.max(spec.target.width, 1);

            // Handle the target being clipped by the bounds of various elements.
            // For example in a grid, the SubGrid element will clip the left and right
            // but the main grid bodyContainer will clip the top and bottom.
            const clippedBy = me.clippedBy;
            if (clippedBy) {
                const clippedTarget = spec.target.intersect(clippedBy);

                // If there is an intersecting Rectangle with the forElement, align
                if (clippedTarget) {
                    spec.target = clippedTarget;
                }
                // This is the case where the target is scrolled or positioned out of view.
                else {
                    const result = me.hide();

                    // The hide method clears this flag.
                    // Only this hide invocation must complete with the
                    // targetHidden flag as true
                    me.lastAlignSpec.targetHidden = true;
                    return result;
                }
            }

            // This is the element which determines our position.
            // This is used in doHideOrRealign to see if a scroll event
            // will have affected our position.
            me.anchoredTo = target;
        }
        else {
            me.anchoredTo = null;
        }

        if (spec.anchor) {
            spec.anchorSize = me.anchorSize;
            element.appendChild(me.anchorElement);
        }

        // Flag to prevent infinite loop when setting html from a beforeAlign listener
        me.isAligning = true;

        // Allow outside world to modify the suggested position
        me.trigger('beforeAlign', spec);

        me.isAligning = false;

        // Calculate the best position WRT target rectangle, our rectangle, a constrainTo rectangle
        // and the rectangle of an anchor pointer.
        const
            { constrainTo }   = spec,
            constrainToWindow = constrainTo === window || constrainTo === document,
            result            = myPosition.alignTo(spec);

        // May change if constraint changes our shape, and we have to go round again
        let { align, anchor, x, y, width, height, bottom, right } = result;

        // Which zone, T=0, R=1, B=2, L=3 the result is in
        me.lastAlignSpec.zone = result.zone;

        // If the alignment specified that we must constrain a dimension in order to
        // fit within our constrainTo, then obey that. If we own a Scroller, then
        // inform it that we do now need to scroll that dimension.
        // These conditions are released upon each alignment call because conditions may change.
        if (height !== myPosition.height) {
            if (!('configuredHeight' in me)) {
                me.configuredHeight = element.style.height;
            }
            me.height = height;
            me.alignConstrained = me.alignConstrained | 1;
            if (scrollable) {
                scrollable.overflowY = true;
            }
        }
        if (width !== myPosition.width) {
            if (!('configuredWidth' in me)) {
                me.configuredWidth = element.style.width;
            }
            me.width = width;
            me.alignConstrained = me.alignConstrained | 2;
            if (scrollable) {
                scrollable.overflowX = scrollable.clientWidth > scrollable.scrollWidth;
            }
        }

        // If either dimension has been constrained, we may have changed shape
        // due to text wrapping/overflowing, so we have to realign at the
        // successful align setting.
        if (align && me.alignConstrained) {
            spec.align = align;
            const
                newResult = Rectangle.from(element, me.positioned ? element.offsetParent : null, true).alignTo(spec);

            anchor = newResult.anchor;
            x = newResult.x;
            y = newResult.y;
            width = newResult.width;
            height = newResult.height;
            bottom = newResult.bottom;
            right = newResult.right;
        }

        me.setXY(x, y);

        // If we asked it to also calculate our anchor position, position our anchor
        if (anchor) {
            const
                { edge }           = anchor,
                { anchorElement }  = me,
                colorMatchPoint    = [],
                stylePointerEvents = element.style.pointerEvents;

            // Enable pointerEvents to make discoverable by elementFromPoint()
            element.style.pointerEvents = 'all';

            // Make the anchor color match the color of the closest adjacent element
            if (edge === 'top' || edge === 'bottom') {
                colorMatchPoint[0] = x + anchor.x;
                colorMatchPoint[1] = edge === 'top' ? y + 1 : bottom - 1;
            }
            else {
                colorMatchPoint[0] = edge === 'left' ? x + 1 : right - 1;
                colorMatchPoint[1] = y + anchor.y;
            }
            const colourSource = document.elementFromPoint(...colorMatchPoint);

            element.style.pointerEvents = stylePointerEvents || null;

            // If  it's off the edge of the screen, we won't be able to read it.
            // But that's fine, the anchor will be off the edge in that case.
            if (colourSource) {
                const fillColour = DomHelper.getStyleValue(colourSource, 'background-color');

                if (fillColour.match(isTransparent)) {
                    me.anchorPathElement.setAttribute('fill', me.defaultAnchorBackgroundColor);
                }
                else {
                    me.anchorPathElement.setAttribute('fill', fillColour);
                }
            }

            anchorElement.classList.remove('b-hide-display');
            anchorElement.style.transform = '';
            anchorElement.className = `b-anchor b-anchor-${edge}`;
            DomHelper.setTranslateXY(anchorElement, anchor.x, anchor.y);
        }
        else if (me._anchorElement) {
            me.anchorElement.classList.add('b-hide-display');
        }

        // If we are to hide on scroll, we still need to know if the element we are
        // aligned to moves. If we have not been *explicitly* aligned to an element,
        // Use the element at our display position. For example, when a context menu
        // is shown on a grid header, then is the grid header is moved by a scroll
        // event, then we must hide.
        if (me.scrollAction === 'hide' && !aligningToElement) {
            // Our element is over the X, Y point now,
            // elementFromPoint must "see through" it.
            element.style.pointerEvents = 'none';
            me.anchoredTo = document.elementFromPoint(x, y);
            element.style.pointerEvents = '';
        }

        // If we're aligning to an element, then listen for scrolls so that we can remain aligned.
        // Scrolls can be instigated with no mousedown, so transient floating Widgets can be put
        // out of alignment by scrolls.
        if ((me.scrollAction === 'realign' && aligningToElement || me.scrollAction === 'hide') && !me.documentScrollListener) {
            // Push binding to the scroll position out until the next animation frame.
            // This is in case the calling code is going to cause a scroll.
            // for example contextmenu is a focusing gesture which may cause a scroll
            // to fire as the target element moves into view.
            me.setTimeout(() => {
                document.addEventListener('scroll', me.doHideOrRealign, true);
                me.documentScrollListener = true;
            }, 0);
        }

        // Don't try to listen for window resizes to try realigning on Android.
        // That just means the keyboard has been shown.
        if (!BrowserHelper.isAndroid && constrainToWindow) {
            if (constrainTo && (constrainTo.nodeType === 1 || constrainToWindow) && !me.constrainListeners) {
                ResizeMonitor.addResizeListener(constrainTo, me.callRealign);

                // Do not listen for constrainTo mutations if it's the viewport.
                // Mutating it won't change its size.
                if (!constrainToWindow) {
                    me.constrainMutationMonitor || (me.constrainMutationMonitor = new MutationObserver(me.callRealign)).observe(constrainTo, { // eslint-disable-line no-undef
                        attributes : true,
                        childList  : true
                    });
                }
                me.constrainListeners = true;
            }
        }
    }

    realign(el) {
        const me = this;

        if (me.isVisible && (me.floating || me.positioned) && me.lastAlignSpec) {
            const target = me.lastAlignSpec.target;

            // If there was a DOM mutation which caused our target to become not layed out, or the target
            // is outside of the passed element's rectangle (passed from scroll handler), we must hide
            if (target && target.nodeType === 1) {
                const targetRect = Rectangle.from(target);

                // We can align to an element which has a zero dimension, but the
                // intersection check requires that both dimensions are non-zero.
                targetRect.minHeight = targetRect.minWidth = 1;
                if (target !== document.body && !target.offsetParent ||
                    el && el.nodeType === 1 && el.contains(target) && !Rectangle.from(el).intersect(targetRect)) {
                    return me.hide();
                }
            }
            me.alignTo(me.lastAlignSpec);
        }
    }

    releaseSizeConstraints() {
        const me       = this,
            scroller = me.scrollable;

        // Release constraints so we can align from scratch each time.
        if (me.alignConstrained & 1) {
            me.height = me.configuredHeight;
            if (scroller) {
                scroller.overflowY = scroller.config.overflowY;
            }
        }
        if (me.alignConstrained & 2) {
            me.width = me.configuredWidth;
            if (scroller) {
                scroller.overflowX = scroller.config.overflowX;
            }
        }
        me.alignConstrained = 0;
    }

    /**
     * Only valid for {@link #config-floating} Widgets. Moves to the front of the visual stacking order.
     * @category Float & align
     */
    toFront() {
        
        if (this.element && this.element.nextSibling) {
            this.element.parentNode.appendChild(this.element);
        }
    }

    //endregion

    //region Getters/setters

    set ref(ref) {
        this._ref = ref;

        this.element.dataset.ref = ref;
    }

    get ref() {
        return this._ref;
    }

    set clippedBy(clippedBy) {
        this._clippedBy = Array.isArray(clippedBy) ? clippedBy : clippedBy ? [clippedBy] : null;
    }

    get clippedBy() {
        const clippedBy = this._clippedBy;

        if (clippedBy) {
            let result = Rectangle.from(clippedBy[0], null, true), i;

            for (i = 1; i < clippedBy.length; i++) {
                result = result.intersect(Rectangle.from(clippedBy[i], null, true));
            }
            return result;
        }
    }

    get overflowElement() {
        return this.contentElement;
    }

    get maxHeightElement() {
        return this.element;
    }

    set scrollable(scrollable) {
        const overflowElement = this.overflowElement;

        if (typeof scrollable === 'boolean') {
            scrollable = {
                overflowX : scrollable,
                overflowY : scrollable
            };
        }
        

        if (overflowElement) {
            scrollable.element = overflowElement;
        }
        scrollable.widget = this;
        this._scrollable = new this.scrollerClass(scrollable);
    }

    /**
     * Accessor to the {@link Core.helper.util.Scroller} which can be used
     * to both set and read scroll information.
     * @property {Core.helper.util.Scroller} scrollable
     */
    get scrollable() {
        return this._scrollable;
    }

    /**
     * Get/set HTML to display. When specifying HTML, this widget's element will also have `b-html` added to its
     * classList, to allow targeted styling.
     * @property {String}
     * @category DOM
     */
    get html() {
        // Maintainer, we cannot use a ternary here, we need the this.initializingElement test to shortcut
        // to the true case to return the _html property to avoid infinite loops.
        if (this.initializingElement || !this.element) {
            return this.content || this._html;
        }
        return this.contentElement.innerHTML;
    }

    set html(html) {
        const
            me                          = this,
            isClearing                  = (html == null),
            { element, contentElement } = me;

        if (me._html !== html) {
            me._html = html;
            if (element) {
                const anchorEl = (contentElement === element) && me._anchorElement;

                // Flag class that we are an HTML carrying element
                element.classList[isClearing ? 'remove' : 'add']('b-html');

                // Setting innerHTML destroys the anchorElement in some browsers
                // so we must temporarily remove it to preserve it.
                // Only if the contentElement is the main element.
                if (anchorEl) {
                    me.element.removeChild(anchorEl);
                }
                me.contentElement.innerHTML = isClearing ? '' : html;

                if (anchorEl) {
                    element.appendChild(anchorEl);
                }
                if (me.floating || me.positioned) {
                    // Must realign because content change might change dimensions
                    if (!me.isAligning) {
                        me.realign();
                    }
                }
            }
        }
    }

    /**
     * Set HTML content safely, without disturbing sibling elements which may have been
     * added to the {@link #property-contentElement} by plugins and features.
     * When specifying html, this widget's element will also have `b-html` added to its
     * classList, to allow targeted styling.
     * @property {String}
     * @category DOM
     */
    set content(html) {
        const
            me          = this,
            isClearing  = (html == null),
            { element } = me;

        if (me._html !== html) {
            me._html = html;
            if (element) {
                const { contentRange } = me;

                // Flag class that we are an HTML carrying element
                element.classList[isClearing ? 'remove' : 'add']('b-html');

                // Only works if we are in the DOM
                if (isInDocument(element)) {
                    // Replace the contents of our content range with the new content
                    contentRange.deleteContents();
                    if (!isClearing) {
                        contentRange.insertNode(DomHelper.createElementFromTemplate(html, {
                            fragment : true
                        }));
                    }
                }
                else {
                    me.contentElement.innerHTML = html;
                }

                // Cache in case it gets collapsed
                me.contentRangeStartOffset = contentRange.startOffset;
                me.contentRangeEndOffset = contentRange.endOffset;

                // Must realign because content change might change dimensions
                if (!me.isAligning || me.positioned) {
                    me.realign();
                }
            }
        }
    }

    onThemeChange() {
        // If we have a *visible* anchor element, then a theme change may
        // invalidate it's size or this.defaultAnchorBackgroundColor, so a
        // run through realign (and get anchorSize) will fix that.
        if (this.anchorElement && this.anchorElement.offsetParent) {
            this._anchorSize = null;
            this.realign();
        }
    }

    /**
     * Returns an `[x, y]` array containing the width and height of the anchor arrow used when
     * aligning this Widget to another Widget or element.
     *
     * The height is the height of the arrow when pointing upwards, the width is the width
     * of the baseline.
     * @property {Number[]}
     * @category Float & align
     */
    get anchorSize() {
        const me = this;

        let result = this._anchorSize;

        if (!result) {
            // TODO: Move the anchoring scheme to the Panel class when we have it.
            // These values will be in the SASS and styled into the SVG through the Panel's theme.
            const
                borderWidth   = parseFloat(DomHelper.getStyleValue(me.element, 'border-top-width')),
                borderColour  = DomHelper.getStyleValue(me.element, 'border-top-color'),
                anchorElement = me.anchorElement,
                svgEl         = anchorElement.firstElementChild,
                pathElement   = me.anchorPathElement = svgEl.lastElementChild,
                hidden        = me._hidden;

            let backgroundColour = DomHelper.getStyleValue(me.contentElement, 'background-color');

            // If the background colour comes through from the outer element, use that.
            if (backgroundColour.match(isTransparent)) {
                backgroundColour = DomHelper.getStyleValue(me.element, 'background-color');
            }
            me.defaultAnchorBackgroundColor = backgroundColour;

            result = anchorElement.getBoundingClientRect();
            const [width, height] = result = me._anchorSize = [result.width, result.height];

            svgEl.setAttribute('height', height + borderWidth);
            svgEl.setAttribute('width', width);
            pathElement.setAttribute('d', `M0,${height}L${width / 2},0.5L${width},${height}`);
            if (borderWidth) {
                pathElement.setAttribute('stroke-width', borderWidth);
                pathElement.setAttribute('stroke', borderColour);
            }
            result[1] -= borderWidth;

            if (hidden) {
                me.element.classList.add('b-hidden');
            }

            if (!me.themeChangeListener) {
                me.themeChangeListener = GlobalEvents.on({
                    theme   : 'onThemeChange',
                    thisObj : me
                });
            }
        }

        // Reset to default in case it has been positioned by a coloured header
        me.anchorPathElement.setAttribute('fill', me.defaultAnchorBackgroundColor);

        return result;
    }

    get anchorElement() {
        let result = this._anchorElement;

        if (!result) {
            result = this._anchorElement = DomHelper.createElement({
                parent    : this.element,
                className : 'b-anchor b-anchor-top',
                children  : [{
                    tag      : 'svg',
                    ns       : 'http://www.w3.org/2000/svg',
                    version  : '1.1',
                    class    : 'b-pointer-el',
                    children : [{
                        tag      : 'defs',
                        children : [{
                            tag      : 'filter',
                            id       : 'shadow-filter',
                            children : [{
                                tag             : 'feDropShadow',
                                dx              : 0,
                                dy              : -1,
                                stdDeviation    : 2,
                                'flood-opacity' : 0.05
                            }]
                        }]
                    }, {
                        tag    : 'path',
                        filter : BrowserHelper.isIE11 || BrowserHelper.isEdge ? null : 'url(#shadow-filter)'
                    }]
                }]
            });
        }

        return result;
    }

    set anchor(anchor) {
        this._anchor = anchor;

        if (this._anchorElement) {
            this._anchorElement.classList[anchor ? 'remove' : 'add']('b-hide-display');
        }
    }

    get draggable() {
        return this._draggable;
    }

    set draggable(draggable) {
        const
            me          = this,
            { element } = me;

        me._draggable = draggable;

        element.setAttribute('draggable', Boolean(draggable));

        if (draggable) {
            me.dragEventDetacher = EventHelper.addListener({
                element   : me.element,
                dragstart : me.onWidgetDragStart,
                dragend   : me.onWidgetDragEnd,
                thisObj   : me
            });
        }
        else {
            me.dragEventDetacher && me.dragEventDetacher();
            me.dragOverEventDetacher && me.dragOverEventDetacher();
        }
    }

    onWidgetDragStart(e) {
        const
            me                 = this,
            actualTarget       = document.elementFromPoint(e.clientX, e.clientY), // Can't be resolved from the event :/
            { handleSelector } = me.draggable;

        if (handleSelector) {
            const blacklist = negationPseudo.exec(handleSelector)[1]; // Extract the content of :not()

            // If the selector was :not(), then if we are a descendant of a matching element, it's a no-drag
            if (blacklist) {
                if (actualTarget.closest(`#${me.element.id} ${blacklist}`)) {
                    e.preventDefault();
                    return;
                }
            }
            // If we are not the descendant of a matching element, it's a no-drag
            else if (!actualTarget.closest(`#${me.element.id} ${handleSelector}`)) {
                e.preventDefault();
                return;
            }
        }

        // Opt out of auto-alignment on scroll or DOM mutation.
        me.removeTransientListeners();

        const
            dragStartX           = e.clientX,
            dragStartY           = e.clientY,
            scrollingPageElement = (document.scrollingElement || document.body),
            widgetX              = me.getXY()[0],
            widgetY              = me.getXY()[1];

        document.body.appendChild(dragGhost);

        if (e.dataTransfer.setDragImage) {
            // Firefox requires this to be called before setDragImage
            e.dataTransfer.setData('application/node type', '');

            // Override the default HTML5 drag ghost and just drag an empty node
            e.dataTransfer.setDragImage(dragGhost, 0, 0);
        }

        // Prevent special cursor from being shown
        e.dataTransfer.effectAllowed = 'none';

        me.dragOverEventDetacher = EventHelper.addListener({
            element  : document.body,
            dragover : event => me.setXY(widgetX + event.clientX - dragStartX - scrollingPageElement.scrollLeft,
                widgetY + event.clientY - dragStartY - scrollingPageElement.scrollTop)
        });

        // Opt out of anchoring
        me.anchor = null;
    }

    onWidgetDragEnd(e) {
        dragGhost.remove();
        this.dragOverEventDetacher();
    }

    get anchor() {
        return this._anchor;
    }

    get floating() {
        return this._floating;
    }

    set floating(floating) {
        // Coerce all to boolean so that we have a true/false value
        floating = Boolean(floating);

        if (Boolean(this.floating) !== floating) {
            

            this._floating = floating;
        }
    }

    get positioned() {
        return this._positioned;
    }

    set positioned(positioned) {
        // Coerce all to boolean so that we have a true/false value
        positioned = Boolean(positioned);
        if (Boolean(this.positioned) !== positioned) {
            this.element.classList[positioned ? 'add' : 'remove']('b-positioned');
            this._positioned = positioned;
        }
    }

    getXY() {
        return [
            DomHelper.getPageX(this.element),
            DomHelper.getPageY(this.element)
        ];
    }

    /**
     * Moves this Widget to the x,y position. Both arguments can be omitted to just set one value.
     *
     * *For {@link #config-floating} Widgets, this is a position in the browser viewport.*
     * *For {@link #config-positioned} Widgets, this is a position in the element it was rendered into.*
     *
     * @param {Number} [x]
     * @param {Number} [y]
     * @category Float & align
     */
    setXY(x, y) {
        const me = this;

        if (me.floating || me.positioned) {
            if (x != null) {
                me._x = x;
                me.centered = false;
            }
            if (y != null) {
                me._y = y;
                me.centered = false;
            }
            DomHelper.setTranslateXY(me.element, me._x || 0, me._y || 0);
        }
        
    }

    /**
     * Moves this Widget to the desired x position. *Only valid for {@link #config-floating} Widgets.
     * @param {Number} x
     * @category Float & align
     */
    set x(x) {
        this.setXY(x);
    }

    get x() {
        return this.getXY()[0];
    }

    /**
     * Moves this Widget to the desired y position. *Only valid for {@link #config-floating} Widgets.
     * @param {Number} y
     * @category Float & align
     */
    set y(y) {
        this.setXY(null, y);
    }

    get y() {
        return this.getXY()[1];
    }

    /**
     * Get elements offsetWidth or sets its style.width, or specified width if element not created yet.
     * @property {Number|String}
     * @category Layout
     */
    get width() {
        const
            me      = this,
            element = me.element;

        if (me.monitorResize) {
            // If the width is invalid, read it now.
            if (me._width == null) {
                me._width = element.offsetWidth;
            }

            // Usually this will be set in onInternalResize
            return me._width;
        }
        // No monitoring, we have to measure;
        return element.offsetWidth;
    }

    set width(width) {
        DomHelper.setLength(this.element, 'width', width);

        // Invalidate the width, so it will be read from the DOM if a read is requested before the resize event
        this._width = null;

        // Setting width explicitly should reset flex, since it's not flexed anymore
        this._flex = null;
        this.element.style.flex = BrowserHelper.isIE11 ? '' : null;
    }

    /**
     * Get/set elements maxWidth. Getter returns max-width from elements style, which is always a string. Setter accepts
     * either a String or a Number (which will have 'px' appended). Note that like {@link #config-width},
     * _reading_ the value will return the numeric value in pixels.
     * @property {String|Number}
     * @category Layout
     */
    get maxWidth() {
        return DomHelper.measureSize(this.element.style.maxWidth, this.element);
    }

    set maxWidth(maxWidth) {
        DomHelper.setLength(this.element, 'maxWidth', maxWidth);
    }

    /**
     * Get/set elements minWidth. Getter returns min-width from elements style, which is always a string. Setter accepts
     * either a String or a Number (which will have 'px' appended). Note that like {@link #config-width},
     * _reading_ the value will return the numeric value in pixels.
     * @property {String|Number}
     * @category Layout
     */
    get minWidth() {
        return DomHelper.measureSize(this.element.style.minWidth, this.element);
    }

    set minWidth(minWidth) {
        DomHelper.setLength(this.element, 'minWidth', minWidth);
    }

    get flex() {
        return this._flex;
    }

    /**
     * Get element's flex property. This may be configured as a single number or a `<flex-grow> <flex-shrink> <flex-basis>` format string.
     * numeric-only values are interpreted as the `flex-grow` value.
     * @property {Number|String}
     * @category Layout
     */
    set flex(flex) {
        this._flex = flex;

        // Default grow to the same as flex and basis to 0.
        if (typeof flex === 'number' || (typeof flex === 'string' && flex.split(/\s/).length === 1)) {
            flex = `${flex} ${flex}`;
        }
        this.element.style.flex = flex;
        this.element.style.width = BrowserHelper.isIE11 ? '' : null;
    }

    /**
     * Get/set this widget's `align-self` flexbox setting. This may be set to modify
     * how this widget is aligned within the cross axis of a flexbox layout container.
     * @property {String}
     * @category Layout
     */
    get alignSelf() {
        return this._alignSelf;
    }

    set alignSelf(alignSelf) {
        this.element.style.alignSelf = alignSelf;
    }

    /**
     * Get element's margin property. This may be configured as a single number or a `TRBL` format string.
     * numeric-only values are interpreted as pixels.
     * @property {Number|String}
     * @category Layout
     */
    get margin() {
        return this._margin;
    }

    set margin(margin) {
        // Convert eg 1 to "1px 1px 1px 1px" or "0 8px" to "0px 8px 0px 8px"
        this.element.style.margin = this._margin = this.parseTRBL(margin).join(' ');
    }

    /**
     * Get element's offsetHeight or sets its style.height, or specified height if element no created yet.
     * @property {Number|String}
     * @category Layout
     */
    get height() {
        const me      = this,
            element = me.element;

        if (me.monitorResize) {
            // If the height is invalid, read it now.
            if (me._height == null) {
                me._height = element.offsetHeight;
            }

            // Usually this will be set in onInternalResize
            return me._height;
        }
        // No monitoring, we have to measure;
        return element.offsetHeight;
    }

    set height(height) {
        DomHelper.setLength(this.element, 'height', height);

        // Invalidate the height, so it will be read from the DOM if a read is requested before the resize event
        this._height = null;
    }

    /**
     * Get/set element's maxHeight. Getter returns max-height from elements style, which is always a string. Setter
     * accepts either a String or a Number (which will have 'px' appended). Note that like {@link #config-height},
     * _reading_ the value will return the numeric value in pixels.
     * @property {String|Number}
     * @category Layout
     */
    get maxHeight() {
        return DomHelper.measureSize(this.maxHeightElement.style.maxHeight, this.element);
    }

    set maxHeight(maxHeight) {
        const
            me          = this,
            { element } = me;

        DomHelper.setLength(me.maxHeightElement, 'maxHeight', maxHeight);

        // Flexbox does not handle overflow correctly when a vertically
        // flexed item is constrained by the maxHeight of its containing el.
        // So we have to propagate the maxHeight from the encapsulating element
        // onto the contentElement.
        if (BrowserHelper.isIE11 && me.contentElement !== element) {
            if (maxHeight == null) {
                ResizeMonitor.removeResizeListener(element, me.boundMaxHeightBugHandler);
            }
            else {
                ResizeMonitor.addResizeListener(element, me.boundMaxHeightBugHandler || (me.boundMaxHeightBugHandler = me.fixIEMaxHeightBug.bind(me)));
                if (document.body.contains(element)) {
                    me.fixIEMaxHeightBug();
                }
            }
        }
    }

    fixIEMaxHeightBug() {
        const { element, contentElement } = this;

        // If this widget is flexed vertically, the maxHeight of the encapsulating element must be
        // propapagated onto the contentElement.
        if (DomHelper.getStyleValue(element, 'flex-direction') === 'column') {
            // Release previous height constraint
            contentElement.style.maxHeight = '';

            let availableHeight = Rectangle.client(element).height;

            const
                siblings = element.childNodes,
                len      = siblings.length;

            // In case there are height-consuming siblings of the contentElement.
            // For example a header/footer. The heights of these must be subtracted.
            for (let i = 0; i < len; i++) {
                const sibling = siblings[i];
                if (sibling !== contentElement && !sibling.classList.contains('b-resize-monitors')) {
                    availableHeight -= sibling.offsetHeight;
                }
            }

            // Apply the adjusted height constraint to the contentElement
            this.contentElement.style.maxHeight = `${availableHeight}px`;
        }
    }

    /**
     * Get/set element's minHeight. Getter returns min-height from elements style, which is always a string. Setter
     * accepts either a String or a Number (which will have 'px' appended). Note that like {@link #config-height},
     * _reading_ the value will return the numeric value in pixels.
     * @property {String|Number}
     * @category Layout
     */
    get minHeight() {
        return DomHelper.measureSize(this.element.style.minHeight, this.element);
    }

    set minHeight(minHeight) {
        DomHelper.setLength(this.element, 'minHeight', minHeight);
    }

    /**
     * Get/set element's disabled state
     * @property {Boolean}
     * @category Misc
     */
    get disabled() {
        return this._disabled;
    }

    set disabled(disabled) {
        const
            el      = this.element,
            focusEl = this.focusElement;

        disabled && this.revertFocus();

        if (el) {
            el.classList[disabled ? 'add' : 'remove']('b-disabled');
            if (focusEl) {
                focusEl.disabled = disabled;
            }
        }
        this._disabled = disabled;
        this.onDisabled(disabled);
    }

    /**
     * Called when disabled state is changed.
     * Override in subclass that needs special handling when being disabled.
     * @param {Boolean} disabled current state
     * @private
     */
    onDisabled(disabled) {
    }

    /**
     * Disable the widget
     */
    disable() {
        this.disabled = true;
    }

    /**
     * Enable the widget
     */
    enable() {
        this.disabled = false;
    }

    get tooltip() {
        if (this._tooltip) {
            return this._tooltip;
        }
        else {
            const source = this.constructor.tooltip;

            // Return the Widget.tooltip singleton configured according to our element's dataset.
            source && source.trigger('pointerOver', { source, target : this.element });
            return source;
        }
    }

    //noinspection JSAnnotator
    /**
     * Get/set a tooltip on the widget. Accepts a string or tooltip config (specify true (or 'true') to use placeholder
     * as tooltip). When using a string it will configure the tooltip with `textContent: true` which enforces a default
     * max width.
     *
     * By default, this uses a singleton Tooltip instance which may be accessed from the
     * `{@link Core.widget.Widget Widget}` class under the name `Widget.tooltip`.
     * This is configured according to the config object on pointer over.
     *
     * To request a separate instance be created just for this widget, add `newInstance : true`
     * to the configuration.
     *
     * @property {String|Object}
     * @category Misc
     */
    set tooltip(config) {
        const me = this;

        if (me._tooltip) {
            me._tooltip.destroy();
            me._tooltip = null;
        }

        delete me.element.dataset.btip;

        if (config) {
            if (!(me.preventTooltipOnTouch && BrowserHelper.isTouchDevice)) {
                if (config.constructor.name !== 'Object') {
                    config = {
                        html        : (typeof config === 'string') ? config : me.placeholder,
                        textContent : true
                    };
                }

                // We have to explicitly request a new instance to avoid spam Tooltip instances
                if (config.newInstance) {
                    config.type = 'tooltip';

                    if (!config.forElement) config.forElement = me.element;
                    if (!('showOnHover' in config) && !config.forSelector) config.showOnHover = true;
                    if (!('autoClose' in config)) config.autoClose = true;

                    me._tooltip = WidgetHelper.createWidget(config);
                }
                // The default is that tooltip content and configs from tipConfig
                else {
                    me.element.dataset.btip = true;
                    me.tipConfig = config;
                }
            }
        }
    }

    /**
     * Determines visibility by checking if the Widget is hidden, or any ancestor is hidden and that it has an
     * element which is visible in the DOM
     * @property {Boolean}
     * @readonly
     */
    get isVisible() {
        const
            me          = this,
            { element } = me;

        // If we are hidden, or destroying, or any ancestors are hidden, we're not visible
        return Boolean(element && !me._hidden && !me.isDestroying && isInDocument(element) && (!me.requireSize || hasLayout(element)) && (!me.owner || me.owner.isVisible));
    }

    /**
     * Focuses this widget if it has a focusable element.
     */
    focus() {
        if (this.isFocusable) {
            DomHelper.focusWithoutScrolling(this.focusElement);
        }
    }

    /**
     * Get this widget's primary focus holding element if this widget is itself focusable, or contains focusable widgets.
     * @property {HTMLElement}
     * @readonly
     * @category DOM
     */
    get focusElement() {
        // Override in widgets which are focusable.
    }

    get isFocusable() {
        const focusElement = this.focusElement;

        // We are only focusable if the focusEl is deeply visible, that means
        // it must have layout - an offsetParent. Body does not have offsetParent.
        return focusElement && this.isVisible && !this.disabled && (focusElement === document.body || focusElement.offsetParent);
    }

    /**
     * Shows this widget
     * @category Visibility
     * @async
     * @returns {Promise} A promise which is resolved when the widget is shown
     */
    show() {
        return new Promise(resolve => {
            const
                me        = this,
                {
                    showAnimation,
                    element
                }         = me,
                floatRoot = Widget.floatRoot,
                style     = element.style;

            let styleProp, animProps;

            /**
             * Triggered before a widget is shown. Return `false` to prevent the action.
             * @event beforeShow
             * @param {Core.widget.Widget} source The widget being shown.
             */
            if (!me.isVisible && me.trigger('beforeShow') !== false) {
                // Cancel any current hide/show animation
                me.cancelHideShowAnimation();

                if (showAnimation) {
                    // setting transitions initial value before showing, to ensure transition will animate
                    styleProp = Object.keys(showAnimation)[0];
                    animProps = showAnimation[styleProp];

                    me.currentAnimation = {
                        styleProp,
                        resolve
                    };

                    me.isAnimating = true;
                    element.addEventListener('transitionend', me.afterHideShowAnimate);

                    // setting transitions initial value before showing, to ensure transition will animate
                    style[styleProp] = animProps.from;
                }

                if (me.floating) {
                    if (!floatRoot.contains(element)) {
                        // Replace this Widget's DOM into the container if it's already rendered
                        if (me.rendered) {
                            floatRoot.appendChild(me.element);
                        }
                        else {
                            // Pass triggerPaint as false. The calls will not propagate
                            // anyway since we are still hidden.
                            me.render(floatRoot, false);
                        }
                    }
                }

                me._hidden = false;

                element.classList.remove('b-hidden');

                if (showAnimation) {
                    style.transition = `${styleProp} ${animProps.duration} ease ${animProps.delay}`;
                    me.requestAnimationFrame(() => {
                        style[styleProp] = animProps.to;
                    });
                }

                me.afterShow(!showAnimation && resolve);

                // Note: popups can be dismissed in the process of focusin/out if an editor has invalidAction='block',
                // so we may be hidden at this point...

                // If we're not being called from showBy, do default aligning
                if (!me.inShowBy && me.floating && me.forElement && !me.hidden) {
                    me.alignTo(me.forElement);
                }
            }
            else {
                resolve();
            }
        });
    }

    /**
     * Show aligned to another target element or {@link Core.widget.Widget} or {@link Core.helper.util.Rectangle}
     * @param {Object|HTMLElement} spec Alignment specification, or the element to align to using the configured
     * {@link #config-align}.
     * @param {HTMLElement|Core.widget.Widget|Core.helper.util.Rectangle} spec.target The Widget or Element or Rectangle to align to.
     * @param {Boolean} [spec.anchor] True to show a pointer arrow connecting to the target. Defaults to false.
     * @param {Boolean} [spec.overlap] True to allow this to overlap the target.
     * @param {String} spec.align The alignment specification string, `[trbl]n-[trbl]n`. Defaults to this instance's
     * {@link #config-align} setting.
     * @param {HTMLElement|Core.widget.Widget|Core.helper.util.Rectangle} [spec.constrainTo] The Widget or Element or Rectangle to constrain to.
     * If the requested alignment cannot be constrained (it will first shrink the resulting Rectangle according
     * to the `minWidth` and `minHeight` properties of this spec, or the Widget), then it will try aligning at other edges
     * (honouring the `axisLock` option), and pick the fallback alignment which results in the shortest translation.
     * @param {Number} [spec.minHeight] The minimum height this widget may be compressed to when constraining within the `constrainTo` option.
     * @param {Number} [spec.minWidth] The minimum width this widget may be compressed to when constraining within the `constrainTo` option.
     * @param {Boolean} [spec.axisLock] Specify as `true` to fall back to aligning against the opposite
     * edge if the requested alignment cannot be constrained into the `constrainTo` option. Specify as
     * `'flexible'` to allow continuation to try the other edges if a solution cannot be found on the origially requested axis.
     * @param {Boolean} [spec.matchSize] *Only honoured when `axisLock` is enabled and alignment succeeds on the requested axis.
     * Specify as `true` to have this widget's size along the aligned edge match the size of the target's edge.
     * For example, a combobox's dropdown should match the width of the combobox.
     * @param {Number|Number[]} [spec.offset] The offset to create an extra margin round the target
     * to offset the aligned widget further from the target. May be configured as -ve to move the aligned widget
     * towards the target - for example producing the effect of the anchor pointer piercing the target.
     * @category Float & align
     * @async
     * @returns {Promise} A promise which is resolved when the widget is shown
     */
    showBy(spec) {
        
        const me = this;

        // Prevent show from rerouting here.
        me.inShowBy = true;
        const result = me.show();
        me.inShowBy = false;

        if (me.isVisible) {
            me.alignTo(spec);
        }

        return result;
    }

    /**
     * Show this widget anchored to a coordinate
     * @param {Number|Number[]} x The x position (or an array with [x,y] values) to show by
     * @param {Number} [y] The y position to show by
     * @param {Object} [options] See {@link #function-showBy} for reference
     * @category Float & align
     * @async
     * @returns {Promise} A promise which is resolved when the widget is shown
     */
    showByPoint(x, y, options) {
        const xy = arguments.length === 1 ? x : [x, y];

        return this.showBy(Object.assign({
            target : new Rectangle(xy[0], xy[1], 1, 1),
            align  : 't-b'
        }, options));
    }

    afterShow(resolveFn) {
        // This method is injected when maxHeight is set on IE11.
        // Flexbox does not handle overflow correctly when a vertically
        // flexed item is constrained by the maxHeight of its containing el.
        // So we have to propagate the maxHeight from the encapsulating element
        // onto the contentElement.
        if (this.boundMaxHeightBugHandler) {
            this.boundMaxHeightBugHandler();
        }
        this.trigger('show');
        this.triggerPaint();
        resolveFn && resolveFn();
    }

    triggerPaint() {
        const
            me          = this,
            { element } = me,
            firstPaint  = !me.isPainted;

        if (me.isVisible) {
            if (firstPaint) {
                // Not for public use, only used in docs
                if (me.scaleToFitWidth) {
                    me.onParentElementResize = me.onParentElementResize.bind(me);
                    ResizeMonitor.addResizeListener(element.parentElement, me.onParentElementResize);

                    if (me.isVisible) {
                        me.updateScale();
                    }
                }
                // Mutually exclusive with scaleToFitWidth.
                // Observe container element before the cascade down to descendnts.
                // Outer elements are expected to fore resize first.
                else if (me.monitorResize) {
                    me.onElementResize = me.onElementResize.bind(me);
                    ResizeMonitor.addResizeListener(element, me.onElementResize);
                }
            }

            if (me.eachWidget) {
                // Trigger paint only on immediate children.
                // Each one will call this recursively.
                // paint is triggered in a bottom up manner.
                me.eachWidget(widgetTriggerPaint, false);
            }
            /**
             * Triggered when a widget which had been in a non-visible state for any reason
             * achieves visibility.
             *
             * A non-visible state *might* mean the widget is hidden and has just been shown.
             *
             * But this event will also fire on widgets when a non-visible (unrendered, or hidden)
             * ancestor achieves visibility, for example a {@link Core.widget.Popup Popup} being shown.
             * @event paint
             * @param {Core.widget.Widget} source The widget being painted.
             * @param {Boolean} firstPaint `true` if this is the first paint.
             */
            me.trigger('paint', { firstPaint });

            if (firstPaint) {
                // On first paint, we should announce our size immediately.
                // When the real event comes along, onElementResize will reject it because the size will be the same.
                if (me.monitorResize && !me.scaleToFitWidth) {
                    ResizeMonitor.onElementResize([{ target : me.element }]);
                }
            }
            me.isPainted = true;
        }
    }

    cancelHideShowAnimation() {
        const
            me      = this,
            element = me.element,
            style   = element.style;

        if (me.currentAnimation) {
            me.isAnimating = false;
            element.classList.remove('b-hiding');
            element.removeEventListener('transitionend', me.afterHideShowAnimate);
            style.transition = style[me.currentAnimation.styleProp] = '';
            me.currentAnimation = null;
        }
    }

    afterHideShowAnimate(event) {
        // If menu is destroyed too soon in Edge, this method will be invoked for destroyed element
        if (this.isDestroyed) {
            return;
        }

        const
            me      = this,
            element = me.element,
            style   = element.style,
            {
                styleProp,
                resolve
            }       = me.currentAnimation;

        if (event.target === element && event.propertyName === styleProp) {
            element.classList.remove('b-hiding');
            me.isAnimating = false;
            me.currentAnimation = null;
            element.removeEventListener('transitionend', me.afterHideShowAnimate);

            style.transition = style[styleProp] = '';

            // Element must be fully hidden after the animation effect finishes
            if (me._hidden) {
                me.afterHideAnimation();
            }
            resolve();
        }
    }

    /**
     * Hide widget
     * @param {Boolean} animate Pass `true` (default) to animate the hide action
     * @category Visibility
     * @returns {Promise} A promise which is resolved when the widget has been hidden
     */
    hide(animate = true) {
        return new Promise(resolve => {
            const me            = this,
                element       = me.element,
                style         = element.style,
                hideAnimation = animate && me.hideAnimation;

            // replaced check for isVisible with _hidden, need to hide a component not yet in view in EventEditor
            if (!me._hidden && me.trigger('beforeHide') !== false) {
                me._hidden = true;

                if (!element) return;

                me.revertFocus();

                // Focus exit causes close if autoClose: true, and if closeAction: 'hide'
                // that might destroy us, so exit now if that happens.
                if (me.isDestroyed) {
                    resolve();
                    return;
                }

                // Cancel any current hide/show animation
                me.cancelHideShowAnimation();

                if (hideAnimation) {
                    const styleProp = Object.keys(hideAnimation)[0],
                        animProps = hideAnimation[styleProp];

                    // Make sure we are not already at the final value of the hide animation (i.e. calling hide() directly after show())
                    if (Number(getComputedStyle(me.element)[styleProp]) !== animProps.to) {
                        me.currentAnimation = {
                            styleProp,
                            resolve
                        };

                        // Element must behave as though it were not there during
                        // the animated hide. This means pointer-events:none
                        element.classList.add('b-hiding');
                        me.isAnimating = true;
                        element.addEventListener('transitionend', me.afterHideShowAnimate);

                        style[styleProp] = animProps.from;
                        style.transition = `${styleProp} ${animProps.duration} ease ${animProps.delay}`;
                        me.requestAnimationFrame(() => {
                            style[styleProp] = animProps.to;
                        });
                    }
                    else {
                        element.classList.add('b-hidden');
                    }
                }
                else {
                    element.classList.add('b-hidden');
                }

                // only supply resolve function if not using animation
                me.afterHide(!hideAnimation && resolve);
            }
        });
    }

    doHideOrRealign(event) {
        const
            me       = this,
            {
                anchoredTo,
                lastAlignSpec
            }        = me,
            target   = lastAlignSpec && lastAlignSpec.target,
            activeEl = document.activeElement,
            [x, y]   = me.getXY();

        // Scroll is inside this widget, no action
        if (me.element.contains(event.target)) {
            return;
        }

        // If it's a synthesized scroll event (such as from our ResizeMonitor polyfill), ignore it
        // If we're scrolling because a focused textual input field which we contain is being shifted into view,
        // we must not reposition - we'll just move with the document content.
        if (!event.isTrusted || (event.target.nodeType === 9 && me.element.contains(activeEl) && textInputTypes[activeEl] && window.innerHeight < document.body.offsetHeight)) {
            return;
        }

        // Perform the realignment. If the scroll did not in fact cause us to become unaligned, then we don't have to hide.
        me.realign(event.target);

        // Might destroy on hide in realign, so check for isdestroyed.
        if (!me.isDestroyed && me.scrollAction === 'hide') {
            const
                [newX, newY] = me.getXY(),
                moved        = newX !== x || newY !== y;

            // If the scroll caused our position to become invalid, and we either don't know what element
            // we're anchored to (or not anchored to one at all), or the element we're anchored to has been
            // affected by the scroll, we must hide.
            if ((moved || target instanceof Point) && (!anchoredTo || DomHelper.isDescendant(event.target, anchoredTo))) {
                me.hide();
            }
        }
    }

    afterHide(resolveFn = null) {
        const
            me                = this,
            { lastAlignSpec } = me;

        // The flag must be cleared on a normal hide.
        // It's set after the hide() call in alignTo
        // if the target is outside our clippedTo region.
        if (lastAlignSpec) {
            lastAlignSpec.targetHidden = null;
        }

        // Remove listeners which are only added during the visible phase.
        // In its own method because it's called on hide and destroy.
        me.removeTransientListeners();

        // Postprocessing to be done after the hideAnimation finishes.
        // If there's no animation, we call it immediately.
        // We set the element to be hidden here, after any animation completes.
        // We also remove floating Widgets from the DOM when they are hidden.
        if (!me.hideAnimation) {
            me.afterHideAnimation();
        }

        me.trigger('hide');
        resolveFn && resolveFn();
    }

    removeTransientListeners() {
        const me = this;

        if (me.documentScrollListener) {
            document.removeEventListener('scroll', me.doHideOrRealign, true);
            me.documentScrollListener = false;
        }

        if (me.constrainListeners) {
            ResizeMonitor.removeResizeListener(me.lastAlignSpec.constrainTo, me.callRealign);
            me.constrainMutationMonitor && me.constrainMutationMonitor.disconnect();
            me.constrainListeners = false;
        }
    }

    afterHideAnimation() {
        const
            me          = this,
            { element } = me;

        if (me.floating && Widget.floatRoot.contains(element)) {
            element.remove();
        }
        else {
            element.classList.add('b-hidden');
        }
    }

    /**
     * Show or hide widget. Deprecated in 2.2.3, please use {@link #property-hidden} instead
     * @type {Boolean}
     * @category Visibility
     * @deprecated 2.2.3
     */
    set visible(show) {
        this.hidden = !show;
    }

    /**
     * Hide or show widget
     * @type {Boolean}
     * @category Visibility
     */
    set hidden(hide) {
        if (this.isConfiguring) {
            this._hidden = hide;
            this.element.classList[hide ? 'add' : 'remove']('b-hidden');
        }
        else {
            if (hide) {
                this.hide();
            }
            else {
                this.show();
            }
        }
    }

    get hidden() {
        return Boolean(this._hidden);
    }

    /**
     * Get id assigned by user (not generated id)
     * @returns {String}
     * @readonly
     * @private
     * @category Misc
     */
    get assignedId() {
        return this.hasGeneratedId ? null : this.id;
    }

    /**
     * Get the owning Widget of this Widget. If this Widget is directly contained, then the containing
     * Widget is returned. If this Widget is floating, the configured `owner` property is returned.
     * If there is a `forElement`, that element's encapsulating Widget is returned.
     * @property {Core.widget.Widget}
     * @category Misc
     */
    get owner() {
        return this.parent || this._owner || (this._element && IdHelper.fromElement(this.forElement || this.element.parentNode));
    }

    set owner(owner) {
        this._owner = owner;
    }

    /**
     * Get this Widget's previous sibling in the parent {@@link Core.widget.Container Container}, or, if not
     * in a Container, the previous sibling widget in the same _parentElement_.
     * @property {Core.widget.Widget}
     * @readonly
     * @category Misc
     */
    get previousSibling() {
        return this.getSibling(-1);
    }

    /**
     * Get this Widget's next sibling in the parent {@@link Core.widget.Container Container}, or, if not
     * in a Container, the next sibling widget in the same _parentElement_.
     * @property {Core.widget.Widget}
     * @readonly
     * @category Misc
     */
    get nextSibling() {
        return this.getSibling(1);
    }

    getSibling(increment) {
        const
            me         = this,
            { parent } = me,
            siblings   = parent ? parent.childItems : Array.from(me.element.parentElement.querySelectorAll('.b-widget'));

        return parent ? siblings[siblings.indexOf(me) + increment] : IdHelper.fromElement(siblings[siblings.indexOf(me.element) + increment]);
    }

    /**
     * Looks up the {@link #property-owner} axis to find an ancestor which matches the passed selector.
     * The selector may be a widget type identifier, such as `'grid'`, or a function which will return
     * `true` when passed the desired ancestore.
     * @param {String|Function} selector A Type identifier or selection function.
     * @param {Boolean} [deep] When using a string identifier, pass `true` if all superclasses should be included, ie if a `Grid` should match `'widget'`.
     * @param {Number|String|Core.widget.Widget} [limit] how many steps to step up before aborting the search, or a selector to stop at or the topmost ancestor to consider.
     */
    up(selector, deep, limit) {
        const
            limitType     = typeof limit,
            numericLimit  = limitType === 'number',
            selectorLimit = limitType === 'string';

        for (let result = this.owner, steps = 1; result; result = result.owner, steps++) {
            if (widgetMatches(result, selector, deep)) {
                return result;
            }
            if (numericLimit && steps >= limit) {
                return;
            }
            else if (selectorLimit && (widgetMatches(result, limit, deep))) {
                return;
            }
            else if (result === limit) {
                return;
            }
        }
    }

    /**
     * Returns `true` if this Widget owns the passed Element, Event or Widget. This is based on the
     * widget hierarchy, not DOM containment. So an element in a `Combo`'s dropdown list
     * will be owned by the `Combo`.
     * @param {HTMLElement|Event|Core.widget.Widget} target The element event or Widget to test for being
     * within the ownership tree of this Widget.
     */
    owns(target) {
        if (target) {
            // Passed an event, grab its target
            if (target.eventPhase) {
                target = target.target;
            }

            // We were passed an HtmlElement
            if (target.nodeType === 1) {
                if (this.element.contains(target)) {
                    return true;
                }
                target = IdHelper.fromElement(target);
            }

            

            while (target) {
                if (target === this) {
                    return true;
                }
                target = target.owner;
            }
        }
        return false;
    }

    onFocusIn(e) {
        const
            me          = this,
            { element } = me;

        me.containsFocus = true;
        me.focusInEvent = e;
        element.classList.add('b-contains-focus');

        if (element.contains(e.target) && me.onInternalKeyDown && !me.keyDownListenerRemover) {
            me.keyDownListenerRemover = EventHelper.on({
                element,
                keydown : 'onInternalKeyDown',
                thisObj : me
            });
        }

        /**
         * Fired when focus enters this Widget.
         * @event focusin
         * @param {Core.widget.Widget} source - This Widget
         * @param {HTMLElement} fromElement The element which lost focus.
         * @param {HTMLElement} toElement The element which gained focus.
         * @param {Core.widget.Widget} fromWidget The widget which lost focus.
         * @param {Core.widget.Widget} toWidget The widget which gained focus.
         * @param {Boolean} backwards `true` if the `toElement` is before the `fromElement` in document order.
         */
        me.trigger('focusin', e);
    }

    onFocusOut(e) {
        const me = this;

        if (me.keyDownListenerRemover) {
            me.keyDownListenerRemover();
            me.keyDownListenerRemover = null;
        }

        if (!me.isDestroyed) {
            // Focus to nowhere, focus a close relation
            if (!e.relatedTarget) {
                me.revertFocus(true);
            }

            me.containsFocus = false;
            me.element.classList.remove('b-contains-focus');

            /**
             * Fired when focus exits this Widget's ownership tree. This is different from a `blur` event.
             * focus moving from within this Widget's ownership tree, even if there are floating widgets
             * will not trigger this event. This is when focus exits this widget completely.
             * @event focusout
             * @param {Core.widget.Widget} source - This Widget
             * @param {HTMLElement} fromElement The element which lost focus.
             * @param {HTMLElement} toElement The element which gained focus.
             * @param {Core.widget.Widget} fromWidget The widget which lost focus.
             * @param {Core.widget.Widget} toWidget The widget which gained focus.
             * @param {Boolean} backwards `true` if the `toElement` is before the `fromElement` in document order.
             */
            me.trigger('focusout', e);
        }
    }

    /**
     * If this Widget contains focus, focus is reverted to the source from which it entered if possible,
     * or to a close relative if not.
     * @param {Boolean} force Pass as `true` to move focus to the previously focused item, or the
     * closest possible relatve even if this widget does not contain focus.
     */
    revertFocus(force) {
        let target = this.focusInEvent && this.focusInEvent.relatedTarget;

        if (force || (this.containsFocus && target && target.nodeType === 1 && this.element.contains(document.activeElement))) {
            if (!target || !DomHelper.isFocusable(target)) {
                target = this.getFocusRevertTarget();
            }
            if (target && DomHelper.isFocusable(target)) {
                DomHelper.focusWithoutScrolling(target);
            }
        }
    }

    /**
     * This method finds a close sibling (or parent, or parent's sibling etc recursively) to which focus
     * can be directed in the case of revertFocus not having a focusable element from our focusInEvent.
     *
     * This can hapen when the "from" component is destroyed or hidden. We should endeavour to prevent
     * focus escaping to `document.body` for accessibility and ease of use, and keep focus close.
     * @internal
     */
    getFocusRevertTarget() {
        const
            me              = this,
            {
                owner,
                focusInEvent
            }               = me,
            searchDirection = focusInEvent ? (focusInEvent.backwards ? 1 : -1) : -1;

        let target        = focusInEvent && focusInEvent.relatedTarget;
        const toComponent = target && IdHelper.fromElement(target);

        // If the from element is now not focusable, for example an Editor which hid
        // itself on focus leave, then we have to find a sibling/parent/parent's sibling
        // to take focus. Anything is better than flipping to document.body.
        if (owner && !owner.isDestroyed && (!target || !DomHelper.isFocusable(target) || (toComponent && !toComponent.isFocusable))) {
            target = null;

            // If this widget can have siblings, then find the closest
            // (in the direction focus arrived from) focusable sibling.
            if (owner.eachWidget) {
                const siblings = [];

                // Collect focusable siblings.
                // With this included so we can find ourselves.
                owner.eachWidget(w => {
                    if (w === me || w.isFocusable) {
                        siblings.push(w);
                    }
                }, false);

                if (siblings.length > 1) {
                    const myIndex = siblings.indexOf(me);

                    target = siblings[myIndex + searchDirection] ||
                        siblings[myIndex - searchDirection];
                }
            }

            // No focusable siblings found to take focus, try the owner
            if (!target && owner.isFocusable) {
                target = owner;
            }

            // If non of the above found any related focusable widget,
            // Go through these steps for the owner.
            target = target ? target.focusElement : owner.getFocusRevertTarget();
        }

        return target;
    }

    /**
     * Used by the Widget class internally to create CSS classes based on this Widget's
     * inheritance chain to allow styling from each level to apply.
     *
     * For example Combo would yield `"["b-widget", "b-field", "b-textfield", "b-pickerfield", "b-combo"]"`
     *
     * May be implemented in subclasses to add or remove classes from the super.widgetClassList
     * @returns {String[]} The css class list named using the class name.
     * @internal
     * @category DOM
     */
    get widgetClassList() {
        const me = this;

        const
            myCls  = me.cls,
            result = me.classHierarchy(Widget).reduce((target, cls) => {
                const widgetClassProperty = Reflect.getOwnPropertyDescriptor(cls.prototype, 'widgetClass');

                let widgetClass;

                // If the Class has its own get widgetClass, call it upon this instance.
                if (widgetClassProperty && widgetClassProperty.get) {
                    widgetClass = widgetClassProperty.get.call(me);
                }
                else {
                    // All built in widgets should define $name to be safer from minifcation/obfuscation, but user
                    // created might not so fall back to actual name. UMD files use a _$name property
                    // which the Base $name getter uses as a fallback.
                    const name = (Object.prototype.hasOwnProperty.call(cls, '$name') || Object.prototype.hasOwnProperty.call(cls, '_$name')) ? cls.$name : cls.name;

                    // Throw error in case of an obfuscated name or an autogenerated name.
                    // These should never be released without a meaningful $name getter.
                    if (name.length < 3 || name.includes('$')) {
                        console.warn(`Widget class ${name} with no $name getter found`);
                    }

                    widgetClass = `b-${name.toLowerCase()}`;
                }

                if (widgetClass) {
                    // The result is used as a DOM classList. Must not contain spaces.
                    target.push(...widgetClass.split(' '));
                }
                return target;
            }, myCls ? myCls.split(' ') : []);

        if (me.floating) {
            result.push('b-floating');
        }
        if (BrowserHelper.isTouchDevice) {
            result.push('b-touch');
        }

        return result;
    }

    //endregion

    //region Cache

    /**
     * Gets dom elements in the view. Caches the results for faster future calls.
     * @param {String} query CSS selector
     * @param {Boolean} children true to fetch multiple elements
     * @param {HTMLElement} element Element to use as root for the query, defaults to the views outermost element
     * @returns {HTMLElement|HTMLElement[]|null} A single element or an array of elements (if parameter children is set to true)
     * @internal
     * @category DOM
     */
    fromCache(query, children = false, element = this.element) {
        if (!element) return null;

        const me = this;

        if (!me.cache[query]) {
            me.cache[query] = children ? DomHelper.children(element, query) : DomHelper.down(element, query);
        }
        return me.cache[query];
    }

    /**
     * Clear caches, forces all calls to fromCache to requery dom. Called on render/rerender.
     * @internal
     * @category DOM
     */
    emptyCache() {
        this.cache = {};
    }

    //endregion

    //region Mask

    /**
     * Mask the widget, showing the specified message
     * @param {String|Object} msg Mask message (or a {@link Core.widget.Mask} config object
     * @returns {Core.widget.Mask}
     */
    mask(msg) {
        const me = this;

        if (me.maskInstance) {
            me.maskInstance.destroy();
        }

        if (typeof msg === 'string') {
            return me.maskInstance = WidgetHelper.mask(me.element, msg);
        }

        msg.element = me.element;

        return me.maskInstance = WidgetHelper.mask(msg);
    }

    /**
     * Unmask the widget
     */
    unmask() {
        if (this.maskInstance) {
            WidgetHelper.unmask(this.element);
            this.maskInstance = null;
        }
    }

    //endregion

    //region Monitor resize

    onInternalResize(element, width, height, oldWidth, oldHeight) {
        this._width = element.offsetWidth;
        this._height = element.offsetHeight;
    }

    onElementResize(resizedElement) {
        const me        = this,
            element   = me.element,
            oldWidth  = me._width,
            oldHeight = me._height,
            newWidth  = element.offsetWidth,
            newHeight = element.offsetHeight;

        if (!me.suspendResizeMonitor && (oldWidth !== newWidth || oldHeight !== newHeight)) {
            me.onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight);
            /**
             * Fired when the encapsulating element of a Widget resizes *only when {@link #config-monitorResize} is `true`*.
             * @event resize
             * @param {Core.widget.Widget} source - This Widget
             * @param {Number} width The new width
             * @param {Number} height The new height
             * @param {Number} oldWidth The old width
             * @param {Number} oldHeight The old height
             */
            me.trigger('resize', { width : newWidth, height : newHeight, oldWidth, oldHeight });
        }
    }

    updateScale() {
        const me            = this,
            element       = me.element,
            parentElement = element.parentElement;

        // this could be placed elsewhere but want to keep it contained to not spam other code,
        // since this is a very specific usecase in our docs
        if (!me.configuredWidth) {
            me.configuredWidth = me.width;
        }

        // TODO: handle autoHeight, but seems it assigns height to late with current setup

        if (!me.parentHeight) {
            me.parentHeight = parentElement.offsetHeight;
        }

        // We are scaling to fit inside the width, so ensure that we are not the cause of a scrollbar
        // in our current, unscaled state by hiding while we measure the parent's offsetWidth which
        // we are going to scale to.
        element.style.display = 'none';

        const scale         = parentElement.offsetWidth / me.configuredWidth,
            adjustedScale = me.allowGrowWidth ? Math.min(scale, 1) : scale;

        element.style.transform = `scale(${adjustedScale})`;
        element.style.transformOrigin = 'top left';
        element.style.display = '';

        parentElement.style.height = (me.parentHeight * adjustedScale) + 'px';

        if (me.allowGrowWidth && scale > 1) {
            // increase width
            me.width = me.configuredWidth * scale;
        }
    }

    onParentElementResize(event) {
        this.updateScale();
    }

    //endregion

    /**
     * Returns a `TRBL` array of values parse from the passed specification. This can be used to parse`
     * a value list for `margin` or `padding` or `border-width` etc - any CSS value which takes a `TRBL` value.
     * @param {Number|String|String[]} values The `TRBL` value
     * @param {String} [units=px] The units to add to values which are specified as numeric.
     */
    parseTRBL(values, units = 'px') {
        values = values || 0;

        if (typeof values === 'number') {
            return [`${values}${units}`, `${values}${units}`, `${values}${units}`, `${values}${units}`];
        }
        

        const
            parts = values.split(' '),
            len   = parts.length;

        if (len === 1) {
            parts[1] = parts[2] = parts[3] = parts[0];
        }
        else if (len === 2) {
            parts[2] = parts[0];
            parts[3] = parts[1];
        }
        else if (len === 3) {
            parts[3] = parts[1];
        }

        return [
            isFinite(parts[0]) ? `${parts[0]}${units}` : parts[0],
            isFinite(parts[1]) ? `${parts[1]}${units}` : parts[2],
            isFinite(parts[2]) ? `${parts[2]}${units}` : parts[3],
            isFinite(parts[3]) ? `${parts[3]}${units}` : parts[4]
        ];
    }

    static get floatRoot() {
        const me = this;
        if (!me._floatRoot) {
            // Reuse any existing floatRoot. There might be one if using multiple product bundles
            me._floatRoot = document.querySelector('.b-float-root');
        }

        if (!me._floatRoot) {
            me._floatRoot = DomHelper.createElement({
                className : 'b-float-root',
                parent    : document.body
            });

            // Make float root immune to keyboard-caused size changes
            if (BrowserHelper.isAndroid) {
                me._floatRoot.style.height = `${screen.height}px`;
                EventHelper.on({
                    element           : window,
                    orientationchange : () => me._floatRoot.style.height = `${screen.height}px`
                });
            }
        }
        else if (!document.body.contains(me._floatRoot)) {
            // Reattach floatRoot if it was detached
            document.body.appendChild(me._floatRoot);
        }

        return me._floatRoot;
    }

    get isAnimating() {
        return this._animating;
    }

    set isAnimating(value) {
        const me = this;

        if (me.isPainted && value !== me.isAnimating) {
            me.element.classList[value ? 'add' : 'remove']('b-animating');
            me._animating = value;
        }
    }
}

Widget._$name = 'Widget'; BryntumWidgetAdapterRegister.register('widget', Widget);

let globaltouchStart,
    focusEventsSuspended = false,
    GlobalEvents = (window.bryntum || (window.bryntum = {})).GlobalEvents = new (class extends Events(Base) {
        suspendFocusEvents() {
            focusEventsSuspended = true;
        }
        resumeFocusEvents() {
            focusEventsSuspended = false;
        }
        get lastInteractionType() {
            return lastInteractionType;
        }
    })(),
    lastInteractionType,
    isTopVisibleModal = w => w.isVisible && w.isTopModal;

function createWidgetEvent(eventName, target, relatedTarget, fromWidget, toWidget, backwards, options) {
    const result = new CustomEvent(eventName, options);

    Object.defineProperty(result, 'target', {
        get() {
            return target;
        }
    });
    Object.defineProperty(result, 'relatedTarget', {
        get() {
            return relatedTarget;
        }
    });
    result.fromWidget = fromWidget;
    result.toWidget = toWidget;
    result.backwards = backwards;

    return result;
}

function getCommonAncestor(from, to) {
    if (from === to) {
        return from;
    }
    const isWidget = from instanceof Widget;

    while (from && !(from[isWidget ? 'owns' : 'contains'](to) || from === to)) {
        from = from[isWidget ? 'owner' : 'parentNode'];
    }
    return from;
}

const listeners = {
    element : document,
    touchstart(touchstart) {
        if (!globaltouchStart && touchstart.changedTouches.length === 1) {
            globaltouchStart = touchstart.changedTouches[0];
        }
        else {
            globaltouchStart = null;
        }
    },
    // Just this one has to be passive: false so that we are allowed to preventDefault
    // if we are part of a contextmenu longpres emulation. Otherwise the gesture will
    // proceed to cause a mousedown event.
    touchend : {
        handler : event => {
            if (globaltouchStart) {
                // If the touchstart was used to synthesize a contextmenu event
                // stop the touch gesture processing right now.
                // Also prevent the conversion of the touch into  click.
                if (globaltouchStart.identifier === EventHelper.contextMenuTouchId) {
                    event.stopImmediatePropagation();
                    event.preventDefault();
                }
                else if (event.changedTouches.length === 1 && event.changedTouches[0].identifier === globaltouchStart.identifier) {
                    GlobalEvents.trigger('globaltap', { event });
                }
                globaltouchStart = null;
            }
        },
        passive : false
    },
    mousedown : {
        handler : event => {
            lastInteractionType = 'mouse';
            if (!globaltouchStart) {
                GlobalEvents.trigger('globaltap', { event });
            }
        },
        passive : false
    },
    keydown() {
        lastInteractionType = 'key';
    },
    keypress() {
        lastInteractionType = 'key';
    },
    focusin(focusin) {
        // https://app.assembla.com/spaces/bryntum/tickets/5503
        // Caused by the browser scrolling a focused element into view. The browser will do *whatever it takes*
        // to scroll a focused element so that as much of it is in view as possible. Its first point of scrolling will
        // be the float containing element. That must never scroll.
        Widget.floatRoot.scrollTop = Widget.floatRoot.scrollLeft = 0;

        if (focusEventsSuspended) {
            return;
        }

        const
            fromElement = !focusin.relatedTarget
                ? null
                : (focusin.relatedTarget instanceof HTMLElement ? focusin.relatedTarget : document.body),
            toElement = focusin.target || document.body,
            fromWidget = IdHelper.fromElement(fromElement),
            toWidget = IdHelper.fromElement(toElement),
            commonAncestor = getCommonAncestor(fromWidget, toWidget),
            // Flag if the fromElement is DOCUMENT_POSITION_FOLLOWING toElement
            backwards = !!(fromElement && (toElement.compareDocumentPosition(fromElement) & 4)),
            topVisibleModal = IdHelper.query(isTopVisibleModal),
            currentFocus = document.activeElement;

        // If there is a topmost modal, and the focus is moving to somewhere *not* a descendant of that
        // modal then we enforce modality and sweep focus back into the modal. By default the Container
        // class will yield the first focusable descendant widget's focusEl as its focusEl, so
        // that will be out of the box behaviour for Popups.
        if (topVisibleModal && (!toWidget || !topVisibleModal.owns(toWidget))) {
            topVisibleModal.focus();
            return;
        }

        let event = createWidgetEvent('focusout', fromElement, focusin.target, fromWidget, toWidget, backwards);

        // Bubble focusout event up the "from" side of the tree
        for (let target = fromWidget; target && target !== commonAncestor; target = target.owner) {
            if (!(target.isDestroyed || target.isDestroying) && target.onFocusOut) {
                target.onFocusOut(event);

                // It is possible for focusout handlers to refocus themselves (editor's invalidAction='block'), so
                // check if the focus is still where it was when we started:
                if (currentFocus !== document.activeElement) {
                    // If the focus has moved, that movement would have kicked off a nested sequence of focusin/out
                    // notifications, so everyone has already been notified... no more to do here.
                    return;
                }
            }
        }

        // Focus is moving upwards to the ancestor widget.
        // Its focus method might delegate focus to a focusable descendant.
        if (commonAncestor && focusin.target === commonAncestor.element) {
            // If one of the handlers above has not moved focus onwards
            // and the common ancestor is a container which delegates
            // focus inwards to a descendant, then give it the opportunity to do that.
            if (document.activeElement === toElement && commonAncestor.focusElement && commonAncestor.focusElement !== commonAncestor.element) {
                // Wait until out of the focusin handler to move focus on.
                commonAncestor.setTimeout(() => commonAncestor.focus && commonAncestor.focus(), 0);
            }
        }
        // Focus is moving between two branches of a subtree.
        // Bubble focusin event up the "to" side of the tree
        else {
            event = createWidgetEvent('focusin', toElement, fromElement, fromWidget, toWidget, backwards);
            for (let target = toWidget; target && target !== commonAncestor; target = target.owner) {
                if (!(target.isDestroyed || target.isDestroying)) {
                    target.onFocusIn && target.onFocusIn(event);
                }
            }
        }
        // Fire element focusmove event. Grid navigation will use  this when cells are focusable.
        const commonAncestorEl = getCommonAncestor(fromElement && fromElement.nodeType === 1 ? fromElement : null, toElement) || toElement.parentNode;
        event = createWidgetEvent('focusmove', toElement, fromElement, fromWidget, toWidget, backwards, { bubbles : true });
        commonAncestorEl.dispatchEvent(event);
    },
    focusout(focusout) {
        if (focusEventsSuspended) {
            return;
        }

        if (!focusout.relatedTarget || !IdHelper.fromElement(focusout.relatedTarget)) {
            listeners.focusin({
                target        : focusout.relatedTarget,
                relatedTarget : focusout.target
            });
        }
    },
    capture : true,
    passive : true
};

function setupFocusListeners(element = document) {
    const config = ObjectHelper.assign({}, listeners, { element });
    EventHelper.on(config);
}

setupFocusListeners();

//TODO: add loader
/**
 * @module Core/widget/Mask
 */

/**
 * Masks an element (document.body if no element specified). Call static methods for ease of use or make instance for
 * reusability.
 *
 * @example
 * Mask.mask('hello');
 * Mask.unmask();
 *
 * @externalexample widget/Mask.js
 */
class Mask extends Delayable() {
    //region Config
    static get $name() {
        return 'Mask';
    }

    static get defaultConfig() {
        return {
            /**
             * Mode: bright, bright-blur, dark or dark-blur
             * @config {String}
             * @default
             */
            mode : 'dark',

            /**
             * The icon to show next to the text. Defaults to showing a spinner
             * @config {String}
             * @default
             */
            icon : 'b-icon b-icon-spinner',

            /**
             * The text (or HTML) to show in mask
             * @config {String}
             */
            text : null,

            type : null,

            progress : null,

            maxProgress : null,

            useTransition : false
        };
    }

    //endregion

    //region Init

    construct(config) {
        super.construct(config);

        if (!this.element) {
            this.element = document.body;
        }

        this.show();
    }

    doDestroy() {
        const me = this;

        if (me.maskElement) {
            me.maskElement.remove();
            me.maskElement = null;
            if (me.mode.endsWith('blur')) {
                DomHelper.forEachChild(me.element, child => {
                    child.classList.remove(`b-masked-${me.mode}`);
                });
            }
            me.elementMask = null;
        }
        super.doDestroy();
    }

    get typeName() {
        return typeof this.type === 'string' ? this.type.trim() : '';
    }

    get maskName(){
        return `mask${this.typeName}`;
    }

    get elementMask() {
        return this.element && this.element[this.maskName];
    }

    set elementMask(value) {
        if (this.element) {
            this.element[this.maskName] = value;
        }
    }

    /**
     * Creates mask element
     * @private
     */
    create() {
        const me = this;
        me.elementMask = me;

        Object.assign(me, DomHelper.createElement({
            parent    : me.element,
            className : {
                'b-mask'                : 1,
                'b-mask-type'                : 1,
                'b-widget'              : 1,
                [`b-mask-${me.mode}`]   : 1,
                'b-progress'            : me.maxProgress,
                'b-prevent-transitions' : !me.useTransition
            },
            reference : 'maskElement',
            children  : [
                {
                    className : 'b-mask-content',
                    reference : 'maskContent',
                    children  : [
                        me.maxProgress ? {
                            className : 'b-mask-progress-bar',
                            reference : 'progressElement',
                            style     : {
                                width : (Math.round(me.progress / me.maxProgress * 100)) + '%'
                            }
                        } : null,
                        {
                            className : 'b-mask-text',
                            reference : 'maskText'
                        }
                    ]
                }
            ]
        }));

        me.text = me._text;
    }

    //endregion

    //region Static

    /**
     * Shows a mask with the specified message
     * @param {String|Object} text Message
     * @param {HTMLElement} element Element to mask
     * @returns {Core.widget.Mask}
     */
    static mask(text, element = document.body) {
        return new Mask(typeof text !== 'string' ? Object.assign({ element }, text) : {
            element,
            text
        });
    }

    /**
     * Unmask
     * @param {HTMLElement} element Element to unmask
     * @returns {Promise} A promise which is resolved when the mask is gone
     */
    static unmask(element = document.body) {
        return element.mask && element.mask.close();
    }

    //endregion

    //region Mask content

    /**
     * Gets or sets the text displayed in the mask
     * @property {String}
     */
    set text(txt) {
        let me = this;

        me._text = txt || '';

        if (me.maskText) {
            me.maskText.innerHTML = `<i class="b-mask-icon ${me.icon}"></i>${me._text}`;
        }
    }

    get text() {
        return this._text;
    }

    set progress(progress) {
        this._progress = progress;

        if (this.progressElement && progress != null) {
            this.progressElement.style.width = (Math.round(progress / this._maxProgress * 100)) + '%';
        }
    }

    get progress() {
        return this._progress;
    }

    set maxProgress(max) {
        this._maxProgress = max;
        this.progress = this.progress;
    }

    get maxProgress() {
        return this._maxProgress;
    }

    //endregion

    //region Show & hide

    /**
     * Show mask
     */
    show() {
        const me = this;

        if (me.hasTimeout('hide')) {
            // TODO: Consider this behaviour, should showing a mask which is not fully hidden resolve?
            me.resolve();
            me.clearTimeout('hide');
        }

        if (!me.elementMask) {
            me.create();
        }
        const { element, maskElement } = me;

        if (!maskElement) return; // already masked by other instance, only allowing one

        element.classList.add('b-masked');
        maskElement.classList.add('b-visible');
        maskElement.classList.remove('b-hidden');
        me.shown = true;

        // blur has to blur child elements
        if (me.mode.endsWith('blur')) {
            DomHelper.forEachChild(element, child => {
                if (child !== maskElement) {
                    child.classList.add(`b-masked-${me.mode}`);
                }
            });
        }
    }

    /**
     * Hide mask
     * @returns {Promise} A promise which is resolved when the mask is hidden, or immediately if already hidden
     */
    hide() {
        const me = this,
            { element, maskElement } = me;

        return new Promise(resolve => {
            if (me.shown) {
                me.shown = false;
                maskElement.classList.remove('b-visible');
                maskElement.classList.add('b-hidden');
                element.classList.remove('b-masked');

                if (me.mode.endsWith('blur')) {
                    DomHelper.forEachChild(element, child => {
                        if (child !== maskElement) {
                            child.classList.remove(`b-masked-${me.mode}`);
                        }
                    });
                }

                // TODO: use AnimationHelper when available
                me.resolve = resolve;
                me.setTimeout(() => resolve(), 500, 'hide');
            }
            else {
                resolve();
            }
        });
    }

    /**
     * Close mask (removes it)
     * @returns {Promise} A promise which is resolved when the mask is closed
     */
    close() {
        return new Promise(resolve => {
            this.hide().then(() => {
                this.destroy();
                resolve();
            });
        });
    }

    //endregion
}
Mask._$name = 'Mask';

/**
 * @module Core/widget/Tool
 */

/**
 * Base class for tools.
 *
 * May be configured with a `cls` and a `handler` which is a function (or name of a function)
 * in the owning Panel.
 * @extends Core/widget/Widget
 *
 * @classType tool
 */
class Tool extends Widget {

    static get $name() {
        return 'Tool';
    }

    template() {
        return `<div class="b-icon"></div>`;
    }

    construct(config) {
        super.construct(config);

        EventHelper.on({
            element   : this.element,
            click     : 'onClick',
            mousedown : 'onMousedown',
            thisObj   : this
        });
    }

    onClick(e) {
        const me = this,
            panel = me.panel,
            handler = (typeof me.handler === 'function') ? me.handler : panel[me.handler];

        if (panel.trigger('toolclick', {
            tool : me
        }) !== false) {
            handler && me.callback(handler, panel, [e]);
        }
    }

    onMousedown(e) {
        const panel = this.panel,
            focusEl = panel.focusElement;

        e.preventDefault();
        if (focusEl && document.activeElement !== focusEl) {
            panel.focus();
        }
    }

    get panel() {
        return this.parent;
    }
}

Tool._$name = 'Tool'; BryntumWidgetAdapterRegister.register('tool', Tool);

/**
 * @module Core/widget/layout/Layout
 */

/**
  * A helper class used by {@link Core.widget.Container Container}s which renders child widgets to their
  * {@link Core.widget.Widget#property-contentElement}. It also adds the Container's
  * {@link Core.widget.Container#config-itemCls} class to child items.
  *
  * Subclasses may modify the way child widgets are rendered, or may offer APIs for manipulating the child widgets.
  *
  * The {@link Core.widget.layout.Card Card} layout class offers slide-in, slide-out animation of multiple
  * child widgets. {@link Core.widget.TabPanel} uses Card layout.
  */
class Layout extends Events(Base) {

    static get defaultConfig() {
        return {
            /**
             * The CSS class which should be added to the owning {@link Core.widget.Container Container}'s
             * {@link Core.widget.Widget#property-contentElement}.
             */
            containerCls : null,

            /**
             * The CSS class which should be added to the encapsulating element of child items.
             */
            itemCls : null
        };
    }

    static getLayout(layout, owner) {
        if (layout instanceof Layout) {
            return layout;
        }

        const
            isString = typeof layout === 'string',
            config   = {
                owner
            };

        return new (isString ? layoutClasses[layout] : layout)(isString ? config : Object.assign(config, layout));
    }

    static registerLayout(cls, name = cls.$name.toLowerCase()) {
        layoutClasses[name] = cls;
    }

    renderChildren() {
        const
            { owner, containerCls, itemCls } = this,
            { contentElement, items }        = owner,
            ownerItemCls                     = owner.itemCls,
            itemCount                        = items && items.length;

        contentElement.classList.add('b-content-element');

        if (containerCls) {
            contentElement.classList.add(containerCls);
        }

        // Need to check that container has widgets, for example TabPanel can have no tabs
        if (itemCount) {
            owner.textContent = false;

            for (let i = 0; i < itemCount; i++) {
                const
                    item = items[i],
                    { element } = item;

                element.dataset.itemIndex = i;
                if (itemCls) {
                    element.classList.add(itemCls);
                }
                if (ownerItemCls) {
                    element.classList.add(ownerItemCls);
                }

                // If instantiated by the app developer, external to Container#createWidget
                // a widget will have the b-outer class. Remove that if it' contained.
                element.classList.remove('b-outer');

                // Only trigger paint if the owner is itself painted, otherwise
                // the outermost Container will cascade the paint signal down.
                item.render(contentElement, Boolean(owner.isPainted));
            }
        }
    }

    removeChild(child) {
        const
            { element }        = child,
            { owner, itemCls } = this,
            { contentElement } = owner,
            ownerItemCls       = owner.itemCls;

        contentElement.removeChild(element);
        delete element.dataset.itemIndex;
        if (itemCls) {
            element.classList.remove(itemCls);
        }
        if (ownerItemCls) {
            element.classList.remove(ownerItemCls);
        }
        this.fixChildIndices();
    }

    appendChild(child) {
        const
            { element }        = child,
            childIndex         = this.owner.indexOfChild(child),
            { owner, itemCls } = this,
            { contentElement } = owner,
            ownerItemCls       = owner.itemCls;

        element.dataset.itemIndex = childIndex;

        owner.textContent = false;

        if (itemCls) {
            element.classList.add(itemCls);
        }
        if (ownerItemCls) {
            element.classList.add(ownerItemCls);
        }
        contentElement.appendChild(element);
    }

    insertChild(toAdd, childIndex) {
        const
            { element }        = toAdd,
            { owner, itemCls } = this,
            { contentElement } = owner,
            prevSibling        = contentElement.querySelector(`[data-item-index="${childIndex - 1}"]`),
            ownerItemCls       = owner.itemCls;

        owner.textContent = false;

        if (itemCls) {
            element.classList.add(itemCls);
        }
        if (ownerItemCls) {
            element.classList.add(ownerItemCls);
        }
        contentElement.insertBefore(element, prevSibling && prevSibling.nextSibling);
        this.fixChildIndices();
    }

    fixChildIndices() {
        this.owner.items.forEach((child, index) => {
            child.element.dataset.itemIndex = index;
        });
    }

    /**
     * The owning Widget
     * @property {String} owner
     * @readonly
     */
}

const layoutClasses = {
    default : Layout
};
Layout._$name = 'Layout';

let lastTouchTime = 0;

const hasRipple = w => w.ripple,
    Ripple = window.Ripple = new (
        class Ripple extends Widget {
            static get defaultConfig() {
                return {
                    id          : 'bryntum-ripple',
                    old_element : {
                        children : [{
                            className : 'b-ripple-inner',
                            reference : 'rippleElement'
                        }]
                    },

                    element : {
                        children : [{
                            tag       : 'svg',
                            class     : 'b-ripple-inner',
                            reference : 'rippleElement',
                            ns        : 'http://www.w3.org/2000/svg',
                            version   : '1.1',
                            viewBox   : '0 0 100 100',
                            children  : [{
                                reference : 'circleElement',
                                tag       : 'circle',
                                cx        : '0',
                                cy        : '0',
                                r         : 10
                            }]
                        }]
                    },

                    floating : true,

                    hideAnimation : false,

                    showAnimation : false,

                    scrollAction : 'realign',

                    color : 'rgba(0,0,0,.3)',

                    startRadius : 10,

                    radius : 100
                };
            }

            static get $name() {
                return 'Ripple';
            }

            afterConstruct() {
                super.afterConstruct();

                EventHelper.on({
                    element          : document,
                    mousedown        : 'onRippleControllingEvent',
                    thisObj          : this,
                    capture          : true,
                    once             : true
                });
            }

            onRippleControllingEvent(event) {
                const me = this;

                me.show();

                const rippleAnimation = DomHelper.getStyleValue(me.circleElement, 'animationName');

                me.hide();

                me.listenerDetacher && me.listenerDetacher();

                // If our theme supports ripples, add our listeners
                if (rippleAnimation && rippleAnimation !== 'none') {
                    me.listenerDetacher = EventHelper.on({
                        // Trap all mousedowns and see if the encapsulating Component is configured to ripple
                        mousedown : {
                            element : document,
                            capture : true,
                            handler : 'onDocumentMousedown'
                        },
                        touchstart : {
                            element : document,
                            capture : true,
                            handler : 'onDocumentTouchStart'
                        },
                        // Hide at the end of the ripple
                        animationend : {
                            element : me.circleElement,
                            handler : 'onAnimationEnd'
                        },
                        thisObj : me
                    });

                    // If this is the first mousedown, start listening to theme changes and trigger ripple manually
                    if (event.type === 'mousedown') {
                        me.onDocumentMousedown(event);

                        GlobalEvents.on({
                            theme   : 'onRippleControllingEvent',
                            thisObj : this
                        });
                    }
                }
            }

            onDocumentTouchStart(event) {
                lastTouchTime = performance.now();
                this.handleTriggerEvent(event);
            }

            onDocumentMousedown(event) {
                // We need to prevent a touchend->mousedown simulated mousedown from triggering a ripple.
                // https://developer.mozilla.org/en-US/docs/Web/API/Touch_events/Supporting_both_TouchEvent_and_MouseEvent
                if (performance.now() - lastTouchTime > 200) {
                    this.handleTriggerEvent(event);
                }
            }

            handleTriggerEvent(event) {
                const targetWidget = IdHelper.fromElement(event.target, hasRipple);

                if (targetWidget) {
                    const
                        rippleCfg = targetWidget.ripple,
                        target    = rippleCfg.delegate
                            ? event.target.closest(rippleCfg.delegate)
                            : (targetWidget.focusElement || targetWidget.element);

                    if (target) {
                        const ripple = ObjectHelper.assign({
                            event,
                            target,
                            radius : this.radius
                        }, rippleCfg);

                        // The clip option is specified as a string property name or delegate
                        if (typeof ripple.clip === 'string') {
                            ripple.clip = targetWidget[ripple.clip] || event.target.closest(ripple.clip);

                            // Not inside an instance of the clip delegate, then no ripple
                            if (!ripple.clip) {
                                return;
                            }
                        }
                        this.ripple(ripple);
                    }
                }
            }

            ripple({
                event,
                point = EventHelper.getClientPoint(event),
                target = event.target,
                clip = target,
                radius = this.radius,
                color = this.color
            }) {
                this.clip = clip;

                
                clip = Rectangle.from(clip, null, true);

                const
                    me            = this,
                    centreDelta   = clip.getDelta(point),
                    rippleStyle   = me.rippleElement.style,
                    circleElement = me.circleElement;

                me.hide();
                me.alignTo(clip);
                rippleStyle.transform = `translateX(${centreDelta[0]}px) translateY(${centreDelta[1]}px)`;
                rippleStyle.height = rippleStyle.width = `${radius}px`;
                circleElement.setAttribute('r', radius);
                circleElement.setAttribute('fill', color);
                me.show();

                // Push binding to the scroll position out until the next animation frame.
                // This is in case the calling code is going to cause a scroll.
                // Mousedown is a focusing gesture which may cause a scroll
                // to fire as the target element moves into view.
                me.requestAnimationFrame(() => {
                    document.addEventListener('scroll', me.callRealign, true);
                    me.documentScrollListener = true;
                });
            }

            alignTo(clip) {
                if (clip.nodeType === 1) {
                    clip = Rectangle.from(clip, null, true);
                }
                const
                    me                      = this,
                    { x, y, width, height } = clip;

                me.x = x;
                me.y = y;
                me.height = height;
                me.width = width;
            }

            // When fully expanded, it's all over.
            onAnimationEnd(event) {
                if (event.animationName === 'b-ripple-expand') {
                    this.hide();
                }
            }

            realign() {
                if (this.isVisible) {
                    this.alignTo(this.clip);
                }
            }
        }
    )();

/**
 * @module Core/util/Bag
 */

/**
 * A simple collection class to contain unique, keyed items.
 */
class Bag {
    constructor(config) {
        const me = this;

        me.generation = 0;
        me.items = new Set();
        me.idMap = {};
        me.idProperty = 'id';

        if (config) {
            if (config.idProperty) {
                me.idProperty = config.idProperty;
            }
            if (config.values) {
                me.values = config.values;
            }
        }
    }

    /**
     * Returns the item with the passed `id`.
     *
     * @param {*} id The `id` to find.
     * @returns {Object} The found item, or `undefined`.
     */
    get(key) {
        return this.idMap[safeIndexKey(key)];
    }

    /**
     * The number of items in this Bag.
     * @property {Number}
     * @readonly
     */
    get count() {
        return this.items.size;
    }

    /**
     * Adds the passed item(s) to this Bag. Existing items with the same ID
     * will be replaced.
     * @param {Object|Object[]} toAdd Item(s) to add.
     */
    add(...toAdd) {
        if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
            toAdd = toAdd[0];
        }
    
        const
            me  = this,
            {
                items,
                idMap,
                idProperty
            }   = me,
            len = toAdd.length;

        for (let i = 0; i < len; i++) {
            const
                item         = toAdd[i],
                key          = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]),
                existingItem = idMap[key];

            // Not already present
            if (existingItem == null) {
                idMap[key] = item;
                items.add(item);
                me.generation++;
            }
            // Already present, replace it if different. No generational change.
            // IDs rule.
            else if (existingItem !== item) {
                idMap[key] = item;
                items.delete(existingItem);
                items.add(item);
            }
        }
    }

    /**
     * Removes the passed item(s) from this Bag.
     * @param {Object|Object[]} toAdd Item(s) to remove.
     */
    remove(toRemove) {
        if (!Array.isArray(toRemove)) {
            toRemove = [toRemove];
        }

        const
            { items, idMap, idProperty } = this,
            len = toRemove.length;

        for (let i = 0; i < len; i++) {
            const
                item         = toRemove[i],
                key          = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]),
                existingItem = idMap[key];

            // Found natch, so delete it
            if (existingItem != null) {
                items.delete(existingItem);
                delete idMap[key];
                this.generation++;
            }
        }
    }

    clear() {
        this.items.clear();
        this.idMap = {};
        this.generation++;
    }

    /**
     * Change the id of an existing member by mutating its idProperty.
     * @param {String|Number|Object} item The item or id of the item to change.
     * @param {String|Number} newId The id to set in the existing member.
     */
    changeId(item, newId) {
        const
            me                    = this,
            { idMap, idProperty } = me,
            oldId                 = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]),
            member                = me.get(oldId);

        if (member) {
            const existingMember = me.get(newId);

            if (existingMember && member !== existingMember) {
                throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
            }

            member[idProperty] = newId;
            delete idMap[oldId];
            idMap[newId] = member;
        }
    }

    /**
     * Returns `true` if this Collection includes an item with the same `id` as the passed item.
     *
     * @param {Object|String|Number} item The item to find, or an `id` to find.
     * @returns {Boolean} True if the passed item is found.
     */
    includes(item) {
        const key = keyTypes[typeof item] ? item : safeIndexKey(item[this.idProperty]);

        return Boolean(this.idMap[key]);
    }

    /**
     * Extracts the content of this Bag into an array based upon the passed
     * value extraction function.
     * @param {Function} fn A function, which, when passed an item, returns a value to place into the resulting array.
     * @param {Object} [thisObj] The `this` reference when the function is called.
     * @returns {Object[]} An array of values extracted from this Bag.
     */
    map(fn, thisObj) {
        const
            { items } = this,
            result    = new Array(items.size);

        // Set has no map
        let i = 0;
        
        items.forEach(item => {
            result[i] = fn.call(thisObj, item, i++, items);
        });

        return result;
    }

    /**
     * Executes the passed function for each item in this Bag, passing in the item.
     * @param {Function} fn The function to execute.
     * @param {Object} [thisObj] The `this` reference when the function is called.
     */
    forEach(fn, thisObj) {
        return this.items.forEach(fn, thisObj);
    }

    /**
     * Returns the first item in this Bag which elicits a *truthy* return value from the passed funtion.
     * @param {Function} fn A function, which, when passed an item, returns `true` to select it as the item to return.
     * @returns {Object} The matched item, or `undefined`.
     */
    find(fn) {
        for (const div of this.items) {
            if (fn(div)) {
                return div;
            }
        }

        return undefined;
    }

    /**
     * Iterator that allows you to do for (let item of bag)
     */
    [Symbol.iterator]() {
        return this.items[Symbol.iterator]();
    }

    indexOf(item) {
        return this.values.indexOf(item);
    }

    /**
     * The set of values of this Bag.
     *
     * Setting this property replaces the data set.
     * @property {Object[]}
     */
    get values() {
        return [...this.items];
    }

    set values(values) {
        if (!Array.isArray(values)) {
            values = [values];
        }
        this.clear();
        this.add.apply(this, values);
        this.generation++;
    }

    /**
     * Sort the values of this Bag using the passed comparison function.
     *
     * Setting this property replaces the data set.
     * @param {Function} fn Comparison function which returns -ve, 0, or +ve
     */
    sort(fn) {
        this.values = this.values.sort(fn);
    }

    some(fn, thisObj) {
        return this.values.some(fn, thisObj);
    }
}
Bag._$name = 'Bag';

/**
 * @module Core/widget/Container
 */

const
    emptyObject$1 = Object.freeze({}),
    returnWeight = i => i.weight,
    sortByWeight = (a, b) => ((a.weight || 0) - (b.weight || 0));

/**
 * Widget that can contain other widgets. Layout is flexbox by default, see the {@link #config-layout} config.
 *
 * ```javascript
 * // create a container with two widgets
 * let container = new Container({
 *     items : [
 *         { type : 'text', label : 'Name' },
 *         { type : 'number', label : 'Score' }
 *     ]
 * });
 * ```
 *
 * Containers can have child widgets added, or removed during their lifecycle to accommodate business needs.
 *
 * For example:
 *
 *  ```javascript
 *  myTaskPopup.on({
 *      beforeShow() {
 *          if (task.type === task.MASTER) {
 *              // Insert the childTask multiselect before the masterTask field
 *              myPopyup.insert(childTaskMultiselect, masterTaskField)
 *
 *              // We don't need this for master tasks
 *              myPopup.remove(masterTaskField);
 *          }
 *          else {
 *              // Insert the masterTask combo before the childTask multiselect
 *              myPopyup.insert(masterTaskField, childTaskMultiselect)
 *
 *              // We don't need this for child tasks
 *              myPopup.remove(childTaskMultiselect);
 *          }
 *      }
 *  });
 * ```
 *
 * @extends Core/widget/Widget
 * @classType container
 * @externalexample widget/Container.js
 */
class Container extends Widget {

    static get $name() {
        return 'Container';
    }

    static get defaultConfig() {
        return {
            /**
             * An array of Widgets or typed Widget config objects.
             *
             * If configured as an Object, the property names are used as the child component's
             * {@link Core.widget.Widget#config-ref ref} name, and the value is the child component's config object.
             *
             * ```javascript
             *  new Panel({
             *      title    : 'Test Panel',
             *      floating : true,
             *      centered : true,
             *      width    : 600,
             *      height   : 400,
             *      layout   : 'fit',
             *      items    : {
             *          tabs : {
             *              type : 'tabpanel',
             *              items : {
             *                  general : {
             *                      title : 'General',
             *                      html  : 'General content'
             *                  },
             *                  details : {
             *                      title : 'Details',
             *                      html  : 'Details content'
             *                  }
             *              }
             *          }
             *      }
             *  }).show();
             * ```
             *
             * @config {Object[]|Core.widget.Widget[]|Object}
             */
            items : null,

            /**
             * Synonym for the {@link #config-items} config option.
             * @config {Object[]|Core.widget.Widget[]|Object}
             * @deprecated 2.1
             */
            widgets : null,

            /**
             * A config object containing default settings to apply to all child widgets.
             * @config {Object}
             */
            defaults : null,

            defaultType : 'widget',

            /**
             * The CSS style properties to apply to the {@link Core.widget.Widget#property-contentElement}.
             *
             * By default, a Container's {@link Core.widget.Widget#property-contentElement} uses flexbox layout, so this config
             * may contain the following properties:
             *
             * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction">flexDirection</a> default '`row`'
             * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap">flexWrap</a>
             * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-flow">flexFlow</a>
             * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content">justifyContent</a>
             * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-items">alignItems</a>
             * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-content">alignContent</a>
             * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/place-content">placeContent</a>
             * @config {Object}
             */
            layoutStyle : null,

            /**
             * An optional CSS class to add to child items of this container.
             * @config {String}
             */
            itemCls : null,

            /**
             * The short name of a helper class which manages rendering and styling of child items.
             *
             * By default, the only special processing that is applied is that the Container class's
             * {@link #config-itemCls} is added to child items.
             *
             * Containers use CSS flexbox in its default configuration to arrange child items. You may either
             * use the {@link #config-layoutStyle} configuration to tune how child items are layed out,
             * or use one of the built in helper classes which include:
             *
             *  - `card` Child items are displayed one at a time, size to fit the {@link Core.widget.Widget#property-contentElement}
             * and are slid in from the side when activated.
             * @config {String}
             */
            layout : 'default',

            /**
             * An object containing named config objects which may be referenced by name in any {@link #config-items}
             * object. For example, a specialized {@link Core.widget.Menu Menu} subclass may have a `namedItems`
             * default value defined like this:
             *
             * ```javascript
             *  namedItems : {
             *      removeRow : {
             *          text : 'Remove row',
             *          onItem() {
             *              this.ownerGrid.remove(this.ownerGrid.selectedRecord);
             *          }
             *      }
             *  }
             * ```
             *
             * Then whenever that subclass is instantiated and configured with an {@link #config-items}
             * object, the items may be configured like this:
             *
             * ```javascript
             *  items : {
             *      removeRow : true,   // The referenced namedItem will be applied to this
             *      otherItemRef : {
             *          text : 'Option 2',
             *          onItem() {
             *          }
             *      }
             * }
             * ```
             * @config {Object}
             */
            namedItems : null,

            /**
             * Specify `true` for a container used to show text markup. It will apply the `b-text-content`
             * class which specifies a default max-width that makes long text more readable. This is automatically set to
             * false if the container adds/defines child Widgets.
             */
            textContent : true
        };
    }

    // TODO: Remove when `widgets` is removed.
    setConfig(config, isConstructing) {
        // Assign deprecated widgets to items as early as possible to not have to have special handling in getters/setters
        if (config.widgets) {
            config.items = config.widgets;
        }

        super.setConfig(config, isConstructing);
    }

    startConfigure(config) {
        // Set a flag so that code can test for presence of items without tickling
        // any initial getter.
        const { items } = this;
        this.hasItems = Boolean(items && items.length);
        super.startConfigure(config);
    }

    /**
     * Removes the passed child/children from this Container.
     * @param  {...Core.widget.Widget} toRemove The child or children to remove.
     * @returns {Core.widget.Widget|Core.widget.Widget[]} All the removed items. An array if multiple items
     * were removed, otherwise, just the item removed.
     */
    remove(...toRemove) {
        let returnArray = true;

        if (toRemove.length === 1) {
            if (Array.isArray(toRemove[0])) {
                toRemove = toRemove[0];
            }
            else {
                returnArray = false;
            }
        }

        const
            me     = this,
            result = [];

        for (let i = 0; i < toRemove.length; i++) {
            const childToRemove = toRemove[i];

            if (me._items.includes(childToRemove)) {
                me._items.remove(childToRemove);
                me.layout.removeChild(childToRemove);
                result.push(childToRemove);
                me.unregisterReference(childToRemove);
            }
        }

        return returnArray ? result : result[0];
    }

    /**
     * Removes all children from this Container.
     * @returns {Core.widget.Widget[]} All the removed items.
     */
    removeAll() {
        return this.remove(this.items);
    }

    /**
     * Appends the passed widget/widgets to this Container.
     * @param  {...Core.widget.Widget} toAdd The child or children to add.
     * @returns {Core.widget.Widget|Core.widget.Widget[]} All the added widgets. An array if multiple items
     * were added, otherwise, just the item added.
     */
    add(...toAdd) {
        let returnArray = true;

        if (toAdd.length === 1) {
            if (Array.isArray(toAdd[0])) {
                toAdd = toAdd[0];
            }
            else {
                returnArray = false;
            }
        }

        const
            me     = this,
            result = [];

        for (let i = 0; i < toAdd.length; i++) {
            let childToAdd = toAdd[i];

            if (!(childToAdd instanceof Widget)) {
                childToAdd = me.createWidget(childToAdd);
            }
            else {
                childToAdd.parent = me;
            }

            if (!me._items.includes(childToAdd)) {
                me.registerReference(childToAdd);
                me._items.add(childToAdd);
                me.layout.appendChild(childToAdd);
                result.push(childToAdd);
            }
        }

        return returnArray ? result : result[0];
    }

    /**
     * Inserts the passed widget into this Container at the specified position.
     * @param  {Core.widget.Widget} toAdd The child to insert.
     * @param {Number|Core.widget.Widget} The index to insert at or the existing child to insert before.
     * @returns {Core.widget.Widget} The added widget.
     */
    insert(toAdd, index) {
        const
            me         = this,
            { _items } = me;

        if (toAdd instanceof Widget) {
            toAdd.parent = me;
        }
        else {
            toAdd = me.createWidget(toAdd);
        }

        if (_items.includes(index)) {
            index = me.indexOfChild(index);
        }

        index = Math.min(index, _items.count);

        const newValues = _items.values;
        newValues.splice(index, 0, toAdd);
        _items.values = newValues;

        // Register inserted item
        me.registerReference(toAdd);

        me.layout.insertChild(toAdd, index);

        return toAdd;
    }

    indexOfChild(child) {
        return this._items.indexOf(child);
    }

    set widgets(widgets) {
        console.warn('`widgets` was deprecated in 2.1, please change your code to use `items`');
        // Does nothing on purpose
    }

    get widgets() {
        console.warn('`widgets` was deprecated in 2.1, please change your code to use `items`');
        return this.items;
    }

    set items(items) {
        

        this.configuredItems = items;
    }

    /**
     * The array of instantiated child Widgets.
     * @property {Core.widget.Widget[]}
     * @readonly
     */
    get items() {
        const
            me = this,
            items = me._items || (me._items = new Bag()),
            { configuredItems } = me;

        // Only convert the widget config objects into widgets
        // when we first access the widgets. This is more efficient
        // if this Container is never rendered.
        if (configuredItems) {
            me.configuredItems = false;

            if (Array.isArray(configuredItems)) {
                me.processItemsArray(configuredItems, items);
            }
            else if (configuredItems) {
                me.processItemsObject(configuredItems, me.namedItems, items);
            }

            // Allow child items to have a weight to establish their order
            if (items.some(returnWeight)) {
                items.sort(sortByWeight);
            }
            items.forEach(me.registerReference, me);
        }

        return items.values;
    }

    processItemsArray(items, result) {
        const len = items.length;

        let i, item;

        for (i = 0; i < len; i++) {
            item = items[i];

            if (item instanceof Widget) {
                item.parent = this;
            }
            else {
                item = this.createWidget(item);
            }

            // If the widget creation function returns null, nothing to add
            if (item) {
                result.add(item);
            }
        }
    }

    processItemsObject(items, namedItems = emptyObject$1, result) {
        let item, ref;

        for (ref in items) {
            item = items[ref];

            // It might come in as itemRef : false
            if (item) {
                // If this class or instance has a "namedItems" object
                // named by this ref, then use it as the basis for the item
                if (ref in namedItems) {
                    item = typeof item === 'object' ? ObjectHelper.merge(ObjectHelper.clone(namedItems[ref]), item) : namedItems[ref];
                }

                // Allow namedItems to be overridden with itemKey : false to indicate unavailability of an item
                if (item) {
                    if (item instanceof Widget) {
                        item.parent = this;
                    }
                    else {
                        item = this.createWidget(item);
                    }

                    // If the widget creation function returns null, nothing to add
                    if (item) {
                        

                        item.ref = ref;
                        result.add(item);
                    }
                }
            }
        }
    }

    registerReference(item) {
        const ref = item.ref || item.id;

        if (ref) {
            for (let current = this; current; current = current.parent) {
                if (!current.widgetMap[ref]) {
                    current.widgetMap[ref] = item;
                }
            }
        }
    }

    unregisterReference(item) {
        const ref = item.ref || item.id;

        if (ref) {
            for (let current = this; current; current = current.parent) {
                if (current.widgetMap[ref] === item) {
                    delete current.widgetMap[ref];
                }
            }
        }
    }

    /**
     * An object which contains a map of descendant widgets keyed by their {@link Core.widget.Widget#config-ref ref}.
     * All descendant widgets will be available in the `widgetMap`.
     * @property {Object}
     * @readonly
     * @typings any
     */
    get widgetMap() {
        if (!this._widgetMap) {
            this._widgetMap = {};
        }

        // Force evaluation of the configured items array by the getter
        // so that configs are promoted to widgets and the widgetMap
        // is created, and if there are widgets, populated.
        this._thisIsAUsedExpression(this.items);

        return this._widgetMap;
    }

    set record(record) {
        this._record = record;
        this.setValues(record, true);
    }

    /**
     * The {@link Core.data.Model record} to be applied to the fields contained in this Container.
     * Any descendant widgets of this Container with a `name` property will have its value set to the
     * value of that named property of the record. If no record is passed, the widget has its value
     * set to `null`.
     * @property {Core.data.Model}
     */
    get record() {
        return this._record;
    }

    getValues(filterFn) {
        const
            me      = this,
            widgets = me.queryAll(w => w.name),
            len     = widgets.length;

        const result = {};

        for (let i = 0; i < len; i++) {
            const widget = widgets[i],
                name     = widget.name;

            if (!filterFn || filterFn(widget)) {
                result[name] = widget.value;
            }
        }

        return result;
    }

    set textContent(value) {
        this._textContent = value;

        this.element.classList[value ? 'add' : 'remove']('b-text-content');
    }

    get textContent() {
        return this._textContent;
    }


    /**
     * Sets multiple flexbox settings which affect how child widgets are arranged.
     *
     * By default, Containers use flexbox layout, so this property
     * may contain the following properties:
     *
     * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction">flexDirection</a> default '`row`'
     * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap">flexWrap</a>
     * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-flow">flexFlow</a>
     * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content">justifyContent</a>
     * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-items">alignItems</a>
     * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-content">alignContent</a>
     * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/place-content">placeContent</a>
     * @property {Object}
     * @category Layout
     */
    set layoutStyle(layoutStyle) {
        DomHelper.applyStyle(this.contentElement, layoutStyle);
        this._layoutStyle = layoutStyle;
    }

    get layoutStyle() {
        return this._layoutStyle;
    }

    set layout(layout) {
        this._layout = Layout.getLayout(layout, this);
    }

    get layout() {
        return this._layout || (this._layout = new Layout());
    }

    // Items to iterate over
    get childItems() {
        return this.items;
    }

    /**
     * Iterate over all widgets in this container and below.
     *
     * *Note*: Due to this method aborting when the function returns
     * `false`, beware of using short form arrow functions. If the expression
     * executed evaluates to `false`, iteration will terminate.
     * @param {Function} fn A function to execute upon all descendant widgets.
     * Iteration terminates if this function returns `false`.
     * @param {Boolean} [deep=true] Pass as `false` to only consider immediate child widgets.
     * @returns {Boolean} Returns `true` if iteration was not aborted by a step returning `false`
     */
    eachWidget(fn, deep = true) {
        const
            widgets = this.childItems,
            length = widgets ? widgets.length : 0;

        for (let i = 0; i < length; i++) {
            const widget = widgets[i];

            // Abort if a call returns false
            if (fn(widget) === false) {
                return false;
            }
            if (deep && widget.eachWidget) {
                // Abort if a deep call returns false
                if (widget.eachWidget(fn, deep) === false) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Returns an array of all descendant widgets which the passed
     * filter function returns `true` for.
     * @param {Function} filter A function which, when passed a widget,
     * returns `true` to include the widget in the results.
     * @returns {Core.widget.Widget[]} All matching descendant widgets.
     */
    queryAll(filter) {
        const result = [];

        this.eachWidget(w => {
            if (filter(w)) {
                result.push(w);
            }
        });

        return result;
    }

    /**
     * Returns the first descendant widgets which the passed
     * filter function returns `true` for.
     * @param {Function} filter A function which, when passed a widget,
     * returns `true` to return the widget as the sole result.
     * @returns {Core.widget.Widget} The first matching descendant widget.
     */
    query(filter) {
        let result = null;

        this.eachWidget(w => {
            if (filter(w)) {
                result = w;
                return false;
            }
        });

        return result;
    }

    /**
     * Returns a directly contained widget by id
     * @param {String} id The widget id
     * @returns {Core.widget.Widget}
     */
    getWidgetById(id) {
        return this.widgetMap[id];
    }

    /**
     * This function is called prior to creating widgets, override it in subclasses to allow containers to modify the
     * configuration of each widget. When adding a widget to a container hierarchy each parent containers
     * `processWidgetConfig` will be called. Returning false from the function prevents the widget from being added at
     * all.
     */
    processWidgetConfig(widget) {

    }

    /**
     * This function converts a Widget config object into a Widget.
     * @param {Object} widget A Widget config object.
     * @internal
     */
    createWidget(widget) {
        const me = this;

        // A string becomes the defaultType (see below) with the html set to the string.
        if (typeof widget === 'string') {
            widget = {
                html : widget
            };
        }
        // An element is encapsulated by a Widget
        else if (widget.nodeType === 1) {
            widget = {
                element : widget,
                id      : widget.id
            };
        }

        // A contained Widget must know its parent, and knowing it during construction
        // is important, but we must not mutate incoming config objects.
        widget = Object.setPrototypeOf({
            parent : me
        }, widget);

        if (!widget.type) {
            widget.type = me.defaultType;
        }

        for (let ancestor = widget.parent; ancestor; ancestor = ancestor.parent) {
            if (ancestor.processWidgetConfig(widget) === false) {
                return null;
            }
        }

        if (me.trigger('beforeWidgetCreate', { widget }) === false) {
            return null;
        }

        return WidgetHelper.createWidget(ObjectHelper.assign({}, me.defaults, widget), me.defaultType || 'widget');
    }

    render() {
        this.layout.renderChildren();

        super.render(...arguments);
    }

    get focusElement() {
        const firstFocusable = this.query(this.defaultFocus || (w => w.isFocusable));

        if (firstFocusable) {
            return firstFocusable.focusElement;
        }
        return super.focusElement;
    }

    doDestroy() {
        // Only destroy the widgets if they have been instanced.
        if (!this.configuredItems && this.items) {
            this.items.forEach(widget => widget.destroy && widget.destroy());
        }

        super.doDestroy();
    }

    /**
     * Checks that all descendant fields are valid.
     * @returns {Boolean} Returns `true` if all contained fields are valid, otherwise `false`
     */
    get isValid() {
        let valid = true;

        this.eachWidget(widget => {
            if ('isValid' in widget && !widget.isValid) {
                return (valid = false);
            }
        }, true);

        return valid;
    }

    /**
     * Retrieves or sets all values from/to contained fields.
     * Accepts and returns a map, using name, ref or id (in that order) as keys.
     *
     * ```javascript
     * container.values = {
     *     firstName : 'Clark',
     *     surname : 'Kent'
     * };
     * ```
     *
     * @property {Object}
     */
    get values() {
        const values = {};

        this.eachWidget(widget => {
            if ('value' in widget) {
                values[widget.name || widget.ref || widget.id] = widget.value;
            }
        }, true);

        return values;
    }

    set values(values) {
        this.setValues(values);
    }

    /**
     * Returns `true` if currently setting values. Allows fields change highlighting to distinguishing between initially
     * setting values and later on changing values.
     * @property {boolean}
     */
    get isSettingValues() {
        // Fields query their parent, pass the question up in case containers are nested
        return this._isSettingValues || this.parent && this.parent.isSettingValues;
    }

    setValues(values, onlyName = false) {
        // Flag checked by Field to determine if it should highlight change or not (it should not in this case)
        this._isSettingValues = true;

        this.eachWidget(widget => {
            const
                hec = widget.highlightExternalChange,
                key = onlyName ? widget.name : (widget.name || widget.ref || widget.id);

            if ('value' in widget && key) {
                // Don't want a field highlight on mass change
                widget.highlightExternalChange = false;

                // Setting to null when value not matched clears field
                widget.value = (values && (key in values)) ? values[key] : null;

                widget.highlightExternalChange = hec;
            }

        }, true);

        this._isSettingValues = false;
    }
}

Container._$name = 'Container'; BryntumWidgetAdapterRegister.register('container', Container);

/**
 * @module Core/widget/Toolbar
 */

/**
 * Widget that is themed to contain Buttons which is docked to the bottom or top of
 * a {@link Core.widget.Panel Panel}.
 *
 * ```javascript
 * // create a toolbar with two buttons
 * let container = new Toolbar({
 *   items : [
 *     { text : 'Add' },
 *     { text : 'Delete' }
 *   ]
 * });
 * ```
 *
 * @extends Core/widget/Container
 * @classType toolbar
 */
class Toolbar extends Container {
    static get $name() {
        return 'Toolbar';
    }

    static get defaultConfig() {
        return {
            defaultType : 'button',

            /**
             * Custom CSS class to add to toolbar widgets
             * @config {String}
             * @category CSS
             */
            widgetCls : null,

            layout : 'default'
        };
    }

    createWidget(widget) {
        if (widget === '->') {
            widget = {
                type : 'widget',
                cls  : 'b-toolbar-fill'
            };
        }
        else if (widget === '|') {
            widget = {
                type : 'widget',
                cls  : 'b-toolbar-separator'
            };
        }
        else if (typeof widget === 'string') {
            widget = {
                type : 'widget',
                cls  : 'b-toolbar-text',
                html : widget
            };
        }

        const result = super.createWidget(widget);

        if (this.widgetCls) {
            result.element.classList.add(this.widgetCls);
        }

        return result;
    }
}

Toolbar._$name = 'Toolbar'; BryntumWidgetAdapterRegister.register('toolbar', Toolbar);

/**
 * @module Core/widget/Panel
 */

const
    acceptNode = e => !e.classList.contains('b-focus-trap') && DomHelper.isFocusable(e) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP,
    byWeight = (l, r) => (l.weight || 0) - (r.weight || 0),
    byWeightReverse = (l, r) => (r.weight || 0) - (l.weight || 0);

// https://github.com/webcomponents/webcomponentsjs/issues/556
// Work around Internet Explorer wanting a function instead of an object.
// IE also *requires* this argument where other browsers don't.
acceptNode.acceptNode = acceptNode;

/**
 * Panel widget. A general pupose container which may be used to contain child {@link Core.widget.Container#config-items}
 * or {@link Core.widget.Widget#config-html}.
 *
 * Also may dock a {@link #config-header} and {@link #config-footer} either at top/bottom or left/right
 *
 *
 * @example
 * let panel = new Panel({
 *   title   : 'A Test Panel',
 *   widgets : [
 *     { type : 'text', placeholder: 'Text' },
 *   ],
 *   bbar : [{
 *     text : 'Proceed',
 *     onClick : () => {
 *       alert('Proceeding!');
 *     }
 *   }]
 * });
 *
 * @classType panel
 *
 * @extends Core/widget/Container
 */
class Panel extends Container {
    //region Config
    static get $name() {
        return 'Panel';
    }

    static get defaultConfig() {
        return {
            /**
             * By default, tabbing within a Panel is not contained, ie you can TAB out of the Panel
             * forwards or backwards.
             * Configure this as `true` to disallow tabbing out of the Panel, and make tabbing circular within this Panel.
             * @config {Boolean}
             * @default false
             */
            trapFocus : null,

            /**
             * A title to display in the header. Causes creation and docking of a header
             * to the top if no header is configured.
             *
             * If specified, overrides any title configured within the {@link #config-header} configuration.
             * @default
             * @config {String}
             */
            title : null,

            /**
             * Config object of a header. May contain a `title`, `titleAlign`, `dock`
             * and a `cls` property. If passed as a string, the value is used
             * as the title, dock is defaulted to `'top', and titleAlign` is defaulted to `start`.
             *
             * The `dock` property may be `top`, `right`, `bottom` or `left`.
             * The `titleAlign` property may be `start`, `center` or `end`.
             * @default
             * @config {Object|String}
             */
            header : null,

            /**
             * Config object of a footer. May contain a `dock`
             * and a `cls` property.
             *
             * The `dock` property may be `top`, `right`, `bottom` or `left`.
             * @default
             * @config {Object|String}
             */
            footer : null,

            /**
             * The tools to add either before or after the title in the Panel header.
             * Each property name is the reference by which an instantiated Tool Widget
             * may be retrieved from the live `{@link #property-tools}` property.
             * Each tool may have the following properties:
             * * `cls` The CSS class to apply.
             * * `handler` A method in the field to call upon click
             * * `align` `'start'` or `'end'` which end of the header the tool should go.
             * * `weight` (Optional) Heigher weighted tools gravitate towards the centre.
             * @config {Object}
             */
            tools : null,

            /**
             * A Config object representing the configuration of a {@link Core.widget.Toolbar},
             * or array of config objects representing the child items of a Toolbar.
             *
             * This creates a toolbar docked to the top of the panel immediately below the header.
             * @config {Object[]|Object}
             */
            tbar : null,

            /**
             * A Config object representing the configuration of a {@link Core.widget.Toolbar},
             * or array of config objects representing the child items of a Toolbar.
             *
             * This creates a toolbar docked to the bottom of the panel immediately above the footer.
             * @config {Object[]|Object}
             */
            bbar : null
        };
    }

    //endregion

    /**
     * A header {@link #config-tools tool} has been clicked.
     * @event toolclick
     * @param {Core.widget.Tool} source - This Panel.
     * @param {Core.widget.Tool} tool - The tool which is being clicked.
     */

    //region Init & destroy

    set element(element) {
        const me = this,
            headerFromTitle = me.title && (!me.parent || !me.parent.suppressChildHeaders),
            // If tools exist, we need to create the header infrastructure
            header = me.header || (me.tools || headerFromTitle ? {} : null),
            footer = me.footer,
            title = header && (typeof header === 'string' ? header : me.title || header.title),
            titleAlign = header && (header.titleAlign || 'start'),
            headerClass = me.classHierarchy(Panel).map(cls => `b-${cls.$name.toLowerCase()}-header`).join(' '),
            tbar = me.tbar,
            bbar = me.bbar || me.buttons,
            children = [{
                reference : 'topFocusTrap',
                className : 'b-focus-trap',
                tabIndex  : 0
            }],
            startTools = [],
            endTools = [],
            result = {
                children
            };

        if (me.hasItems || me.focusable) {
            result.tabIndex = 0;
        }

        if (header) {
            const headerChildren = [{
                reference : 'titleElement',
                className : `b-header-title b-align-${titleAlign}`,
                html      : title
            }];

            for (const toolRef in me.tools) {
                const tool = me.tools[toolRef];
                if (tool.align === 'start') {
                    startTools.unshift(tool);
                }
                else {
                    endTools.push(tool);
                }
            }

            // The tools at each end are sorted "gravitationally".
            // Higher weight sorts towards the center which is the title element.
            startTools.sort(byWeight);
            endTools.sort(byWeightReverse);
            headerChildren.unshift(...startTools.map(t => t.element));
            headerChildren.push(...endTools.map(t => t.element));

            children.push({
                tag       : 'header',
                reference : 'headerElement',
                className : `${headerClass} b-dock-${header.dock || 'top'} ${header.cls || ''}`,
                children  : headerChildren
            });
        }

        if (tbar) {
            tbar.layout.renderChildren();
            children.push(tbar.element);
        }

        children.push(me.bodyConfig);

        if (bbar) {
            bbar.layout.renderChildren();
            children.push(bbar.element);
        }

        if (footer) {
            children.push({
                tag       : 'footer',
                reference : 'footerElement',
                className : `${headerClass} b-dock-${footer.dock || 'bottom'} ${footer.cls || ''}`
            });
        }

        children.push({
            reference : 'bottomFocusTrap',
            className : 'b-focus-trap',
            tabIndex  : 0
        });

        super.element = result;
    }

    set bodyConfig(bodyConfig) {
        this._bodyConfig = bodyConfig;
    }

    get bodyConfig() {
        return this._bodyConfig || {
            reference : 'bodyElement',
            className : this.classHierarchy(Panel).map(cls => `b-${cls.$name.toLowerCase()}-content`).join(' '),
            html      : this.html
        };
    }

    get element() {
        return super.element;
    }

    /**
     * Get toolbar {@link Core.widget.Toolbar} docked to the top of the panel,
     * @property {Object}
     * @readonly
     * @typings Toolbar
     */
    get tbar() {
        return this._tbar;
    }

    set tbar(tbar) {
        if (tbar instanceof Toolbar) {
            tbar.parent = this;
        }
        else {
            if (Array.isArray(tbar)) {
                tbar = {
                    items : tbar
                };
            }
            tbar = new Toolbar(Object.assign({
                parent : this
            }, tbar));
        }
        this.hasItems = this.hasItems || tbar.hasItems;
        tbar.element.classList.add('b-top-toolbar', `b-dock-${tbar.dock || 'top'}`);
        this._tbar = tbar;
    }

    /**
     * Get toolbar {@link Core.widget.Toolbar} docked to the bottom of the panel,
     * @property {Object}
     * @readonly
     * @typings Toolbar
     */
    get bbar() {
        return this._bbar;
    }

    set bbar(bbar) {
        if (bbar instanceof Toolbar) {
            bbar.parent = this;
        }
        else {
            if (Array.isArray(bbar)) {
                bbar = {
                    items : bbar
                };
            }
            bbar = WidgetHelper.createWidget(Object.assign({
                type   : 'toolbar',
                parent : this
            }, bbar));
        }
        this.hasItems = this.hasItems || bbar.hasItems;
        bbar.element.classList.add('b-bottom-toolbar', `b-dock-${bbar.dock || 'bottom'}`);
        this._bbar = bbar;
    }

    // Override to iterate docked Toolbars in the correct order around contained widgets.
    get childItems() {
        const
            me = this,
            items = me.items ? me.items.slice() : [];

        if (me.tools) {
            items.unshift(...Object.values(me.tools));
        }
        if (me.tbar) {
            items.unshift(me.tbar);
        }
        if (me.bbar) {
            items.push(me.bbar);
        }

        return items;
    }

    /**
     * The tool Widgets as specified by the {@link #config-tools} configuration
     * (and the {@link Core.widget.Popup#config-closable} configuration in the Popup subclass).
     * Each is a {@link Core.widget.Widget Widget} instance which may be hidden, shown and observed and styled just like any other widget.
     * @property {Object}
     */
    set tools(tools) {
        const me = this,
            myTools = me._tools = {};

        for (const toolRef in tools) {
            const tool = myTools[toolRef] = WidgetHelper.createWidget(ObjectHelper.assign({
                type      : 'tool',
                ref       : toolRef,
                //@nige: Widget defines ref but not reference, typo?
                reference : toolRef,
                parent    : me
            }, tools[toolRef]), me.defaultToolType || 'tool');

            me.registerReference(tool, tool.ref);
        }
    }

    get tools() {
        return this._tools;
    }

    set trapFocus(trapFocus) {
        const me = this;

        me.element.classList[trapFocus ? 'add' : 'remove']('b-focus-trapped');
        if (trapFocus) {
            me.focusTrapListener = EventHelper.on({
                element  : me.element,
                focusin  : 'onFocusTrapped',
                delegate : '.b-focus-trap',
                thisObj  : me
            });

            // Create a TreeWalker which visits focusable elements.
            if (!me.treeWalker) {
                me.treeWalker = document.createTreeWalker(me.element, NodeFilter.SHOW_ELEMENT, acceptNode, false);
            }
        }
        else {
            if (me.focusTrapListener) {
                me.focusTrapListener();
                me.focusTrapListener = null;
            }
        }
        me._trapFocus = trapFocus;
    }

    get trapFocus() {
        return this._trapFocus;
    }

    onFocusTrapped(e) {
        const me = this,
            treeWalker = me.treeWalker;

        // The only way of focusing these invisible elements is by TABbing to them.
        // If we hit the bottom one, wrap to the top.
        if (e.target === me.bottomFocusTrap) {
            treeWalker.currentNode = me.topFocusTrap;
            treeWalker.nextNode();
        }
        // If we hit the top one, wrap to the bottom.
        else {
            treeWalker.currentNode = me.bottomFocusTrap;
            treeWalker.previousNode();
        }

        me.requestAnimationFrame(() => treeWalker.currentNode.focus());
    }

    get focusElement() {
        // Either use our Containerness to yield the focus element of
        // a descendant or fall back to the encapsulating element.
        return this.hasItems && (super.focusElement || this.element);
    }

    get contentElement() {
        return this.element && this.bodyElement;
    }

    get widgetClassList() {
        const me = this,
            result = super.widgetClassList,
            header = me.header;

        if (header || me.title || me.tools) {
            result.push(`b-panel-has-header b-header-dock-${header && header.dock || 'top'}`);
        }

        if (me.tbar) {
            result.push(`b-panel-has-top-toolbar`);
        }

        if (me.bbar) {
            result.push(`b-panel-has-bottom-toolbar`);
        }

        return result;
    }

    //endregion

    doDestroy() {
        const { tools } = this;

        if (tools) {
            for (const t of Object.values(tools)) {
                t.destroy();
            }
        }

        // Only destroy the widgets if they have been instanced.
        if (this.tbar) {
            this.tbar.destroy();
        }

        if (this.bbar) {
            this.bbar.destroy();
        }

        super.doDestroy();
    }
}

Panel._$name = 'Panel'; BryntumWidgetAdapterRegister.register('panel', Panel);

/**
 * @module Core/widget/Popup
 */

/**
 * Popup widget, used as base class for Menu but can also be used as is to contain widgets or html
 *
 * @example
 * let popup = new Popup({
 *   forElement : document.querySelector('button'),
 *   widgets    : [
 *     { type : 'text', placeholder: 'Text' },
 *     { type: 'button', text: 'Okey', style: 'width: 100%', color: 'orange'}
 *   ]
 * });
 *
 * @classType popup
 * @externalexample widget/Popup.js
 *
 * @extends Core/widget/Panel
 */
class Popup extends Panel {
    //region Config
    static get $name() {
        return 'Popup';
    }

    static get defaultConfig() {
        return {

            /**
             * Auto show flag for Popup.
             * If truthy then Popup is shown automatically upon hover.
             * @config {Boolean}
             * @default
             */
            autoShow : true,

            /**
             * By default a Popup is transient, and will {@link #function-close} when the user clicks or
             * taps outside its owned widgets and when focus moves outside its owned widgets.
             *
             * **Note**: {@link #config-modal Modal} popups won't {@link #function-close} when focus moves outside even if autoClose is `true`.
             *
             * Configure as `false` to make a Popup non-transient.
             * @config {Boolean}
             * @default
             */
            autoClose : true,

            /**
             * Show popup when user clicks the element that it is anchored to. Cannot be combined with showOnHover
             * @config {Boolean}
             * @default
             */
            showOnClick : false,

            /**
             * DOM element to attach popup.
             * @config {HTMLElement}
             */
            forElement : null,

            monitorResize : true,

            floating : true,
            hidden   : true,

            axisLock : true, // Flip edges if align violates constrainTo

            hideAnimation : BrowserHelper.isIE11 ? null : {
                opacity : {
                    from     : 1,
                    to       : 0,
                    duration : '.3s',
                    delay    : '0s'
                }
            },

            showAnimation : BrowserHelper.isIE11 ? null : {
                opacity : {
                    from     : 0,
                    to       : 1,
                    duration : '.4s',
                    delay    : '0s'
                }
            },

            testConfig : {
                hideAnimation :  null,
                showAnimation :  null
            },

            /**
             * The action to take when calling the {@link #function-close} method.
             * By default, the popup is hidden.
             *
             * This may be set to `'destroy'` to destroy the popup upon close.
             * @config {String}
             * @default
             */
            closeAction : 'hide',

            /**
             * By default, tabbing within a Popup is circular - that is it does not exit.
             * Configure this as `false` to allow tabbing out of the Popup.
             * @config {Boolean}
             * @default
             */
            trapFocus : true,

            /**
             * By default a Popup is focused when it is shown.
             * Configure this as `false` to prevent automatic focus on show.
             * @config {Boolean}
             * @default
             */
            focusOnToFront : true,

            /**
             * Show a tool in the header to close this Popup, and allow `ESC` close it.
             * The tool is available in the {@link #property-tools} object
             * under the name `close`. It uses the CSS class `b-popup-close` to apply a
             * default close icon. This may be customized with your own CSS rules.
             * @config {Boolean}
             * @default
             */
            closable : null,

            /**
             * Optionally show an opaque mask below this Popup when shown.
             * Configure this as `true` to show the mask.
             *
             * When a Popup is modal, it defaults to being {@link Core.widget.Widget#config-centered centered}.
             * Also it won't {@link #function-close} when focus moves outside even if {@link #config-autoClose} is `true`.
             *
             * May also be an object containing the following properties:
             * * `closeOnMaskTap` Specify as `true` to {@link #function-close} when mask is tapped.
             * The default action is to focus the popup.
             *
             * Usage:
             * ```javascript
             * new Popup({
             *     title  : 'I am modal',
             *     modal  : {
             *         closeOnMaskTap : true
             *     },
             *     height : 100,
             *     width  : 200
             * });
             * ```
             *
             * @config {Boolean}
             * @default
             */
            modal : null
        };
    }

    //endregion

    startConfigure(config) {
        // Read the closable config which will force evaluation of tools
        // to include close tool.
        this._thisIsAUsedExpression(this.closable);

        super.startConfigure(config);
    }

    //region Init & destroy

    finalizeInit() {
        const me = this;

        me.anchoredTo        = me.forElement;
        me.initialAnchor     = me.anchor;

        if (me.forElement && me.showOnClick) {
            // disable autoShow if not enabled by config
            if (!me.initialConfig.autoShow) {
                me.autoShow = false;
            }
            EventHelper.on({
                element : me.forElement,
                click   : 'onElementUserAction',
                thisObj : me
            });
        }

        super.finalizeInit();

        if (me.autoShow) {
            if (me.autoShow === true) {
                me.show();
            }
            else {
                me.setTimeout(() => me.show(), me.autoShow);
            }
        }
    }

    doDestroy() {
        this.syncModalMask();
        super.doDestroy();
    }

    //endregion

    //region Show/hide

    /**
     * Performs the configured {@link #config-closeAction} upon this popup.
     * By default, the popup hides. The {@link #config-closeAction} may be
     * configured as `'destroy'`.
     * @fires beforeclose If popup is not hidden
     */
    close() {
        /**
         * Fired when the {@link #function-close} method is called and the popup is not hidden.
         * May be vetoed by returning `false` from a handler.
         * @event beforeClose
         * @param {Core.widget.Popup} source - This Popup
         */
        if ((!this._hidden && this.trigger('beforeClose') !== false) ||
            // we should destroy it even if it's hidden just omit beforeclose event
            (this._hidden && this.closeAction == 'destroy')) {
            return this[this.closeAction]();
        }
    }

    //endregion

    //region Events

    onElementResize(resizedElement, lastRect, myRect) {
        const me = this,
            { lastAlignSpec } = me;

        // If this Popup changes size while we are aligned and we are aligned to
        // a target (not a position), then we might need to realign.
        if (me.isVisible && lastAlignSpec && lastAlignSpec.target) {
            const heightChange = !lastRect || myRect.height !== lastRect.height,
                widthChange = !lastRect || myRect.width !== lastRect.width;

            // Only realign if:
            // the height has changed and we are not aligned below, or
            // the width has changed and we are not aligned to the right.
            if ((heightChange && lastAlignSpec.zone !== 2) || (widthChange && lastAlignSpec.zone !== 1)) {
                // Must move to next AF because in Chrome, the resize monitor might fire
                // before the element is painted and the anchor color matching
                // scheme cannot work in that case.
                me.requestAnimationFrame(() => me.realign());
            }
        }

        super.onElementResize(resizedElement);
    }

    onInternalKeyDown(event) {
        // close on escape key
        if (event.key === 'Escape') {
            event.stopImmediatePropagation();
            this.close(true);
        }
    }

    onDocumentMouseDown({ event }) {
        const me = this;

        if (me.modal && event.target === Popup.modalMask) {
            event.preventDefault();
            if (me.modal.closeOnMaskTap) {
                me.close();
            }
            else if (!me.containsFocus) {
                me.focus();
            }
        }
        // in case of outside click and if popup is focused, focusout will trigger closing
        else if (!me.owns(event.target) && me.autoClose && !me.containsFocus) {
            me.close();
        }

        // Focus moves unrelated to where the user's attention is upon this gesture.
        // Go into the keyboard mode where the focused widget gets a rendition so that
        // it is obvious where focus now is.
        // Must jump over EventHelper's global mousedown listener which will remove this class.
        me.setTimeout(() => document.body.classList.add('b-using-keyboard'), 0);
    }

    get isTopModal() {
        return DomHelper.isVisible(Popup.modalMask) && this.element.previousElementSibling === Popup.modalMask;
    }

    onFocusIn(e) {
        const activeEl = document.activeElement;

        super.onFocusIn(e);

        // No event handler has moved focus, and target is outermost el
        // then delegate to the focusElement which for a Container
        // is found by finding the first visible, focusable descendant widget.
        if (document.activeElement === activeEl && e.target === this.element) {
            this.focus();
        }
    }

    onFocusOut(e) {
        if (!this.modal && this.autoClose) {
            this.close();
        }

        super.onFocusOut(e);
    }

    onShow() {
        const me = this;

        if (me.autoClose && !me.mouseDownRemover) {
            me.addDocumentMouseDownListener();
        }

        // TODO: It's the floating "toFront" operation that should handle
        // focusing based on config focusOnToFront.
        if (me.focusOnToFront) {
            me.focus();
        }

        super.onShow && super.onShow();

        // Insert the modal mask below this Popup if needed
        me.syncModalMask();
    }

    addDocumentMouseDownListener() {
        this.mouseDownRemover = GlobalEvents.on({
            globaltap : 'onDocumentMouseDown',
            thisObj   : this
        });
    }

    syncModalMask() {
        const
            me            = this,
            { modal }     = me,
            { modalMask } = Popup;

        if (modal && me.isVisible) {
            // If we have not been explicitly positioned, a modal is centered.
            if (!me._x && !me._y) {
                me.centered = true;
            }
            modalMask.classList.remove('b-hide-display');
            modalMask.parentNode.insertBefore(modalMask, me.element);
            me.element.classList.add('b-modal');
        }
        else {
            me.element.classList.remove('b-modal');

            const remaningModals = me.constructor.floatRoot.querySelectorAll('.b-modal');

            // If there are any other visible modals, drop the mask to just below the new topmost
            if (remaningModals.length) {
                const topModal = remaningModals[remaningModals.length - 1];

                modalMask.classList.remove('b-hide-display');
                modalMask.parentNode.insertBefore(modalMask, topModal);

            }
            else {
                modalMask.classList.add('b-hide-display');
            }
        }
    }

    onHide() {
        const me = this;

        if (me.mouseDownRemover) {
            me.mouseDownRemover();
            me.mouseDownRemover = null;
        }

        super.onHide && super.onHide();

        // Insert the modal mask below the topmost Popup if needed, else hide it
        me.syncModalMask();
    }

    onElementUserAction() {
        this.show();
    }

    //endregion

    set closable(closable) {
        this._closable = closable;
        if (!this.tools) {
            this.tools = {};
        }
    }

    get closable() {
        return this._closable;
    }

    set tools(tools) {
        const me = this;

        if (me.closable) {
            (tools || (tools = {})).close = {
                cls     : 'b-popup-close',
                handler : 'close',
                weight  : -1000
            };
        }
        super.tools = tools;
    }

    get tools() {
        return super.tools;
    }

    static get modalMask() {
        const me = this;
        if (!me._modalMask) {
            me._modalMask = DomHelper.createElement({
                className : 'b-modal-mask b-hide-display',
                parent    : me.floatRoot
            });
        }
        else if (!me.floatRoot.contains(me._modalMask)) {
            // Reattach modalMask if it was detached
            me.floatRoot.appendChild(me._modalMask);
        }

        return me._modalMask;
    }
}

Popup._$name = 'Popup'; BryntumWidgetAdapterRegister.register('popup', Popup);

/**
 * @module Core/helper/TemplateHelper
 */

const
    tagSpaceRe = />[ \t\r\n]+</g,
    multiSpaceRe = /\s\s+/g;

/**
 * Helper for template strings, use as tag function
 * @example
 * TemplateHelper.tpl`...`
 * @internal
 */
class TemplateHelper {
    /**
     * Tag function for template literals that does some basic cleanup
     * @private
     */
    static tpl(strings, ...values) {
        let count  = 0,
            output = values.map((val, i) => {
                // TODO: pad output nicely instead of just trimming away
                let ret = strings[i];

                if (Array.isArray(val)) {
                    ret += val.reduce((ack, item) => ack += (typeof item === 'string' ? item.trim() : item) + '\n', '');
                }
                else {
                    if (val === undefined) {
                        val = '';
                    }
                    ret += typeof val === 'string' ? val.trim() : val;
                }

                count++;

                return ret;
            }).join('');

        if (count <= strings.length) {
            output += strings[strings.length - 1];
        }

        // Excise unnecessary *soft* whitespace textNodes. We cannot use \s because that
        // matches non-breaking spaces which need to be preserved.
        // Also reduce any usage of multiple spaces to single, since they have no value in html
        return output.replace(tagSpaceRe, '><').replace(multiSpaceRe, ' ').trim();
    }

    /**
     * Tag function for template literals that does some basic cleanup. Version for docs that do not remove blank space,
     * to keep code snippets formatting intact.
     * @private
     */
    static docsTpl(strings, ...values) {
        let count  = 0,
            output = values.map((val, i) => {
                // TODO: pad output nicely instead of just trimming away

                let str = strings[i],
                    ret = str;

                if (Array.isArray(val)) {
                    ret += val.reduce((ack, item) => ack += (typeof item === 'string' ? item.trim() : item) + '\n', '');
                }
                else {
                    if (val === undefined) {
                        val = '';
                    }
                    ret += typeof val === 'string' ? val.trim() : val;
                }

                count++;

                return ret;
            }).join('');

        if (count <= strings.length) {
            output += strings[strings.length - 1];
        }

        // Excise unnecessary *soft* whitespace textNodes. We cannot use \s because that
        // matches non-breaking spaces which need to be preserved.
        return output.replace(tagSpaceRe, '><').trim();
    }

    static repeat(times) {
        return function(...args) {
            return TemplateHelper.tpl(...args).repeat(times);
        };
    }

    static loop(times) {

    }
}
TemplateHelper._$name = 'TemplateHelper';

/**
 * @module Core/widget/MenuItem
 */

const
    bIcon = /^b-icon-/,
    bFa = /^b-fa-/;

/**
 * Menu item widget, encapsulates a menu item within a Menu.
 *
 * May be configured with a {@link #config-checked} state which creates
 * a checkbox which may bwe toggled.
 *
 * Fires events when activated which bubble up through the parent hierachy
 * and may be listened for on an ancestor. See {@link Core.widget.Menu Menu}
 * for more details on usage.
 *
 * @extends Core/widget/Widget
 *
 * @classType menuitem
 */
class MenuItem extends Widget {
    //region Config
    static get $name() {
        return 'MenuItem';
    }

    static get defaultConfig() {
        return {
            /**
             * A submenu configuration object, or an array of MenuItem configuration
             * objects from which to create a submenu.
             *
             * Note that this does not have to be a Menu. The `type` config can be used
             * to specify any widget as the submenu.
             * @config {Object|Object[]}
             */
            menu : null,

            /**
             * Item icon class.
             *
             * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
             *
             * Otherwise this is a developer-defined CSS class string which results in the desired icon.
             * @config {String}
             */
            icon : null,

            /**
             * The text to be displayed in the item
             * @config {String}
             */
            text : null,

            /**
             * If configured with a `Boolean` value, a checkbox is displayed
             * as the start icon, and the {@link #event-toggle} event is fired
             * when the checked state changes.
             * @config {Boolean}
             */
            checked : null,

            /**
             * By default, upon activate, non-checkbox menu items will collapse
             * the owning menu hierarchy.
             *
             * Configure this as `false` to cause the menu to persist after
             * activating an item
             * @config {Boolean}
             */
            closeParent : null,

            localizableProperties : ['text']
        };
    }

    /**
     * Actions this item. Fires the {@link #event-item} event, and if this
     * if a {@link #config-checked} item, toggles the checked state, firing
     * the {@link #event-toggle} event.
     */
    doAction(event) {
        const item = this,
            menu = this.parent,
            itemEvent = { menu, item, element : item.element, bubbles : true };

        if (typeof item.checked === 'boolean') {
            item.checked = !item.checked;
        }

        // Give internal handlers a chance to inject extra information before
        // user-supplied "item" handlers see the event.
        // Scheduler's ContextMenu feature does this
        item.trigger('beforeItem', itemEvent);

        /**
         * This menu item has been activated.
         *
         * Note that this event bubbles up through parents and can be
         * listened for on a top level {@link Core.widget.Menu Menu} for convenience.
         * @event item
         * @param {Core.widget.MenuItem} item - The menu item which is being actioned.
         * @param {Core.widget.Menu} menu - Menu containing the menu item
         */
        item.trigger('item', itemEvent);

        // Collapse the owning menu hierarchy if configured to do so
        if (item.closeParent && menu) {
            menu.rootMenu.close();

            // Don't prevent links doing their thing
            if (event && !item.href) {
                event.preventDefault();
            }
        }
    }

    doDestroy() {
        const menu = this._menu;

        if (menu instanceof Widget) {
            menu.destroy();
        }
        super.doDestroy();
    }

    template(me) {
        const
            icon = me.icon || ((typeof me.checked === 'boolean') ? `b-fw-icon b-icon-${me.checked ? '' : 'un'}checked` : ''),
            iconExtraCls = bIcon.test(icon) ? ' b-icon' : (bFa.test(icon) ? ' b-fa' : ''),
            tag = me.href ? 'a' : 'div';

        return TemplateHelper.tpl`
            <${tag} ${tag === 'a' ? `href="${me.href}"` : ''} ${tag === 'a' && me.target ? `target="${me.target}"` : ''} class="${me.hasMenu ? 'b-has-submenu' : ''}" ${me.name ? `data-name="${me.name}"` : ''} tabIndex="-1">
                ${icon ? `<i class="b-menuitem-icon ${icon}${iconExtraCls}" reference="iconElement"></i>` : ''}
                <span class="b-menu-text" reference="textElement">${me.text}</span>
                ${me.hasMenu ? '<i class="b-fw-icon b-icon-sub-menu" reference="subMenuIcon"></i>' : ''}
            </${tag}>`;
    }

    get focusElement() {
        return this.element;
    }

    get contentElement() {
        return this.textElement;
    }

    get isFocusable() {
        const focusElement = this.focusElement;

        // We are only focusable if the focusEl is deeply visible, that means
        // it must have layout - an offsetParent. Body does not have offsetParent.
        // Disabled menu items are focusable but cannot be activated.
        // https://www.w3.org/TR/wai-aria-practices/#h-note-17
        return focusElement && this.isVisible && (focusElement === document.body || focusElement.offsetParent);
    }

    onFocusIn(e) {
        super.onFocusIn(e);
        if (!this.disabled && this.menu) {
            this.openMenu();
        }
    }

    onFocusOut(e) {
        super.onFocusOut(e);
        this.closeMenu();
    }

    openMenu(andFocus) {
        const menu = this.menu;

        if (!this.disabled && menu) {
            menu.focusOnToFront = andFocus;
            menu.show();
            this.owner.currentSubMenu = menu;
        }
    }

    closeMenu() {
        if (this._menu instanceof Widget) {
            this.menu.close();
        }
    }

    /**
     * Get/sets the checked state of thie `MenuItem` and fires the {@link #event-toggle}
     * event upon change.
     *
     * Note that this must be configured as a `Boolean` to enable the checkbox UI.
     * @property {Boolean}
     */
    set checked(checked) {
        const me = this,
            { isConfiguring } = me;

        // If we began life as a non-checkitem, then reject attempts to set checked status.
        if (!isConfiguring && !(typeof me._checked === 'boolean')) {
            return;
        }

        // Ensure we're always dealing with a Boolean
        checked = !!checked;

        // Reject non-changes.
        if (checked !== me._checked) {
            me._checked = checked;

            // During config this is initial state; do not fire change events.
            // Initial icon state is set in the template.
            if (!isConfiguring) {
                me.iconElement.classList[checked ? 'add' : 'remove']('b-icon-checked');
                me.iconElement.classList[checked ? 'remove' : 'add']('b-icon-unchecked');

                /**
                 * The checked state of this menu item has changed.
                 *
                 * Note that this event bubbles up through parents and can be
                 * listened for on a top level {@link Core.widget.Menu Menu} for convenience.
                 * @event toggle
                 * @param {Core.widget.MenuItem} item - The menu item whose checked state changed.
                 * @param {Core.widget.Menu} menu - Menu containing the menu item
                 * @param {Boolean} checked - The _new_ checked state.
                 */
                me.trigger('toggle', {
                    menu    : me.owner,
                    item    : me,
                    checked : me._checked,
                    element : me.element,
                    bubbles : true
                });
            }
        }
    }

    get checked() {
        return this._checked;
    }

    set menu(menu) {
        this._menu = menu;
    }

    get text() {
        return this.html;
    }

    set text(text) {
        this.html = text;
    }

    /**
     * Returns the instantiated menu widget as configured by {@link #config-menu}.
     * @property {Core.widget.Widget}
     * @readonly
     */
    get menu() {
        const me = this;

        let result = me._menu;

        if (result && !(result instanceof Widget)) {
            // This covers both Array and Object which are valid items config formats.
            // menu could be { itemRef : { text : 'sub item 1 } }. But if it has
            // child items or html property in it, it's the main config
            if (typeof result === 'object' && !(('items' in result) || ('widgets' in result) || ('html' in result))) {
                result = {
                    items : result
                };
            }
            result = me.menu = WidgetHelper.createWidget(Object.assign({
                type         : 'menu',
                autoShow     : false,
                autoClose    : true,
                scrollAction : me.owner.scrollAction,
                constrainTo  : me.owner.constrainTo,
                forElement   : me.element,
                align        : 'l0-r0',
                anchor       : true,
                owner        : me,
                cls          : 'b-sub-menu' // Makes the anchor hoverable to avoid mouseleave
            }, result));
        }

        return result;
    }

    set closeParent(closeParent) {
        this._closeParent = closeParent;
    }

    get closeParent() {
        const result =  (typeof this.checked === 'boolean') ? this._closeParent : (this._closeParent !== false);

        return result && !this.hasMenu;
    }

    get hasMenu() {
        const menu = this.isConfiguring ? this.initialConfig.menu : this._menu;

        return menu && ((menu instanceof Widget) || typeof menu === 'object' || menu.length > 0);
    }
}

MenuItem._$name = 'MenuItem'; BryntumWidgetAdapterRegister.register('menuitem', MenuItem);

const validKeys = {
    ArrowUp    : 1,
    ArrowDown  : 1,
    ArrowRight : 1,
    ArrowLeft  : 1,
    Enter      : 1,
    Escape     : 1
};

/**
 * @module Core/widget/Menu
 */

/**
 * Menu widget, displays a list of items which the user can select from using mouse or keyboard. Can have submenus.
 *
 * @example
 * let menu = new Menu({
 *     forElement : btn.element,
 *     items      : [{
 *         icon : 'b-icon b-icon-add',
 *         text : 'Add'
 *     }, {
 *         icon : 'b-icon b-icon-trash',
 *         text : 'Remove'
 *     }, {
 *         text : 'Sub menu',
 *         menu : [{
 *             icon : 'b-icon b-fa-play',
 *             text : 'Play'
 *         }]
 *     }],
 *     // Method is called for all ancestor levels
 *     onItem({ item }) {
 *         Toast.show('You clicked ' + item.text);
 *     }
 * });
 *
 * @classType menu
 * @externalexample widget/Menu.js
 *
 * @extends Core/widget/Popup
 */
class Menu extends Popup {
    //region Config
    static get $name() {
        return 'Menu';
    }

    static get defaultConfig() {
        return {
            align : 't-b',

            scrollAction : 'hide',

            /**
             * Specify false to prevent the menu from getting focus when hovering items
             * @default
             * @config {Boolean}
             */
            focusOnHover : null,

            // We do need a Scroller so that we can use its API to scroll around.
            // But the overflow flags default to false.
            scrollable : false,

            defaultType : 'menuitem'
        };
    }

    //endregion

    /**
     * A descendant menu item has been activated.
     *
     * Note that this event bubbles up through parents and can be
     * listened for on a top level {@link Core.widget.Menu Menu} for convenience.
     * @event item
     * @param {Core.widget.MenuItem} item - The menu item which is being actioned.
     * @param {Core.widget.Menu} menu - Menu containing the menu item
     */

    /**
     * The checked state of a descendant menu item has changed.
     *
     * Note that this event bubbles up through parents and can be
     * listened for on a top level {@link Core.widget.Menu Menu} for convenience.
     * @event toggle
     * @param {Core.widget.MenuItem} item - The menu item whose checked state changed.
     * @param {Core.widget.Menu} menu - Menu containing the menu item
     * @param {Boolean} checked - The _new_ checked state.
     */

    //region Init

    construct(config) {
        if (Array.isArray(config)) {
            config = {
                items : config
            };
        }

        super.construct(config);

        EventHelper.on({
            element    : this.element,
            click      : 'onMouseClick',
            mouseover  : 'onMouseOver',
            mouseleave : 'onMouseLeave',
            thisObj    : this
        });
    }

    afterShow(resolveFn) {
        // Don't instantiate all our items' subMenus right now.
        // Use our private _menu property which will still be a config item.
        const hasSubmenu = this.items.some(item => Boolean(item._menu));

        // afterShow is called before alignment, so this is the correct time
        // to mutate things which will change this Widget's size.
        if (hasSubmenu) {
            this.element.classList.add('b-menu-with-submenu');
        }

        // Add CSS class to menu if any item has an icon, to allow aligning icon-less items
        const hasIcon = this.items.some(item => item.icon);

        if (hasIcon) {
            this.element.classList.add('b-menu-with-icon');
        }

        super.afterShow(resolveFn);
    }

    createWidget(item) {
        if (typeof item === 'string') {
            item = {
                text : item
            };
        }

        return super.createWidget(item);
    }

    get focusElement() {
        const fromParentMenu = this.parentMenu && this.parentMenu.element.contains(document.activeElement),
            firstWidget = this.items[0];

        if (fromParentMenu || !(firstWidget instanceof MenuItem)) {
            return super.focusElement;
        }
        return this.element;
    }

    //endregion

    onDocumentMouseDown(event) {
        // It's not a click outside if its a click on our owner Menu
        if (!this.parentMenu || !this.parentMenu.owns(event.event.target)) {
            super.onDocumentMouseDown(event);
        }
    }

    //region Show

    hide(animate) {
        // We need to be _hidden when any focused descendants try to revertFocus
        // so that they continue to fall back through the getFocusRevertTarget upward chain.
        super.hide(animate);

        if (this.currentSubMenu && !this.currentSubMenu.isDestroyed) {
            this.currentSubMenu.hide(animate);
        }

        if (this.parentMenu) {
            this.parentMenu.currentSubMenu = null;
        }
    }

    //endregion

    //region Events

    /**
     * Activates a menu item if user clicks on it
     * @private
     */
    onMouseClick(event) {
        const me       = this,
            menuItem = event.target.closest('.b-menuitem');

        if (menuItem) {
            me.triggerElement(menuItem, event);

            // IE / Edge still triggers event listeners that were removed in a listener - prevent this
            event.stopImmediatePropagation();
        }
    }

    /**
     * Activates menu items on hover. On real mouse hover, not on a touchstart.
     * @private
     */
    onMouseOver(event) {
        const me = this;

        if (this.focusOnHover !== false) {
            const fromItemElement = DomHelper.up(event.relatedTarget, '.b-widget'),
                toItemElement   = DomHelper.up(event.target, '.b-widget'),
                overItem        = IdHelper.fromElement(toItemElement);

            // Activate soon in case they're moving fast over items.
            if (!DomHelper.isTouchEvent && toItemElement && toItemElement !== fromItemElement && overItem.parent === this) {
                me.setTimeout({
                    fn                : 'handleMouseOver',
                    delay             : 30,
                    args              : [overItem],
                    cancelOutstanding : true
                });
            }
        }
    }

    handleMouseOver(overItem) {
        overItem.focus();
    }

    // unselect any menu item if mouse leaves the menu element (unless it enters a child menu)
    onMouseLeave(event) {
        const me                = this,
            { relatedTarget } = event,
            leavingToChild    = relatedTarget && me.owns(relatedTarget);

        let targetCmp = relatedTarget && relatedTarget instanceof HTMLElement && IdHelper.fromElement(relatedTarget),
            shouldHideMenu = !leavingToChild;

        if (targetCmp) {
            while (targetCmp.ownerCmp) {
                targetCmp = targetCmp.ownerCmp;
            }

            // Or was found and does not belong to current menu DOM tree
            // This condition will not allow possibly existing picker to hide
            // Covered by Menu.t.js
            shouldHideMenu &= !DomHelper.getAncestor(targetCmp.element, [event.target]);
        }

        if (!leavingToChild && shouldHideMenu) {
            me.currentSubMenu && me.currentSubMenu.hide();
            me.currentSubMenu = me.selectedElement = null;

            // Deactivate currently active *menu items* on mouseleave
            if (me.element.contains(document.activeElement) && document.activeElement.matches('.b-menuitem')) {
                me.element.focus();
            }
        }
    }

    /**
     * Keyboard navigation. Up/down, close with esc, activate with enter
     * @private
     */
    onInternalKeyDown(event) {
        const sourceWidget = IdHelper.fromElement(event),
            isFromWidget = sourceWidget && sourceWidget !== this && !(sourceWidget instanceof MenuItem);

        if (event.key === 'Escape') {
            // Only close this menu if the ESC was in a child input Widget
            (isFromWidget ? this : this.rootMenu).close();
            return;
        }

        super.onInternalKeyDown(event);

        // Do not process keys from certain elemens
        if (isFromWidget) {
            return;
        }

        if (validKeys[event.key]) {
            event.preventDefault();
        }

        const active = document.activeElement,
            el = this.element;

        this.navigateFrom(active !== el && el.contains(active) ? active : null, event.key, event);
    }

    navigateFrom(active, key, event) {
        const me       = this,
            treeWalker = me.treeWalker,
            item       = active && me.getItem(active);

        let toActivate;

        switch (key) {
            case 'ArrowUp':
                treeWalker.currentNode = active || (active = me.bottomFocusTrap);
                treeWalker.previousNode();
                toActivate = treeWalker.currentNode;
                break;

            case 'ArrowDown':
                treeWalker.currentNode = active || (active = me.topFocusTrap);
                treeWalker.nextNode();
                toActivate = treeWalker.currentNode;
                break;

            case ' ':
                if (active && !active.classList.contains('b-disabled')) {
                    if (item && item.menu) {
                        me.openSubMenu(active, item);
                    }
                    else {
                        me.triggerElement(active, event);
                    }
                }
                break;

            case 'ArrowRight':
                if (active && item && item.menu && !active.classList.contains('b-disabled')) {
                    // opening with arrow keys highlights first item (as in menus on mac)
                    const openedMenu = me.openSubMenu(active, item);

                    // If show hs not been vetoed, ask it to focus.
                    // Container will delegate focus inward if possible.
                    if (openedMenu) {
                        openedMenu.focus();
                    }
                }
                else {
                    treeWalker.currentNode = active || (active = me.topFocusTrap);
                    treeWalker.nextNode();
                    toActivate = treeWalker.currentNode;
                }
                break;

            case 'ArrowLeft':
                if (me.isSubMenu) {
                    me.hide();
                }
                else if (!active) {
                    treeWalker.currentNode = active || (active = me.topFocusTrap);
                    treeWalker.nextNode();
                    toActivate = treeWalker.currentNode;
                }
                break;

            case 'Enter':
                if (active && !active.classList.contains('b-disabled')) {
                    me.triggerElement(active, event);
                }
                break;
        }

        // Move focus to wherever we have calculated
        if (toActivate) {
            // Previous moved to encapsulating element; wrap from end
            if (toActivate === me.element) {
                me.navigateFrom(me.bottomFocusTrap, 'ArrowUp', event);
            }
            // Next could not move because we're at the end; wrap from top
            else if (toActivate === active) {
                me.navigateFrom(me.topFocusTrap, 'ArrowDown', event);
            }
            else {
                toActivate.focus();
            }
        }
    }

    //endregion

    //region Activate menu item

    getItem(item) {
        // Cannot use truthiness test because index zero may be passed.
        if (item != null) {
            // Access by index
            if (typeof item === 'number') {
                return this.items[item];
            }
            // Access by element
            if (item.nodeType === 1) {
                return IdHelper.fromElement(item, 'menuitem', this.contentElement);
            }
            // Access by id
            else {
                return this.items.find(c => c.id == item);
            }
        }
    }

    /**
     * Activate a menu item (from its element)
     * @private
     * @fires item
     * @param menuItemElement
     */
    triggerElement(menuItemElement, event) {
        const menu   = this,
            item = menu.getItem(menuItemElement);

        // If the trigger gesture happened on a non-MenuItem
        // item will be undefined. Do not action on a non-MenuItem
        // or a disabled MenuItem
        if (item && !item.disabled) {
            item.doAction(event);
        }
    }

    /**
     * Returns true if this menu is a sub menu.
     * To find out which menu is the parent, check {@link #property-parentMenu}.
     * @type {boolean}
     * @readonly
     */
    get isSubMenu() {
        return this.owner && this === this.owner.menu;
    }

    /**
     * Opens a submenu anchored to a menu item
     * @private
     * @param element
     * @param item
     */
    openSubMenu(element, item) {
        const me = this,
            subMenu = item.menu;

        if (subMenu) {
            if (!subMenu.isVisible) {
                const event = { item, element };

                if (me.trigger('beforeSubMenu', event) === false) {
                    return;
                }
                if (item.onBeforeSubMenu && item.onBeforeSubMenu(event) === false) {
                    return;
                }
                subMenu.show();
            }

            /**
             * Currently open sub menu, if any
             * @member {Core.widget.Menu} currentSubMenu
             * @readonly
             */
            return me.currentSubMenu = subMenu;
        }
    }

    /**
     * Get/set focused menu item.
     * Shows submenu if newly focused item has a menu and is not disabled.
     * @property {HTMLElement}
     */
    set selectedElement(element) {
        const me = this,
            lastSelected = me._selectedElement;

        if (lastSelected) {
            const lastItem   = me.getItem(lastSelected),
                lastItemMenu = lastItem && lastItem.menu;

            if (lastItemMenu) {
                lastItemMenu.hide();
            }
            lastSelected.classList.remove('b-active');
        }

        me._selectedElement = element;

        // might set to null to deselect
        if (element) {
            const doFocus = DomHelper.isFocusable(element);

            element.classList.add('b-active');
            me.scrollable.scrollIntoView(element, {
                animate : !doFocus,
                focus   : doFocus
            });
        }
    }

    get selectedElement() {
        return this._selectedElement;
    }

    selectFirst() {
        const treeWalker = this.treeWalker;

        treeWalker.currentNode = this.topFocusTrap;
        treeWalker.nextNode();

        // If we are under keyboard control, this must happen in the next
        // animation frame so that the keydown event doesn't fire on the
        // newly focused node.
        this.requestAnimationFrame(() => treeWalker.currentNode.focus());
    }

    //endregion

    //region Close

    /**
     * Gets the parent Menu if this Menu is a submenu.
     * @returns {Core.widget.Menu} The parent menu if this is a submenu, otherwise, `undefined`.
     */
    get parentMenu() {
        let result = this.owner;

        if (result instanceof MenuItem) {
            result = result.owner;
        }
        if (result instanceof Menu) {
            return result;
        }
    }

    /**
     * Gets this menus root menu, the very first menu shown in a sub menu hierarchy
     * @property {Core.widget.Menu}
     * @private
     */
    get rootMenu() {
        let menu = this;

        while (menu.parentMenu && menu.parentMenu instanceof this.constructor) {
            menu = menu.parentMenu;
        }

        return menu;
    }

    //endregion
}

Menu._$name = 'Menu'; BryntumWidgetAdapterRegister.register('menu', Menu);

/**
 * Basic toast. Toasts are stacked on top of each other
 * @example
 * // simplest possible
 * Toast.show('Just toasting');
 *
 * // with config
 * Toast.show({
 *   html: 'Well toasted',
 *   showProgress: false
 * });
 *
 * // as instance (instance is also returned from Toast.show()
 * let toast = new Toast({
 *   html: 'Not going away',
 *   timeout: 0
 * });
 *
 * toast.show();
 *
 * @classType toast
 * @externalexample widget/Toast.js
 */
class Toast extends Widget {

    static get $name() {
        return 'Toast';
    }

    static get defaultConfig() {
        return {
            testConfig : {
                timeout : 100,
                destroyTimeout : 1
            },

            floating : true,

            /**
             * Timeout (in ms) until the toast is automatically dismissed. Set to 0 to never hide.
             * @config {Number}
             * @default
             */
            timeout : 2500,

            // How long to wait after hide before destruction
            destroyTimeout : 200,

            /**
             * Show a progress bar indicating the time remaining until the toast is dismissed.
             * @config {Boolean}
             * @default
             */
            showProgress : true,

            /**
             * Toast color (should have match in toast.scss or your custom styling).
             * Valid values in Bryntum themes are:
             * * b-amber
             * * b-blue
             * * b-dark-gray
             * * b-deep-orange
             * * b-gray
             * * b-green
             * * b-indigo
             * * b-lime
             * * b-light-gray
             * * b-light-green
             * * b-orange
             * * b-purple
             * * b-red
             * * b-teal
             * * b-white
             * * b-yellow
             *
             * ```
             * new Toast({
             *    color : 'b-blue'
             * });
             * ```
             *
             * @config {String}
             */
            color : null,

            bottomMargin : 20
        };
    }

    doDestroy() {
        const index = Toast.toasts.indexOf(this);

        if (index > -1) {
            Toast.toasts.splice(index, 1);
        }

        super.doDestroy();
    }

    // Toasts must not create their element until show.
    set element(element) {}

    get element() {
        // Toasts must not create their element until show.
        if (!this._element && !this.isConfiguring) {
            const
                me       = this,
                topToast = Toast.toasts.length && Toast.toasts[0].element,
                bottom   = topToast ? topToast._nextBottom : me.bottomMargin,
                element  = super.element = DomHelper.createElement({
                    parent   : me.appendTo || Widget.floatRoot,
                    children : me.showProgress ? [{
                        className : 'b-toast-progress',
                        style     : `animation-duration:${me.timeout / 1000}s;`
                    }] : null,
                    html      : me._html,
                    className : me.color || '',
                    style     : me._style || ''
                });

            EventHelper.on({
                element,
                click   : 'hide',
                thisObj : me
            });

            Toast.toasts.unshift(me);

            element._nextBottom = bottom + element.offsetHeight + me.bottomMargin;

            // Transitioned style props must be set dynamically
            element.style.cssText += `;bottom:${bottom}px;transform:translateY(0)`;
        }
        return super.element;
    }

    /**
     * Show the toast
     */
    show() {
        super.show();

        if (this.timeout > 0) {
            this.hideTimeout = this.setTimeout('hide', this.timeout);
        }
    }

    /**
     * Hide the toast
     */
    hide() {
        const me = this;
        if (!me.destroyTimer) {
            me.element.classList.add('b-toast-hide');
            me.element.style.bottom = '';
            me.destroyTimer = me.setTimeout('destroy', me.destroyTimeout);
        }
    }

    /**
     * Hide all visible toasts
     */
    static hideAll() {
        Toast.toasts.reverse().forEach(toast => toast.hide());
    }

    /**
     * Easiest way to show a toast
     * @param {String|Object} msgOrConfig Message or toast config object
     * @returns {Core.widget.Toast}
     * @example
     * Toast.show('Hi');
     * @example
     * Toast.show({
     *   html   : 'Read quickly, please',
     *   timeout: 1000
     * });
     */
    static show(msgOrConfig) {
        const toast = new Toast((typeof msgOrConfig === 'string') ? { html : msgOrConfig } : msgOrConfig);
        toast.show();
        return toast;
    }
}

Toast.toasts = [];

Toast._$name = 'Toast'; BryntumWidgetAdapterRegister.register('toast', Toast);

const realignTransitions = {
    left      : true,
    right     : true,
    top       : true,
    bottom    : true,
    transform : true
};

/**
 * @module Core/widget/Tooltip
 */

/**
 * Tooltip. Easiest way of assigning a tooltip to a widget is by setting {@link Core.widget.Widget#config-tooltip}, see example below.
 *
 * ```javascript
 * new Button {
 *     text    : 'Hover me',
 *     tooltip : 'Click me and you wont believe what happens next'
 * });
 * ```
 *
 * By default, tooltips of widgets use a singleton Tooltip instance which may be accessed from the
 * `{@link Core.widget.Widget Widget}` class under the name `Widget.tooltip`.
 * This is configured according to the config object on pointer over.
 *
 * To request a separate instance be created just for this widget, add `newInstance : true`
 * to the configuration:
 *
 * ```javascript
 * new Button {
 *     text    : 'Hover me',
 *     tooltip : {
 *         html        : 'Click me and you wont believe what happens next',
 *         newInstance : true
 *     }
 * });
 * ```
 *
 * You can ask for the singleton instance to display configured tips for your own DOM structure using
 * `data-btip` element attributes:
 *
 * ```html
 * <button class="my-button" data-btip="Contextual help for my button" data-btip-scroll-action="realign">Hover me</button>
 * ```
 *
 * ## Showing async content
 * To load remote content into a simple tooltip, just load your data in the `beforeShow` listener (but ensure that the {@link #property-activeTarget} is the same when the data arrives)
 *
 * ```javascript
 * new Tooltip({
 *     listeners : {
 *         beforeShow : ({ source : tip }) => tip.html = AjaxHelper.get('someurl').then(response => response.text());
 *     }
 * });
 * ```
 *
 * If you have multiple targets that should show a tooltip when hovered over, look at {@link #config-forSelector} and {@link #config-getHtml}.
 *
 * ```javascript
 * new Tooltip({
 *     forSelector : '.myCssClass',
 *     getHtml     : ({ source : tip }) => AjaxHelper.fetch('data').then(response => response.text())
 * });
 * ```
 *
 * @extends Core/widget/Popup
 * @classType tooltip
 * @externalexample widget/Tooltip.js
 */
class Tooltip extends Popup {
    //region Default config
    static get $name() {
        return 'Tooltip';
    }

    static get defaultConfig() {
        return {
            /**
             * Horizontal offset from mouse when {@link #config-anchorToTarget} is `false`
             * @config {Number}
             * @default
             */
            mouseOffsetX : 15,

            /**
             * Vertical offset from mouse when {@link #config-anchorToTarget} is `false`
             * @config {Number}
             * @default
             */
            mouseOffsetY : 15,

            floating : true,

            /**
             * A method called to update the tooltip's content when the cursor is moved over a target. It receives one argument containing context about the tooltip and show operation.
             * The function should return a string, or a Promise yielding a string.
             * @param {Object} context
             * @param {Core.widget.Tooltip} context.tip The tooltip instance
             * @param {HTMLElement} context.element The Element for which the Tooltip is monitoring mouse movement
             * @param {HTMLElement} context.activeTarget The target element that triggered the show
             * @param {Event} context.event The raw DOM event
             * @return {String|Promise}
             * @config {Function}
             */
            getHtml : null,

            /**
             * DOM element to attach tooltip to. By default, the mouse entering this element will kick off a timer
             * (see {@link #config-hoverDelay}) to show itself.
             *
             * If the {@link #config-forSelector} is specified, then mouse entering matching elements within the `forElement`
             * will trigger the show timer to start.
             *
             * Note that when moving from matching element to matching element within the `forElement`, the tooltip
             * will remain visible for {@link #config-hideDelay} milliseconds after exiting one element, so that rapidly
             * entering another matching element will not cause hide+show flicker. To prevent this behaviour configure
             * with `hideDelay: 0`.
             * @config {HTMLElement}
             */
            forElement : null,

            trackMouse : null,

            /**
             * By default, a tooltip displays static content. In the Scheduler however, there are
             * plenty of uses cases when the tip content is based on the current mouse position (dragging events, resizing events, schedule hover tip, drag creation of events etc). Set
             * to `true` to update contents on mouse movement.
             * @config {Boolean}
             * @private
             */
            updateContentOnMouseMove : false,

            /**
             * A CSS selector which targets child elements of the {@link #config-forElement} that should produce a tooltip when hovered over.
             * @config {String}
             */
            forSelector : null,

            /**
             * By default, when moving rapidly from target to target, if, when mouseing over
             * a new target, the tip is still visible, the tooltip does not hide, it remains
             * visible, but updates its content however it is configured to do so.
             *
             * Configure `hideOnDelegateChange : true` to have the tip hide, and then trigger
             * a new show delay upon entry of a new target while still visible.
             * @config {Boolean}
             * @default false
             */
            hideOnDelegateChange : null,

            /**
             * Set to true to anchor tooltip to the triggering target. If set to `false`, the tooltip
             * will align to the mouse position. When set to `false`, it will also set `anchor: false`
             * to hide anchor arrow.
             * @config {Boolean}
             * @default true
             */
            anchorToTarget : true,

            /**
             * Show on hover
             * @config {Boolean}
             * @default
             */
            showOnHover : false,

            /**
             * The amount of time to hover before showing
             * @config {Number}
             * @default
             */
            hoverDelay : 500,

            /**
             * Show immediately when created
             * @config {Boolean}
             * @default
             */
            autoShow : false,

            /**
             * The time (in milliseconds) that the Tooltip should stay visible for when it shows over its
             * target. If the tooltip is anchored to its target, then moving the mouse during this time
             * resets the timer so that the tooltip will remain visible.
             *
             * Defaults to `0` which means the Tooltip will persist until the mouse leaves the target.
             * @config {Number}
             * @default
             */
            dismissDelay : 0,

            /**
             * The time (in milliseconds) for which the Tooltip remains visible when the mouse leaves the target.
             *
             * May be configured as `false` to persist visible after the mouse exits the target element. Configure it
             * as 0 to always retrigger `hoverDelay` even when moving mouse inside `fromElement`
             * @config {Number}
             * @default
             */
            hideDelay : 500,

            /**
             * The message to show while an async tooltip is fetching its content.
             * @config {String}
             * @default
             */
            loadingMsg : 'Loading...',

            /**
             * Keep the tooltip open if user hovers it
             * @config {Boolean}
             * @default
             */
            allowOver : false,

            anchor   : true,
            align    : 'b-t',
            axisLock : true,

            showAnimation : null,
            hideAnimation : null,

            testConfig : {
                hideDelay  : 100,
                hoverDelay : 100
            }
        };
    }

    //endregion

    //region Events

    /**
     * Triggered when a mouseover event is detected on a potential target element.
     * Return false to prevent the action
     * @event pointerOver
     * @param {Core.widget.Tooltip} sourceThe tooltip instance.
     * @param {Event} event The mouseover event.
     */

    //endregion

    //region Properties

    /**
     * The HTML element that triggered this Tooltip to show
     * @member {HTMLElement} activeTarget
     */

    //endregion

    //region Init & destroy

    afterConstruct() {
        const me = this,
            { forSelector } = me;

        if (forSelector) {
            me.showOnHover = true;
            if (!me.forElement) {
                me.trackMouse = true;
                me.forElement = document.body;
            }
        }

        super.afterConstruct();

        // There's a triggering element, and we're showing on hover, add the mouse listeners
        if (me.forElement && me.showOnHover) {
            me.pointerOverOutDetacher = EventHelper.on({
                element   : me.forElement,
                mouseover : 'internalOnPointerOver',
                mouseout  : 'internalOnPointerOut',
                thisObj   : me
            });
        }

        if (me.autoShow) {
            me.show();
        }

        if (me.allowOver) {
            EventHelper.on({
                element    : me.element,
                mouseenter : 'onOwnElementMouseEnter',
                mouseleave : 'internalOnPointerOut',
                thisObj    : me
            });
        }
    }

    doDestroy() {
        this.pointerOverOutDetacher && this.pointerOverOutDetacher();

        super.doDestroy();
    }

    get focusElement() {
        const result = super.focusElement;
        if (result !== this.element) {
            return result;
        }
    }

    get anchorToTarget() {
        return this._anchorToTarget;
    }

    set anchorToTarget(anchorToTarget) {
        this._anchorToTarget = anchorToTarget;
        if (!anchorToTarget) this.anchor = false;
    }

    set trackMouse(trackMouse) {
        this._trackMouse = trackMouse;
    }

    get trackMouse() {
        // We do not track the mouse if we are anchored to (aligned to) the target
        return this._trackMouse && !this.anchorToTarget;
    }

    //endregion

    //region Hovering, show and hide

    onDocumentMouseDown({ event }) {
        const
            me = this,
            { pointerEvent } = me;

        // If it's a tap that is caused by the touch that was converted into a mousover we should not hide.
        // That is if it's a touch and at the same place and within 500ms
        if (pointerEvent && DomHelper.isTouchEvent) {
            if (event.pageX === pointerEvent.pageX && event.pageY === pointerEvent.pageY && me.activeTarget.contains(event.target) && (performance.now() - pointerEvent.timeStamp < 500)) {
                return;
            }
        }

        me.abortDelayedShow();

        super.onDocumentMouseDown({ event });
    }

    internalOnPointerOver(event) {
        const me = this,
            forElement = me.forElement,
            forSelector = me.forSelector,
            activeTarget = me.activeTarget;
        let newTarget;

        if (me.disabled) {
            return;
        }

        // If the mouse moves over this tooltip, it is theoretically a mouseout of its
        // forElement, but allowOver lets us tolerate this ane remain visible.
        if (me.allowOver && me.element.contains(event.target)) {
            return;
        }

        // There's been a mouseover. If we have a forSelector, we have to check
        // if it's an enter of a matching child
        if (forSelector) {
            // Moving inside a forSelector matching element
            if (activeTarget && activeTarget.contains(event.target) && activeTarget.contains(event.relatedTarget)) {
                return;
            }
            newTarget = event.target.closest(forSelector);

            // Mouseovers while within a target do nothing
            if (newTarget && event.relatedTarget && event.relatedTarget.closest(forSelector) === newTarget) {
                return;
            }
        }
        // There's no forSelector, so check if we moved from outside the target
        else if (!forElement.contains(event.relatedTarget)) {
            newTarget = forElement;
        }
        // Mouseover caused by moving from child to child inside the target
        else {
            return;
        }

        // If pointer entered the target or a forSelector child, then show.
        if (newTarget) {
            me.handleForElementOver(event, newTarget);
        }
        // If over a non-forSelector child, behave as in forElement out
        else if (activeTarget) {
            me.handleForElementOut();
        }
    }

    // Handle a transitioned reposition when the activeTarget moved beneath the pointer.
    // When it comes to an end, if the mouseout has not hidden, then realign at the new position
    // if the activeTarget is still beneath the pointer.
    onTransitionEnd(event) {
        const me = this,
            currOver = Tooltip.currentOverElement;

        if (realignTransitions[event.propertyName]) {
            // Don't realign if the mouse is over this, and is allowed to be over this
            // If user is interacting with this Toolltip, they won't expect it to move.
            if (me.allowOver && me.element.contains(currOver)) {
                return;
            }

            // If we are still visible, and mouse is still over the activeTarget, realign
            if (me.activeTarget && me.activeTarget.contains(currOver) && !me.trackMouse) {
                me.realign();
            }
        }
    }

    handleForElementOver(event, newTarget) {
        const me = this;

        // Vetoed, then behave as is a targetout
        if (me.trigger('pointerOver', { event, target : newTarget }) === false) {
            me.internalOnPointerOut(event);
        }
        else {
            me.pointerEvent = event;
            me.abortDelayedHide();

            // We are over a new target. If we are still visible, we
            // do not want to hide to avoid flickering. But if there is a
            // beforeshow listener which may mutate us, we still have to
            // consult it. If it returns a veto, then we do in fact hide.
            // Under normal circumstances we just alignTo the new target.
            // We must handle the post show tasks like starting the dismiss timer etc.
            if (me.isVisible && !me.hideOnDelegateChange) {
                me.updateActiveTarget(newTarget);
                if (me.trigger('beforeShow') === false) {
                    return me.hide();
                }

                me.updateContents();

                me.alignTo({
                    target  : me.anchorToTarget ? newTarget : new Point(me.pointerEvent.pageX - window.pageXOffset + me.mouseOffsetX, me.pointerEvent.pageY - window.pageYOffset + me.mouseOffsetY),
                    overlap : !(me.anchorToTarget && me.anchor)
                });
                me.trigger('show');
                me.afterShowByTarget();
            }
            else {
                if (me.hideOnDelegateChange) {
                    me.hide();
                }
                me.updateActiveTarget(newTarget);
                me.delayShow(newTarget);
            }
        }
    }

    delayShow(target) {
        const me = this;

        // Caught in an animation - cancel it
        if (me.currentAnimation) {
            me.cancelHideShowAnimation();
            me._hidden = true;
        }

        if (!me.isVisible && !me.hasTimeout('show')) {
            // Allow hoverDelay:0 or rapid movement from delegate to delegate to show immediately
            if (!me.hoverDelay || (me.forSelector && Date.now() - me.lastHidden < me.quickShowInterval)) {
                me.updateContents();
                me.showByTarget(target);
            }
            else {
                // If a mouse down happens during the delay period, we cancel the show
                me.addDocumentMouseDownListener();

                // If we're not going to anchor to the hovered element, then we need to keep track
                // of mousemoves until the show happens so we can show where the mouse currently is.
                if (!me.listeningForMouseMove && !me.anchorToTarget) {
                    me.mouseMoveRemover = EventHelper.on({
                        element   : document,
                        mousemove : 'onMouseMove',
                        thisObj   : me
                    });
                }
                // If a tap event triggered, do not wait. Show immediately.
                me.setTimeout(() => {
                    if (!DomHelper.isOrphaned(target)) {
                        me.updateContents();
                        me.showByTarget(target);
                    }
                }, (!me.pointerEvent || me.pointerEvent.type === 'mouseover') ? me.hoverDelay : 0, 'show');
            }
        }
        else if (me.isVisible) {
            me.showByTarget(target);
        }
    }

    updateContents() {
        const me = this;

        if (me.getHtml) {
            me.html = me.getHtml({
                tip          : me,
                element      : me.element,
                activeTarget : me.activeTarget,
                event        : me.pointerEvent
            });
        }
    }

    /**
     * Shows a spinner and a message to indicate an async flow is ongoing
     * @param {String} message The message, defaults to {@link #config-loadingMsg}
     */
    showAsyncMessage(message = this.L(this.loadingMsg)) {
        // TODO: Load masking should ideally use a general Widget ability.
        if (message) {
            this.html = `<div class="b-tooltip-loading"><div class="b-icon b-icon-spinner"></div>${message}</div>`;
        }
    }

    showByTarget(target) {
        const me = this;

        if (me.mouseMoveRemover) {
            me.mouseMoveRemover();
            me.mouseMoveRemover = null;
        }

        // Show by the correct thing.
        // If we are not anchored to the target, then it's the current pointer event.
        // Otherwise it's the activeTarget.
        me.showBy({
            target  : me.anchorToTarget ? target : new Point(me.pointerEvent.pageX - window.pageXOffset + me.mouseOffsetX, me.pointerEvent.pageY - window.pageYOffset + me.mouseOffsetY),
            overlap : !(me.anchorToTarget && me.anchor)
        });
    }

    afterShowByTarget() {
        const me = this,
            dismissDelay = me.dismissDelay;

        me.abortDelayedShow();
        if (dismissDelay) {
            me.setTimeout('hide', dismissDelay);
        }
        me.toFront();
    }

    updateActiveTarget(newTarget) {
        const me = this,
            lastTarget = me.activeTarget;

        me.activeTarget = newTarget;

        if (!me.isConfiguring) {
            me.trigger('overtarget', { newTarget, lastTarget });
        }
    }

    internalOnPointerOut(event) {
        const me = this,
            toElement = event.relatedTarget;

        // Edge case: If there is no space to fit the tooltip, and as a result of showing the tooltip - the mouse is over the tooltip
        // Make sure we don't end up in an infinite hide/show loop
        if (me.allowOver && me.element.contains(toElement)) {
            return;
        }

        // If we were in an allowOver situation and exited
        // into the activeTarget, do nothing; in this situation
        // the tip is treated as if it were part of the target.
        if (me.element.contains(event.target) && me.activeTarget && me.activeTarget.contains(toElement)) {
            return;
        }

        // We have exited the active target
        if (me.activeTarget && !me.activeTarget.contains(event.relatedTarget)) {
            me.handleForElementOut();
        }
    }

    handleForElementOut() {
        // Separated from onTargetOut so that subclasses can handle target out in any way.
        const me = this,
            { hideDelay } = me;

        // Allow outside world to veto the hide
        if (me.trigger('pointerOut') === false) {
            me.activeTarget = null;
            return;
        }

        me.abortDelayedShow();

        // Even if there is a hide timer, it's a *dismiss* timer which hides the tip
        // after a hover time. We begin a new delay on target out.
        if (me.isVisible && hideDelay !== false) {
            me.abortDelayedHide();
            if (hideDelay > 0) {
                me.setTimeout('hide', hideDelay);
            }
            else {
                // Hide immediately when configured with `hideDelay: 0`. Used by async cell tooltips that always should
                // retrigger `hoverDelay`, to not spam the backend
                me.hide();
            }
        }
    }

    show() {
        const me = this;

        // If we know what element to show it by, and we are anchoring to it
        // and there's no ambiguity with a selector for sub elements,
        // then show it by our forElement (Unless we're being called from showBy)
        if (me.forElement && me.anchorToTarget && !me.forSelector && !me.inShowBy) {
            me.showByTarget(me.forElement);
        }
        // All we can do is the basic Widget show.
        else {
            if (me.inShowBy) {
                me.y = -10000;
            }
            super.show();
        }

        me.afterShowByTarget();
        // If we've shown, and are tracking the mouse and not anchored to (aligned to) the target, track the mouse
        if (!me.mouseMoveRemover && !me._hidden && (me.trackMouse || me.updateContentOnMouseMove)) {
            me.mouseMoveRemover = EventHelper.on({
                element   : document,
                mousemove : 'onMouseMove',
                thisObj   : me
            });
        }

        if (me.forElement && !me.transitionEndDetacher && !me._hidden) {
            me.transitionEndDetacher = EventHelper.on({
                element       : me.forElement,
                transitionend : 'onTransitionEnd',
                thisObj       : me
            });
        }
    }

    hide(...args) {
        const me = this;

        if (me.isVisible) {
            me.abortDelayedShow();
            me.abortDelayedHide();

            super.hide(...args);

            me.lastHidden = Date.now();
            me.activeTarget = null;
            if (me.mouseMoveRemover) {
                me.mouseMoveRemover();
                me.mouseMoveRemover = null;
            }

            if (me.transitionEndDetacher) {
                me.transitionEndDetacher();
                me.transitionEndDetacher = null;
            }

            me.listeningForMouseMove = false;
        }
    }

    abortDelayedShow() {
        const me = this;
        if (me.hasTimeout('show')) {
            me.clearTimeout('show');

            if (me.mouseMoveRemover) {
                me.mouseMoveRemover();
                me.mouseMoveRemover = null;
            }

            if (me.transitionEndDetacher) {
                me.transitionEndDetacher();
                me.transitionEndDetacher = null;
            }
        }
    }

    /**
     * Stops both timers which may hide this tooltip, the one which counts down from mouseout
     * and the one which counts down from mouseover show for dismissDelay ms
     * @private
     */
    abortDelayedHide()    {
        this.clearTimeout('hide');
    }

    realign(el) {
        const me = this,
            spec = me.lastAlignSpec,
            clippedBy = me.clippedBy;

        // If we are hidden because our align target scrolled, or otherwise
        // moved out of its clipping boundaries, then check if it's moved back in.
        // For example EventDrag might move the element outside of the scheduler
        // SubGrid, which will cause the tip to hide, but then moving it back in
        // must reshow it.
        if (!me.isConfiguring && clippedBy && !me.isVisible && spec && spec.targetHidden) {
            const target = Rectangle.from(spec.target, me.positioned ? me.element.offsetParent : null, !me.positioned),
                clippedTarget = target.intersect(clippedBy);

            // If there is an intersecting Rectangle with the forElement, align
            if (clippedTarget) {
                me.show();
                spec.targetHidden = false;
            }
        }

        super.realign(el);
    }

    alignTo(spec) {
        const me = this;

        if (!me.isVisible) return;

        // If mouse pointer is over this, do not attempt
        // to call the getHtml method.
        if (!(me.pointerEvent && me.element.contains(me.pointerEvent.target))) {
            
            if (spec.nodeType === 1) {
                spec = {
                    target : spec
                };
            }
        }

        super.alignTo(spec);
    }

    //endregion

    //region Tooltip contents

    set html(htmlOrPromise) {
        const me = this;

        if (htmlOrPromise === false) {
            VersionHelper.deprecate('Grid', '5.0.0', 'Setting false to indicate loading is deprecated, in favor of `showAsyncMessage`. Please see https://bryntum.com/docs/grid/#guides/upgrades/3.0.1.md for more information');
            this.showAsyncMessage();
            return;
        }
        else if (htmlOrPromise instanceof Promise) {
            me.showAsyncMessage();
            htmlOrPromise.target = me.activeTarget;

            htmlOrPromise.then(html => {
                // Cursor might have exited the element while loading
                if (htmlOrPromise.target === me.activeTarget) {
                    me.html = html;
                }
            });

            return;
        }
        else if (htmlOrPromise != null) {
            htmlOrPromise = me.L(String(htmlOrPromise)); // in case a number was passed in
        }

        // we have something to show...
        if (htmlOrPromise) {
            super.html = htmlOrPromise;

            if (me.isVisible) {
                // Must realign before restoring getHtml, to not get stuck in infinite html setting loop
                me.realign();
            }

            me.trigger('innerHtmlUpdate');
        }
        else { // do not show empty tooltips
            me.hide();
        }
    }

    /**
     * Get/set the HTML to display. When specifying HTML, this widget's element will also have `b-html` added to its
     * classList, to allow targeted styling. To create async tooltip and show the {@link #config-loadingMsg}, see code below:
     * For example:
     *
     * ```javascript
     * new Tooltip({
     *     listeners : {
     *         beforeShow : ({ source : tip }) => {
     *             tip.showAsyncMessage();
     *             AjaxHelper.get('someurl').then(response => tip.html = 'Done!');
     *         }
     *     }
     * });
     * ```
     *
     * @property {String}
     * @category DOM
     */
    get html() {
        return super.html;
    }

    //endregion

    //region Events

    /**
     * Mouse move event listener which updates tooltip
     * @private
     */
    onMouseMove(event) {
        const
            me = this,
            x = event.pageX - window.pageXOffset + me.mouseOffsetX,
            y = event.pageY - window.pageYOffset + me.mouseOffsetY,
            // If we are trackMouse: true
            // we must keep out of the way of the mouse by continuing
            // to track if we are on the way out due to a hide timer.
            isHiding = me.hasTimeout('hide'),
            target   = event.target;

        // MouseMove is listened for during the hover show timer wait phase if anchorToTarget is false
        // so that when the timer fires, it can show near the most recent pointer position.
        // It's also listened for after show when we are not anchored to the target and so tracking the mouse.
        me.pointerEvent = event;

        // Check that we are still valid to be visible, and if so, track the mouse.
        if (!me._hidden) {
            let hideVetoed;

            const isElementOut = me.forSelector && me.activeTarget && !isHiding && target.nodeType === 1 && !target.matches(me.forSelector) && !(me.allowOver && me.element.contains(target));

            // Check whether the element we are over is still a valid delegate matching the forSelector,
            // or it's the tip element, and we're allowOver. If not, we have to hide.
            // nodeType check is for FF on Linux, event.target is sometimes a text node
            if (isElementOut) {
                hideVetoed = me.handleForElementOut();
            }
            // If we are not hiding due to moving mouse outside our forElement (or hide being vetoed), tooltip stays visible and optionally realigns based on trackMouse setting.
            if (hideVetoed || !isHiding || me.forElement.contains(target)) {
                // Mousemoves restart the dismiss timer.
                if (me.dismissDelay && !isHiding) {
                    me.setTimeout('hide', me.dismissDelay);
                }

                if (me.updateContentOnMouseMove && me.getHtml) {
                    me.html = me.getHtml({
                        tip        : me,
                        element    : me.element,
                        forElement : me.activeTarget,
                        event      : event
                    });
                }

                // If we're not anchoring to the target, track the mouse
                if (me.trackMouse) {
                    me.alignTo({
                        position         : new Point(x, y),
                        ignorePageScroll : true
                    });
                }
            }
        }
    }

    onOwnElementMouseEnter(event) {
        this.abortDelayedHide();
    }
    //endregion
}

EventHelper.on({
    element    : document,
    mouseenter : event => Tooltip.currentOverElement = event.target,
    capture    : true
});

/**
 * Updated dynamically with the current element that the mouse is over. For use when showing a Tooltip
 * from code which is not triggered by a pointer event so that a tooltip can be positioned.
 * @member {HTMLElement} currentOverElement
 * @readonly
 * @static
 */

Tooltip._$name = 'Tooltip'; BryntumWidgetAdapterRegister.register('tooltip', Tooltip);

Widget.tooltip = new Tooltip({
    id          : 'bryntum-tooltip',
    forElement  : window,
    forSelector : '[data-btip]',
    header      : true,  // So that we can set a title
    resetCfg    : {},
    listeners   : {
        // Reconfigure on pointerOver
        pointerOver({ source : me, target }) {
            // Revert last pointerOver config set to initial setting.
            for (const key in me.resetCfg) {
                if (key === 'listeners') {
                    me.un(me.resetCfg[key].set);
                }
                else {
                    if ('was' in me.resetCfg[key]) {
                        me[key] = me.resetCfg[key].was;
                    }
                    else {
                        delete me[key];
                    }
                }
            }
            me.resetCfg = {};

            const forComponent = IdHelper.get(target.id);

            // If it's a component's tooltip, configure from the component,
            // Otherwise gather from the dataset
            const config = forComponent ? forComponent.tipConfig : me.gatherDataConfigs(target.dataset);

            for (const key in config) {
                me.resetCfg[key] = {
                    set : config[key]
                };
                // If no property, the reset must delete it.
                if (me.hasOwnProperty(key)) {
                    me.resetCfg[key].was = me[key];
                }

                if (key === 'listeners') {
                    me.on(config[key]);
                }
                else {
                    me[key] = config[key];
                }
            }
            me.headerElement.style.display = me.title ? '' : 'none';
        }
    },
    gatherDataConfigs(dataset) {
        const
            me = this,
            config = {};

        for (const key in dataset) {
            if (key.startsWith('btip')) {
                if (key.length > 4) {
                    const configProp = StringHelper.lowercaseFirstLetter(key.substr(4)); // Snip off "btip" prefix to convert to property name

                    // If we have a config by the name, set it
                    if (configProp in me.getDefaultConfiguration()) {
                        const value = dataset[key];

                        // gather the found config value
                        config[configProp] = isNaN(value) ? value : parseInt(value, 10);
                    }
                }
                else {
                    config.html = dataset[key];
                }
            }
        }
        return config;
    }
});

/**
 * @module Core/widget/mixin/Badge
 */

/**
 * Mixin that allows a widget to display a badge (mostly done as css)
 *
 * @example
 * // show badge
 * button.badge = 5;
 *
 * // hide badge
 * button.badge = null;
 *
 * @externalexample widget/Badge.js
 *
 * @mixin
 */
var Badge = Target => class Badge extends (Target || Base) {
    construct(config) {
        super.construct(config);

        // set after we have element to display badge from start
        if (this._badge) this.badge = this._badge;
    }

    /**
     * Initial text to show in badge
     * @config {String} badge
     */

    /**
     * Get/sets and display badge, set to null or empty string to hide
     * @property {String}
     */
    set badge(badge) {
        const { element } = this;

        this._badge = badge;

        if (element) {
            if (badge != null && badge !== '') {
                element.dataset.badge = badge;
                element.classList.add('b-badge');
            }
            else {
                if (element.dataset.badge) delete element.dataset.badge;
                element.classList.remove('b-badge');
            }
        }
    }

    get badge() {
        return this._badge;
    }

    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {
        // If we don't have a badge, our classList doesn't include "b-badge"
        if (this.badge) {
            return 'b-badge';
        }
    }
};

//TODO: should togglebutton be own class implemented as input type=checkbox?
//TODO: A toggling widget's focusElement should be an opacity:0 input type=checkbox which covers the clickable area.

/**
 * @module Core/widget/Button
 */

const
    bIcon$1 = /^b-icon-/,
    bFa$1 = /^b-fa-/;

/**
 * Button widget, wraps and styles a regular <code>&lt;button&gt;</code> element. Can display text and icon and allows specifying button color.
 *
 * @extends Core/widget/Widget
 * @mixes Core/widget/mixin/Badge
 *
 * @example
 * // button with text and icon
 * let button = new Button({
 *   icon: 'b-fa-plus-circle',
 *   text: 'Add',
 *   color: 'green',
 *   onClick: () => {}
 * });
 *
 * @classType button
 * @externalexample widget/Button.js
 */
class Button extends Badge(Widget) {
    //region Config
    static get $name() {
        return 'Button';
    }

    static get defaultConfig() {
        return {
            /**
             * Button icon class.
             *
             * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
             *
             * Otherwise this is a developer-defined CSS class string which results in the desired icon.
             * @config {String}
             */
            icon : null,

            /**
             * Icon class for the buttons pressed state. Only applies to toggle buttons
             *
             * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
             *
             * Otherwise this is a developer-defined CSS class string which results in the desired icon.
             *
             * ```
             * new Button({
             *    // Icon for unpressed button
             *    icon        : 'b-fa-wine-glass',
             *
             *    // Icon for pressed button
             *    pressedIcon : 'b-fa-wine-glass-alt',
             *
             *    // Only applies to toggle buttons
             *    toggleable  : true
             * });
             * ```
             *
             * @config {String}
             */
            pressedIcon : null,

            /**
             * Button icon alignment. May be `'start'` or `'end'`. Defaults to `'start'`
             * @config {String}
             */
            iconAlign : 'start',

            /**
             * Button text
             * @config {String}
             */
            text : '',

            /**
             * Button color (should have match in button.scss or your custom styling). Valid values in Bryntum themes
             * are:
             * * b-amber
             * * b-blue
             * * b-dark-gray
             * * b-deep-orange
             * * b-gray
             * * b-green
             * * b-indigo
             * * b-lime
             * * b-light-gray
             * * b-light-green
             * * b-orange
             * * b-purple
             * * b-red
             * * b-teal
             * * b-white
             * * b-yellow
             * Combine with specifying `b-raised` for raised/filled style (theme dependent).
             *
             * ```
             * new Button({
             *    color : 'b-teal b-raised'
             * });
             * ```
             *
             * @config {String}
             */
            color : null,

            /**
             * Enabled toggling of the button (stays pressed when pressed).
             * @config {Boolean}
             * @default
             */
            toggleable : false,

            /**
             * Initially pressed or not. Only applies with `toggleable = true`.
             * ```
             * const toggleButton = new Button({
             *    toggleable : true,
             *    text : 'Enable cool action'
             * });
             * ```
             * @config {Boolean}
             * @default
             */
            pressed : false,

            /**
             * Indicate that this button is part of a group where only one button can be pressed. Assigning a value
             * also sets `toggleable` to `true`.
             * ```
             * const yesButton = new Button({
             *    toggleGroup : 'yesno',
             *    text        : 'Yes'
             * });
             *
             * const noButton = new Button({
             *    toggleGroup : 'yesno',
             *    text        : 'No'
             * });
             * ```
             * @config {String}
             */
            toggleGroup : null,

            ripple : {
                radius : 75
            },

            defaultBindProperty : 'text',

            localizableProperties : ['text'],

            /**
             * A submenu configuration object, or an array of MenuItem configuration
             * objects from which to create a submenu which is shown when this button is pressed.
             *
             * Note that this does not have to be a Menu. The `type` config can be used
             * to specify any widget as the submenu.
             *
             * May also be specified as a fully instantiated {@link Core.widget.Widget#config-floating floating Widget}
             * such as a {@link Core.widget.Popup Popup}.
             * @config {Object|Object[]|Core.widget.Widget}
             */
            menu : null,

            onMenuHideTimeout : 300,

            testConfig : {
                onMenuHideTimeout : 0
            }
        };
    }

    template() {
        const me = this;

        return TemplateHelper.tpl`
            <button class="${me.color || ''} ${me.toggleable && me.pressed ? 'b-pressed' : ''}" ${me.toggleGroup ? `data-group="${me.toggleGroup}"` : ''}>
                \xa0
            </button>
        `;
    }

    //endregion

    //region Construct/Destroy

    construct(config = {}, ...args) {
        if (config.toggleGroup) {
            config.toggleable = true;
        }

        super.construct(config, ...args);

        EventHelper.on({
            element : this.element,
            click   : 'onInternalClick',
            thisObj : this
        });
    }

    doDestroy() {
        this.destroyProperties('menu');
        super.doDestroy();
    }

    //endregion

    eachWidget(fn, deep = true) {
        const { menu } = this;

        if (menu) {
            if (fn(menu) === false) {
                return;
            }
            if (deep && menu.eachWidget) {
                menu.eachWidget(fn, deep);
            }
        }
    }

    onFocusOut(e) {
        super.onFocusOut(e);
        if (this.menu) {
            this.menu.hide();
        }
    }

    //region Getters/Setters

    get focusElement() {
        return this.element;
    }

    /**
     * Get/set text displayed on the button.
     * @property {String}
     */
    get text() {
        return this._text;
    }

    set text(text) {
        const { element } = this;

        if (text == null) {
            text = '';
        }

        element.lastChild.data = this._text = text;
        element.classList[String(text).length ? 'add' : 'remove']('b-text');
    }

    /**
     * Returns the instantiated menu widget as configured by {@link #config-menu}.
     * @property {Core.widget.Widget}
     * @readonly
     */
    get menu() {
        const me = this;

        let result = me._menu;

        if (result && !(result instanceof Widget)) {
            // This covers both Array and Object which are valid items config formats.
            // menu could be { itemRef : { text : 'sub item 1 } }. But if it has
            // child items or html property in it, it's the main config
            if (typeof result === 'object' && !(('items' in result) || ('widgets' in result) || ('html' in result))) {
                result = {
                    items : result
                };
            }
            result = me.menu = WidgetHelper.createWidget(Object.assign({
                type         : 'menu',
                autoShow     : false,
                autoClose    : true,
                scrollAction : 'realign',
                constrainTo  : document.body,
                forElement   : me.element,
                align        : 't0-b0',
                owner        : me,
                onHide() {
                    // In case the reason for the hide is a mousedown
                    // on this button, wait until after any impending
                    // click handler to sync our state with the visibility.
                    me.setTimeout(() => me.toggle(false), me.onMenuHideTimeout);
                }
            }, result));
        }

        return result;
    }

    set menu(menu) {
        this._menu = menu;

        // We are toggleable if there's a menu.
        // Pressed means menu visible, not pressed means menu hidden.
        this.toggleable = Boolean(menu);
    }

    /**
     * Get/set button pressed state
     * @property {Boolean}
     */
    set pressed(pressed) {
        const me = this;

        if (pressed && me.toggleGroup) {
            DomHelper.forEachSelector(`button[data-group=${me.toggleGroup}]`, btnEl => {
                if (btnEl !== me.element) {
                    WidgetHelper.getById(btnEl.id).toggle(false);
                }
            });
        }

        me._pressed = pressed;

        if (me.element) me.element.classList[pressed ? 'add' : 'remove']('b-pressed');
    }

    get pressed() {
        return this._pressed;
    }

    /**
     * Get/set the Button icon
     * @property {String}
     */
    set icon(icon) {
        this._icon = icon;
        this.syncIconCls();
    }

    get icon() {
        return this._icon;
    }

    /**
     * Get/set the Button pressed icon
     * @property {String}
     */
    set pressedIcon(icon) {
        this._pressedIcon = icon;
        this.syncIconCls();
    }

    get pressedIcon() {
        return this._pressedIcon;
    }

    /**
     * Get/Set the Button icon alignment.
     * May be `'start'` or `'end'`. Defaults to `'start'`
     * @property {String}
     */

    set iconAlign(iconAlign) {
        const
            me       = this,
            oldAlign = me._iconAlign;

        if (iconAlign !== oldAlign) {
            if (oldAlign) {
                me.element.classList.remove(`b-icon-align-${oldAlign}`);
            }
            me.element.classList.add(`b-icon-align-${iconAlign}`);
            me._iconAlign = iconAlign;
        }
    }

    get iconAlign() {
        return this._iconAlign;
    }

    //endregion

    //region Events

    /**
     * Triggers events when user clicks button
     * @fires click
     * @fires action
     * @private
     */
    onInternalClick(event) {
        const me = this,
            bEvent = { event };

        if (me.toggleable) {
            // Clicking the pressed button in a toggle group should do nothing
            if (me.toggleGroup && me.pressed) {
                return;
            }

            me.toggle(!me.pressed);
        }

        /**
         * User clicked button
         * @event click
         * @property {Core.widget.Button} button - Clicked button
         * @property {Event} event - DOM event
         */
        me.trigger('click', bEvent);

        /**
         * User performed the default action (clicked the button)
         * @event action
         * @property {Core.widget.Button} button - Clicked button
         * @property {Event} event - DOM event
         */
        // A handler may have resulted in destruction.
        if (!me.isDestroyed) {
            me.trigger('action', bEvent);
        }

        // since Widget has Events mixed in configured with 'callOnFunctions' this will also call onClick and onAction

        // stop the event since it has been handled
        event.preventDefault();
        event.stopPropagation();
    }

    //endregion

    //region Toggle

    /**
     * Toggle button state (only use with toggleable = true)
     * @param {Boolean} pressed Specify to force a certain toggle state
     * @fires toggle
     */
    toggle(pressed = null) {
        const
            me       = this,
            { menu } = me;

        if (!me.toggleable) {
            return;
        }

        if (pressed === null) {
            pressed = !me.pressed;
        }

        me.pressed = pressed;

        // For handlers from the code below to detect and avoid recursion
        me.toggling = true;

        if (menu) {
            menu.minWidth = me.width;
            menu[pressed ? 'show' : 'hide']();
        }

        me.syncIconCls();

        /**
         * Button state was toggled
         * @event toggle
         * @property {Core.widget.Button} button - Button
         * @property {Boolean} pressed - New pressed state
         */
        me.trigger('toggle', { pressed });

        me.toggling = false;
    }

    //endregion

    //region Other

    syncIconCls() {
        const me = this;
        let iconEl = me._iconEl;

        if (me.icon) {
            if (!iconEl) {
                iconEl = me._iconEl = DomHelper.createElement({
                    tag         : 'i',
                    nextSibling : me.element.firstChild
                });
            }

            const iconCls = (me.pressed && me.pressedIcon) ? me.pressedIcon : me.icon;
            me._iconEl.className = iconCls;

            // if it's a supplied icon class b-fa-xxx or b-icon-xxx, add extra class
            // so user doesn't have to; they can just specify the icon
            if (bIcon$1.test(iconCls)) {
                iconEl.classList.add('b-icon');
            }
            else if (bFa$1.test(iconCls)) {
                iconEl.classList.add('b-fa');
            }
        }
        else {
            iconEl && iconEl.remove();
        }
    }

    //endregion
}

Button._$name = 'Button'; BryntumWidgetAdapterRegister.register('button', Button);

/**
 * @module Core/widget/ButtonGroup
 */

/**
 * A specialized container that holds buttons, displaying them in a horizontal group with borders adjusted to make them
 * stick together.
 *
 * Trying to add other widgets than buttons will throw an exception.
 *
 * ```javascript
 * new ButtonGroup({
 *   items : [
 *       { icon : 'b-fa b-fa-kiwi-bird' },
 *       { icon : 'b-fa b-fa-kiwi-otter' },
 *       { icon : 'b-fa b-fa-kiwi-rabbit' },
 *       ...
 *   ]
 * });
 * ```
 *
 * @externalexample widget/ButtonGroup.js
 * @classType buttonGroup
 * @extends Core/widget/Container
 */
class ButtonGroup extends Container {
    static get $name() {
        return 'ButtonGroup';
    }

    static get defaultConfig() {
        return {
            defaultType : 'button',

            /**
             * Custom CSS class to add to element. When using raised buttons (cls 'b-raised' on the buttons), the group
             * will look nicer if you also set that cls on the group.
             *
             * ```
             * new ButtonGroup({
             *   cls : 'b-raised,
             *   items : [
             *       { icon : 'b-fa b-fa-unicorn', cls : 'b-raised' },
             *       ...
             *   ]
             * });
             * ```
             *
             * @config {String}
             * @category CSS
             */
            cls : null,

            /**
             * An array of Buttons or typed Button config objects.
             * @config {Object[]|Core.widget.Button[]}
             */
            items : null,

            /**
             * Default color to apply to all contained buttons, see {@link Core.widget.Button#config-color Button#color}.
             * Individual buttons can override the default.
             * @config {String}
             */
            color : null,

            /**
             * Set to `true` to turn the ButtonGroup into a toggle group, assigning a generated value to each contained
             * buttons {@link Core.widget.Button#config-toggleGroup toggleGroup config}. Individual buttons can
             * override the default.
             */
            toggleGroup : null,

            valueSeparator : ',',

            columns : null
        };
    }

    construct(config = {}) {
        super.construct(config);

        // track button clicks to update value
        this.items.forEach(w => w.on('click', this.onItemClick, this));
    }

    onItemClick() {
        // reset cached value to revalidate next time it's requested
        this._value = null;
    }

    createWidget(widget) {
        const me = this;

        if (me.color && !widget.color) {
            widget.color = me.color;
        }

        if (me.toggleGroup && !widget.toggleGroup) {

            if (typeof me.toggleGroup === 'boolean') {
                me.toggleGroup = IdHelper.generateId('toggleGroup');
            }

            widget.toggleGroup = me.toggleGroup;
        }

        if (me.columns) {
            widget.width = `${100 / me.columns}%`;
        }

        const button = super.createWidget(widget);

        if (!(button instanceof Button)) {
            throw new Error('A ButtonGroup can only contain buttons');
        }

        return button;
    }

    get value() {
        // if we don't have cached value
        // let's calculate it based on item values
        if (!this._value) {
            const values = [];

            // collect pressed item values
            this.items.forEach(w => {
                if (w.pressed && w.value !== undefined) values.push(w.value);
            });

            // build a string
            this._value = values.join(this.valueSeparator);
        }

        return this._value;
    }

    set value(value) {
        if (!Array.isArray(value)) {
            if (value === undefined || value === null) {
                value = [];
            }
            else if (typeof value == 'string') {
                value = value.split(this.valueSeparator);
            }
            else {
                value = [value];
            }
        }

        this._value = value;

        // reflect value on items
        this.items.forEach(w => {
            if (w.value !== undefined) {
                w.pressed = value.indexOf(w.value) > -1;
            }
        });
    }

    get disabled() {
        return super.disabled;
    }

    set disabled(state) {
        super.disabled = state;
        this.items.forEach(w => w.disabled = state);
    }

    get widgetClassList() {
        const classList = super.widgetClassList;
        // if the buttons should be shown in rows
        if (this.columns) classList.push('b-columned');
        return classList;
    }
}

ButtonGroup._$name = 'ButtonGroup'; BryntumWidgetAdapterRegister.register('buttonGroup', ButtonGroup);

/**
 * @module Core/util/ClickRepeater
 */

/**
 * A helper class, which, when applied to an {@link #config-element} means that a mousedown
 * and hold on that element will, after a configured {@link #config-delay}, begin
 * autorepeating `click` events on that element, starting at a rate of
 * {@link #config-startRate} clicks per second, and over {@link #config-accelerateDuration}
 * milliseconds, accelerate to firing clicks at {@link #config-endRate} times per second.
 *
 * An example of this is used by the {@link Core.widget.NumberField NumberField}'s
 * spinner triggers.
 */
class ClickRepeater extends Delayable(Base) {
    static get defaultConfig() {
        return {
            /**
             * The element on which to fire autorepeating `click` events when the mouse is held down.
             * @config {HTMLElement}
             */
            element : null,

            /**
             * A query selector which specifies subtargets of this ClickRepeater's {@link #config-element}
             * which act as the click auto repeat event targets.
             * @config {String}
             * @default
             */
            delegate : null,

            /**
             * How long in milliSeconds to pause before starting the click repeats.
             * @config {Number}
             * @default
             */
            delay : 500,

            /**
             * Clicks per second to start firing after the initial {@link #config-delay}
             * @config {Number}
             * @default
             */
            startRate : 2,

            /**
             * Clicks per second to fire at top speed, after accelerating over the {@link #config-accelerateDuration}
             * @config {Number}
             * @default
             */
            endRate : 20,

            /**
             * How long in millieconds to accelerate from the
             * {@link #config-startRate} to the {@link #config-startRate}.
             * @config {Number}
             * @default
             */
            accelerateDuration : 4000
        };
    }

    doDestroy() {
        this.mousedownRemover && this.mousedownRemover();
        super.doDestroy();
    }

    set element(element) {
        this._element = element;

        this.mousedownRemover = EventHelper.on({
            element,
            mousedown : 'onMouseDown',
            thisObj   : this
        });
    }

    get element() {
        return this._element;
    }

    onMouseDown(e) {
        const me = this,
            target = me.delegate ? e.target.closest(me.delegate) : me.element;

        if (target) {
            me.triggerEvent = e;
            EventHelper.lockComposedPath(me.triggerEvent);

            me.activeListenerRemover = EventHelper.on({
                mouseup : {
                    element : document,
                    handler : 'onMouseUp'
                },
                mousemove : {
                    element : target,
                    handler : 'onTargetMouseMove'
                },
                mouseleave : {
                    element : target,
                    handler : 'onTargetMouseLeave'
                },
                mouseenter : {
                    element : target,
                    handler : 'onTargetMouseEnter'
                },
                thisObj : me
            });

            me.setTimeout('startAutoRepeat', me.delay);
        }
    }

    onMouseUp(e) {
        const me = this;

        me.acceleration && me.acceleration.cancel();
        me.activeListenerRemover && me.activeListenerRemover();
        me.clearTimeout('startAutoRepeat');
        me.clearTimeout(me.repeatTimer);
    }

    onTargetMouseLeave() {
        this.clearInterval(this.repeatTimer);
    }

    onTargetMouseEnter(e) {
        this.triggerEvent = e;
        this.fireClick();
    }

    onTargetMouseMove(e) {
        this.triggerEvent = e;
    }

    startAutoRepeat() {
        const me = this;

        me.interval = me.startInterval = 1000 / me.startRate;
        me.accelerationDelta = me.startInterval - 1000 / me.endRate;

        // Begin animating the interval from 1000/me.startRate to 1000/me.endRate
        me.fireClick();
        me.acceleration = FunctionHelper.animate(me.accelerateDuration, me.nextTick, me, 'easeOutQuad');
    }

    nextTick(progress) {
        this.interval = this.startInterval - (this.accelerationDelta * progress);
    }

    fireClick() {
        const me = this,
            clickEvent = new MouseEvent('click', me.triggerEvent);

        me.triggerEvent.target.dispatchEvent(clickEvent);
        me.repeatTimer = me.setTimeout(me.fireClick, me.interval);
    }
}
ClickRepeater._$name = 'ClickRepeater';

/**
 * @module Core/widget/Field
 */

const
    byWeight$1 = (l, r) => (l.weight || 0) - (r.weight || 0),
    byWeightReverse$1 = (l, r) => (r.weight || 0) - (l.weight || 0),
    arrayOption = { array : true };

/**
 * Base class for {@link Core.widget.TextField TextField} and {@link Core.widget.NumberField NumberField}. Not to be used directly.
 * All subclasses can be used as editors for the {@link Grid.column.Column Column}. The most popular are:
 * - {@link Core.widget.TextField TextField};
 * - {@link Core.widget.NumberField NumberField};
 * - {@link Core.widget.DateField DateField};
 * - {@link Core.widget.TimeField TimeField};
 * - {@link Core.widget.Combo Combo};
 *
 * @extends Core/widget/Widget
 * @mixes Core/widget/mixin/Badge
 * @abstract
 */
class Field extends Badge(Widget) {

    //region Config
    static get $name() {
        return 'Field';
    }

    static get defaultConfig() {
        return {
            /**
             * Text to display in empty field.
             * @config {String} placeHolder
             */

            /**
             * Default value
             * @config {String}
             */
            value : '',

            /**
             * Label, prepended to field
             * @config {String}
             */
            label : null,

            /**
             * The labels to add either before or after the input field.
             * Each label may have the following properties:
             * * `html` The label text.
             * * `align` `'start'` or `'end'` which end of the field the label should go.
             * @config {Object}
             */
            labels : null,

            /**
             * Configure as `true` to indicate that a `null` field value is to be marked as invalid.
             * @config {Boolean}
             * @default false
             */
            required : null,

            /**
             * Show a trigger to clear field, and allow `ESC` key to clear field if this field is
             * not {@link #config-readOnly}. The trigger is available in the {@link #property-triggers} object
             * under the name `clear`.
             * @config {Boolean}
             * @default false
             */
            clearable : null,

            /**
             * If this field is not {@link #config-readOnly}, then setting this option means that pressing
             * the `ESCAPE` key after editing the field will revert the field to the value it had when
             * the user focused the field. If the field is _not_ changed from when focused, the {@link #config-clearable}
             * behaviour will be activated.
             * @config {Boolean}
             * @default false
             */
            revertOnEscape : null,

            /**
             * The width to apply to the `<label>` element. If a number is specified, `px` will be used.
             * @config {String|Number}
             */
            labelWidth : null,

            /**
             * The width to apply to the `<input>` element. If a number is specified, `px` will be used.
             * @config {String|Number}
             */
            inputWidth : null,

            /**
             * The delay in milliseconds to wait after the last keystroke before triggering a change event.
             * Set to 0 to not trigger change events from keystrokes (listen for input event instead to have
             * immediate feedback, change will still be triggered on blur)
             * @config {Number}
             * @default
             */
            keyStrokeChangeDelay : 0,

            /**
             * Makes the field unmodifiable by user action. The input area is not editable, and triggers
             * are unresponsive.
             *
             * This is a wider-acting setting than {@link #config-editable} which *only* sets the
             * `readOnly` attribute of the `<input>` field.
             *
             * PickerFields such as `Combo` and `DateField` can be `edtable : false`, but still
             * modifiable through the UI.
             * @config {Boolean}
             */
            readOnly : null,

            /**
             * Set to false to prevent user from editing the field. For TextFields it is basically the same as setting
             * {@link #config-readOnly}, but for PickerFields there is a distinction where it allows you to pick a value
             * but not to type one in the field.
             *
             * PickerFields such as `Combo` and `DateField` can be `edtable : false`, but still
             * modifiable through the UI.
             * @config {Boolean}
             * @default true
             */
            editable : true,

            defaultAction : 'change',

            /**
             * The triggers to add either before or after the input field. Each property name is the reference by which an
             * instantiated Trigger Widget may be retrieved from the live `{@link #property-triggers}` property.
             * Each trigger may have the following properties:
             * * `cls` The CSS class to apply.
             * * `handler` A method in the field to call upon click
             * * `align` `'start'` or `'end'` which end of the field the trigger should go.
             * * `weight` (Optional) Heigher weighted triggers gravitate towards the input field.
             * @config {Object}
             */
            triggers : null,

            /**
             * Specify `false` to prevent field from being highlighted when on external value changes
             * @config {Boolean}
             */
            highlightExternalChange : true,

            localizableProperties : ['label', 'title', 'placeholder'],

            autoSelect : false,

            /**
             * Sets the native `autocomplete` property of the underlying input element. For more information, please refer to
             * [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete)
             * @config {String}
             * @default
             */
            autoComplete : 'off',

            /**
             * Sets custom attributes of the underlying input element. For more information, please refer to
             * [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes)
             * @config {Object}
             * @default
             */
            inputAttributes : null,

            updatedClsDuration : 1500,

            testConfig : {
                updatedClsDuration : 10
            }
        };
    }

    doDestroy() {
        const
            me           = this,
            { triggers } = me,
            errorTip = Field._errorTip;

        me.inputListenerRemover && me.inputListenerRemover();
        me.keyListenerRemover && me.keyListenerRemover();

        super.doDestroy();

        if (triggers) {
            for (const t of Object.values(triggers)) {
                t.destroy();
            }
        }

        // The errorTip references this field, hide it when we die.
        if (errorTip && errorTip.field === me) {
            errorTip.hide();
        }
    }

    /**
     * A singleton error tooltip which activates on hover of invalid fields.
     * before show, it gets a reference to the field and interrogates its
     * active error list to display as the tip content.
     * @member {Core.widget.Tooltip}
     * @readonly
     */
    get errorTip() {
        return this.constructor.errorTip;
    }

    /**
     * A singleton error tooltip which activates on hover of invalid fields.
     * before show, it gets a reference to the field and interrogates its
     * active error list to display as the tip content.
     * @member {Core.widget.Tooltip}
     * @readonly
     * @static
     */
    static get errorTip() {
        return Field._errorTip || (Field._errorTip = new Tooltip({
            id           : 'bryntum-field-errortip',
            cls          : 'b-field-error-tip',
            forSelector  : '.b-field.b-invalid .b-field-inner',
            align        : 'l-r',
            scrollAction : 'realign',
            onBeforeShow() {
                const tip = this,
                    field = IdHelper.fromElement(tip.activeTarget);

                if (field) {
                    const errors = field.getErrors();

                    if (errors) {
                        tip.html = errors.join('<br>');
                        tip.field = field;
                        return true;
                    }
                }

                // Veto show
                return false;
            }
        }));
    }

    //endregion

    //region Event
    /**
     * User typed into the field
     * @event input
     * @param {Core.widget.Field} source - The field
     * @param {String} value - Value
     */

    /**
     * Fired when the field value changes
     * @event change
     * @param {String} value - Value
     * @param {String} oldValue - Previous value
     * @param {Boolean} userAction - Triggered by user taking an action (`true`) or by setting a value (`false`)
     * @param {Core.widget.Field} source - Field
     */

    /**
     * User performed default action (typed into the field)
     * @event click
     * @param {Core.widget.Field} field - Field
     * @param {String} value - Value
     */

    /**
     * User clicked fields clear icon
     * @event clear
     * @param {Core.widget.Field} field - Field
     */

    /*
     * User clicked on one of the field's {@link #property-triggers}
     * @event trigger
     * @param {Core.widget.Field.Trigger} trigger The trigger activated by click or touch tap.
     * @param {Core.widget.Field} trigger.field The trigger's owning Field.
     */

    //endregion

    //region Init

    construct(config) {
        const me = this;

        me.highlightChanged = me.createOnFrame('addUpdatedCls');
        super.construct(config);

        if (me.keyStrokeChangeDelay) {
            me.changeOnKeyStroke = me.buffer(me.internalOnChange, me.keyStrokeChangeDelay);
        }
    }

    onFocusIn(e) {
        this.valueOnFocus = ObjectHelper.clone(this.value);
        super.onFocusIn(e);
    }

    onFocusOut(e) {
        super.onFocusOut(e);

        // Required field not flagged with error initially, flag on blur instead for better appearance
        this.updateRequired();

        // Check field consistency on blur
        this.onEditComplete();
    }

    /**
     * Template function which may be implemented by subclasses to synchronize
     * input state and validity state upon completion of the edit.
     * @internal
     */
    onEditComplete() {

    }

    set element(element) {
        const me = this,
            value = me.initialConfig.value,
            innerElements = DomHelper.createElementFromTemplate(me.inputTemplate(me), arrayOption),
            children = [{
                className : 'b-field-inner',
                reference : 'inputWrap',
                children  : innerElements
            }],
            startTriggers = [],
            endTriggers = [];

        const labels = me.labels || [];

        if (me.label) {
            labels.push({
                reference : 'labelElement',
                html      : me.label
            });
        }

        if (labels) {
            labels.forEach(label => {
                const entry = Object.assign({
                    tag       : 'label',
                    htmlFor   : `${me.id}_input`,
                    className : `b-align-${label.align || 'start'}`
                }, label);

                if (!label.align || label.align === 'start') {
                    children.unshift(entry);
                }
                else {
                    children.push(entry);
                }
            });
        }

        // Read the clearable config which will force evaluation of triggers
        // to include clearable trigger.
        me._thisIsAUsedExpression(me.clearable);

        for (const triggerRef in me.triggers) {
            const trigger = me.triggers[triggerRef];

            if (trigger.align === 'start') {
                startTriggers.unshift(trigger);
            }
            else {
                endTriggers.push(trigger);
            }
        }

        // The triggers at each end are sorted "gavitationally".
        // Higher weight sorts towards the center which is the input element.
        startTriggers.sort(byWeight$1);
        endTriggers.sort(byWeightReverse$1);
        innerElements.unshift(...startTriggers.map(t => t.element));
        innerElements.push(...endTriggers.map(t => t.element));

        super.element = {
            className : labels.length ? 'b-has-label' : '',
            children
        };

        // Value must be injected into the input element after it has been constructed, not in the
        // initial template, otherwise the caret position will not be as expected.
        if (value != null) {
            me.value = value;
        }

        me.updateEmpty();
        me.updateInvalid();

        const keyEventElement = me.input || me.focusElement;

        if (keyEventElement) {
            me.keyListenerRemover = EventHelper.on({
                element  : keyEventElement,
                thisObj  : me,
                keydown  : 'internalOnKeyPress',
                keypress : 'internalOnKeyPress',
                keyup    : 'internalOnKeyPress'
            });
        }
    }

    get element() {
        return super.element;
    }

    //endregion

    //region Focus & select

    get focusElement() {
        return this.input;
    }

    /**
     * Selects the field contents. Optionally may be passed a start and end.
     * NOTE: This method is async for IE11
     * @param {Number} [start] The start index from which to select the input.
     * @param {Number} [end] The index at which to end the selection of the input.
     */
    select(start, end) {
        // Use focusElement which is the input field in this class
        // but allows subclasses to use other elements.
        // See, for example, TextAreaField
        const input = this.focusElement;

        if (input.value.length) {

            if (arguments.length === 0) {
                this.selectAll();
                return;
            }

            // Only allowed to select range in certain element / input types
            if (!this.supportsTextSelection) {
                return;
                // throw new Error('Trying to select text on an invalid element type');
            }

            if (BrowserHelper.isIE11) {
                // this.clearTimeout(this.selectTimeout);

                // HACK: IE focus processing is async and we can't select text until field is focused
                // Getting flaky exception in IE, something timing related. Found no way to detect it so using this
                // workaround for now
                input.focus();
                input.setSelectionRange(start, end);
                //
                // this.selectTimeout = this.setTimeout(() => {
                //     input && input.setSelectionRange(start, end);
                // }, 10);
            }
            else {
                input.setSelectionRange(start, end);
            }
        }
    }

    moveCaretToEnd() {
        const input = this.input;

        if (input.createTextRange) {
            const range = input.createTextRange();
            range.collapse(false);
            range.select();
        }
        else if (this.supportsTextSelection) {
            // Move caret to the end if possible
            this.select(input.value.length, input.value.length);
        }

    }

    selectAll() {
        this.focusElement.select();
    }

    // called on value changes to update styling of empty vs non-empty field
    updateEmpty() {
        const { isEmptyInput, isEmpty, element, clearIcon } = this,
            empty = isEmptyInput && isEmpty;

        if (element) {
            if (clearIcon) {
                // IE11...
                clearIcon.classList[empty ? 'add' : 'remove']('b-icon-hidden');
            }

            // IE11...
            element.classList[empty ? 'add' : 'remove']('b-empty');
        }
    }

    updateInvalid() {
        this.updatingInvalid = true;

        const { isValid, element, errorTip, inputWrap } = this;

        if (element) {
            element.classList[isValid ? 'remove' : 'add']('b-invalid');

            // We achieved validity, so ensure the error tip is hidden
            if (isValid) {
                if (errorTip.isVisible && errorTip.field === this) {
                    errorTip.hide();
                }
            }
            // If the mouse is over, the tip should spring into view
            else if (inputWrap.contains(Tooltip.currentOverElement)) {
                // Already shown by this field's inputWrap, just update content.
                if (errorTip.activeTarget === inputWrap && errorTip.isVisible) {
                    errorTip.onBeforeShow();
                }
                else {
                    errorTip.activeTarget = inputWrap;
                    errorTip.showBy(inputWrap);
                }
            }
        }

        this.updatingInvalid = false;
    }

    //endregion

    //region Getters/setters

    get attributeString() {
        const me = this;

        let attributeString = me.attributes.map(attr => me[attr] != null ? `${attr.toLowerCase()}="${me[attr]}"` : '').join(' ');

        // add custom attributes provided
        if (me.inputAttributes) {
            attributeString += Object.keys(me.inputAttributes).map(key => `${key}="${me.inputAttributes[key]}"`).join(' ');
        }

        return attributeString;
    }

    get editable() {
        return this._editable;
    }

    set editable(editable) {
        const
            me    = this,
            input = me.input;

        me._editable = editable;

        // Editable refers *ONLY* to the readOnly state of the <input> field within the field.
        // It does *NOT* imply that the field is not modifiable by user interaction.
        // For example, a Combo or DateField may be not editable, but may still be set through the UI.
        // It is the readOnly config which disables user interaction from modifying the field.
        if (input) {
            input.readOnly = editable === false ? 'readOnly' : null;

            if (editable !== false) {
                me.inputListenerRemover = EventHelper.on({
                    element : input,
                    thisObj : me,
                    focus   : 'internalOnInputFocus',
                    change  : 'internalOnChange',
                    input   : 'internalOnInput'
                });
            }
            else {
                me.inputListenerRemover && me.inputListenerRemover();
            }
        }
    }

    set clearable(clearable) {
        this._clearable = clearable;
        if (clearable && !this.triggers) {
            this.triggers = {};
        }
    }

    get clearable() {
        return this._clearable;
    }

    /**
     * The trigger Widgets as specified by the {@link #config-triggers} configuration and the {@link #config-clearable} configuration.
     * Each is a {@link Core.widget.Widget Widget} instance which may be hidden, shown and observed and styled just like any other widget.
     * @property {Object}
     */
    set triggers(triggers) {
        const me = this,
            myTriggers = me._triggers = {};

        if (me.clearable) {
            (triggers || (triggers = {})).clear = {
                cls : 'b-icon-remove',
                handler() {
                    me._isUserAction = true;
                    me.clear();
                    me._isUserAction = false;
                },
                weight : 1000
            };
        }

        for (const triggerRef in triggers) {
            myTriggers[triggerRef] = WidgetHelper.createWidget(ObjectHelper.assign({
                type      : 'trigger',
                reference : triggerRef,
                parent    : me
            }, triggers[triggerRef]), me.defaultTriggerType || 'trigger');
        }
    }

    get triggers() {
        return this._triggers;
    }

    set labelWidth(labelWidth) {
        if (this.labelElement) {
            this.labelElement.style.flex = `0 0 ${DomHelper.setLength(labelWidth)}`;

            // If there's a label width, the input must conform with it, and not try to expand to 100%
            this.inputWrap.style.flexBasis = (labelWidth == null) ? '' : 0;
        }
    }

    /**
     * Get/set fields label. Please note that the Field needs to have a label specified from start for this to work,
     * otherwise no element is created.
     * @property {String}
     */
    get label() {
        return this._label;
    }

    set label(label) {
        if (label === null || label === undefined) label = '';
        this._label = label;
        // since value is used in template it is not certain that element is available
        // TODO: move the code from template here instead
        if (this.labelElement) {
            // using innerHTML since we sometimes use icons as label
            this.labelElement.innerHTML = label;
        }
    }

    /**
     * Get/set read only
     * @property {Boolean}
     */
    get readOnly() {
        // Fields which are disabled cannot be updated.
        // This ensures ESC and clear click won't be able to clear disabled fields.
        return this._readOnly || this.disabled;
    }

    set readOnly(readOnly) {
        const me = this;

        readOnly = Boolean(readOnly);

        if (Boolean(me._readOnly) !== readOnly) {
            me._readOnly = readOnly;

            me.element.classList[readOnly ? 'add' : 'remove']('b-readonly');

            // If Setting to readOnly, we make the input field non-editable.
            // But we must save the editability to *restore* it when we clear
            // our readOnly state. For example, ComboBoxes and Date and Time fields
            // (and any picker fields) can all be editable : false while allowing
            // user modification.
            if (readOnly) {
                me.readWriteEditability = me.editable;

                // readOnly: true does imply that the <input> is not editable
                me.editable = false;
            }
            else {
                // But on the converse side, readOnly: false merely means allow UI modification
                // of the field. The developer's <input> editability setting must be honoured.
                me.editable = me.readWriteEditability;
            }
        }
    }

    /**
     * Returns true if the field value is valid
     * @type {Boolean}
     * @readonly
     */
    get isValid() {
        const me = this;

        // Disabled fields are considered valid
        if (!me.disabled) {
            me.updateRequired();

            if (me.errors && ObjectHelper.getTruthyValues(me.errors).length) {
                return false;
            }
            if (me.input && me.input.validity) {
                return me.input.validity.valid;
            }
        }

        return true;
    }

    /**
     * Returns true if the field value is empty
     * @type {boolean}
     * @readonly
     */
    get isEmpty() {
        return this.value == null || this.value === '';
    }

    /**
     * Returns true if the field's input is empty
     * @type {boolean}
     * @readonly
     */
    get isEmptyInput() {
        return !this.input || this.input.value == null || this.input.value === '';
    }

    /**
     * Gets or sets the value. The returned type will depend upon the Field subclass.
     *
     * `TextField` returns a `String`.
     *
     * `NumberField` returns a `Number`.
     *
     * `DateField` and `TimeField` return a `Date` object, and `null` if the field is empty.
     *
     * `Combo` will return a `String` if configured with `items` as a simple string array.
     * Otherwise it will return the {@link Core.widget.Combo#config-valueField} value from the
     * selected record, or `null` if no selection has been made.
     * @property {*}
     */
    get value() {
        return this._value;
    }

    set value(value) {
        const
            me       = this,
            oldValue = me._value;

        if (me.hasChanged(oldValue, value)) {
            me._value = value;

            // Do not flag with error if configured empty, looks ugly to have fields start red
            if (!me.isConfiguring) {
                me.updateRequired();

                // Do not trigger change event during configuration phase
                // or during keyboard input
                if (!me.inputting) {
                    // trigger change event, signaling that origin is from set operation,
                    // makes it easier to ignore such events in applications that set value on load etc
                    me.triggerChange();
                }
            }

            // lastValue is used for IE to check if a change event should be triggered when pressing ENTER
            if (!me.inputting) {
                me._lastValue = value;
            }

            me.syncInputFieldValue();
        }
        // When loading a record into a form, an empty value might be loaded into a field, which is not detected as a
        // change. In this scenario it should still be flagged as invalid
        else if (value === '') {
            me.updateRequired();
        }
    }

    /**
     * Compare's this field's value with its previous value. May be overridden in subclasses
     * which have more complex value types. See, for example, {@link Core.widget.DurationField}.
     * @param {*} oldValue
     * @param {*} newValue
     * @private
     */
    hasChanged(oldValue, newValue) {
        return newValue !== oldValue;
    }

    /**
     * Called by the base Field class's `set value` to sync the state of the UI with the field's value.
     *
     * Relies upon the class implementation of `get inputValue` to return a string representation of
     * the value for user consumption and editing.
     * @private
     */
    syncInputFieldValue(skipHighlight = false) {
        const
            me       = this,
            { input } = me;

        // If we are updating from internalOnInput, we must not update the input field
        if (input && !me.inputting) {
            // Subclasses may implement their own read only inputValue property.
            me.input.value = me.inputValue;

            // If it's being manipulated from the outside, highlight it
            if (!me.isConfiguring && !me.containsFocus && me.highlightExternalChange) {
                input.classList.remove('b-field-updated');
                me.clearTimeout('removeUpdatedCls');
                if (!skipHighlight && (!me.parent || !me.parent.isSettingValues)) {
                    me.highlightChanged();
                }
            }
        }
        me.updateEmpty();
        me.updateInvalid();
    }

    addUpdatedCls() {
        this.input.classList.add('b-field-updated');
        this.setTimeout('removeUpdatedCls', this.updatedClsDuration);
    }

    removeUpdatedCls() {
        this.input.classList.remove('b-field-updated');
    }

    /**
     * A String representation of the value of this field for {@link #function-syncInputFieldValue} to use
     * as the input element's value.
     *
     * Subclasses may override this to create string representations.
     *
     * For example, {@link Core.widget.DateField}'s implementation will format the field date
     * value according to its configured {@link Core.widget.DateField#config-format}. And {@link Core.widget.Combo}'s
     * implementation will return the {@link Core.widget.Combo#config-displayField} of the selected record.
     * @internal
     * @readOnly
     */
    get inputValue() {
        // Do not use the _value property. If called during configuration, this
        // will import the configured value from the config object.
        return this.value == null ? '' : this.value;
    }

    get supportsTextSelection() {
        const input = this.focusElement;

        // Text selection using setSelectionRange is allowed in Chrome for certain elements. Edge supports it even for input[type=number]
        return input && (input.tagName.toLowerCase() === 'textarea' || (input.type && (/text|search|password|tel|url/.test(input.type) || BrowserHelper.isEdge)));
    }

    //endregion

    //region Events

    internalOnInputFocus() {
        const length = this.input.value.length;

        // Help IE to set caret at the end like the other browsers
        if (BrowserHelper.isIE11 && length && !this.autoSelect) {
            this.select(length, length);
        }
    }

    /**
     * Trigger event when fields input changes
     * @fires change
     * @private
     */
    internalOnChange(event) {
        const me = this;

        // Don't trigger change if we enter invalid value or if value has not changed (for IE when pressing ENTER)
        if (me.isValid && me.hasChanged(me._lastValue, me.value)) {
            me.triggerChange(event, true);
            me._lastValue = me.value;
        }
    }

    triggerChange(event, userAction = Boolean(this._isUserAction)) {
        const
            me  = this,
            {
                value,
                _lastValue : oldValue,
                // TODO: The `internalOnChange`-path excludes invalid changes, while the `set value`-path includes them
                isValid    : valid
            } = me;

        // trigger change event, signaling that origin is from user
        me.trigger('change', { value, oldValue, event, userAction, valid });

        // per default Field triggers action event on change, but might be reconfigured in subclasses (such as Combo)
        if (me.defaultAction === 'change') {
            me.trigger('action', { value, oldValue, event, userAction, valid });
        }

        // since Widget has Events mixed in configured with 'callOnFunctions' this will also call onClick and onAction
    }

    /**
     * Trigger event when user inputs into field
     * @fires input
     * @param event
     * @private
     */
    internalOnInput(event) {
        const me = this;

        // Keep the value synced with the inputValue at all times.
        me.inputting = true;
        me.value = me.input.value;
        me.inputting = false;

        me.trigger('input', { value : me.value, event });

        me.changeOnKeyStroke && me.changeOnKeyStroke(event);

        // since Widget has Events mixed in configured with 'callOnFunctions' this will also call onInput
    }

    internalOnKeyPress(event) {
        const
            me        = this,
            { value } = me;

        let stopEvent = false;

        if (event.type === 'keydown') {
            if (event.key === 'Escape' && !me.readOnly) {
                // We can be started with an initialValue which takes precedence over the valueOnFocus.
                // Because in some situations focus can move out and back in after a change which needs
                // to be revertable. For example in cell editing.
                const
                    initialValue   = ('initialValue' in me) ? me.initialValue : me.valueOnFocus,
                    valueChanged   = me.hasChanged(initialValue, value),
                    needsInputSync = me.input.value !== String(me.inputValue);

                // We revert on escape if we are configured to do so AND:
                // We are in an invalid state, or the value has changed, or the displayed value doesn't match the field value.
                if (me.revertOnEscape && (!me.isValid || valueChanged || needsInputSync)) {
                    if (valueChanged) {
                        me.value = initialValue;
                    }
                    if (needsInputSync) {
                        me.syncInputFieldValue(true);
                    }
                    me.clearError();
                    stopEvent = true;
                }
                else if (me.clearable && (value || me.input.value)) {
                    me.clear();
                }
            }
            // #5730 - IE11 doesn't trigger "change" event by Enter click
            else if (event.key === 'Enter' && BrowserHelper.isIE11) {
                me.internalOnChange(event);
            }
        }

        // The above processing might have destructive consequences.
        if (!me.isDestroyed) {
            // If the keystroke had the effect of changing the field, prevent other handlers
            // which may mask that effect. Such as ESC exiting some UI context. Keep it contained.
            if (stopEvent) {
                event.stopImmediatePropagation();
            }
            me.trigger(event.type, { event });
        }
    }

    clear() {
        this.value = null;

        this.trigger('clear');
    }

    /**
     * Called when disabled state is changed.
     * Used to add or remove 'b-invalid' class for the invalid field based on current disabled state.
     * @private
     */
    onDisabled() {
        this.updateInvalid();
    }

    //endregion

    //region Error

    updateRequired() {
        const me = this;

        if (!me.isConfiguring && me.required && (me.value === '' || me.value == null)) {
            me.setError('fieldRequired', me.updatingInvalid);
        }
        else {
            me.clearError('fieldRequired', me.updatingInvalid);
        }
    }

    /**
     * Adds an error message to the list of errors on this field.
     * By default the field's valid/invalid state is updated; pass
     * `false` as the second parameter to disable that if multiple
     * changes are being made to the error state.
     * @param {String} error A locale string, or message to use as an error message.
     * @param {Boolean} [silent=false] Pass as `true` to skip updating the field's valid/invalid state.
     */
    setError(error, silent) {
        (this.errors || (this.errors = {}))[error] = this.L(error);

        if (!silent) {
            this.updateInvalid();
        }
    }

    /**
     * Removes an error message from the list of errors on this field.
     * By default the field's valid/invalid state is updated; pass
     * `false` as the second parameter to disable that if multiple
     * changes are being made to the error state.
     * @param {String} [error] A locale string, or message to remove. If not passed, all errors are cleared.
     * @param {Boolean} [silent=false] Pass as `true` to skip updating the field's valid/invalid state.
     */
    clearError(error, silent) {
        if (this.errors) {
            if (error) {
                delete this.errors[error];
            }
            else {
                this.errors = {};
            }
        }
        if (!silent) {
            this.updateInvalid();
        }
    }

    /**
     * Returns an array of error messages as set by {@link #function-setError}, or
     * `undefined` if there are currently no errors.
     * @return {String[]} The errors for this field, or `undefined` if there are no errors.
     */
    getErrors() {
        if (!this.isValid) {
            const errors = this.errors ? ObjectHelper.getTruthyValues(this.errors) : [this.input.validationMessage || this.L('invalidValue')];

            if (errors && errors.length) {
                return errors;
            }
        }
    }

    //endregion

}

/**
 * Base class for field triggers May be configured with a `cls` and a `handler` which is a function (or name of a function)
 * in the owning Field.
 * @extends Core/widget/Widget
 */
Field.Trigger = class FieldTrigger extends Widget {
    static get $name() {
        return 'FieldTrigger';
    }

    static get defaultConfig() {
        return {
            align : null
        };
    }

    template() {
        return `<div class="b-icon b-align-${this.align || 'end'}"></div>`;
    }

    construct(config) {
        super.construct(config);

        EventHelper.on({
            element : this.element,
            click   : {
                handler : 'onClick',
                thisObj : this
            },
            mousedown : {
                handler : 'onMousedown',
                thisObj : this
            }
        });
    }

    onClick(e) {
        const me = this,
            field = me.field,
            handler = (typeof me.handler === 'function') ? me.handler : field[me.handler];

        if (field.disabled || field.readOnly) {
            return;
        }

        if (handler && field.trigger('trigger', {
            trigger : me
        }) !== false) {
            handler.call(field, e);
        }
    }

    onMousedown(e) {
        const field = this.field,
            isKeyEvent = ('key' in e);

        // If it's a touch tap on the trigger of an editable, then
        // avoid the keyboard by setting the field to not be editable
        // before focusing the field. Reset to be editable after focusing
        // has happened. Keyboard will not appear.
        if (!isKeyEvent && DomHelper.isTouchEvent) {
            if (field.editable) {
                field.editable = false;
                field.setTimeout(() => field.editable = true, 500);
            }
        }

        e.preventDefault();
        if (document.activeElement !== field.input) {
            field.focus();
        }
    }

    get field() {
        return this.parent;
    }
};

Field.SpinTrigger = class SpinTrigger extends Field.Trigger {
    static get $name() {
        return 'SpinTrigger';
    }

    static get defaultConfig() {
        return {
            repeat : true
        };
    }

    doDestroy() {
        this.clickRepeater && this.clickRepeater.destroy();

        super.doDestroy();
    }

    template() {
        return  `<div class="b-icon b-align-${this.align || 'end'}">
                    <div reference="upButton" class="b-icon b-spin-up"></div>
                    <div reference="downButton" class="b-icon b-spin-down"></div>
                </div>`;
    }

    set repeat(repeat) {
        const me = this;

        if (repeat) {
            me.clickRepeater = new ClickRepeater(Object.assign({
                element : me.element
            }, repeat));
        }
        else if (me.clickrepeater) {
            me.clickRepeater.destroy();
            me.clickrepeater = null;
        }
    }

    onClick(e) {
        const me = this,
            field = me.field;

        if (field.disabled) {
            return;
        }

        if (e.target === me.upButton) {
            field.doSpinUp();
        }
        else if (e.target === me.downButton) {
            field.doSpinDown();
        }
    }
};

Field._$name = 'Field'; BryntumWidgetAdapterRegister.register('trigger', Field.Trigger);
BryntumWidgetAdapterRegister.register('spintrigger', Field.SpinTrigger);

/**
 * @module Core/widget/Checkbox
 */

/**
 * Checkbox field, wraps <code>&lt;input type="checkbox"&gt;</code>.
 * Color can be specified and you can optionally configure {@link #config-text}
 * to display in a label to the right of the checkbox in addition to a standard
 * field {@link #config-label}.
 *
 * This field can be used as an {@link Grid.column.Column#config-editor editor} for the {@link Grid.column.Column Column}.
 *
 * @extends Core/widget/Field
 *
 * @example
 * // checkbox with a label and a handler
 * let checkbox = new Checkbox({
 *   text: 'Check me, please',
 *   onAction: () => {}
 * });
 *
 * @classType checkbox
 * @externalexample widget/Checkbox.js
 */
class Checkbox extends Field {
    //region Config
    static get $name() {
        return 'Checkbox';
    }

    static get defaultConfig() {
        return {
            /**
             * Text to display on checkbox label
             * @config {String}
             */
            text : '',

            /**
             * Checkbox color, must have match in css
             * @config {String}
             */
            color : null,

            /**
             * Sets input fields value attribute
             * @config {String}
             */
            value : '',

            toggleGroup : null,

            defaultBindProperty : 'value',

            localizableProperties : ['label', 'text']
        };
    }

    //endregion

    //region Init

    construct(config) {
        super.construct(config);

        const me = this;

        if (me.initialConfig.readOnly) me.readOnly = true;

        me.isConfiguring = true;
        if (me.initialConfig.checked) me.checked = true;
        me.isConfiguring = false;

    }

    inputTemplate() {
        const me = this;

        return TemplateHelper.tpl`
            <input type="checkbox" id="${me.id}_input" reference="input" ${me.toggleGroup ? `data-group="${me.toggleGroup}"` : ``}/>
            <label class="b-checkbox-label" for="${me.id}_input" reference="textLabel">${me.text || ''}</label>
        `;
    }

    set element(element) {
        const me = this;

        super.element = element;

        if (me.color) {
            me.element.classList.add(me.color);
        }
        if (me.text) {
            me.element.classList.add('b-text');
        }
    }

    get element() {
        return super.element;
    }
    //endregion

    //region Toggle

    /**
     * Get/set label
     * @property {String}
     */
    get text() {
        return this._text;
    }

    set text(value) {
        this._text = value;
        if (this.textLabel) {
            this.textLabel.innerHTML = value;
        }
    }

    /**
     * Get/set value
     * @property {String}
     */
    get value() {
        return this.checked;
    }

    set value(value) {
        this.checked = value === 'false' ? false : Boolean(value);
    }

    /**
     * Get/set checked state
     * @property {Boolean}
     */
    get checked() {
        return this.input.checked;
    }

    set checked(checked) {
        const me = this;
        checked = Boolean(checked);
        
        // Only do action if change needed.
        if (!me.inputting && me.input.checked !== checked) {
            me.input.checked = checked;

            me.uncheckToggleGroupMembers();

            // The change event does not fire on programmatic change of input.
            if (!me.isConfiguring) {
                me.triggerChange(false);
            }
        }
    }

    getToggleGroupMembers() {
        const
            me = this,
            { checked, toggleGroup, input : checkedElement } = me,
            result = [];

        if (checked && toggleGroup) {
            DomHelper.forEachSelector(`input[type=checkbox][data-group=${toggleGroup}]`, inputEl => {
                if (inputEl !== checkedElement) {
                    const partnerCheckbox = WidgetHelper.fromElement(inputEl);
                    partnerCheckbox && result.push(partnerCheckbox);
                }
            });
        }

        return result;
    }

    uncheckToggleGroupMembers() {
        if (this.checked && this.toggleGroup) {
            this.getToggleGroupMembers().forEach(widget => widget.checked = false);
        }
    }

    /**
     * Get/set readonly state (disabled underlying input)
     * @property {Boolean}
     */
    get readOnly() {
        return this._readOnly;
    }

    set readOnly(readOnly) {
        this._readOnly = readOnly;
        this.element.classList[readOnly ? 'add' : 'remove']('b-readonly');
        this.input.disabled = readOnly;
    }

    /**
     * Check the box
     */
    check() {
        this.checked = true;
    }

    /**
     * Uncheck the box
     */
    uncheck() {
        this.checked = false;
    }

    /**
     * Toggle checked state. If you want to force a certain state, assign to {@link #property-checked} instead.
     */
    toggle() {
        this.checked = !this.checked;
    }

    //endregion

    //region Events

    /**
     * Triggers events when user toggles the checkbox
     * @fires beforeChange
     * @fires change
     * @fires action
     * @private
     */
    internalOnChange(event) {
        /**
         * Fired before checkbox is toggled. Returning false from a listener prevents the checkbox from being toggled.
         * @event beforeChange
         * @preventable
         * @param {Core.widget.Checkbox} source Checkbox
         * @param {Boolean} checked Checked or not
         */

        /**
         * Fired when checkbox is toggled
         * @event change
         * @param {Core.widget.Checkbox} source Checkbox
         * @param {Boolean} checked Checked or not
         */

        this.triggerChange(true);
    }

    /**
     * Triggers events when checked state is changed
     * @fires beforeChange
     * @fires change
     * @fires action
     * @private
     */
    triggerChange(userAction) {
        const me = this,
            { checked } = me.input;

        // Prevent uncheck if this checkbox is part of a toggleGroup (radio-button mode) ..also ensure the group has visible active members
        const prevented = (!checked && userAction && me.toggleGroup && me.getToggleGroupMembers().filter(widget => widget.isVisible && !widget.disabled).length) ||
            // Since Widget has Events mixed in configured with 'callOnFunctions' this will also call onBeforeChange, onChange and onAction
            !me.callPreventable(
                'change',

                { checked, value : checked, userAction }, eventObject => {

                    if (userAction) {
                        me.uncheckToggleGroupMembers();
                    }

                    /**
                    * User performed the default action (toggled the checkbox)
                    * @event action
                    * @param {Core.widget.Checkbox} source Checkbox
                    * @param {Boolean} checked Checked or not
                    */
                    me.trigger('action', eventObject);

                    return true;
                }
            );

        // If prevented need to rollback the checkbox input
        if (prevented) {
            // Input change is not preventable, so need to revert the changes
            // The change event does not fire on programmatic change of input, so no need to suspend
            me.input.checked = !me.input.checked;
        }
    }

    //endregion
}

Checkbox._$name = 'Checkbox'; BryntumWidgetAdapterRegister.register('checkbox', Checkbox);
BryntumWidgetAdapterRegister.register('check', Checkbox);

/**
 * @module Core/mixin/InstancePlugin
 */

/**
 * Base class for plugins. Published functions will be available from the other class. `this` in published functions is
 * referenced to the plugin, access the other class using `this.pluggedInto` (deprecated in 2.3) or `this.client`.
 *
 * Observe that plugin doesn't apply itself on class level but instead on instance level. Plugin is its own instance
 * that can have own functions and data that is not exposed to target class.
 *
 * Functions can be published in four ways:
 *
 * * `assign` (when function is not already available on target)
 * * `before` (when function is already available on target, will be called before original function)
 * * `after` (when function is already available on target, will be called after original function)
 * * `override` (replaces function on target, but old function can be reached)
 *
 * To configure which functions get published and in what way, specify `pluginConfig` getter on plugin:
 *
 * ```
 * class Sort extends InstancePlugin {
 *   static get pluginConfig {
 *      return {
 *          before   : ['init'],
 *          after    : ['destroy', 'onElementClick'],
 *          override : ['render']
 *      };
 *   }
 * }
 * ```
 *
 * @mixes Core/localization/Localizable
 * @mixes Core/mixin/Events
 */
class InstancePlugin extends Localizable(Events(Base)) {

    //region Config

    static get defaultConfig() {
        return {
            /**
             * The plugin disabled state
             * @config {Boolean}
             * @default
             * @category Common
             */
            disabled : false
        };
    }

    //endregion

    //region Init

    /**
     * Call from another instance to add plugins to it.
     * @example
     * InstancePlugin.initPlugins(this, Search, Stripe);
     * @param plugInto Instance to mix into (usually this)
     * @param plugins Classes to plug in
     * @internal
     */
    static initPlugins(plugInto, ...plugins) {
        const property = plugInto.plugins || (plugInto.plugins = {});

        for (const PluginClass of plugins) {
            property[PluginClass.$name] = new PluginClass(plugInto);
        }
    }

    /**
     * The Widget which was passed into the constructor,
     * which is the Widget we are providing extra services for.
     * @property {Core.widget.Widget}
     * @readonly
     * @category Misc
     */
    get client() {
        return this._client;
    }

    set client(client) {
        this._client = client;
    }

    /**
     * Initializes the plugin.
     * @internal
     * @param plugInto Target instance to plug into
     * @function constructor
     */
    construct(plugInto, config) {
        this.pluggedInto = this.client = plugInto;

        super.construct(config);

        this.applyPluginConfig(plugInto);
    }

    /**
     * Applies config as found in plugInto.pluginConfig, or published all if no config found.
     * @private
     * @param plugInto Target instance to plug into
     */
    applyPluginConfig(plugInto) {
        const
            me          = this,
            config      = me.pluginConfig || me.constructor.pluginConfig;

        if (config) {
            const { assign, chain, after, before, override } = config;

            assign && me.applyAssign(plugInto, assign);
            (chain || after) && me.applyChain(plugInto, chain || after);
            before && me.applyChain(plugInto, before, false);
            override && me.applyOverride(plugInto, override);
        }
    }

    /**
     * Applies assigning for specified functions.
     * @private
     * @param plugInto
     * @param fnNames
     */
    applyAssign(plugInto, fnNames) {
        fnNames.forEach(fnName => this.assign(plugInto, fnName));
    }

    /**
     * Applies chaining for specified functions.
     * @private
     * @param plugInto
     * @param fnNames
     * @param after
     */
    applyChain(plugInto, fnNames, after = true) {
        fnNames.forEach(fnName => {
            if (plugInto[fnName]) {
                this.chain(plugInto, fnName, after);
            }
            else {
                this.assign(plugInto, fnName);
            }
        });
    }

    /**
     * Applies override for specified functions.
     * @private
     * @param plugInto
     * @param fnNames
     */
    applyOverride(plugInto, fnNames) {
        const me = this;

        if (!me.overridden) {
            me.overridden = {};
        }

        fnNames.forEach(fnName => {
            if (!me[fnName]) {
                throw new Error(this.L('overrideFnMissing', {
                    plugIntoName : plugInto.$name,
                    pluginName   : me.$name,
                    fnName       : fnName
                }));
            }
            // override
            if (typeof plugInto[fnName] === 'function') {
                me.overridden[fnName] = plugInto[fnName].bind(plugInto);
            }

            plugInto[fnName] = me[fnName].bind(me);
        });
    }

    /**
     * Assigns specified functions.
     * @private
     * @param plugInto
     * @param fnName
     */
    assign(plugInto, fnName) {
        const
            me       = this,
            property = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(me), fnName);

        if (property && (property.get || property.set)) {
            // getter/setter, define corresponding property on target
            Object.defineProperty(plugInto, fnName, {
                configurable : true,
                enumerable   : true,
                get          : property.get && property.get.bind(me),
                set          : property.set && property.set.bind(me)
            });
        }
        else {
            plugInto[fnName] = me[fnName].bind(me);
        }
    }

    //endregion

    //region Chaining

    /**
     * Chains functions. When the function is called on the target class all functions in the chain will be called in
     * the order they where added.
     * @private
     * @param plugInto
     * @param key
     */
    chain(plugInto, key, after = true) {
        const
            me    = this,
            chain = plugInto.pluginFunctionChain || (plugInto.pluginFunctionChain = {});

        // duplicate function, make chain and use function to run all functions in it upon call...
        if (!chain[key]) {
            chain[key] = [plugInto[key].bind(plugInto)];
        }

        if (!me[key]) {
            throw new Error(
                this.L('fnMissing', {
                    plugIntoName : plugInto.$name,
                    pluginName   : me.$name,
                    fnName       : key
                })
            );
        }

        chain[key][after ? 'push' : 'unshift'](me[key].bind(me));

        // use function to run all functions in chain on call
        plugInto[key] = (...params) => me.functionChainRunner(key, ...params);
    }

    /**
     * Used to run multiple plugged in functions with the same name, see chain above. Returning false from a
     * function will abort chain.
     * @private
     * @param fnName
     * @param params
     * @returns value returned from last function in chain (or false if any returns false)
     */
    functionChainRunner(fnName, ...params) {
        const chain = this.client.pluginFunctionChain[fnName];
        let returnValue;

        // changed from for..of to try and fix Edge problems
        for (let i = 0; i < chain.length; i++) {
            returnValue = chain[i](...params);
            if (returnValue === false) {
                return false;
            }
        }

        return returnValue;
    }

    //endregion

    /**
     * Called when disabling/enabling the plugin. By default removes the cls of the plugin from its client.
     * Override in subclasses to take any other actions necessary.
     */
    doDisable(disable) {
        const
            { constructor } = this,
            cls = 'featureClass' in constructor ? constructor.featureClass : `b-${constructor.$name.toLowerCase()}`;

        // Some features do not use a cls
        if (cls) {
            this.client && this.client.element && this.client.element.classList[disable ? 'remove' : 'add'](cls);
        }

        if (disable) {
            /**
             * Fired when the plugin/feature is disabled.
             * @event disable
             * @param {Core.mixin.InstancePlugin} source
             */
            this.trigger('disable');
        }
        else {
            /**
             * Fired when the plugin/feature is enabled.
             * @event enable
             * @param {Core.mixin.InstancePlugin} source
             */
            this.trigger('enable');
        }
    }

    /**
     * Get/set the plugin disabled state
     * @property {Boolean}
     * @category Common
     */
    get disabled() {
        return this._disabled;
    }

    set disabled(disabled) {
        this._disabled = disabled;

        this.doDisable(disabled);
    }
}
InstancePlugin._$name = 'InstancePlugin';

/**
 * @module Core/mixin/Pluggable
 */

/**
 * Enables using plugins for a class by specifying property plugins as an array of plugin classes. If only a single plugin
 * is used, just give the plugin class instead of an array. This class isn't required for using plugins, just makes it
 * easier. Without mixin you can otherwise use `InstancePlugin.initPlugins(this, PluginClass)`.
 *
 * @example
 * new Store({
 *   plugins: [PluginClass, ...]
 * });
 *
 * @mixin
 */
var Pluggable = Target => class Pluggable extends (Target || Base) {
    /**
     * Specify plugins (an array of classes) in config
     * @config {Function[]} plugins
     * @category Misc
     */

    /**
     * Map of applied plugins
     * @property {Object}
     * @readonly
     * @category Misc
     */
    get plugins() {
        if (!this._plugins) {
            this._plugins = {};
        }
        return this._plugins;
    }

    set plugins(plugins) {
        if (plugins) {
            if (!Array.isArray(plugins)) plugins = [plugins];
            InstancePlugin.initPlugins(this, ...plugins);
        }
        this.initPlugins();
    }

    /**
     * Template method which may be implemented in subclasses to initialize any plugins.
     * This method is empty in the `Pluggable` base class.
     * @internal
     */
    initPlugins() {

    }

    /**
     * Adds plugins to an instance.
     * @param plugins Plugins to add
     */
    addPlugins(...plugins) {
        InstancePlugin.initPlugins(this, ...plugins);
    }

    /**
     * Checks if instance has plugin.
     * @param pluginClassOrName Plugin or name to check for
     * @returns {Boolean}
     */
    hasPlugin(pluginClassOrName) {
        return this.getPlugin(pluginClassOrName) != null;
    }

    /**
     * Get a plugin instance.
     * @param pluginClassOrName
     * @returns {Object}
     */
    getPlugin(pluginClassOrName) {
        if (typeof pluginClassOrName === 'function') pluginClassOrName = pluginClassOrName.$name;
        return this.plugins && this.plugins[pluginClassOrName];
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

/**
 * @module Core/mixin/State
 */

/**
 * Mixin that simplifies handling state for an ui component. Classes that uses this mixin must implement `getState()` and
 * `applyState(state)`.
 *
 * ```
 * class MyUIComponent extends State() {
 *   getState() {
 *     return {
 *       this.text,
 *       this.size
 *     }
 *   }
 *
 *   applyState(state) {
 *      this.text = state.text;
 *      this.size = state.size;
 *   }
 * }
 * ```
 *
 * @demo Grid/state
 *
 * @mixin
 */
var State = Target => class State extends (Target || Base) {
    //getState() {}

    //applyState(State) {}

    /**
     * Gets or sets a component's state
     * @property {Object}
     */
    get state() {
        this._state = this.getState();
        return this._state;
    }

    set state(state) {
        this._state = state;
        this.applyState(state);
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

/**
 * @module Core/data/stm/mixin/ModelStm
 */

const
    STM_PROP         = Symbol('STM_PROP'),
    unrecordedFields = {
        // This field's value is a by product of node insertion and must not be recorded here.
        // It's the node insertion operation which is recorded by STM.
        parentIndex : 1
    };

/**
 * Mixin making a model compatible with {@link Core/data/stm/StateTrackingManager}
 *
 * @mixin
 */
var ModelStm = Target => class ModelStm extends (Target || Base) {

    static get defaultConfig() {
        return {
            stm : null
        };
    }

    

    joinStore(store) {
        super.joinStore && super.joinStore(store);

        if (!this.stm) {
            this.stm = store.stm;
        }
    }

    unJoinStore(store) {
        if (this.stm === store.stm) {
            this.stm = null;
        }

        super.unJoinStore && super.unJoinStore(store);
    }

    /**
     * Reference to STM manager, if used
     * @member {Core.data.stm.StateTrackingManager}
     * @category Misc
     */
    get stm() {
        return this[STM_PROP];
    }

    set stm(stm) {
        this[STM_PROP] = stm;
    }

    /**
     * Overridden to collect initial data for the fields about to be changed.
     * The method is called from within {@link Core/data/Model#function-set} method.
     *
     * @private
     */
    beforeSet(field, value, silent, fromRelationUpdate) {
        const preResult = super.beforeSet ? super.beforeSet(field, value, silent, fromRelationUpdate) : [];

        const stm = this.stm;

        if (stm && !stm.disabled && !unrecordedFields[field]) {

            let newDataCandidate, oldDataCandidate;

            if (typeof field == 'object') {
                [newDataCandidate, oldDataCandidate] = Object.keys(field).reduce(
                    (data, fName) => {
                        data[0][fName] = field[fName];
                        data[1][fName] = this.get(fName);
                        return data;
                    },
                    [{}, {}]
                );
            }
            else {
                newDataCandidate = { [field] : value };
                oldDataCandidate = { [field] : this.get(field) };
            }

            preResult.push([newDataCandidate, oldDataCandidate]);
        }

        return preResult;
    }

    /**
     * Overridden to store initial data of the changed fields and to notify STM
     * manager about the change action if anything has been changed in result.
     *
     * The method is called from within {@link Core/data/Model#function-set} method.
     *
     * @private
     */
    afterSet(field, value, silent, fromRelationUpdate, beforeResult, wasSet) {

        const stm = this.stm;

        if (stm && !stm.disabled && !unrecordedFields[field]) {

            const preResult = beforeResult.pop();

            if (wasSet) {
                let [newDataCandidate, oldDataCandidate] = preResult;

                let [newData, oldData] = Object.keys(wasSet).reduce(
                    (data, fName) => {
                        data[0][fName] = newDataCandidate[fName];
                        data[1][fName] = oldDataCandidate[fName];
                        return data;
                    },
                    [{}, {}]
                );

                stm.onModelUpdate(this, newData, oldData);
            }
        }

        super.afterSet && super.afterSet(field, value, silent, fromRelationUpdate, beforeResult, wasSet);
    }

    /**
     * Called from {@link Core/data/mixin/TreeNode#function-insertChild} to obtain inserted
     * records initial parents and parent index, to be able to restore the state back upon undo.
     *
     * @param {Core.data.Model[]} childRecords
     * @return {Array} Array of results from this call and any of super calls if any.
     *               This result is consumed by {@link #function-afterInsertChild} which pops
     *               from the result array to take only results of this method call and leave
     *               results from super calls untouched.
     *
     * @private
     */
    beforeInsertChild(childRecords) {
        const preResult = super.beforeInsertChild ? super.beforeInsertChild(childRecords) : [];

        const stm = this.stm;

        if (stm && !stm.disabled) {
            preResult.push(
                childRecords.reduce((result, childRecord) => {
                    // We are interested only in records from the same root node.
                    // Removing (which is done before insertion) of the records
                    // from another root (and store) should
                    // be handled by that store STM instance.
                    if (childRecord.root === this.root) {
                        result.set(childRecord, {
                            parent : childRecord.parent,
                            index  : childRecord.parent ? childRecord.parentIndex : undefined
                        });
                    }

                    return result;
                }, new Map())
            );
        }

        return preResult;
    }

    /**
     * Called from {@link Core/data/mixin/TreeNode#function-insertChild} to notify {@link Core/data/stm/StateTrackingManager}
     * about children insertion. Provides it with all necessary context information collected
     * in {@link #function-beforeInsertChild} required to undo/redo the action.
     *
     * @private
     */
    afterInsertChild(index, childRecords, beforeResult, inserted) {
        const stm = this.stm;

        if (stm && !stm.disabled) {
            const context = beforeResult.pop();

            if (inserted) {
                stm.onModelInsertChild(this, index, inserted, context);
            }
        }

        super.afterInsertChild && super.afterInsertChild(index, childRecords, beforeResult, inserted);
    }

    /**
     * Called from {@link Core/data/mixin/TreeNode#function-removeChild} to obtain removed
     * records initial parent index, to be able to restore the state back upon undo.
     *
     * @param {Core.data.Model[]} childRecords
     * @param {Boolean} isMove
     * @return {Array} Array of results from this call and any of super calls if any.
     *               This result is consumed by {@link #function-afterRemoveChild} which pops
     *               from the result array to take only results of this method call and leave
     *               results from super calls untouched.
     *
     * @private
     */
    beforeRemoveChild(childRecords, isMove) {
        const preResult = super.beforeRemoveChild ? super.beforeRemoveChild(childRecords, isMove) : [];

        const stm = this.stm;

        // If it's move then InsertChildAction will handle this case
        if (stm && !stm.disabled && !isMove) {
            // Child records we receive are guaranteed to be direct children
            // of this node, see Core/data/mixin/TreeNode#removeChild method

            // Here we interested in the original index for each child removed,
            // we collect it and store for future use in RemoveChildAction
            preResult.push(
                childRecords.reduce((result, childRecord) => {
                    result.set(childRecord, childRecord.parentIndex);
                    return result;
                }, new Map())
            );
        }

        return preResult;
    }

    /**
     * Called from {@link Core/data/mixin/TreeNode#function-removeChild} to notify {@link Core/data/stm/StateTrackingManager}
     * about children removing. Provides it with all necessary context information collected
     * in {@link #function-beforeRemoveChild} required to undo/redo the action.
     *
     * @private
     */
    afterRemoveChild(childRecords, beforeResult, isMove) {
        const stm = this.stm;

        // If it's move then InsertChildAction will handle this case
        if (stm && !stm.disabled && !isMove) {
            const context = beforeResult.pop();

            if (childRecords && childRecords.length) {
                stm.onModelRemoveChild(this, childRecords, context);
            }
        }

        super.afterRemoveChild && super.afterRemoveChild(childRecords, beforeResult, isMove);
    }
};

/**
 * @module Core/data/mixin/TreeNode
 */

/**
 * Mixin for Model with tree node related functionality. This class is mixed into the {@link Core/data/Model} class.
 *
 * ## Adding and removing child nodes
 * ```
 * const parent = store.getById(1),
 *
 * firstBorn = parent.insertChild({
 *      name : 'Child node'
 *  }, parent.children[0]); // Insert a child at a specific place in the children array
 *
 * parent.removeChild(parent.children[0]); // Removes a child node
 * parent.appendChild({ name : 'New child node' }); // Appends a child node
 * ```
 *
 * @mixin
 */
var TreeNode = Target => class TreeNode extends (Target || Base) {
    /**
     * This static configuration option allows you to control whether an empty parent task should be converted into a
     * leaf. Enable/disable it for a whole class:
     *
     * ```javascript
     * Model.convertEmptyParentToLeaf = false;
     * ```
     *
     * By specifying `true`, all empty parents will be considered leafs. Can also be assigned a configuration object
     * with with the following Boolean properties to customize the behaviour:
     *
     * * `onLoad` - Apply the transformation on load to any parents without children (`children : []`)
     * * `onRemove` - Apply the transformation when all children have been removed from a parent
     *
     * ```javascript
     * Model.convertEmptyParentToLeaf = {
     *     onLoad   : false,
     *     onRemove : true
     * }
     * ```
     *
     * @property {Boolean|Object}
     * @default false
     * @category Parent & children
     */
    static set convertEmptyParentToLeaf(value) {
        if (value === true) {
            value = {
                onLoad   : true,
                onRemove : true
            };
        }
        else if (value === false) {
            value = {
                onLoad   : false,
                onRemove : false
            };
        }
        this._convertEmptyParentToLeaf = value;
    }

    static get convertEmptyParentToLeaf() {
        return this._convertEmptyParentToLeaf || { onLoad : false, onRemove : false };
    }

    /**
     * This is a read-only property providing access to the parent node.
     * @member {Core.data.Model} parent
     * @readonly
     * @category Parent & children
     */

    /**
     * This is a read-only field provided in server synchronization packets to specify
     * which record id is the parent of the record.
     * @readonly
     * @field {String|Number} parentId
     */

    /**
     * This is a read-only field provided in server synchronization packets to specify
     * which position the node takes in the parent's children array.
     * This index is set on load and gets updated automatically after row reordering, sorting, etc.
     * To save the order, need to persist the field on the server and when data is fetched to be loaded,
     * need to sort by this field.
     * @readonly
     * @field {Number} parentIndex
     */

    ingestChildren(childRecord, stores = this.stores) {
        const
            { inProcessChildren, constructor : MyClass } = this,
            store = stores[0];

        if (childRecord === true) {
            if (inProcessChildren) {
                return true;
            }
            return [];
        }
        if (childRecord) {
            if (!Array.isArray(childRecord)) {
                childRecord = [childRecord];
            }
            const
                len = childRecord.length,
                result = [];

            for (let i = 0, child; i < len; i++) {
                child = childRecord[i];
                child = child instanceof Model ? child : (store ? store.createRecord(child) : new MyClass(child, null, null, true));
                result.push(child);
            }
            return result;
        }
    }

    /**
     * Child nodes. To allow loading children on demand, specify `children : true` in your data.
     * @member {Core.data.Model[]} children
     * @category Parent & children
     */

    /**
     * Called during creation to also turn any children into Models joined to the same stores as this model
     * @internal
     * @category Parent & children
     */
    processChildren(stores = this.stores) {
        const
            me = this,
            { meta } = me;

        me.inProcessChildren = true;

        const children = me.ingestChildren(me.data[me.constructor.childrenField], stores);

        if (children) {
            if (children.length) {
                meta.isLeaf = false;
                // We are processing a remote load
                if (me.children === true) {
                    me.children = [];
                }
                me.appendChild(children);
            }
            // Flagged for load on demand
            else if (children === true) {
                meta.isLeaf = false;
                me.children = true;
            }
            // Empty child array, flag is leaf if configured to do so
            else if (!me.isRoot) {
                meta.isLeaf = me.constructor.convertEmptyParentToLeaf.onLoad;
            }
        }

        me.inProcessChildren = false;
    }

    /**
     * This property is `true` if this record has all expanded ancestors and is therefore
     * eligible for inclusion in a UI.
     * @property {Boolean}
     * @readonly
     * @category Parent & children
     */
    ancestorsExpanded(store) {
        const { parent } = this;

        return !parent || (parent.isExpanded(store) && parent.ancestorsExpanded(store));
    }

    /**
     * Used by stores to assess the record's collapsed/expanded state in that store.
     * @param {Core.data.Store} store
     * @category Parent & children
     */
    isExpanded(store) {
        const mapMeta = this.instanceMeta(store.id);

        // Default initial expanded/collapsed state when in the store
        // to the record's original expanded property.
        if (!Object.prototype.hasOwnProperty.call(mapMeta, 'collapsed')) {
            mapMeta.collapsed = !this.expanded;
        }

        return !mapMeta.collapsed;
    }

    // A read-only property. It provides the initial state upon load
    // The UI's expanded/collapsed state is in the store's meta map.
    get expanded() {
        return this.data.expanded;
    }

    /**
     * Depth in the tree at which this node exists. First visual level of nodes are at level 0, their direct children at
     * level 1 and so on.
     * @property {Number}
     * @readonly
     * @category Parent & children
     */
    get childLevel() {
        return this.parent ? this.parent.childLevel + 1 : (this.isRoot ? -1 : 0);
    }

    /**
     * Is a leaf node in a tree structure?
     * @property {Boolean}
     * @readonly
     * @category Parent & children
     */
    get isLeaf() {
        return this.meta.isLeaf !== false && !this.isRoot;
    }

    /**
     * Is a parent node in a tree structure?
     * @property {Boolean}
     * @readonly
     * @category Parent & children
     */
    get isParent() {
        return !this.isLeaf;
    }

    /**
     * Returns true for parent nodes with children loaded (there might still be no children)
     * @property {Boolean}
     * @readonly
     * @category Parent & children
     */
    get isLoaded() {
        return this.isParent && Array.isArray(this.children);
    }

    /**
     * Count all children (including sub-children) for a node (in its `firstStore´)
     * @member {Number}
     * @category Parent & children
     */
    get descendantCount() {
        return this.getDescendantCount();
    }

    /**
     * Count visible (expanded) children (including sub-children) for a node (in its `firstStore`)
     * @member {Number}
     * @category Parent & children
     */
    get visibleDescendantCount() {
        return this.getDescendantCount(true);
    }

    /**
     * Count visible (expanded)/all children for this node, optionally specifying for which store.
     * @param {Boolean} [onlyVisible] Specify `true` to only count visible (expanded) children.
     * @param {Core.data.Store} [store] A Store to which this node belongs
     * @returns {Number}
     * @category Parent & children
     */
    getDescendantCount(onlyVisible = false, store = this.firstStore) {
        const children = this.children;

        if (!children || !Array.isArray(children) || (onlyVisible && !this.isExpanded(store))) {
            return 0;
        }

        return children.reduce((count, child) => count + child.getDescendantCount(onlyVisible), children.length);
    }

    /**
     * Retrieve all children (by traversing sub nodes)
     * @returns {Core.data.Model[]}
     * @category Parent & children
     */
    get allChildren() {
        const children = this.children;
        if (!children) return [];

        return children.reduce((all, child) => {
            all.push(child);

            // push.apply is faster than push with array spread:
            // https://jsperf.com/push-apply-vs-push-with-array-spread/1
            all.push.apply(all, child.allChildren);
            return all;
        }, []);
    }

    /**
     * Get the first child of this node
     * @returns {Core.data.Model}
     * @category Parent & children
     */
    get firstChild() {
        const children = this.children;

        return (children && children.length && children[0]) || null;
    }

    /**
     * Get the last child of this node
     * @returns {Core.data.Model}
     * @category Parent & children
     */
    get lastChild() {
        const children = this.children;

        return (children && children.length && children[children.length - 1]) || null;
    }

    /**
     * Returns count of all preceding sibling nodes (including their children).
     * @property {Number}
     * @category Parent & children
     */
    get previousSiblingsTotalCount() {
        let task  = this.previousSibling,
            count = this.parentIndex;

        while (task) {
            count += task.descendantCount;
            task = task.previousSibling;
        }

        return count;
    }

    get root() {
        return this.parent && this.parent.root || this;
    }

    /**
     * Reading this property returns the id of the parent node, if this record is a child of a node.
     *
     * Setting this property appends this record to the record with the passed
     * id **in the same store that this record is already in**.
     *
     * Note that setting this property is **only valid if this record is already
     * part of a tree store**.
     *
     * This is not intended for general use. This is for when a server responds to a record
     * mutation and the server decides to move a record to a new parent. If a `parentId` property
     * is passed in the response data for a record, that record will be moved.
     * @property {Number|String}
     * @category Parent & children
     */
    get parentId() {
        return this.parent && !this.parent.isRoot ? this.parent.id : null;
    }

    set parentId(parentId) {
        const
            me = this,
            { parent } = me,
            newParent = parentId && me.firstStore.getById(parentId);

        // Handle exact equality of parent.
        // Also handle one being null and the other being undefined meaning no change.
        if (!(newParent === parent || (!parent && !newParent))) {
            // If we are batching, we do not trigger a change immediately.
            // endBatch will set the field which will set the property again.
            if (me.isBatchUpdating) {
                me.meta.batchChanges.parentId = parentId;
            }
            else {
                if (newParent) {
                    newParent.appendChild(me);
                }
                else {
                    me.parent.removeChild(me);
                }
            }
        }
    }

    static set parentIdField(parentIdField) {
        // Maintainer: the "this" references in here reference two different contexts.
        // Outside of the property definition, it's the Model Class.
        // In the getter and setter, it's the record instance.
        this._parentIdField = parentIdField;

        Object.defineProperty(this.prototype, parentIdField, {
            set : function(parentId) {
                // no arrow functions here, need `this` to change to instance
                // noinspection JSPotentiallyInvalidUsageOfClassThis
                this.parentId = parentId;
            },
            get : function() {
                // no arrow functions here, need `this` to change to instance
                // noinspection JSPotentiallyInvalidUsageOfClassThis
                return this.parentId;
            }
        });
    }

    static get parentIdField() {
        return this._parentIdField || 'parentId';
    }

    /**
     * Traverses all child nodes recursively calling the passed function
     * on a target node **before** iterating the child nodes.
     * @param fn
     * @category Parent & children
     */
    traverse(fn, skipSelf = false) {
        const { children } = this;

        if (!skipSelf) {
            fn.call(this, this);
        }

        // Simply testing whether there is non-zero children length
        // is 10x faster than using this.isLoaded
        for (let i = 0, l = children && children.length; i < l; i++) {
            children[i].traverse(fn);
        }
    }

    /**
     * Traverses all child nodes recursively calling the passed function
     * on child nodes of a target **before** calling it it on the node.
     * @param fn
     * @category Parent & children
     */
    traverseBefore(fn, skipSelf = false) {
        const { children } = this;

        // Simply testing whether there is non-zero children length
        // is 10x faster than using this.isLoaded
        for (let i = 0, l = children && children.length; i < l; i++) {
            children[i].traverse(fn);
        }
        if (!skipSelf) {
            fn.call(this, this);
        }
    }

    /**
     * Traverses child nodes recursively while fn returns true
     * @param {Function} fn
     * @category Parent & children
     * @returns {Boolean}
     */
    traverseWhile(fn, skipSelf = false) {
        const me = this;

        let goOn = true;

        if (!skipSelf) {
            goOn = fn.call(me, me) !== false;
        }

        if (goOn && me.isLoaded) {
            goOn = me.children.every(child => child.traverseWhile(fn));
        }

        return goOn;
    }

    /**
     * Bubbles up from this node, calling the specified function with each node.
     *
     * @param {Function} fn
     * @category Parent & children
     */
    bubble(fn, skipSelf = false) {
        let me = this;

        if (!skipSelf) {
            fn.call(me, me);
        }

        while (me.parent) {
            me = me.parent;
            fn.call(me, me);
        }
    }

    /**
     * Bubbles up from this node, calling the specified function with each node,
     * while the function returns true.
     *
     * @param {Function} fn
     * @category Parent & children
     * @return {Boolean}
     */
    bubbleWhile(fn, skipSelf = false) {
        let me = this,
            goOn = true;

        if (!skipSelf) {
            goOn = fn.call(me, me);
        }

        while (goOn && me.parent) {
            me = me.parent;
            goOn = fn.call(me, me);
        }

        return goOn;
    }

    /**
     * Checks if this model contain another model as one of it's descendants
     *
     * @param {Core.data.Model|String|Number} childOrId child node or id
     * @category Parent & children
     * @returns {Boolean}
     */
    contains(childOrId) {
        if (childOrId && typeof childOrId === 'object') {
            childOrId = childOrId.id;
        }
        return !this.traverseWhile(node => node.id != childOrId);
    }

    getTopParent(all) {
        let result;

        if (all) {
            result = [];
            this.bubbleWhile((t) => {
                result.push(t);
                return t.parent && !t.parent.isRoot;
            });
        }
        else {
            result = null;
            this.bubbleWhile((t) => {
                if (!t.parent) {
                    result = t;
                }
                return t.parent && !t.parent.isRoot;
            });
        }

        return result;
    }

    /**
     * Append a child record(s) to any current children.
     * @param {Core.data.Model|Core.data.Model[]} childRecord Record or array of records to append
     * @param {Boolean} [silent] Pass `true` to not trigger events during append
     * @returns {Core.data.Model|Core.data.Model[]}
     * @category Parent & children
     */
    appendChild(childRecord, silent = false) {
        return this.insertChild(childRecord, null, silent);
    }

    /**
     * Insert a child record(s) before an existing child record.
     * @param {Core.data.Model|Core.data.Model[]} childRecord Record or array of records to insert
     * @param {Core.data.Model} [before] Optional record to insert before, leave out to append to the end
     * @param {Boolean} [silent] Pass `true` to not trigger events during append
     * @returns {Core.data.Model|Core.data.Model[]}
     * @category Parent & children
     */
    insertChild(childRecord, beforeRecord = null, silent = false) {
        // Handle deprecated signature
        if (typeof childRecord === 'number') {
            const index = childRecord;
            childRecord = beforeRecord;
            beforeRecord = this.children[index];
        }

        const
            me          = this,
            wasLeaf     = me.isLeaf,
            returnArray = Array.isArray(childRecord);

        if (!Array.isArray(childRecord)) childRecord = [childRecord];

        if (!silent) {
            if (!me.stores.every(s => s.trigger('beforeAdd', { records : childRecord, parent : me }) !== false)) {
                return null;
            }
        }

        // This call makes child record an array containing Models
        childRecord = me.ingestChildren(childRecord);

        // NOTE: see comment in Model::set() about before/in/after calls approach.
        const
            index     = beforeRecord ? beforeRecord.parentIndex : me.children ? me.children.length : 0,
            preResult = me.beforeInsertChild ? me.beforeInsertChild(childRecord) : undefined,
            inserted  = me.internalAppendInsert(childRecord, beforeRecord, silent);

        // Turn into a parent if not already one
        if (wasLeaf && inserted.length) {
            me.meta.isLeaf = false;
        }

        // If we've transitioned to being a branch node, signal a change event
        // so that the UI updates.
        // Not if it's due to root node loading. StoreTree#onNodeAddChild
        // for the rootNode will fire a store refresh.
        if (me.isLeaf !== wasLeaf && !me.root.isLoading && !silent) {
            me.stores.forEach(s => {
                const changes = {
                    isLeaf : {
                        value    : false,
                        oldValue : true
                    }
                };
                s.trigger('update', { record : me, changes });
                s.trigger('change', { action : 'update', record : me, changes });
            });
        }

        me.afterInsertChild && me.afterInsertChild(index, childRecord, preResult, inserted);

        return (returnArray || !inserted) ? inserted : inserted[0];
    }

    tryInsertChild() {
        return this.insertChild(...arguments);
    }

    internalAppendInsert(recordsToInsert, beforeRecord, silent) {
        const
            me = this,
            { stores, root } = me,
            { firstStore : rootStore } = root,
            isMove = {};

        let isNoop, start, i, newRecordsCloned;

        // The reference node must be one of our children. If not, fall back to an append.
        if (beforeRecord && beforeRecord.parent !== me) {
            beforeRecord = null;
        }

        // If the records starting at insertAt or (insertAt - 1), are the same sequence
        // that we are being asked to add, this is a no-op.
        if (me.children) {
            const
                children = me.children,
                insertAt = beforeRecord ? beforeRecord.parentIndex : children.length;

            if (children[start = insertAt] === recordsToInsert[0] || children[start = insertAt - 1] === recordsToInsert[0]) {
                for (isNoop = true, i = 0; isNoop && i < recordsToInsert.length; i++) {
                    if (recordsToInsert[i] !== children[start + i]) {
                        isNoop = false;
                    }
                }
            }
        }

        // Fulfill the contract of appendChild/insertChild even if we did not have to do anything.
        // Callers must be able to correctly postprocess the returned value as an array.
        if (isNoop) {
            return recordsToInsert;
        }

        // Remove incoming child nodes from any current parent.
        for (i = 0; i < recordsToInsert.length; i++) {
            const newRecord = recordsToInsert[i],
                oldParent = newRecord.parent;

            // Store added should not be modified for adds
            // caused by moving.
            isMove[newRecord.id] = newRecord.root === root;

            // Check if any descendants of the added node are moves.
            rootStore && newRecord.traverse(r => {
                if (r.root === root) {
                    isMove[r.id] = true;
                }
            });

            // If the new record has a parent, remove from that parent.
            // This operation may be vetoed by listeners.
            // If it is vetoed, then remove from the newRecords and do not
            // set the parent property
            if (oldParent && oldParent.removeChild(newRecord, isMove[newRecord.id]) === false) {
                if (!newRecordsCloned) {
                    recordsToInsert  = recordsToInsert.slice();
                    newRecordsCloned = true;
                }
                recordsToInsert.splice(i--, 1);
            }
            else {
                const
                    { parentIdField } = newRecord.constructor,
                    parentId = me.isAutoRoot ? null : me.id;

                newRecord.parent = me;
                newRecord.data[parentIdField] = parentId;

                // If we are in the recursive inclusion of children at construction
                // time, or in a store load, that must not be a data modification.
                // Otherwise, we have to signal a change
                if (!(me.inProcessChildren || me.isLoading)) {
                    const
                        toSet = {
                            parentId
                        },
                        { modified } = newRecord.meta,
                        oldParentId = oldParent ? oldParent.id : null,
                        wasSet = {
                            [parentIdField] : {
                                value    : me.id,
                                oldValue : oldParentId
                            }
                        };

                    // Changing back to its original value
                    if (modified[parentIdField] === me.id) {
                        delete modified[parentIdField];
                    }
                    // Cache its original value
                    else if (!('parentId' in modified)) {
                        modified[parentIdField] = oldParentId;
                    }

                    newRecord.afterChange(toSet, wasSet);
                }
            }
        }

        // Still records to insert after beforeRemove listeners may have vetoed some
        if (recordsToInsert.length) {
            // Add to the children
            const insertAt = me.addToChildren(me.children || (me.children = []), beforeRecord, recordsToInsert);
            // When filter is used add to the unfiltered children
            me.addToChildren(me.unfilteredChildren, beforeRecord, recordsToInsert, true);

            stores.forEach(store => {
                if (!store.isChained) {

                    recordsToInsert.forEach(record => {
                        // Initialize context for newly added records
                        record.joinStore(store);
                    });

                    // Add to store (will also add any child records and trigger events)
                    store.onNodeAddChild(me, recordsToInsert, insertAt, isMove, silent);
                }
            });
        }

        return recordsToInsert;
    }

    /**
     * Remove a child record. Only direct children of this node can be removed, others are ignored.
     * @param {Core.data.Model|Core.data.Model[]} childRecords The record(s) to remove.
     * @param {Boolean} [isMove] Pass `true` if the record is being moved within the same store.
     * @param {Boolean} [silent] Pass `true` to not trigger events during remove.
     * @category Parent & children
     */
    removeChild(childRecords, isMove = false, silent = false) {
        const
            me = this,
            wasLeaf = me.isLeaf,
            { children, stores } = me;

        if (!Array.isArray(childRecords)) {
            childRecords = [childRecords];
        }

        childRecords = childRecords.filter(r => r.parent === me);

        if (!silent) {
            // Allow store listeners to veto the beforeRemove event
            for (const store of stores) {
                if (!store.isChained) {
                    if (store.trigger('beforeRemove', { parent : me, records : childRecords, isMove }) === false) {
                        return false;
                    }
                }
            }
        }

        const preResult = me.beforeRemoveChild ? me.beforeRemoveChild(childRecords, isMove) : undefined;

        for (const childRecord of childRecords) {

            const index = me.removeFromChildren(children, childRecord);
            me.removeFromChildren(me.unfilteredChildren, childRecord, true);

            stores.forEach(store => {
                if (!store.isChained) {
                    store.onNodeRemoveChild(me, [childRecord], index, { isMove, silent });
                }
            });

            childRecord.parent = childRecord.parentIndex = childRecord.unfilteredIndex = childRecord.nextSibling = childRecord.previousSibling = null;
        }

        // Convert emptied parent into leaf if configured to do so
        if (!children.length && me.constructor.convertEmptyParentToLeaf.onRemove && !me.isRoot) {
            me.meta.isLeaf = true;
        }

        // If we've transitioned to being a leaf node, signal a change event
        // so that the UI updates
        if (me.isLeaf !== wasLeaf && !silent) {
            me.stores.forEach(s => {
                const changes = {
                    isLeaf : {
                        value    : true,
                        oldValue : false
                    }
                };
                s.trigger('update', { record : me, changes });
                s.trigger('change', { action : 'update', record : me, changes });
            });
        }

        me.afterRemoveChild && me.afterRemoveChild(childRecords, preResult, isMove);
    }

    clearChildren() {
        const me = this,
            { children, stores } = me;

        if (children) {
            me.children = [];

            stores.forEach(store => {
                if (!store.isChained) {
                    // unfiltered:true to unregister children on filtered stores
                    store.onNodeRemoveChild(me, children, 0, { unfiltered : true });
                }
            });

            // clear unfilteredChildren (must be after the above loop)
            if (me.unfilteredChildren) {
                me.unfilteredChildren = [];
            }

        }
    }

    /**
     * Removes all records from the rootNode
     * @private
     */
    clear() {
        const
            me         = this,
            { stores } = me,
            children   = me.children && me.children.slice();

        // Only allow for root node and if data is present
        if (!me.isRoot || !children) {
            return;
        }

        for (const store of stores) {
            if (!store.isChained) {
                if (store.trigger('beforeRemove', { parent : me, records : children, isMove : false, removingAll : true }) === false) {
                    return false;
                }
            }
        }

        me.children.length = 0;

        stores.forEach(store => {
            children.forEach(child => {
                if (child.stores.includes(store)) {
                    // this will drill down the child, unregistering whole branch
                    child.unJoinStore(store);
                }

                child.parent = child.parentIndex = child.nextSibling = child.previousSibling = null;
            });

            store.storage.suspendEvents();
            store.storage.clear();
            store.storage.resumeEvents();

            store.added.clear();
            store.modified.clear();

            store.trigger('removeAll');
            store.trigger('change', { action : 'removeall' });
        });
    }

    updateChildrenIndex(children, unfiltered = false) {
        const indexName = unfiltered ? 'unfilteredIndex' : 'parentIndex';
        let previousSibling = null;
        for (let i = 0; i < children.length; i++) {
            const child = children[i];

            child[indexName] = i;
            if (!unfiltered) {
                child.previousSibling = previousSibling;
                if (previousSibling) {
                    previousSibling.nextSibling = child;
                }
                // Last child never has a nextSibling
                if (i === children.length - 1) {
                    child.nextSibling = null;
                }
                previousSibling = child;
            }
        }
    }

    addToChildren(children, beforeRecord, newRecords, unfiltered = false) {
        if (children) {
            const
                indexName = unfiltered ? 'unfilteredIndex' : 'parentIndex',
                index     = beforeRecord ? beforeRecord[indexName] : children.length;
            children.splice(index, 0, ...newRecords);
            this.updateChildrenIndex(children, unfiltered);
            return index;
        }
    }

    removeFromChildren(children, childRecord, unfiltered = false) {
        if (children) {
            const
                indexName = unfiltered ? 'unfilteredIndex' : 'parentIndex',
                index     = childRecord[indexName];
            if (index > -1) {
                children.splice(index, 1);
                this.updateChildrenIndex(children, unfiltered);
            }
            return index;
        }
    }

};

/* eslint-disable no-prototype-builtins */

const
    internalProps = {
        children : 1,
        data     : 1,
        meta     : 1
    },
    _undefined    = undefined,
    emptyObject$2   = {},
    convertDate   = function(date) {
        if (!(date instanceof Date)) {
            // Use configured format, if null/undefined use DateHelpers default format
            date = DateHelper.parse(date, this.format || this.dateFormat || DateHelper.defaultFormat);
        }
        // if parsing has failed, we would like to return `undefined` to indicate the "absence" of data
        // instead of `null` (presence of "empty" data)
        return date || _undefined;
    },
    isEqual       = (field, oldValue, value) => {
        // using fn to keep field scope
        return field && field.isEqual ? field.isEqual(oldValue, value) : ObjectHelper.isEqual(oldValue, value);
    },
    nullFn        = () => {};

/**
 * @module Core/data/Model
 */

/**
 * A Model is a definition for a record in a store. It defines which fields the data contains and exposes an interface
 * to access and manipulate that data.
 *
 * Models are created from json objects, the input json is stored in `Model#data`. By default it stores a shallow copy of
 * the raw json, but for records in stores configured with `useRawData: true` it stores the supplied json object as is.
 *
 * ## Defining fields
 * A Model can either define its fields explicitly or have them created from its data. This snippet shows a model with
 * two fields:
 *
 * ```
 * class Person extends Model {
 *     static get fields() {
 *         return [
 *             'name',
 *             { name : 'birthday', type : 'date', dateFormat : 'YYYY-MM-DD' },
 *             { name : 'shoeSize', type : 'number', defaultValue : 11 },
 *             { name : 'age', readOnly : true }
 *         ];
 *     }
 * }
 * ```
 *
 * The first field (name) has an unspecified type, which is fine in most cases since this is JavaScript. The second
 * field (birthday) is defined to be a date, which will make the model parse any supplied value into an actual date.
 * The parsing is handled by {@link Core/helper/DateHelper#function-parse-static DateHelper.parse()} using the specified
 * `dateFormat`, or if no format is specified using
 * {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat}. Currently date is the only
 * specified type available.
 *
 * You can also set a `defaultValue that will be used if the data doesn't contain a value for the field:
 *
 * ```
 *       { name : 'shoeSize', type : 'number', defaultValue : 11 }
 * ```
 *
 * To create a record from a Model, supply data to its constructor:
 *
 * ```
 * let guy = new Person({
 *   id       : 1,
 *   name     : 'Dude',
 *   birthday : '2014-09-01'
 * });
 * ```
 *
 * If no id is specified, a temporary id will be generated.
 *
 * ## Persisting fields
 * By default all fields are persisted. If you don't want particular field to get saved to the server, configure it with
 * `persist: false`. In this case field will not be among changes which are sent by
 * {@link Core/data/AjaxStore#function-commit store.commit()}, otherwise its behavior doesn't change.
 *
 * ```
 * class Person extends Model {
 *     static get fields() {
 *         return [
 *             'name',
 *             { name : 'age', persist : false }
 *         ];
 *     }
 * }
 * ```
 *
 * ## Id field
 * By default Model expects its id to be stored in a field named "id". The name of the field can be customized by
 * setting {@link #property-idField-static}:
 *
 * ```
 * class Person extends Model {
 *     static get fields() {
 *         return {
 *             'name',
 *             { name : 'age', persist : false },
 *             { name : 'personId' },
 *             { name : 'birthday', type : 'date' }
 *         }
 *     }
 * }
 * // Id drawn from 'id' property by default; use custom field here
 * Person.idField = 'personId';
 *
 * let girl = new Person({
 *    personId : 2,
 *    name     : 'Lady',
 *    birthday : '2011-11-05'
 * });
 * ```
 *
 * ## Getting and setting values
 * Fields are used to generate getters and setters on the records. Use them to access or modify values (they are
 * reactive):
 *
 * ```
 * console.log(guy.name);
 * girl.birthday = new Date(2011,10,6);
 * ```
 *
 * NOTE: In an application with multiple different models you should subclass Model, since the prototype is decorated
 * with getters and setters. Otherwise you might got unforeseen collisions.
 *
 * ## Field data mapping
 * By default fields are mapped to data using their name. If you for example have a "name" field it expects data to be
 * `{ name: 'Some name' }`. If you need to map it to some other property, specify `dataSource` in your field definition:
 *
 * ```
 * class Person extends Model {
 *   static get fields {
 *     return [
 *       { name : 'name', dataSource : 'TheName' }
 *     ];
 * }
 *
 * // This is now OK:
 * let dude = new Person({ TheName : 'Manfred' });
 * console.log(dude.name); // --> Manfred
 * ```
 *
 * ## Tree API
 * This class mixes in the {@link Core/data/mixin/TreeNode TreeNode} mixin which provides an API for tree related functionality (only relevant if your
 * store is configured to be a {@link Core/data/Store#config-tree tree}).
 *
 * @mixes Core/data/mixin/TreeNode
 * @mixes Core/data/stm/mixin/ModelStm
 */
class Model extends TreeNode(ModelStm()) {
    /**
     * The name of the data field which provides the ID of instances of this Model.
     * @property {String}
     * @category Fields
     */
    static set idField(idField) {
        this._assignedIdField = true;
        this._idField = idField;
    }

    static get idField() {
        return this._idField;
    }

    /**
     * The name of the data field which holds children of this Model when used in a tree structure
     * ```javascript
     * MyModel.childrenField = 'kids';
     * const parent = new MyModel({
     *   name : 'Dad',
     *   kids : [
     *     { name : 'Daughter' },
     *     { name : 'Son' }
     *   ]
     * });
     * ```
     * @property {String}
     * @category Fields
     */
    static set childrenField(childrenField) {
        this._childrenField = childrenField;
    }

    static get childrenField() {
        return this._childrenField || 'children';
    }

    /**
     * Returns index path to this node. This is the index of each node in the node path
     * starting from the topmost parent. (only relevant when its part of a tree store).
     * @returns {Number[]} The index of each node in the path from the topmost parent to this node.
     * @category Parent & children
     * @private
     */
    get indexPath() {
        const indices = [];

        for (let task = this; task && !task.isRoot; task = task.parent) {
            indices.unshift(task.parentIndex + 1);
        }

        return indices;
    }

    /**
     * Unique identifier for the record. Might be mapped to another dataSource using idField, but always exposed as
     * record.id. Will get a generated value if none is specified in records data.
     * @member {String|Number} id
     * @category Identification
     */

    //region Init

    /**
     * Constructs a new record from the supplied data.
     * @param {Object} [data] Raw data
     * @param {Core.data.Store} [store] Data store
     * @param {Object} [meta] Meta data
     * @function constructor
     * @category Misc
     */
    construct(data = {}, store = null, meta = null, skipExpose = false) {
        const
            me              = this,
            { constructor } = me,
            { fieldMap }    = constructor,
            stores          = store ? Array.isArray(store) ? store : [store] : [];

        // null passed to Base construct inhibits config processing.
        let configs = null;

        store = stores[0];

        me.meta = Object.assign({
            modified : {}
        }, constructor.metaConfig, meta);

        // Should apply configs?
        if (constructor.applyConfigs) {
            // Extract from data and combine with defaultConfigs
            const
                defaultConfig = constructor.getDefaultConfiguration(),
                configKeys    = [...new Set(ObjectHelper.allKeys(defaultConfig))];

            if (configKeys.length) {
                if (!me.useRawData || !me.useRawData.enabled) {
                    // Shallow copy of data to not mutate incoming object
                    data = Object.assign({}, data);
                }

                configs = {};

                configKeys.forEach(key => {
                    // Use as config
                    configs[key] = data[key] || defaultConfig[key];
                    // Remove from data
                    delete data[key];
                });
            }
        }

        super.construct(configs);

        // make getters/setters for fields, needs to be done before processing data to make sure defaults are available
        if (skipExpose) {
            if (!constructor.hasOwnProperty('fieldMap')) {
                constructor.exposeProperties();
            }
        }
        else {
            constructor.exposeProperties(data);
        }

        // It's only valid to do this once, on construction of the first instance
        if (!constructor.hasOwnProperty('idFieldProcessed')) {
            // idField can be overridden from meta, or from the store if we have not had an idField set programmatically
            // and if we have not had an id field defined above the base Model class level.

            let overriddenIdField = me.meta.idField;

            if (!overriddenIdField) {
                // Might have been set to Model after construction but before load
                if (constructor._assignedIdField) {
                    overriddenIdField = constructor.idField;
                }
                // idField on store was deprecated, but should still work to not break code
                // TODO: Remove in 3.0? Or reintroduce it...
                else if (store) {
                    overriddenIdField = store.idField;
                }
            }

            // If it's overridden to something different than we already have, replace the 'id' field in the fieldMap
            if (overriddenIdField && overriddenIdField !== fieldMap.id.dataSource) {
                constructor.addField({
                    name       : 'id',
                    dataSource : overriddenIdField
                });
            }
            constructor.idFieldProcessed = true;
        }

        // assign internalId, unique among all records
        me._internalId = Model._internalIdCounter++;

        // relation code expects store to be available for relation lookup, but actual join done below
        me.stores = [];
        me.unjoinedStores = [];

        // Superclass constructors may set this in their own way before this is called.
        if (!me.originalData) {
            me.originalData = data;
        }

        me.data = constructor.processData(data, false, store);

        // Consider undefined and null as missing id and generate one
        if (me.id == null) {
            // Assign a generated id silently, record should not be considered modified
            me.setData('id', me.generateId(store));
        }
        if (me.data[constructor.childrenField]) {
            me.processChildren(stores);
        }
        me.generation = 0;
    }

    /**
     * Compares this Model instance to the passed instance. If they are of the same type, and all fields
     * (except, obviously, `id`) are equal, this returns `true`.
     * @param {Core.data.Model} other The record to compare this record with.
     * @returns {Boolean} `true` if the other is of the same class and has all fields equal.
     */
    equals(other) {
        if (other instanceof this.constructor) {
            for (let { fields } = this, i = 0, { length } = fields; i < length; i++) {
                const
                    field    = fields[i],
                    { name } = field;

                if (name !== 'id' && !isEqual(field, this[name], other[name])) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }

    get subclass() {
        return new this.constructor(Object.setPrototypeOf({
            id : _undefined
        }, this.data), this.stores[0], null, true);
    }

    /**
     * Processes raw data, converting values and setting defaults.
     * @private
     * @param {Object} data Raw data
     * @param {Boolean} [ignoreDefaults] Ignore setting default values, used when updating
     * @returns {Object} Processed data
     * @category Fields
     */
    static processData(data, ignoreDefaults = false, store) {
        const
            { fieldMap, defaultValues } = this,
            { useRawData = { enabled : false } } = store || { },
            // Store configured with useRawData uses the supplied data object, polluting it. When not configured with
            // useRawData it instead makes a shallow copy.
            processed = useRawData.enabled ? data : Object.assign({}, data);

        let fieldName;

        ignoreDefaults = ignoreDefaults || useRawData.disableDefaultValue;

        if (!ignoreDefaults) {
            for (fieldName in defaultValues) {
                if (processed[fieldName] === _undefined) processed[fieldName] = defaultValues[fieldName];
            }
        }

        if (!useRawData.disableTypeConversion) {
            // Convert field types which need converting
            for (fieldName in fieldMap) {
                const
                    fieldDefinition      = fieldMap[fieldName],
                    { name, dataSource } = fieldDefinition,
                    // Value might have been supplied either using mapped dataSource (when loading JSON etc. for example
                    // event.myStartDate) or as field name (from internal code, for example event.startDate). If [name]
                    // exists but not [dataSource], use it.
                    useNameForValue      = dataSource !== name && !ObjectHelper.pathExists(data, dataSource) && name in data,
                    convert              = !useRawData.disableTypeConversion && fieldDefinition.convert;

                // Only action field definitions which have a convert function or remap data
                if (useNameForValue || convert) {
                    const value = useNameForValue ? data[name] : data[dataSource];

                    // When ignoringDefaults, do not convert unspecified values
                    if (!ignoreDefaults || ((useNameForValue && name in data) || (!useNameForValue && dataSource in data))) {
                        ObjectHelper.setPath(
                            processed,
                            dataSource,
                            convert
                                ? fieldDefinition.convert(value)
                                : value
                        );
                        // Remove [startDate] from internal data holder, only keeping [myStartDate]
                        if (useNameForValue) {
                            delete processed[name];
                        }
                    }
                }
            }
        }

        return processed;
    }

    /**
     * Makes getters and setters for fields (from definitions and data). Called once when class is defined and once when
     * data is loaded first time.
     * @internal
     * @param {Object} [data] Raw data
     * @category Fields
     */
    static exposeProperties(data) {
        const me         = this,
            superclass = me.superclass,
            rawFields  = me.hasOwnProperty('fields') && me.fields;

        // Ensure that the class hierarchy processes its fields on first construction.
        if (superclass.exposeProperties && !superclass.hasOwnProperty('fieldMap')) {
            superclass.exposeProperties();
        }

        // Don't expose field properties if already done
        if (!me.hasOwnProperty('propertiesExposed')) {
            // Clone the superclass's defaults, and override that with our own defaults.
            // As we find fields with a defaultValue, more defaults may be added
            me.defaultValues = Object.assign({}, superclass.defaultValues, me.hasOwnProperty('defaults') ? me.defaults : null);

            // Hook up our field maps with the class hierarchy's fieldMaps.
            // We need to be able to look up field definitions by the name, or by the dataSource property name

            /**
             * An object containing all the _defined_ fields for this Model class. This will include all superclass's
             * defined fields through its prototype chain. So be aware that `Object.keys` and `Object.entries` will only
             * access this class's defined fields.
             * @member {Object} fieldMap
             * @static
             * @readonly
             * @category Fields
             */
            me.fieldMap = Object.setPrototypeOf({}, superclass.fieldMap || emptyObject$2);
            me.fieldDataSourceMap = Object.setPrototypeOf({}, superclass.fieldDataSourceMap || emptyObject$2);

            // Hook up our propertiesExposed with the superclass's version
            me.propertiesExposed = Object.setPrototypeOf({}, superclass.propertiesExposed || emptyObject$2);

            // If the idField is overridden at this level, create a new field
            if (me.hasOwnProperty('idField')) {
                me.addField({
                    name       : 'id',
                    dataSource : me.idField
                });
                me.propertiesExposed[me.idField] = true;
            }

            // Process fields defined in the class definition
            if (rawFields && rawFields.length) {
                rawFields.map(me.addField, me);
            }
        }

        // Process the raw data properties and expose them as fields unless the property name
        // has already been used by the "dataSource" of a defined field.
        if (me.autoExposeFields && data && !me.hasOwnProperty('propertiesExposedForData')) {
            for (const dataProperty in data) {
                if (!me.propertiesExposed[dataProperty]) {
                    // Create a field definition in our fieldMap with the flag that it's from data
                    me.addField({
                        name       : dataProperty,
                        dataSource : dataProperty,
                        fromData   : true
                    });
                }
            }
            me.propertiesExposedForData = true;
        }

        me.exposeRelations();
    }

    /**
     * Add a field definition in addition to those predefined in `fields`.
     * @param {String|Object} field A field name or definition
     */
    static addField(fieldDef) {
        if (fieldDef == null) {
            return;
        }

        if (typeof fieldDef === 'string') {
            fieldDef = {
                name : fieldDef
            };
        }

        const
            me = this,
            { propertiesExposed, defaultValues } = me,
            { name } = fieldDef,
            dataSource = fieldDef.dataSource || (fieldDef.dataSource = name);

        if (!fieldDef.hasOwnProperty('persist')) {
            fieldDef.persist = true;
        }

        if (fieldDef.type === 'date') {
            fieldDef.convert = convertDate;
        }
        me.fieldMap[name] = fieldDef;

        if (!me.fieldDataSourceMap[dataSource]) {
            me.fieldDataSourceMap[dataSource] = fieldDef;
        }

        // With complex mapping avoid exposing object as model field
        if (dataSource.includes('.') || fieldDef.type === 'model') {
            fieldDef.complexMapping = true;
            propertiesExposed[dataSource.split('.')[0]] = true;
        }
        // When iterating through the raw data, if autoExposeFields is set
        // We do not need to create properties for raw property names we've processed here
        else {
            propertiesExposed[dataSource] = true;
        }

        // Maintain an object of defaultValues for fields.
        if ('defaultValue' in fieldDef) {
            defaultValues[dataSource] = fieldDef.defaultValue;
        }

        // Create a property on this Model's prototype, named for the defined field name
        // which reads the correct property out of the raw data object.
        me.createFieldProperty(name, dataSource, fieldDef);

        return fieldDef;
    }

    /**
     * Remove a field definition by name.
     * @param {String} fieldName Field name
     */
    static removeField(fieldName) {
        const definition = this.fieldMap[fieldName];
        if (definition) {
            const { dataSource } = definition;
            delete this.fieldMap[fieldName];
            delete this.fieldDataSourceMap[dataSource];
            delete this.prototype[fieldName];
            this._internalFields = null; // Regenerated on next usage
        }
    }

    /**
     * Create getter and setter functions for the specified field name under the specified key.
     *
     * @param {String} fieldName The defined field name (or property name if this is created by exposing a raw property)
     * @param {String} propertyName The property name to read off the data property
     * @param {Object} fieldDef The full field definition.
     * @private
     * @category Fields
     */
    static createFieldProperty(fieldName, propertyName, fieldDef) {
        const me = this;

        // checking (fieldName in me.prototype) instead of hasOwnProperty to catch cases where getters/setters are
        // manually created on some parent
        if (!internalProps[propertyName]) {

            if (!(fieldName in me.prototype)) {
                Object.defineProperty(me.prototype, fieldName, {
                    enumerable   : true,
                    configurable : true, // To allow removing it later
                    get() {
                        // no arrow functions here, need `this` to change to instance
                        // noinspection JSPotentiallyInvalidUsageOfClassThis
                        return this.get(fieldName);
                    },
                    // Only create a real setter if the field is read/write.
                    // privately, we will use setData to set a field's value
                    set : (fieldDef && fieldDef.readOnly) ? nullFn : function(value) {
                        // no arrow functions here, need `this` to change to instance
                        // noinspection JSPotentiallyInvalidUsageOfClassThis
                        this.set(fieldName, value);
                    }
                });
            }
        }
    }

    /**
     * Makes getters and setters for related records. Populates a Model#relation array with the relations, to allow it
     * to be modified later when assigning stores.
     * @internal
     * @category Relations
     */
    static exposeRelations() {
        const me = this;

        if (me.hasOwnProperty('relationsExposed')) return;

        if (me.relationConfig) {
            me.relationsExposed = true;
            me.relations = [];

            me.relationConfig.forEach(relation => {
                me.relations.push(relation);

                const name = relation.relationName;

                // getter and setter for related object
                if (!Reflect.ownKeys(me.prototype).includes(name)) {
                    Object.defineProperty(me.prototype, name, {
                        enumerable : true,
                        get        : function() {
                            // noinspection JSPotentiallyInvalidUsageOfClassThis
                            return this.getForeign(name);
                        },
                        set : function(value) {
                            // noinspection JSPotentiallyInvalidUsageOfClassThis
                            this.setForeign(name, value, relation);
                        }
                    });
                }
            });
        }
    }

    //endregion

    //region Fields

    /**
     * Flag checked from Store when loading data that determines if fields found in first records should be exposed in
     * same way as predefined fields.
     * @returns {Boolean}
     * @category Fields
     */
    static get autoExposeFields() {
        return true;
    }

    /**
     * Predefined fields, none per default, override in subclasses to add fields.
     * @returns {Object[]}
     * @readonly
     * @category Fields
     */
    static get fields() {
        return [];
    }

    static get internalFields() {
        const { fieldMap } = this;

        let result = this._internalFields;

        // Produce the array lazily - it probably will never be used.
        // Only available when we have exposed our properties.
        if (this.hasOwnProperty('fieldMap') && !result) {
            result = this._internalFields = [];
            for (const fieldName in fieldMap) {
                result.push(fieldMap[fieldName]);
            }
        }
        return result;
    }

    /**
     * Convenience getter to get field definitions from class.
     * @returns {Array}
     * @category Fields
     */
    get fields() {
        return this.constructor.internalFields || this.constructor.fields;
    }

    /**
     * Convenience function to get the definition for a field from class.
     * @param {String} fieldName Field name
     * @returns {Object}
     * @category Fields
     */
    getFieldDefinition(fieldName) {
        return this.constructor.getFieldDefinition(fieldName);
    }

    getFieldDefinitionFromDataSource(dataSource) {
        return this.constructor.fieldDataSourceMap[dataSource];
    }

    /**
     * Get the names of all fields in data.
     * @returns {String[]} Field names
     * @readonly
     * @category Fields
     */
    get fieldNames() {
        return Object.keys(this.data);
    }

    /**
     * Get the definition for a field by name. Caches results.
     * @param {String} fieldName Field name
     * @returns {Object} Field definition or null if none found
     * @category Fields
     */
    static getFieldDefinition(fieldName) {
        return this.fieldMap[fieldName];
    }
    
    /**
     * Returns dataSource configuration for a given field name
     * @param {String} fieldName
     * @returns {String} Field `dataSource` mapping
     * @internal
     */
    static getFieldDataSource(fieldName) {
        return this.getFieldDefinition(fieldName).dataSource;
    }

    /**
     * Get the data source used by specified field. Returns the fieldName if no data source specified.
     * @param {String} fieldName Field name
     * @returns {String}
     * @category Fields
     */
    getDataSource(fieldName) {
        const def = this.constructor.getFieldDefinition(fieldName);
        if (def) return def.dataSource || def.name;
    }

    /**
     * Processes input to a field, converting to expected type.
     * @param {String} fieldName Field dataSource
     * @param {*} value Value to process
     * @returns {*} Converted value
     * @category Fields
     */
    static processField(fieldName, value) {
        const field = this.fieldMap[fieldName];

        if (field && field.convert) {
            return field.convert(value);
        }
        return value;
    }

    //endregion

    //region Relations

    /**
     * Initializes model relations. Called from store when adding a record.
     * @private
     * @category Relations
     */
    initRelations() {
        const me        = this,
            relations = me.constructor.relations;

        if (!relations) return;

        // TODO: feels strange to have to look at the store for relation config but didn't figure out anything better.
        // TODO: because other option would be to store it on each model instance, not better...

        me.stores.forEach(store => {
            if (!store.modelRelations) store.initRelations();

            // TODO: not at all tested for multiple stores, can't imagine it works as is
            const relatedRecords = [];

            store.modelRelations && store.modelRelations.forEach(config => {
                relatedRecords.push({ related : me.initRelation(config), config });
            });
            store.updateRecordRelationCache(me, relatedRecords);
        });
    }

    /**
     * Initializes/updates a single relation.
     * @param config Relation config
     * @returns {Core.data.Model} Related record
     * @private
     * @category Relations
     */
    initRelation(config) {
        const
            me          = this,
            keyValue    = me.get(config.fieldName),
            foreign     = keyValue !== _undefined && typeof config.store !== 'string' && config.store.getById(keyValue),
            placeHolder = { id : keyValue, placeHolder : true };

        if (!me.meta.relationCache) me.meta.relationCache = {};
        // apparently scheduler tests expect cache to work without matched related record, thus the placeholder
        me.meta.relationCache[config.relationName] = foreign || (keyValue != null ? placeHolder : null);

        return foreign;
    }

    removeRelation(config) {
        // (have to check for existence before deleting to work in Safari)
        if (this.meta.relationCache[config.relationName]) {
            delete this.meta.relationCache[config.relationName];
            if (config.nullFieldOnRemove) {
                // Setting to null silently, to not trigger additional relation behaviour
                this.setData(config.fieldName, null);
            }
        }
    }

    getForeign(name) {
        return this.meta.relationCache && this.meta.relationCache[name];
    }

    setForeign(name, value, config) {
        const id = Model.asId(value);
        return this.set(config.fieldName, id);
    }

    //endregion

    //region Get/set values, data handling

    /**
     * Get value for specified field name. You can also use the generated getters if loading through a Store.
     * If model is currently in batch operation this will return updated batch values which are not applied to Model
     * until endBatch() is called.
     * @param {String} fieldName Field name to get value from
     * @returns {*} Fields value
     * @category Fields
     */
    get(fieldName) {
        const
            me         = this,
            recData    = me.meta.batchChanges ?  Object.assign({}, me.data, me.meta.batchChanges) : me.data;

        let field      = me.constructor.fieldMap[fieldName];

        const dataSource = field ? field.dataSource : fieldName;

        if (dataSource) {
            // Getting property of nested record?
            if (!field && fieldName.includes('.')) {
                const nestedName = fieldName.split('.')[0];

                field = me.constructor.fieldMap[nestedName];
            }

            if (field && field.complexMapping) {
                return ObjectHelper.getPath(recData, dataSource);
            }

            return (dataSource in recData) ? recData[dataSource] : recData[fieldName];
        }
    }

    /**
     * Internal function used to update a records underlying data block (record.data) while still respecting field
     * mappings. Needed in cases where a field needs setting without triggering any associated behaviour and it has a
     * dataSource with a different name.
     *
     * For example:
     * ```javascript
     * // startDate mapped to data.beginDate
     * { name : 'startDate', dataSource : 'beginDate' }
     *
     * // Some parts of our code needs to update the data block without triggering any of the behaviour associated with
     * // calling set. This would then not update "beginDate":
     * record.data.startDate = xx;
     *
     * // But this would
     * record.setData('startDate', xx);
     * ```
     * @internal
     * @category Editing
     */
    setData(fieldName, value) {
        const field      = this.constructor.fieldMap[fieldName],
            dataSource = field ? field.dataSource : fieldName;

        if (dataSource) {
            ObjectHelper.setPath(this.data, dataSource, value);
        }
    }

    /**
     * Silently updates record's id with no flagging the property as modified.
     * Triggers onModelChange event for changed id.
     * @param {String|Number} value id value
     * @private
     */
    syncId(value) {
        const oldValue = this.id;
        if (oldValue !== value) {
            this.setData('id', value);
            const data = { id : { value, oldValue } };
            this.afterChange(data, data);
        }
    }

    /**
     * Set value for the specified field. You can also use the generated setters if loading through a Store.
     * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call
     * @param {*} value Value to set
     * @param {Boolean} [silent] Set to true to not trigger events
     * @fires Store#idChange
     * @fires Store#update
     * @fires Store#change
     * @example
     * person.set('name', 'Donald');
     * @category Editing
     */
    set(field, value, silent = false, fromRelationUpdate = false) {
        const me = this;

        // We use beforeSet/inSet/afterSet approach here because mixin interested in overriding set() method
        // like STM, for example, might be mixed before Model class or after. In general I have no control over this.
        // STM mixed before, so the only option to wrap set() method body is actually to call
        // beforeSet()/afterSet().

        if (me.isBatchUpdating) {
            me.inBatchSet(field, value);
            return null;
        }
        else {
            const
                preResult = me.beforeSet ? me.beforeSet(field, value, silent, fromRelationUpdate) : _undefined,
                wasSet    = me.inSet(field, value, silent, fromRelationUpdate);
            me.afterSet && me.afterSet(field, value, silent, fromRelationUpdate, preResult, wasSet);
            return wasSet;
        }
    }

    fieldToKeys(field, value) {
        let result;
        if (typeof field !== 'string') {
            result = {};
            // will get in trouble when setting same field on multiple models without this
            Reflect.ownKeys(field).forEach(key => result[key] = field[key]);
        }
        else {
            result = {
                [field] : value
            };
        }
        return result;
    }

    inBatchSet(field, value) {
        if (typeof field !== 'string') {
            const toSet = this.fieldToKeys(field, value);
            Object.keys(toSet).forEach(key => {
                // Store batch changes
                this.meta.batchChanges[key] = this.constructor.processField(key, toSet[key]);
            });
        }
        else {
            // Minor optimization for engine writing back a lot of changes
            this.meta.batchChanges[field] = value;
        }
    }

    inSet(field, value, silent, fromRelationUpdate) {
        const
            me       = this,
            fieldMap = me.constructor.fieldMap,
            myProto  = me.constructor.prototype,
            data     = me.data,
            wasSet   = {},
            toSet    = me.fieldToKeys(field, value);
        let
            changed  = false;

        // Give a chance to cancel action before records updated.
        if (!silent && !me.triggerBeforeUpdate(toSet)) {
            return null;
        }

        Object.keys(toSet).forEach(key => {
            // Currently not allowed to set children in a TreeNode this way, will be ignored
            if (key === me.constructor.childrenField) {
                return;
            }

            const
                field    = fieldMap[key],
                readOnly = field && field.readOnly,
                mapping  = field ? field.dataSource : key,
                useProp  = !field && (key in myProto),
                oldValue = useProp ? me[mapping] : ObjectHelper.getPath(data, mapping),
                value    = me.constructor.processField(key, toSet[key]),
                val      = toSet[key] = { value },
                relation = me.getRelationConfig(key);

            if (!readOnly && !isEqual(field, oldValue, value))  {
                // Indicate to observers that data has changed.
                me.generation++;
                val.oldValue = oldValue;

                changed = true;

                // changing back to old value? remove from modified
                // `modified` should contain mapped field name, it is used in sync
                if (isEqual(field, me.meta.modified[key], value)) {
                    delete me.meta.modified[key];
                }
                else {
                    // store info on modification
                    me.meta.modified[key] = oldValue;
                    if (val.oldValue === _undefined && 'oldValue' in val) {
                        delete val.oldValue;
                    }
                }

                // The wasSet object keys must be the field *name*, not its dataSource.
                wasSet[key] = val;

                // If we don't have a field, but we have a property defined
                // eg, the fullDuration property defined in TaskModel, then
                // use the property
                if (useProp) {
                    me[key] = value;
                }
                // Otherwise, push the value through into the data.
                else {
                    ObjectHelper.setPath(data, mapping, value);
                }

                // changing foreign key
                if (relation && !fromRelationUpdate) {
                    me.initRelation(relation);
                    me.stores.forEach(store => store.cacheRelatedRecord(me, value, relation.relationName, val.oldValue));
                }
            }
            else {
                delete toSet[key];
            }
        });

        if (changed) {
            me.afterChange(toSet, wasSet, silent, fromRelationUpdate);
        }

        return changed ? wasSet : null;
    }

    afterChange(toSet, wasSet, silent, fromRelationUpdate) {
        this.stores.forEach(store => {
            store.onModelChange(this, toSet, wasSet, silent, fromRelationUpdate);
        });
    }

    get isPersistable() {
        return true;
    }

    /**
     * True if this model has any uncommitted changes.
     * @property {Boolean}
     * @readonly
     * @category Editing
     */
    get isModified() {
        return Boolean(this.meta.modified && Object.keys(this.meta.modified).length > 0);
    }

    /**
     * Returns true if this model has uncommitted changes for the provided field.
     * @param {String} fieldName Field name
     * @returns {Boolean} True if the field is changed
     */
    isFieldModified(fieldName) {
        return this.isModified && this.meta.modified[fieldName];
    }

    /**
     * Returns field value that should be persisted, or `undefined` if field is configured with `persist: false`.
     * @param {String} name Name of the field to get value
     * @private
     * @category Fields
     */
    getFieldPersistentValue(name) {
        const field = this.getFieldDefinition(name);
        let result;

        if (!field || field.persist) {
            result = this[name];
            // if serialize function is provided we use it to prepare the persistent value
            if (field && field.serialize) {
                result = field.serialize.call(this, result, this);
            }
        }

        return result;
    }

    /**
     * Get a map of the modified fields in form of an object. The field *names* are used as the property names
     * in the returned object.
     * @property {Object}
     * @readonly
     * @category Editing
     */
    get modifications() {
        const me = this;

        if (!me.isModified) {
            return null;
        }

        const data = {};
        Object.keys(me.meta.modified).forEach(key => {
            // TODO: isModified will report record as modified even if a modification wont be persisted here. Should it?
            const value = me.getFieldPersistentValue(key);
            if (value !== _undefined) {
                data[key] = value;
            }
        });
        data[me.constructor.idField] = me.id;

        return data;
    }

    /**
     * Get a map of the modified fields in form of an object. The field *dataSources* are used as the property names
     * in the returned object.
     * @property {Object}
     * @readonly
     * @category Editing
     */
    get modificationData() {
        const
            me = this,
            {
                fieldMap,
                idField
            } = me.constructor;

        if (!me.isModified) {
            return null;
        }

        const data = {};
        Object.keys(me.meta.modified).forEach(fieldName => {
            // TODO: isModified will report record as modified even if a modification wont be persisted here. Should it?
            const field = fieldMap[fieldName];

            // No field definition means there's no original dataSource to update
            if (field) {
                const value = me.getFieldPersistentValue(fieldName);

                if (value !== _undefined) {
                    ObjectHelper.setPath(data, field.dataSource, value);
                }
            }
        });
    
        // If there are some persistable field changes, append record id
        if (Object.keys(data).length) {
            ObjectHelper.setPath(data, me.constructor.getFieldDefinition(idField).dataSource, me.id);
        }

        return data;
    }

    /**
     * Get persistable data in form of an object.
     * @property {Object}
     * @internal
     * @readonly
     * @category Editing
     */
    get persistableData() {
        const
            me   = this,
            data = {};

        me.fields.forEach(field => {
            const value = me.getFieldPersistentValue(field.name);
            
            if (value !== _undefined) {
                ObjectHelper.setPath(data, field.dataSource, value);
            }
        });

        return data;
    }

    /**
     * True if this models changes are currently being committed.
     * @property {boolean}
     * @category Editing
     */
    get isCommitting() {
        return Boolean(this.meta.committing);
    }

    /**
     * Clear stored changes, used on commit. Does not revert changes.
     * @param {Boolean} [removeFromStoreChanges] Update related stores modified collection or not
     * @param {Boolean} [includeDescendants] Set true to clear store descendants
     * @category Editing
     * @private
     */
    clearChanges(removeFromStoreChanges = true, includeDescendants = true) {
        const me = this,
            { meta } = me;

        meta.modified = {};
        meta.committing = false;

        if (removeFromStoreChanges) {
            me.stores.forEach(store => {
                store.modified.remove(me);
                store.added.remove(me);
                if (includeDescendants) {
                    const descendants = store.collectDescendants(me).all;
                    store.added.remove(descendants);
                    store.modified.remove(descendants);
                }
            });
        }
    }

    //endregion

    //region Id

    /**
     * Gets the records internalId. It is assigned during creation, guaranteed to be globally unique among models.
     * @property {Number}
     * @category Identification
     */
    get internalId() {
        return this._internalId;
    }

    /**
     * Returns true if the record is new and has not been persisted (and received a proper id).
     * @property {Boolean}
     * @readonly
     * @category Identification
     */
    get isPhantom() {
        return this.id === '' || this.id == null || this.hasGeneratedId;
    }

    get isModel() {
        return true;
    }

    /**
     * Checks if record has a generated id. New records are assigned a generated id (starting with _generated), which should be
     * replaced on commit.
     * @property {Boolean}
     * @category Identification
     */
    get hasGeneratedId() {
        return this.id && typeof this.id === 'string' && this.id.startsWith('_generated');
    }

    /**
     * Generates id for new record which starts with _generated.
     * @category Identification
     */
    generateId() {
        if (!this.constructor.generatedIdIndex) this.constructor.generatedIdIndex = 0;
        return '_generated' + this.$name + (++this.constructor.generatedIdIndex);
    }

    /**
     * Gets the id of specified model or the value if passed string/Number.
     * @param {Core.data.Model|String|Number} model
     * @returns {String|Number} id
     * @category Identification
     */
    static asId(model) {
        return model && model.isModel ? model.id : model;
    }

    //endregion

    //region JSON

    /**
     * Get the records data as a json string.
     * @member {String}
     * @category Misc
     */
    get json() {
        return JSON.stringify(this.data);
    }

    /**
     * Used by JSON.stringify to correctly convert this record to json. No point in calling it directly.
     * @private
     * @category Misc
     */
    toJSON() {
        return this.data;
    }

    //endregion

    //region Batch

    /**
     * True if this Model is currently batching its changes.
     * @property {Boolean}
     * @readonly
     * @category Editing
     */
    get isBatchUpdating() {
        return Boolean(this.batching);
    }

    /**
     * Begin a batch, which stores changes and commits them when the batch ends.
     * Prevents events from being fired during batch.
     * ```
     * record.beginBatch();
     * record.name = 'Mr Smith';
     * record.team = 'Golden Knights';
     * record.endBatch();
     * ```
     * Please note that you can also set multiple fields in a single call using {@link #function-set}, which in many
     * cases can replace using a batch:
     * ```
     * record.set({
     *   name : 'Mr Smith',
     *   team : 'Golden Knights'
     * });
     * ```
     * @category Editing
     */
    beginBatch() {
        const me = this;
        if (!me.batching) {
            me.batching = 0;
            me.meta.batchChanges = {};
        }
        me.batching++;
    }

    /**
     * End a batch, triggering events if data has changed.
     * @param {Boolean} [silent] Specify `true` to not trigger events
     * @category Editing
    */
    endBatch(silent = false) {
        const
            me = this,
            { parentIdField } = me.constructor;

        if (!me.batching) {
            return;
        }

        me.batching--;

        if (me.batching > 0) {
            return;
        }

        // Set pending batch changes
        if (!ObjectHelper.isEmpty(me.meta.batchChanges)) {
            const batchChanges = Object.assign({}, me.meta.batchChanges);
            me.meta.batchChanges = null;

            // Move to its new parent before applying the other changes.
            if (batchChanges[parentIdField]) {
                me.parentId = batchChanges[parentIdField];
                delete batchChanges[parentIdField];
            }

            me.set(batchChanges, _undefined, silent);
            me.cancelBatch();
        }
    }

    /**
     * Cancels current batch operation. Any changes during the batch are discarded.
     * @category Editing
     */
    cancelBatch() {
        this.batching = null;
        this.meta.batchChanges = null;
    }

    //endregion

    //region Events

    /**
     * Triggers beforeUpdate event for each store and checks if changes can be made from event return value.
     * @param {Object} changes Data changes
     * @returns {Boolean} returns true if data changes are accepted
     * @private
     */
    triggerBeforeUpdate(changes) {
        return !this.stores.some(s => {
            if (s.trigger('beforeUpdate', { record : this, changes }) === false) {
                return true;
            }
        });
    }

    //endregion

    //region Additional functionality

    /**
     * Makes a copy of this model, assigning the specified id or a generated id.
     * @param {Number|String|Object} [newId] Id to set (or config object), leave out to use generated id or specify false to also copy id
     * @param {Number|String} [newId.id] Id to set, leave out to use generated id or specify false to also copy id
     * @param {Boolean} [newId.deep] True to also clone children
     * @returns {Core.data.Model} Copy of this model
     * @category Editing
     */
    copy(newId = null) {
        const
            me      = this,
            data    = Object.assign({}, me.data),
            idField = me.constructor.idField;

        let returnInstance = true,
            deep, id, copy;

        if (newId && typeof newId === 'object') {
            deep = newId.deep;
            id   = newId.id;

            // Only use id once to avoid collisions
            delete newId.id;
        }
        else {
            id = newId;
        }

        // Iterate over instance children, because data may not reflect actual children state
        if (deep && me.children) {
            returnInstance = false;
            data.children  = me.children.map(child => child.copy(newId));
        }
        else {
            delete data.children;
            delete data.expanded;
        }

        if (id) {
            data[idField] = id;
        }
        else if (id == null) {
            data[idField] = me.generateId(me.firstStore);
        }

        if (returnInstance) {
            copy = new me.constructor(data);
        }
        else {
            copy = data;
        }

        // Store original record internal id to lookup from copy later
        copy.originalInternalId = me.internalId;

        return copy;
    }

    /**
     * Removes this record from all stores (and in a tree structure, also from its parent if it has one).
     * @param {Boolean} [silent] Specify `true` to not trigger events
     * @category Editing
     */
    remove(silent = false) {
        const me = this,
            { parent } = this;

        // Remove from parent if we're in a tree structure.
        // This informs the owning store(s)
        if (parent) {
            parent.removeChild(me);
        }
        // Store handles remove
        else if (me.stores.length) {
            // Not sure what should happen if you try to remove a special row (group row for example), bailing out
            if (!me.meta.specialRow) {
                me.stores.forEach(s => s.remove(me, silent, false, true));
            }
        }
    }

    /**
     * Get the first store that this model is assigned to.
     * @returns {Core.data.Store}
     * @category Misc
     */
    get firstStore() {
        return this.stores.length > 0 && this.stores[0];
    }

    /**
     * Get a relation config by name, from the first store.
     * @param {String} name
     * @returns {Object}
     * @private
     * @category Relations
     */
    getRelationConfig(name) {
        // using first store for relations, might have to revise later..
        return this.firstStore && this.firstStore.modelRelations && this.firstStore.modelRelations.find(r => r.fieldName === name);
    }

    //endregion

    //region Validation

    /**
     * Check if record has valid data. Default implementation returns true, override in your model to do actual validation.
     * @returns {Boolean}
     * @category Editing
     */
    get isValid() {
        return true;
    }

    //endregion

    //region Store

    /**
     * Joins this record and any children to specified store, if not already joined.
     * @internal
     * @param {Core.data.Store} store Store to join
     * @category Misc
     */
    joinStore(store) {
        const me = this,
            { stores, unjoinedStores } = me;

        if (!stores.includes(store)) {
            super.joinStore && super.joinStore(store);
            store.register(me);
            stores.push(store);
            if (unjoinedStores.includes(store)) {
                unjoinedStores.splice(unjoinedStores.indexOf(store), 1);
            }
            me.isLoaded && me.children.forEach(child => child.joinStore(store));
            me.initRelations();

            if (store.tree && !me.isRoot) {
                me.instanceMeta(store.id).collapsed = !me.expanded;
            }
        }
    }

    /**
     * Unjoins this record and any children from specified store, if already joined.
     * @internal
     * @param {Core.data.Store} store Store to join
     * @category Misc
     */
    unJoinStore(store) {
        const me = this,
            { stores, unjoinedStores } = me;

        if (stores.includes(store)) {
            store.unregister(me);
            me.children && me.children.forEach(child => child.unJoinStore(store));
            stores.splice(stores.indexOf(store), 1);
            // keep the cord to allow removed records to reach the store when needed
            unjoinedStores.push(store);
            super.unJoinStore && super.unJoinStore(store);

            // remove from relation cache
            store.uncacheRelatedRecord(me);
        }
        if (!stores.length) {
            me.meta.removed = true;
        }
    }

    /**
     * Returns true if this record is contained in the specified store, or in any store if store param is omitted.
     * @internal
     * @param {Core.data.Store} store Store to join
     * @returns {Boolean}
     * @category Misc
     */
    isPartOfStore(store) {
        if (store) {
            return store.indexOf(this) >= 0;
        }

        return this.stores.length > 0;
    }
    //endregion

    //region Per instance meta

    /**
     * Used to set per external instance meta data. For example useful when using a record in multiple grids to store some state
     * per grid.
     * @param {String|Object} instanceOrId External instance id or the instance itself, if it has id property
     * @private
     * @category Misc
     */
    instanceMeta(instanceOrId) {
        const { meta } = this,
            id       = instanceOrId.id || instanceOrId;
        if (!meta.map) meta.map = {};
        return meta.map[id] || (meta.map[id] = {});
    }

    //endregion
}

Model._idField = 'id';
Model._internalIdCounter = 1;
Model._assignedIdField = false;

Model.exposeProperties();
Model._$name = 'Model';

//inspired by http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/

const base = (baseClass) => (
    {
        mixes : (...mixins) => {
            return mixins.reduce((result, mixin) => mixin(result), baseClass || Base);
        }
    }
);

/**
 * @module Core/data/StoreBag
 */

class StoreBag extends Bag {

    add(...toAdd) {
        if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
            toAdd = toAdd[0];
        }

        // ignore unpersistable records
        return super.add(...toAdd.filter(record => record.isPersistable));
    }

}StoreBag._$name = 'StoreBag';

/**
 * @module Core/data/mixin/StoreCRUD
 */

/**
 * Mixin for Store that handles modifying records (add, remove etc).
 *
 * @example
 * // add new record to store
 * store.add({ id: 1, team: 'FC Krasnodar' });
 *
 * // remove a record from store, using id
 * store.remove(1);
 *
 * @mixin
 */
var StoreCRUD = Target => class StoreCRUD extends (Target || Base) {
    //region Config

    static get defaultConfig() {
        return {
            /**
             * Commit changes automatically
             * @config {Boolean}
             * @default
             * @category Common
             */
            autoCommit : false
        };
    }

    //endregion

    //region Events

    /**
     * Fired after removing all records
     * @event removeAll
     * @param {Core.data.Store} source This Store
     */

    /**
     * Fired before committing changes. Return false from handler to abort commit
     * @event beforeCommit
     * @param {Core.data.Store} source This Store
     * @param {Object} changes Modification data
     */

    /**
     * Fired after committing changes
     * @event commit
     * @param {Core.data.Store} source This Store
     * @param {Object} changes Modification data
     */

    /**
     * Fired before records are removed from this store by the {@link #function-remove} or {@link #function-removeAll}.
     * Also fired when removing a child record in a tree store using {@link Core.data.mixin.TreeNode#function-removeChild}.
     * The remove may be vetoed by returning `false` from a handler.
     * @event beforeRemove
     * @param {Core.data.Store} source This Store
     * @param {Core.data.Model[]} records The records which are to be removed.
     * @param {Core.data.Model} parent The record from which children are being removed when using a tree store
     * @param {Boolean} isMove Set to `true` if the child node is being removed by
     * {@link Core.data.mixin.TreeNode#function-appendChild appendChild} to be moved
     * _within the same tree_.
     * @param {Boolean} removingAll Set to `true` if the operation is removing the store's entire data set.
     */

    /**
     * Fired before records are added to this store by the {@link #function-add} or {@link #function-insert}. In a tree
     * store, also fired by {@link Core.data.mixin.TreeNode#function-appendChild} and
     * {@link Core.data.mixin.TreeNode#function-insertChild}. The add or insert may be vetoed by returning `false`
     * from a handler.
     * @event beforeAdd
     * @param {Core.data.Store} source This Store
     * @param {Core.data.Model[]} records The records which are to be added
     * @param {Core.data.Model} parent The parent node when using a tree store
     * @preventable
     */

    /**
     * Fired after adding/inserting record(s). If the record was added to a parent, the `isChild` flag is set on the
     * event. If it was inserted, event contains `index`
     * @event add
     * @param {Core.data.Store} source This Store
     * @param {Core.data.Model[]} records Added records. In case of tree store, if branch is added, only branch root
     * is returned
     * @param {Core.data.Model[]} [allRecords] Flat list of all added records. In case of tree store, if branch is
     * added, all new records are returned, not only branch root
     * @param {Core.data.Model} [parent] If due to an {@link Core.data.mixin.TreeNode#function-appendChild appendChild}
     * call, this is the parent node added to.
     * @param {Number} [index] Insertion point in the store's {@link Core.data.Store#config-storage Collection}.
     * @param {Number} [oldIndex] Not used for tree stores. The index of the first record moved.
     * @param {Boolean} [isChild] Flag which is set to true if the records are added to a parent record
     * @param {Boolean} [isExpand] Flag which is set to true if records are added to the store by expanding parent
     * @param {Object} [isMove] An object keyed by the ids of the records which were moved from another
     * position in the store, or from another parent node in the store. The ids of moved records will be
     * property names with a value `true`.
     */

    /**
     * Fired when a record has been removed
     * @event remove
     * @param {Core.data.Store} source This Store
     * @param {Core.data.Model[]} records Removed records. In case of tree store, if branch is removed, only branch root
     * is returned
     * @param {Core.data.Model[]} [allRecords] Flat list of all removed records. In case of tree store, if branch is
     * removed, all removed records are returned, not only branch root
     * @param {Core.data.Model} [parent] If due to a {@link Core.data.mixin.TreeNode#function-removeChild removeChild}
     * call, this is the parent node removed from.
     * @param {Number} [index] Visible index at which record was removed. In case record is removed from the collapsed
     * branch -1 is returned.
     * @param {Boolean} [isChild] Flag which is set to true if the record is added to a parent record
     * @param {Boolean} [isCollapse] Flag which is set to true if records are removed from the store by collapsing parent
     * @param {Boolean} [isMove] Passed as `true` if the remove was part of a move operation within this Store.
     */
    //endregion

    //region Add, insert & remove

    /**
     * Removes a record from this store.
     * @param {String|String[]|Number|Number[]|Core.data.Model|Core.data.Model[]} records Record/array of records (or record ids) to remove
     * @param {Boolean} [silent] Specify `true` to suppress events/autoCommit
     * @returns {Core.data.Model[]} Removed records
     * @fires beforeRemove
     * @fires remove
     * @fires change
     * @category CRUD
     */
    remove(records, silent = false, fromRemoveChild) {
        const
            me          = this,
            { storage } = me;

        // Ensure we have an array of records in case we are passed IDs
        records = (Array.isArray(records) ? records : [records]).reduce((result, r) => {
            r = me.getById(r);
            if (r) {
                result.push(r);
            }
            return result;
        }, []);

        if (records.length) {
            if (me.tree) {
                // In case it's a set of records from different parents, group them by parent
                const
                    removeChildArgs = records.reduce((result, child) => {
                        const
                            parent = child.parent;

                        if (parent) {
                            if (!result[parent.id]) {
                                result[parent.id] = [parent, []];
                            }
                            result[parent.id][1].push(child);
                        }
                        return result;
                    }, {});

                // Remove the records each from their correct parent
                for (const argBlock of Object.values(removeChildArgs)) {
                    argBlock[0].removeChild(argBlock[1], false, silent);
                }

                return records;
            }
            // Ensure that records in collapsed groups are removed and events fired.
            else if (me.isGrouped) {
                const
                    oldCount                 = storage.count,
                    recordsInCollapsedGroups = [],
                    changedGroupParents      = new Set();

                // Collect any records which are in collapsed groups which will not be in the storage
                // Collection, and so will not cause a store change.
                // If we find some, we must fire the event which the store will react to and update itself.
                for (const rec of records) {
                    const { groupParent } = rec.instanceMeta(me);

                    if (groupParent && groupParent.meta.collapsed) {
                        recordsInCollapsedGroups.push(rec);
                    }

                    // Collect group header records which change so they can announce this to cause UI updates.
                    ArrayHelper.remove(groupParent.groupChildren, rec);
                    groupParent.meta.childCount--;
                    changedGroupParents.add(groupParent);
                }

                // The changed group parents must announce their changes, otherwise the group headers
                // in a UI will not refresh to reflect the change.
                for (const groupParent of changedGroupParents) {
                    me.onModelChange(groupParent, {}, {});
                }

                // The store must react as if these records in collapsed groups have been removed from storage
                if (recordsInCollapsedGroups.length) {
                    storage.trigger('change', {
                        action   : 'splice',
                        removed  : recordsInCollapsedGroups,
                        added    : [],
                        replaced : [],
                        oldCount
                    });
                }
            }

            // Give chance to veto or take action before records disappear.
            if (!records.length || (!silent && me.trigger('beforeRemove', { records }) === false)) {
                return null;
            }

            if (silent) {
                me.suspendEvents();
            }

            storage.remove(records);

            if (silent) {
                me.resumeEvents();
            }

            if (me.autoCommit) {
                me.commit();
            }
        }

        return records;
    }

    /**
     * Clears store data. Used by removeAll, separate function for using with chained stores.
     * @private
     * @category CRUD
     */
    clear(removing = true) {
        const
            me          = this,
            { storage } = me;

        if (me.storage.totalCount) {
            // Give chance to veto or take action before records disappear.
            if (removing && me.trigger('beforeRemove', { records : storage.allValues, removingAll : true }) === false) {
                return null;
            }

            if (!removing) {
                // If !removing, we suspend events, and Store#onDataChange won't get to
                // do all this stuff.
                const
                    allRecords = me.registeredRecords;

                for (let i = allRecords.length - 1, rec; i >= 0; i--) {
                    rec = allRecords[i];
                    if (rec && !rec.isDestroyed) {
                        rec.unJoinStore(me);
                    }
                }
                me.removed.clear();
            }

            if (!removing) storage.suspendEvents();
            // Clearing the storage will trigger 'removeAll' and 'change' if `removing`
            storage.clear();
            if (!removing) storage.resumeEvents();

            me.added.clear();
            me.modified.clear();
        }
    }

    /**
     * Removes all records from the store.
     * @param {Boolean} [silent] Specify `true` to suppress events
     * @fires removeAll
     * @fires change
     * @category CRUD
     */
    removeAll(silent = false) {
        const
            me      = this,
            storage = me.storage;

        // No reaction to the storage Collection's change event.
        if (silent) {
            storage.suspendEvents();

            // If silent, the storage Collection won't fire the event we react to
            // to unjoin, and we allow the removing flag in remove() to be true,
            // so *it* will not do the unJoin, so if silent, so do it here.
            const allRecords = me.registeredRecords;

            for (let i = allRecords.length - 1, rec; i >= 0; i--) {
                rec = allRecords[i];
                if (rec && !rec.isDestroyed) {
                    rec.unJoinStore(me);
                }
            }
        }

        if (me.tree) {
            me.rootNode.clear();
        }
        else {
            me.clear();
        }

        if (silent) {
            storage.resumeEvents();
        }
    }

    /**
     * Add records to store.
     * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} records Array of records/data or a single record/data to add to store
     * @param {Boolean} [silent] Specify `true` to suppress events
     * @returns {Core.data.Model[]} Added records
     * @fires add
     * @fires change
     * @category CRUD
     */
    add(records, silent = false) {
        const
            me      = this,
            storage = me.storage,
            added   = [];

        if (!Array.isArray(records)) {
            records = [records];
        }
        else if (!records.length) {
            // Adding zero records, bail out
            return;
        }

        me.tree = me.tree || Boolean(me.autoTree && records[0].children);

        if (me.tree) {
            const
                // Map and not Object to allow keys to keep their type
                parentIdMap = new Map(),
                added       = [];

            records.forEach(node => {
                const
                    parentId = node[me.modelClass.parentIdField];
                if (!parentIdMap.has(parentId)) {
                    parentIdMap.set(parentId, []);
                }
                parentIdMap.get(parentId).push(node);
            });

            parentIdMap.forEach((nodes, parentId) => {
                const
                    parentNode = parentId == null ? me.rootNode : me.getById(parentId);

                if (!parentNode) {
                    throw new Error(`Parent node with id ${parentId} not found, cannot add children.`);
                }

                added.push(...parentNode.appendChild(nodes, silent));
            });

            return added;
        }

        // Give chance to cancel action before records added.
        if (!silent) {
            if (me.trigger('beforeAdd', { records }) === false) {
                return null;
            }
        }

        me.tree = me.tree || Boolean(me.autoTree && records[0].children);

        if (me.tree) {
            return me.rootNode.appendChild(records);
        }

        records.forEach(data => {
            added.push(data instanceof Model ? data : me.createRecord(data));
        });

        if (silent) {
            me.suspendEvents();
        }
        storage.add(added);
        if (silent) {
            me.resumeEvents();
        }

        if (me.autoCommit) {
            me.commit();
        }

        return added;
    }

    /**
     * Insert records to store.
     * @param {Number} index Index to insert at
     * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} records Array of records/data or a single record/data to insert to store
     * @param {Boolean} [silent] Specify `true` to suppress events
     * @returns {Core.data.Model[]} Inserted records
     * @fires add
     * @fires change
     * @category CRUD
     */
    insert(index, records, silent = false) {
        const
            me            = this,
            storage       = me.storage,
            added         = [],
            insertBefore  = me.getAt(index),
            _records      = storage.values,
            removeIndices = [];

        if (!Array.isArray(records)) records = [records];

        // Give chance to cancel action before records added.
        if (me.trigger('beforeAdd', { records }) === false) {
            return null;
        }

        let isNoop, start, i;

        // If the records starting at index or (index - 1), are the same sequence
        // that we are being asked to add, this is a no-op.
        if (_records[start = index] === records[0] || _records[start = index - 1] === records[0]) {
            for (isNoop = true, i = 0; isNoop && i < records.length; i++) {
                if (records[i] !== _records[start + i]) {
                    isNoop = false;
                }
            }
        }
        if (isNoop) {
            return null;
        }

        records.forEach(data => {
            const
                record         = data instanceof Model ? data : me.createRecord(data),
                removedAtIndex = storage.indexOf(record);

            if (record.children && record.children.length && me.autoTree) {
                me.tree = true;
            }

            added.push(record);

            // already in store, do some cleanup
            if (removedAtIndex > -1) {
                if (removedAtIndex < index && insertBefore) index--;
                removeIndices.push(removedAtIndex);
            }

            // Store previous index to be able to determine that it is a move, since Collection does not handle that
            record.meta.previousIndex = removedAtIndex;
        });

        if (me.tree) {
            const
                root = me.rootNode;

            return root.insertChild(records, root.children && root.children[index]);
        }

        // Silently remove them, so that they will be inserted into place.
        // Collection is stable by default, and inserting an existing item
        // is a no-op.
        me.suspendEvents();
        me.storage.remove(removeIndices);
        me.resumeEvents();

        if (silent) {
            me.suspendEvents();
        }
        storage.splice(index, 0, ...added);
        if (silent) {
            me.resumeEvents();
        }

        if (me.autoCommit) {
            me.commit();
        }

        return added;
    }

    /**
     * Moves an individual item to another location.
     * @param {Object} item The item to move.
     * @param {Object} beforeItem the item to insert the first item before.
     */
    move(item, beforeItem) {
        this.storage.move(item, beforeItem);
    }

    //endregion

    //region Update multiple

    setMultiple(filterFn, field, value) {
        const
            me      = this,
            records = [],
            changes = [];

        me.forEach(r => {
            if (filterFn(r)) {
                changes.push(r.set(field, value, true));
                records.push(r);
            }
        });

        // TODO: should consolidate with update, make it take an array instead? to only have to listen for one event outside of store?

        me.trigger('updateMultiple', { records, all : me.records.length === records.length });
        me.trigger('change', { action : 'updatemultiple', records, all : me.records.length === records.length });

        if (me.reapplyFilterOnUpdate && me.isFiltered) me.filter();
    }

    setAll(field, value) {
        const
            me      = this,
            changes = [];

        me.forEach(r => {
            changes.push(r.set(field, value, true));
        });

        me.trigger('updateMultiple', { records : me.records, all : true });
        me.trigger('change', { action : 'updatemultiple', records : me.records, all : true });

        if (me.reapplyFilterOnUpdate && me.isFiltered) me.filter();
    }

    //endregion

    //region Commit

    /**
     * Accepts all changes, resets the modification tracking:
     * * Clears change tracking for all records
     * * Clears added
     * * Clears modified
     * * Clears removed
     * Leaves the store in an "unmodified" state.
     * @internal
     */
    acceptChanges() {
        const
            me = this;

        // Clear record change tracking
        me.added.forEach(r => r.clearChanges(false));
        me.modified.forEach(r => r.clearChanges(false));

        // Clear store change tracking
        me.added.clear();
        me.modified.clear();
        me.removed.clear();
    }

    /**
     * Commits changes, per default only returns changes and resets tracking.
     * @param {Boolean} [silent] Specify `true` to suppress events
     * @returns {Object} Changes, see {@link #property-changes}
     * @fires beforeCommit
     * @fires commit
     * @category CRUD
     */
    commit(silent = false) {
        // resets stores tracking of changed records, doesn't store changes, only returns them
        const
            { changes } = this;

        return this.callPreventable('commit', { changes }, () => {
            this.acceptChanges();

            return changes;
        }, [], silent);
    }

    /**
     * Discards changes in the store.
     * @fires change
     * @category CRUD
     * @private
     */
    // TODO: Need to think of its name. `reject` is a candidate.
    clearChanges() {
        const
            me = this;

        me.remove(me.added.values, true);
        me.modified.forEach(r => r.clearChanges(false));

        // TODO: removed records should be restored
        me.added.clear();
        me.modified.clear();
        me.removed.clear();

        me.trigger('change', { action : 'clearchanges' });
    }

    /**
     * Get uncommitted changes as an object of added/modified/removed arrays of records.
     *
     * ```javascript
     * // Format:
     * {
     *      added: [], // array of Core.data.Model
     *      modified: [], // array of Core.data.Model
     *      removed: [] // array of Core.data.Model
     * }
     * ```
     *
     * @property {Object} changes
     * @property {Array} changes.added Records that have been added
     * @property {Array} changes.modified Records that have been updated
     * @property {Array} changes.removed Records that have been removed
     * @readonly
     * @category Records
     */
    get changes() {
        const
            me = this;

        return (me.added.count || me.modified.count || me.removed.count) ? {
            // Slicing to have changes intact when triggering commit
            added    : me.added.values.slice(),
            modified : me.modified.values.slice(),
            removed  : me.removed.values.slice()
        } : null;
    }

    /**
     * Setting autoCommit to true automatically commits changes to records.
     * @property {Boolean}
     * @category Records
     */
    get autoCommit() {
        return this._autoCommit;
    }

    set autoCommit(auto) {
        this._autoCommit = auto;
        if (auto && this.changes) this.commit();
    }

    //endregion

    //region Changes from other store

    /**
     * Applies changes from another store to this store. Useful if cloning records in one store to display in a
     * grid in a popup etc. to reflect back changes.
     * @param {Core.data.Store} otherStore
     * @category CRUD
     */
    applyChangesFromStore(otherStore) {
        const
            me      = this,
            changes = otherStore.changes;

        if (!changes) return;

        if (changes.added) {
            me.add(changes.added);
        }

        if (changes.removed) {
            // Remove using id, otherwise indexOf in remove fn won't yield correct result
            me.remove(changes.removed.map(r => r.id));
        }

        if (changes.modified) {
            changes.modified.forEach(record => {
                const
                    localRecord = me.getById(record.id);
                localRecord.set(record.modifications);
            });
        }
    }

    //endregion
};

/**
 * @module Core/data/mixin/StoreFilter
 */

/**
 * Mixin for Store that handles filtering.
 * Filters are instances of {@link Core.util.CollectionFilter CollectionFilter} class.
 *
 * - Adding a filter for the same property will replace the current one (unless a unique {@link Core.util.CollectionFilter#config-id Id} is specified),
 * but will not clear any other filters.
 * - Adding a filter through the {@link #function-filterBy} function is ultimate.
 * It will clear all the property based filters and replace the current filterBy function if present.
 * - Removing records from the store does not remove filters!
 * The filters will be reapplied if {@link #config-reapplyFilterOnAdd}/{@link #config-reapplyFilterOnUpdate} are true and you add new records or update current.
 *
 * ```
 * // Add a filter
 * store.filter({
 *     property : 'score',
 *     value    : 10,
 *     operator : '>'
 * });
 *
 * // Replace any filter set with new filters
 * store.filter({
 *     filters : {
 *         property : 'score',
 *         value    : 10,
 *         operator : '>'
 *     },
 *     replace : true
 * });
 *
 * // Remove this one specific filter, leaving any possible others in place.
 * // A filter's id defaults to the property name that it's filtering on.
 * store.removeFilter('age');
 *
 * // Reapply filters without firing an event.
 * // Use if making multiple data mutations with the
 * // intention of updating UIs when all finished.
 * store.filter({
 *     silent : true
 * });
 * ```
 *
 * @mixin
 */
var StoreFilter = Target => class StoreFilter extends (Target || Base) {
    //region Config

    static get defaultConfig() {
        return {
            /**
             * Specify a filter config to use initial filtering
             * @config {Object}
             * @category Filtering
             */
            filters : null,

            /**
             * Specify true to reapply filters when a record is added to the store.
             * @config {Boolean}
             * @default
             * @category Filtering
             */
            reapplyFilterOnAdd : false,

            /**
             * Specify true to reapply filters when a record is updated in the store.
             * @config {Boolean}
             * @default
             * @category Filtering
             */
            reapplyFilterOnUpdate : false

        };
    }

    //endregion

    //region Events

    /**
     * Fired after applying filters to the store
     * @event filter
     * @param {Core.data.Store} source This Store
     * @param {Core.util.Collection} filters Filters used by this Store
     * @param {Core.data.Model[]} records Filtered records
     */

    //endregion

    //region Properties

    /**
     * Currently applied filters. A collection of {@link Core.util.CollectionFilter} instances.
     * @type {Core.util.Collection}
     * @readonly
     * @category Sort, group & filter
     */
    set filters(filters) {
        const me         = this,
            collection = me.filters;

        collection.clear();

        // Invalidate the filtersFunction so that it has to be recalculated upon next access
        me._filtersFunction = null;

        // If we are being asked to filter, parse the filters.
        if (filters) {
            if (filters.constructor.name === 'Object') {
                for (const f of Object.entries(filters)) {
                    // Entry keys are either a field name with its value being the filter value
                    // or, there may be one filterBy property which specifies a filering function.
                    if (f[0] === 'filterBy' && typeof f[1] === 'function') {
                        collection.add(new CollectionFilter({
                            filterBy : f[1]
                        }));
                    }
                    else {
                        collection.add(new CollectionFilter(f[1].constructor.name === 'Object' ? Object.assign({
                            property : f[0]
                        }, f[1]) : {
                            property : f[0],
                            value    : f[1]
                        }));
                    }
                }
            }
            else if (Array.isArray(filters)) {
                // Make sure we are adding CollectionFilters
                collection.add(...filters.map(filterConfig => {
                    if (filterConfig instanceof CollectionFilter) {
                        return filterConfig;
                    }
                    return new CollectionFilter(filterConfig);
                }));
            }
            else if (filters.isCollection) {
                // Use supplied collection? Opting to use items from it currently
                collection.add(...filters.values);
            }
            else {
                
                collection.add(new CollectionFilter({
                    filterBy : filters
                }));
            }

            collection.forEach(item => item.owner = me);
        }
    }

    get filters() {
        return this._filters || (this._filters = new Collection({ extraKeys : ['property'] }));
    }

    set filtersFunction(filtersFunction) {
        this._filtersFunction = filtersFunction;
    }

    get filtersFunction() {
        const me                     = this,
            { filters, isGrouped } = me;

        if (!me._filtersFunction) {
            if (filters.count) {
                const generatedFilterFunction = CollectionFilter.generateFiltersFunction(filters);

                me._filtersFunction = candidate => {
                    // A group record is filtered in if it has passing groupChildren.
                    if (isGrouped && candidate.meta.specialRow) {
                        return candidate.groupChildren.some(generatedFilterFunction);
                    }
                    else {
                        return generatedFilterFunction(candidate);
                    }
                };
            }
            else {
                me._filtersFunction = FunctionHelper.returnTrue;
            }
        }

        return me._filtersFunction;
    }

    /**
     * Check if store is filtered
     * @returns {Boolean}
     * @readonly
     * @category Sort, group & filter
     */
    get isFiltered() {
        return this.filters.values.some(filter => !filter.disabled);
    }

    //endregion

    traverseFilter(record) {
        const
            me          = this,
            hitsCurrent = !record.isRoot && me.filtersFunction(record),
            children    = record.unfilteredChildren || record.children;

        // leaf, bail out
        if (!children || !children.length) {
            return hitsCurrent;
        }

        if (!record.unfilteredChildren) {
            record.unfilteredChildren = record.children.slice();
        }

        record.children = record.unfilteredChildren.filter(r => {
            return me.traverseFilter(r);
        });

        return hitsCurrent || Boolean(record.children.length);
    }

    traverseClearFilter(record) {
        const me = this;

        if (record.unfilteredChildren) {
            record.children = record.unfilteredChildren.slice();
            record.unfilteredChildren = null;
        }

        if (record.children) {
            record.children.forEach(r => me.traverseClearFilter(r));
        }
    }

    // TODO: Get rid of this.
    // The Filter feature of a Grid pokes around in the Store to ask this question.
    get latestFilterField() {
        return this.filters.last ? this.filters.last.property : null;
    }

    processFieldFilter(filter, value) {
        if (typeof filter === 'string') {
            filter = {
                property : filter,
                value    : value
            };
        }

        
        filter = filter instanceof CollectionFilter ? filter : new CollectionFilter(filter);

        // We want notification upon change of field, value or operator
        filter.owner = this;

        // Collection will replace any already existing filter on the field, unless it has id specified
        this.filters.add(filter);
    }

    /**
     * Filters the store by *adding* the specified filter or filters to the existing filters applied to this Store. Call without arguments to reapply filters.
     * ```
     * // Add a filter
     * store.filter({
     *     property : 'age',
     *     operator : '>',
     *     value    : 90
     * });
     *
     * // Replace existing filters
     * store.filter({
     *     filters : {
     *         property : 'age',
     *         operator : '<',
     *         value    : 90
     *     },
     *     replace : true
     * });
     *.
     * // Remove this one specific filter, leaving any possible others in place
     * // A filter's id defaults to the property name that it's filtering on.
     * store.removeFilter('age');
     *
     * // Filter using function
     * store.filter(r => r.age < 90);
     *
     * // Replacing existing filters with function
     * store.filter({
     *     filters : r => r.age > 90,
     *     replace : true
     * });
     * ```
     * @param {Object|Object[]|function} newFilters A filter config, or array of filter configs, or a function to use for filtering
     * @fires filter
     * @fires change
     * @category Sort, group & filter
     */
    filter(newFilters) {
        const
            me          = this,
            { filters } = me;

        let silent = false;

        if (newFilters) {
            let fieldType = typeof newFilters;

            if (fieldType === 'object') {
                if (('silent' in newFilters) || ('replace' in newFilters)) {
                    silent = newFilters.silent;
                    if (newFilters.replace) {
                        filters.clear();
                    }
                    newFilters = newFilters.filters;
                    fieldType = typeof newFilters;
                }
            }

            // If it was just a config object containing no filters, this will be null
            if (newFilters) {
                // We will not be informed about Filter mutations while configuring.
                me.isConfiguring = true;

                // If we provide array of objects looking like :
                //  {
                //      property  : 'fieldName',
                //      value     : 'someValue',
                //      [operator : '>']
                //  }
                //  or ...
                //  {
                //      property : 'fieldName',
                //      filterBy : function (value, record) {
                //          return value > 50;
                //      }
                //  }
                if (Array.isArray(newFilters)) {
                    newFilters.forEach(me.processFieldFilter, me);
                }
                else if (fieldType === 'function') {
                    
                    filters.add(new CollectionFilter(newFilters));
                }
                // Old signature of fieldname, value with implicit equality test.
                // Not documented, but still tested.
                else if (fieldType === 'string') {
                    me.processFieldFilter(newFilters, arguments[1]);
                }
                // An object-based filter definition
                else {
                    me.processFieldFilter(newFilters);
                }

                // Open up to recieving Filter mutation notifications again
                me.isConfiguring = false;

                // We added a disabled filter to either no filters, or all disabled filters, so no change.
                if (!me.isFiltered) {
                    return;
                }
            }
        }

        // Invalidate the filtersFunction so that it has to be recalculated upon next access
        me.filtersFunction = null;

        // Implemented here for local filtering, and AjaxStore implements for remote.
        me.performFilter(silent);
    }

    /**
     * Perform filtering according to the {@link #property-filters} Collection.
     * This is the internal implementation which is overridden in {@link Core.data.AjaxStore} and
     * must not be overridden.
     * @private
     */
    performFilter(silent) {
        const
            me          = this,
            { storage, filters, rootNode } = me,
            oldCount    = me.count;

        if (me.tree) {
            if (me.isFiltered) {
                me.traverseFilter(rootNode);
            }
            else {
                me.traverseClearFilter(rootNode);
            }
            storage.replaceValues(me.collectDescendants(rootNode).visible, true);
        }
        else {
            if (me.isFiltered) {
                storage.addFilter({
                    id       : 'primary-filter',
                    filterBy : me.filtersFunction
                });
            }
            else {
                storage.filters.clear();
            }
        }

        me.afterPerformFilter(silent ? null : {
            action  : 'filter',
            filters,
            oldCount,
            records : me.storage.values
        });
    }

    afterPerformFilter(event) {
        this.resetRelationCache();

        if (event) {
            this.triggerFilterEvent(event);
        }
    }

    get filtered() {
        return this.storage.isFiltered;
    }

    // Used from filter() and StoreCRUD when reapplying filters
    triggerFilterEvent(event) {
        this.trigger('filter', event);

        // Only fire these events if it's a local filter.
        // If we are configured with filterParamName, the loadData will fire them.
        if (!this.filterParamName) {
            this.trigger('refresh', event);
            this.trigger('change', event);
        }
    }

    /**
     * *Adds* a function used to filter the store. Alias for calling `filter(fn)`. Return `true` from the function to
     * include record in filtered set
     *
     * ```javascript
     * store.filterBy(record => record.age > 25 && record.name.startsWith('A'));
     * ```
     *
     * @param {Function} fn Function used to test records
     * @category Sort, group & filter
     */
    filterBy(fn) {
        this.filter(fn);
    }

    /**
     * Removes filtering from the specified field.
     * @param {String} field Field to not filter the store on any longer
     * @private
     * @deprecated
     * Only used by the Grid Filtering plugin which assumes one Filter per field.
     * @category Sort, group & filter
     */
    removeFieldFilter(field, silent) {
        const me     = this,
            filter = me.filters.getBy('property', field);

        // If we have such a filter, remove it.
        if (filter) {

            me.filters.remove(filter);

            // Invalidate the filtersFunction so that it has to be recalculated upon next access
            me._filtersFunction = null;

            if (!silent) {
                me.filter();
            }
        }
    }

    /**
     * Removes the passed filter, or the filter by the passed ID.
     * @param {String} idOrInstance Filter to remove, or ID of the filter to remove
     * @param {Boolean} [silent] Pass `true` to *not* refilter the store immediately. Such as when
     * removing multiple filters.
     *
     *```javascript
     *  // Only view top priority events
     *  myEventStore.filter({
     *      id       : 'priorityFilter',
     *      property : 'priority',
     *      value    : 1,
     *      operator : '='
     *  });
     *```
     *
     * That individual filter can be remove like this:
     *
     *```javascript
     *  myEventStore.removeFilter('priorityFilter');
     *```
     * @category Sort, group & filter
     */
    removeFilter(idOrInstance, silent) {
        const
            me     = this,
            filter = idOrInstance instanceof CollectionFilter ? idOrInstance : me.filters.get(idOrInstance);

        // If we have such a filter, remove it.
        if (filter) {
            me.filters.remove(filter);

            // Invalidate the filtersFunction so that it has to be recalculated upon next access
            me._filtersFunction = null;

            if (!silent) {
                me.filter();
            }
        }
    }

    /**
     * Removes all filters from the store.
     * @category Sort, group & filter
     */
    clearFilters(silent) {
        this.filters.clear();
        this.filter(undefined, undefined, silent);
    }

    convertFilterToString(field) {
        const filter = this.filters.getBy('property', field);
        return (filter && !filter.filterBy) ? String(filter) : '';
    }

    get filterState() {
        return this.filters.values.map(filter => ObjectHelper.cleanupProperties(filter.config));
    }
};

/**
 * @module Core/data/mixin/StoreGroup
 */

const resortActions = {
    add     : 1,
    replace : 1
};

/**
 * Mixin for Store that handles grouping.
 *
 * ```javascript
 * // simple grouper
 * store.group('city');
 *
 * // grouper as object, descending order
 * store.group({ field : 'city', ascending : false });
 *
 * // using custom sorting function
 * store.group({
 *     field : 'city',
 *     fn : (recordA, recordB) => {
 *         // apply custom logic, for example:
 *         return recordA.city.length < recordB.city.length ? -1 : 1;
 *     }
 * });
 * ```
 *
 * @mixin
 */
var StoreGroup = Target => class StoreGroup extends (Target || Base) {
    //region Config

    static get defaultConfig() {
        return {
            /**
             * Initial groupers, specify to have store grouped automatically after initially setting data
             * @config {Object[]}
             * @category Common
             */
            groupers : null
        };
    }

    //endregion

    //region Events

    /**
     * Fired when grouping is stopped
     * @event groupingOff
     * @param {Core.data.Store} source This Store
     */

    //endregion

    //region Init

    construct(config) {
        super.construct(config);

        // For handling record mutation, *not* add/remove of records.
        // Sorts dataset if necessary.
        this.on('change', this.onDataChanged);
    }

    /**
     * Currently used groupers
     * @property {Object[]}
     * @category Sort, group & filter
     */
    get groupers() {
        return this._groupers;
    }

    set groupers(groupers) {
        const me = this;

        if (groupers && groupers.length) {
            me._groupers = groupers;
        }
        else if (me.groupers) {
            delete me._groupers;

            me.groupRecords.forEach(r => {
                if (r.meta.collapsed) {
                    me.includeGroupRecords(r);
                }
            });
            me.storage.replaceValues(me.removeHeadersAndFooters(me.registeredRecords), true);
            me.group(null, null, null, false);
            if ('groupRecords' in me) {
                delete me.groupRecords;
            }
        }
    }

    storeCollapsedGroups() {
        const me = this;

        me.collapsedGroupsHash = {};

        // Remember which groups are collapsed
        if (me.groupRecords && me.groupRecords.length) {
            me.groupRecords.forEach(rec => {
                if (me.expand(rec)) {
                    me.collapsedGroupsHash[rec.id] = true;
                }
            });

            return true;
        }

        return false;
    }

    restoreCollapsedGroups() {
        const me = this;

        Object.keys(me.collapsedGroupsHash).forEach(id => me.collapse(me.getById(id)));
    }

    onDataChange({ source : storage, action, removed }) {
        const
            me           = this,
            { groupers } = me;

        // Only do grouping transformations if we have groupers to apply.
        // In stores which never use grouping, this code is superfluous and will reduce performance.
        // The else side will simply replace the ungrouped data with itself.
        if (groupers) {
            const records = storage.values;

            // When records are added or removed, re-evaluate the group records
            // so that when the events are fired by the super call, the group
            // records are in place.
            if (groupers.length) {
                if (action === 'splice' && removed && removed.length) {
                    // Remember which groups are collapsed
                    if (me.storeCollapsedGroups()) {
                        me.storage.replaceValues(me.removeHeadersAndFooters(records), true);
                    }

                    me.storage.replaceValues(me.prepareGroupRecords(records), true);

                    // Re-collapse the groups
                    me.restoreCollapsedGroups();
                }
            }
            // Remove all group headers and footers
            else {
                storage.replaceValues(me.removeHeadersAndFooters(records), true);
            }
        }

        super.onDataChange && super.onDataChange(...arguments);
    }

    // private function that collapses on the data level
    // TODO: make public and trigger events for grid to react to?
    collapse(groupRecord) {
        if (groupRecord && !groupRecord.meta.collapsed) {
            this.excludeGroupRecords(groupRecord);
            groupRecord.meta.collapsed = true;
            return true;
        }
        return false;
    }

    // private function that expands on the data level
    // TODO: make public and trigger events for grid to react to?
    expand(groupRecord) {
        if (groupRecord && groupRecord.meta.collapsed) {
            this.includeGroupRecords(groupRecord);
            groupRecord.meta.collapsed = false;
            return true;
        }
        return false;
    }

    removeHeadersAndFooters(records) {
        const me = this;

        return records.filter(r => {
            if (r.meta.specialRow) {
                me.unregister(r);
                return false;
            }
            else {
                return true;
            }
        }, true);
    }

    prepareGroupRecords(records = this.registeredRecords) {
        const me = this;

        records = me.removeHeadersAndFooters(records);

        if (!me.isGrouped) {
            return records;
        }

        const groupedRecords = [],
            field          = me.groupers[0].field,
            groupRecords   = [];

        let curGroup       = null,
            curGroupRecord = null,
            childCount     = 0;

        function addFooter() {
            const
                val    = curGroupRecord.meta.groupRowFor,
                id     = `group-footer-${typeof val === 'number' ? val : StringHelper.createId(val)}`,
                footer = me.getById(id) || new me.modelClass({ id }, me, {
                    specialRow     : true,
                    groupFooterFor : val,
                    groupRecord    : curGroupRecord
                });

            me.register(footer);
            footer.groupChildren = curGroupRecord.groupChildren;
            groupRecords.push(footer);
            groupedRecords.push(footer);
            me.allRecords.push(footer);
            curGroupRecord.groupChildren.push(footer);
            childCount++;
            return footer;
        }

        records.forEach((record) => {
            const val = record[field],
                id  = `group-header-${typeof val === 'number' ? val : StringHelper.createId(val)}`;

            // A group header or footer record of an empty group.
            // Remove from the data
            if (record.groupChildren && !record.groupChildren.length) {
                me.unregister(record);
                return;
            }

            if (!ObjectHelper.isEqual(val, curGroup)) {
                if (curGroupRecord) {
                    // also add group footer? used by GroupSummary feature
                    if (me.useGroupFooters) {
                        addFooter();
                    }

                    curGroupRecord.meta.childCount = childCount;
                }

                curGroupRecord = me.getById(id) || new me.modelClass({ id }, me, {
                    specialRow  : true,
                    groupRowFor : val,
                    groupField  : field
                });

                me.register(curGroupRecord);
                curGroupRecord.groupChildren = [];
                groupedRecords.push(curGroupRecord);
                me.allRecords.push(curGroupRecord);
                groupRecords.push(curGroupRecord);
                curGroup = val;
                childCount = 0;
            }

            record.instanceMeta(me.id).groupParent = curGroupRecord;
            groupedRecords.push(record);
            curGroupRecord.groupChildren.push(record);
            childCount++;
        });

        // misses for last group without this
        if (curGroupRecord) {
            curGroupRecord.meta.childCount = childCount;

            // footer for last group
            if (me.useGroupFooters) {
                addFooter();
            }
        }

        me.groupRecords = groupRecords;

        return groupedRecords;
    }

    //endregion

    //region Group and ungroup

    /**
     * Is store currently grouped?
     * @property {Boolean}
     * @readonly
     * @category Sort, group & filter
     */
    get isGrouped() {
        return Boolean(this.groupers && this.groupers.length);
    }

    /**
     * Group records, either by replacing current sorters or by adding to them.
     * A grouper can specify a **_custom sorting function_** which will be called with arguments (recordA, recordB).
     * Works in the same way as a standard array sorter, except that returning `null` triggers the stores
     * normal sorting routine. Grouped store **must** always be sorted by the same field.
     *
     * ```javascript
     * // simple grouper
     * store.group('city');
     *
     * // grouper as object, descending order
     * store.group({ field : 'city', ascending : false });
     *
     * // using custom sorting function
     * store.group({
     *     field : 'city',
     *     fn : (recordA, recordB) => {
     *         // apply custom logic, for example:
     *         return recordA.city.length < recordB.city.length ? -1 : 1;
     *     }
     * });
     * ```
     *
     * @param {String|Object} field Field to group by.
     * Can also be a config containing a field to group by and a custom sorting function called `fn`.
     * @param {Boolean} [ascending] Sort order of the group titles
     * @param {Boolean} [add] Add a grouper (true) or use only this grouper (false)
     * @param {Boolean} [performSort] Trigger sort directly, which does the actual grouping
     * @param {Boolean} [silent] Set as true to not fire events
     * @category Sort, group & filter
     * @fires group
     * @fires refresh
     */
    group(field, ascending, add = false, performSort = true, silent = false) {
        const me = this;

        let newGrouper;

        if (add) {
            me.groupers.push(newGrouper = {
                field          : field,
                ascending      : ascending,
                complexMapping : field.includes('.')
            });
        }
        else if (field) {
            if (ascending == undefined) {
                ascending = me.groupInfo && me.groupInfo.field === field ? !me.groupInfo.ascending : true;
            }

            me.groupInfo = newGrouper = {
                field          : field,
                ascending      : ascending,
                complexMapping : field.includes('.')
            };

            me.groupers = [me.groupInfo];
        }

        if (newGrouper) {
            const { prototype } = me.modelClass;

            // Create a getter for complex field names like "get resource.city"
            if (newGrouper.complexMapping && !prototype.hasOwnProperty(field)) {
                Object.defineProperty(prototype, field, {
                    get() {
                        return ObjectHelper.getPath(this, field);
                    }
                });
            }
        }

        // as far as the store is concerned, grouping is just more sorting. so trigger sort
        if (performSort !== false) {
            me.sort(null, null, false, true);
        }

        if (!silent) {
            /**
             * Fired when grouping changes
             * @event group
             * @param {Core.data.Store} source This Store
             * @param {Object[]} groupers Applied groupers
             * @param {Core.data.Model[]} records Grouped records
             */
            me.trigger('group', { isGrouped : me.isGrouped, groupers : me.groupers, records : me.storage.values });
            me.trigger('refresh', { action : 'group', isGrouped : me.isGrouped, groupers : me.groupers, records : me.storage.values });
        }
    }

    // Internal since UI does not support multi grouping yet
    /**
     * Add a grouping level (a grouper).
     * @param {String} field Field to group by
     * @param {Boolean} ascending Group direction
     * @category Sort, group & filter
     * @internal
     */
    addGrouper(field, ascending = true) {
        this.group(field, ascending, true);
    }

    // Internal since UI does not support multi grouping yet
    /**
     * Removes a grouping level (a grouper)
     * @param {String} field Grouper to remove
     * @category Sort, group & filter
     * @internal
     */
    removeGrouper(field) {
        const me    = this,
            index = me.groupers.findIndex(grouper => grouper.field === field);
        if (index > -1) {
            me.groupers.splice(index, 1);

            me.group();
        }
    }

    /**
     * Removes all groupers, turning store grouping off.
     * @fires groupingOff
     * @category Sort, group & filter
     */
    clearGroupers() {
        this.groupers = null;
    }

    //endregion

    //region Get and check

    /**
     * Check if a record belongs to a certain group (only for the first grouping level)
     * @param {Core.data.Model} record Record
     * @param groupValue Groups value
     * @returns {Boolean} True if the record belongs to the group, otherwise false
     * @category Sort, group & filter
     */
    isRecordInGroup(record, groupValue) {
        if (!this.isGrouped) return null;

        const me         = this,
            groupField = me.groupers[0] && me.groupers[0].field;

        return record[groupField] === groupValue && !record.meta.specialRow;
    }

    isInCollapsedGroup(record) {
        const parentGroupRec = record.instanceMeta(this).groupParent;

        return parentGroupRec && parentGroupRec.meta.collapsed;
    }

    /**
     * Returns all records in the group with specified groupValue.
     * @param groupValue
     * @returns {Core.data.Model[]} Records in specified group or null if store not grouped
     * @category Sort, group & filter
     */
    getGroupRecords(groupValue) {
        const me = this;

        if (!me.isGrouped) return null;

        return me.storage.values.filter(record => me.isRecordInGroup(record, groupValue));
    }

    /**
     * Get all group titles.
     * @returns {String[]} Group titles
     * @category Sort, group & filter
     */
    getGroupTitles() {
        const me = this;

        if (!me.isGrouped) return null;

        return me.getDistinctValues(me.groupers[0] && me.groupers[0].field);
    }

    //endregion

    onDataChanged(event) {
        if (
            this.isGrouped && (
                // If an action flagged as requiring resort is performed...
                (!event.changes && resortActions[event.action]) ||
                // ...or if the group field has changes...
                (event.changes && this.groupers.some(grouper => grouper.field in event.changes))
            )
        ) {
            // ...then resort
            this.sort();
        }
    }

    /**
     * Adds or removes records in a group from storage. Used when expanding/collapsing groups.
     * @private
     * @param {Core.data.Model} groupRecord Group which records should be added or removed
     * @param {Boolean} include Include (true) or exclude (false) records
     * @category Grouping
     */
    internalIncludeExcludeGroupRecords(groupRecord, include) {
        const me    = this,
            index = me.indexOf(groupRecord),
            mapId = me.id;

        // Skip if group record is not found, otherwise it removes records from wrong position
        if (index === -1) {
            return;
        }

        // Prevent removing from already collapsed and vice versa
        if ((groupRecord.meta.collapsed && !include) || (!groupRecord.meta.collapsed && include)) {
            return;
        }

        groupRecord.groupChildren.forEach(child =>
            child.instanceMeta(mapId).hiddenByCollapse = !include
        );

        if (include) {
            // Avoid adding record duplicates which may already have been reinserted by clearing filters
            const groupChildren = groupRecord.groupChildren.filter(r => !me.isAvailable(r));
            me.storage.values.splice(index + 1, 0, ...groupChildren);
        }
        else {
            me.storage.values.splice(index + 1, groupRecord.groupChildren.length);
        }
        me.storage._indicesInvalid = true;
        me._idMap = null;
    }

    /**
     * Removes records in a group from storage. Used when collapsing a group.
     * @private
     * @param groupRecord Group which records should be removed
     * @category Grouping
     */
    excludeGroupRecords(groupRecord) {
        this.internalIncludeExcludeGroupRecords(groupRecord, false);
    }

    /**
     * Adds records in a group to storage. Used when expanding a group.
     * @private
     * @param groupRecord Group which records should be added
     * @category Grouping
     */
    includeGroupRecords(groupRecord) {
        this.internalIncludeExcludeGroupRecords(groupRecord, true);
    }

    /**
     * Collects all group headers + children, whether expanded or not
     * @private
     * @returns {Core.data.Model[]}
     */
    collectGroupRecords() {
        return this.records.reduce((records, record) => {
            if (record.meta.specialRow) {
                records.push(record);

                if ('groupRowFor' in record.meta) {
                    records.push.apply(records, record.groupChildren);
                }
            }

            return records;
        }, []);
    }
};

/**
 * @module Core/data/mixin/StoreRelation
 */

/**
 * Mixin for Store that handles relations with other stores (actually defined on model).
 *
 * @mixin
 */
var StoreRelation = Target => class StoreRelation extends (Target || Base) {
    //region Init

    /**
     * Initialized relations, called from constructor
     * @private
     */
    initRelations(reset) {
        const
            me        = this,
            relations = me.modelClass.relations;

        if (reset && me.modelRelations) {
            // reset will reinit all relations, stop listening for store events on existing ones
            me.modelRelations.forEach(relation => {
                if (relation.storeDetacher) relation.storeDetacher();
            });
        }

        if ((!me.modelRelations || me.modelRelations.length === 0 || reset) && relations) {
            me.modelRelations = [];

            // foreignKeys is filled when model exposes its properties
            relations && relations.forEach(modelRelationConfig => {
                const
                    config       = Object.assign({}, modelRelationConfig),
                    relatedStore = typeof config.store === 'string' ? me[config.store] : config.store;

                config.dependentStore = me;

                me.modelRelations.push(config);

                if (relatedStore) {
                    config.storeProperty = config.store;
                    config.store = relatedStore; // repeated from initRelationStores, needed if stored is assigned late

                    const dependentStoreConfigs = relatedStore.dependentStoreConfigs;

                    // Add link to dependent store
                    if (dependentStoreConfigs.has(me)) {
                        dependentStoreConfigs.get(me).push(config);
                    }
                    else {
                        dependentStoreConfigs.set(me, [config]);
                    }

                    // if foreign key specifies collectionName the related store should also be configured
                    if (config.collectionName) {
                        relatedStore.initRelationCollection(config, me);
                    }

                    if (relatedStore.count > 0) {
                        relatedStore.updateDependentStores('dataset', relatedStore.records);
                    }
                }
            });
        }
    }

    /**
     * Called from other end of an relation when this store should hold a collection of related records.
     * @private
     * @param config
     * @param collectionStore
     */
    initRelationCollection(config, collectionStore) {
        // TODO: parts of this should move to model?
        const
            me   = this,
            name = config.collectionName;

        if (!me.collectionStores) {
            me.collectionStores = {};
        }

        me.collectionStores[name] = {
            store  : collectionStore,
            config : config
        };

        if (!me[name + 'Store']) {
            me[name + 'Store'] = collectionStore;
        }

        if (me.count > 0) {
            me.initModelRelationCollection(name, me.records);
        }
    }

    initModelRelationCollection(name, records) {
        const me = this;
        // add collection getter to each model
        records.forEach(record => {
            // Needs to work in trees also, if not a tree traverse just calls fn on self
            record.traverse(node => {
                !(name in node) && Object.defineProperty(node, name, {
                    enumerable : true,
                    get        : function() {
                        return me.getCollection(this, name);
                    },
                    set : function(value) {
                        return me.setCollection(this, name, value);
                    }
                });
            });
        });
    }

    //TODO: Do diff update, this is called on filtering and will be heavy with lots of records

    /**
     * Updates relationCache for all records.
     * @private
     */
    resetRelationCache() {
        this.relationCache = {};
        this.forEach(record => record.initRelations());
    }

    /**
     * Caches related records from related store on the local store.
     * @private
     * @param record Local record
     * @param relations Relations to related store
     */
    updateRecordRelationCache(record, relations) {
        const me = this;

        relations && relations.forEach(relation => {
            // use related records id, or if called before "binding" is complete use foreign key
            const foreignId = relation.related ? relation.related.id : record.get(relation.config.fieldName);
            // cache on that id, removing previously cached value if any
            foreignId !== undefined && me.cacheRelatedRecord(record, foreignId, relation.config.relationName, foreignId);
        });
    }

    //endregion

    //region Getters

    /**
     * Returns records from a collection of related records. Not to be called directly, called from Model getter.
     * TODO: Move to Model?
     * @private
     * @param model
     * @param name
     * @returns {*}
     */
    getCollection(model, name) {
        const { config, store } = this.collectionStores[name];

        return (store.relationCache[config.relationName] && store.relationCache[config.relationName][model.id]) || [];
    }

    /**
     * Sets a collection of related records. Will updated the related store and trigger events from it. Not to be called
     * directly, called from Model setter.
     * @private
     */
    setCollection(model, name, records) {
        const { config, store } = this.collectionStores[name];

        if (!store.relationCache[config.relationName]) store.relationCache[config.relationName] = {};

        const old = (store.relationCache[config.relationName][model.id] || []).slice(),
            added = [],
            removed = [];

        store.suspendEvents();

        // Remove any related records not in the new collection
        old.forEach(record => {
            if (!records.includes(record)) {
                record[config.fieldName] = null;
                store.remove(record);
                removed.push(record);
            }
        });

        // Add records from the new collection not already in store
        records.forEach(record => {
            if (record instanceof Model) {
                if (!record.stores.includes(store)) {
                    store.add(record);
                    added.push(record);
                }
            }
            else {
                [record] = store.add(record);
                added.push(record);
            }

            // Init relation
            record[config.fieldName] = model.id;
        });

        store.resumeEvents();

        if (removed.length) {
            store.trigger('remove', { records : removed });
            store.trigger('change', { action : 'remove', records : removed });
        }

        if (added.length) {
            store.trigger('add', { records : added });
            store.trigger('change', { action : 'add', records : added });
        }
    }

    //endregion

    //region Caching

    /**
     * Adds a record to relation cache, optionally removing it if already there.
     * @private
     * @param record
     * @param id
     * @param name
     * @param uncacheId
     */
    cacheRelatedRecord(record, id, name, uncacheId = null) {
        const me    = this,
            cache = me.relationCache[name] || (me.relationCache[name] = {});

        if (uncacheId !== null) {
            me.uncacheRelatedRecord(record, name, uncacheId);
        }

        if (id != null) {
            // Only include of not already in relation cache, which might happen when removing and re-adding the same instance
            ArrayHelper.include(cache[id] || (cache[id] = []), record);
        }
    }

    /**
     * Removes a record from relation cache, for a specific relation (specifiy relation name and id) or for all relations
     * @private
     * @param record Record to remove from cache
     * @param name Optional, relation name
     * @param id Optional, id
     */
    uncacheRelatedRecord(record, name = null, id = null) {
        const me       = this;

        function remove(relationName, relatedId) {
            const cache    = me.relationCache[relationName],
                oldCache = cache && cache[relatedId];

            // When unjoining a record from a filtered store the relationCache will also be filtered
            // and might give us nothing, in which case we have nothing to clean up and bail out
            if (oldCache) {
                const uncacheIndex = oldCache.indexOf(record);
                uncacheIndex >= 0 && oldCache.splice(uncacheIndex, 1);

                if (oldCache.length === 0) {
                    delete cache[relatedId];
                }
            }
        }

        if (id != null) {
            remove(name, id);
        }
        else {
            if (record.meta.relationCache) {
                Object.entries(record.meta.relationCache).forEach(([relationName, relatedRecord]) => {
                    const relatedId     = relatedRecord && relatedRecord.id;

                    remove(relationName, relatedId);
                });
            }
        }
    }

    /**
     * Updates related stores when store is cleared, a record is removed or added.
     * @private
     * @param {String} action
     * @param {Core.data.Model[]} records
     */
    updateDependentStores(action, records) {
        this.dependentStoreConfigs.forEach(configs => {
            configs.forEach(config => {
                const
                    dependentStore = config.dependentStore,
                    cache = dependentStore.relationCache[config.relationName];

                if (action === 'dataset') {
                    config.collectionName && this.initModelRelationCollection(config.collectionName, records);

                    dependentStore.forEach(record => {
                        const foreign = record.initRelation(config);
                        foreign && dependentStore.cacheRelatedRecord(record, foreign.id, config.relationName, foreign.id);
                    });

                    return;
                }

                if (action === 'removeall') {
                    dependentStore.forEach(record => {
                        record.removeRelation(config);
                    });

                    delete dependentStore.relationCache[config.relationName];

                    return;
                }

                if (action === 'add') {
                    config.collectionName && this.initModelRelationCollection(config.collectionName, records);
                }

                if (action === 'add' || action === 'remove') {
                    records.forEach(record => {
                        const dependentRecords = cache && cache[record.id];

                        switch (action) {
                            case 'remove':
                                // removing related record removes from cache on model and store
                                if (dependentRecords) {
                                    dependentRecords.forEach(dependentRecord => dependentRecord.removeRelation(config));
                                    // Altered to not delete on self, simplifies taking actions on related records after remove if relation still lives
                                    //delete cache[relatedRecord.id];
                                }
                                // TODO: Should removing related set foreign key to null? (removing Team sets Player.teamId to null)
                                break;
                            case 'add':
                                // adding a new record in related store checks if any foreign keys match the new id,
                                // and if so it sets up the relation
                                dependentStore.forEach(dependentRecord => {
                                    if (dependentRecord.get(config.fieldName) == record.id) {
                                        dependentRecord.initRelation(config);
                                        dependentStore.cacheRelatedRecord(dependentRecord, record.id, config.relationName);
                                    }
                                });
                                break;
                        }
                    });
                }
            });
        });
    }

    /**
     * Updates relation cache and foreign key value when a related objects id is changed.
     * @private
     */
    updateDependentRecordIds(oldValue, value) {
        this.dependentStoreConfigs && this.dependentStoreConfigs.forEach(configs => {
            configs.forEach(config => {
                const
                    dependentStore = config.dependentStore,
                    cache        = dependentStore.relationCache[config.relationName],
                    localRecords = cache && cache[oldValue] && cache[oldValue].slice();

                localRecords && localRecords.forEach(localRecord => {
                    localRecord.set(config.fieldName, value, false, true);
                    dependentStore.cacheRelatedRecord(localRecord, value, config.relationName, oldValue);
                });
            });
        });
    }

    //endregion
};

/**
 * @module Core/data/mixin/StoreSum
 */

/**
 * Mixin for Store that handles summaries.
 *
 * @mixin
 */
var StoreSum = Target => class StoreSum extends (Target || Base) {
    /**
     * Returns sum calculated by adding value of specified field for specified records. Defaults to using all records
     * in store
     * @param {String} field Field to summarize by
     * @param {Core.data.Model[]} records Records to summarize, uses all records if unspecified.
     * @returns {Number}
     */
    sum(field, records = this.storage.values) {
        if (!records) return 0;

        return records.reduce((sum, record) => {
            if (record.meta.specialRow) return sum;
            const v = Number(record[field]);

            return isNaN(v) ? sum : sum + v;
        }, 0);
    }

    /**
     * Returns min value for the specified field. Defaults to look through all records in store
     * @param {String} field Field to find min value for
     * @param {Core.data.Model[]} records Records to process, uses all records if unspecified
     * @returns {Number}
     */
    min(field, records = this.storage.values) {
        if (!records || !records.length) return 0;

        return records.reduce((min, record) => {
            if (record[field] < min) min = record[field];
            return min;
        }, records[0][field]);
    }

    /**
     * Returns max value for the specified field. Defaults to look through all records in store
     * @param {String} field Field to find max value for
     * @param {Core.data.Model[]} records Records to process, uses all records if unspecified
     * @returns {Number}
     */
    max(field, records = this.storage.values) {
        if (!records || !records.length) return 0;

        return records.reduce((max, record) => {
            if (record[field] > max) max = record[field];
            return max;
        }, records[0][field]);
    }

    /**
     * Returns the average value for the specified field. Defaults to look through all records in store
     * @param {String} field Field to calculate average value for
     * @param {Core.data.Model[]} records Records to process, uses all records if unspecified
     * @returns {Number}
     */
    average(field, records = this.storage.values) {
        if (!records || !records.length) return 0;

        let count = 0,
            sum = records.reduce((sum, record) => {
                if (record.meta.specialRow) return sum;
                const v = parseFloat(record[field]);

                if (!isNaN(v)) {
                    count++;
                    return sum + v;
                }
                else {
                    return sum;
                }
            }, 0);

        return sum / count;
    }

    /**
     * Returns sum by adding value of specified field for records in the group with the specified groupValue.
     * @param groupValue Group to summarize
     * @param {String} field Field to summarize by
     * @returns {Number} Sum or null if store not grouped
     */
    groupSum(groupValue, field) {
        return this.sum(field, this.getGroupRecords(groupValue));
    }
};

/**
 * @module Core/data/mixin/StoreSearch
 */

const stringFound = (value, find) => String(value).toLowerCase().indexOf(find) !== -1,
    comparisons = {
        string  : stringFound,
        number  : stringFound,
        boolean : stringFound,
        date    : (value, find) => {
            if (value instanceof Date && find instanceof Date) {
                return String(value) === String(find);
            }
            return String(value.getMonth() + 1).indexOf(find) !== -1 ||
                String(value.getDate()).indexOf(find) !== -1 ||
                String(value.getFullYear()).indexOf(find) !== -1;
        }
    };

/**
 * Mixin for Store that handles searching (multiple records) and finding (single record).
 *
 * @example
 * // find all records that has a field containing the string john
 * let hits = store.search('john');
 *
 * @mixin
 */
var StoreSearch = Target => class StoreSearch extends (Target || Base) {
    //region Search (multiple hits)

    /**
     * Find all hits.
     * @param find Value to search for
     * @param {Object[]} fields Fields to search value in
     * @returns {*} Array of hits, in the format { index: x, data: record }
     */
    search(find, fields = null) {
        const records    = this.storage.values,
            len        = records.length,
            found      = [];

        if (find == null) {
            return null;
        }

        if (typeof find === 'string') {
            find = String(find).toLowerCase();
        }

        let i,
            record,
            value,
            valueType,
            comparison;

        for (i = 0; i < len; i++) {
            record = records[i];
            for (let key of fields || record.fieldNames) {
                value = record[key];
                valueType = (value instanceof Date) ? 'date' : typeof value;
                comparison = comparisons[valueType];
                if (value && comparison && comparison(value, find)) {
                    found.push({
                        index : i,
                        data  : record,
                        field : key,
                        id    : record.id
                    });
                }
            }
        }

        return found;
    }

    /**
     * Find all hits in a column
     * @param field The store field to search in
     * @param value Value to search for
     * @returns {*} Array of hits, in the format { index: x, data: record }
     */
    findByField(field, value) {
        let records = this.storage.values,
            i,
            len     = records.length,
            record,
            found   = [],
            fieldValue;

        if (value !== null && value !== undefined) {
            value = String(value).toLowerCase();
        }

        for (i = 0; i < len; i++) {
            record      = records[i];
            fieldValue  = record[field];

            let type = fieldValue instanceof Date ? 'date' : typeof fieldValue;

            let comparison = {
                'date'      : () => Boolean(fieldValue) && fieldValue.toLocaleString().includes(value),
                'string'    : () => Boolean(fieldValue) && fieldValue.toLowerCase().includes(value),
                'number'    : () => typeof fieldValue === 'number' && fieldValue.toString().includes(value),
                'object'    : () => fieldValue === value, // typeof null === object
                'undefined' : () => fieldValue === value
            };

            if (((value === null || value === undefined) && fieldValue === value) || value && comparison[type]()) {
                found.push({
                    id    : record.id,
                    index : i,
                    data  : record
                });
            }
        }

        return found;
    }

    //endregion

    //region Find (single hit)

    /**
     * Finds the first record for which the specified function returns true
     * @param {Function} fn Comparison function, called with record as parameter
     * @returns {Core.data.Model} Record or null if none found
     *
     * @example
     * store.find(record => record.color === 'blue');
     */
    find(fn) {
        return this.storage.values.find(fn);
    }

    /**
     * Finds the first record for which the specified field has the specified value
     * @param {String} fieldName Field name
     * @param {*} value Value to find
     * @returns {Core.data.Model} Record or null if none found
     */
    findRecord(fieldName, value, searchAllRecords = false) {
        const matchFn = r => ObjectHelper.isEqual(r[fieldName], value);

        if (this.tree) {
            return this.query(matchFn)[0];
        }
        return (searchAllRecords ? this.storage.allValues : this.storage.values).find(matchFn);
    }

    /**
     * Searches the Store records using the passed function.
     * @param fn A function that is called for each record. Return true to indicate a match
     * @returns {Core.data.Model[]} An array of the matching Records
     */
    query(fn) {
        if (this.isTree) {
            const matches = [];

            this.traverse((node) => {
                if (fn(node)) {
                    matches.push(node);
                }
            });
            return matches;
        }

        return this.storage.values.filter(fn);
    }
    //endregion

    //region Others

    /**
     * Returns true if the supplied function returns true for any record in the store
     * @param fn
     * @returns {Boolean}
     *
     * @example
     * store.some(record => record.age > 95); // true if any record has age > 95
     */
    some(fn) {
        return this.storage.values.some(fn);
    }

    //endregion
};

/**
 * @module Core/data/mixin/StoreSort
 */

/**
 * Mixin for Store that handles simple sorting as well as multi-level sorting.
 *
 * ```javascript
 * // single sorter
 * store.sort('age');
 *
 * // single sorter as object, descending order
 * store.sort({ field : 'age', ascending : false });
 *
 * // multiple sorters
 * store.sort(['age', 'name']);
 *
 * // using custom sorting function
 * store.sort({
 *     fn : (recordA, recordB) => {
 *         // apply custom logic, for example:
 *         return recordA.name.length < recordB.name.length ? -1 : 1;
 *     }
 * });
 *
 * // using locale specific sort (slow)
 * store.sort({ field : 'name', useLocaleSort : 'sv-SE' });
 * ```
 *
 * @mixin
 */
var StoreSort = Target => class StoreSort extends (Target || Base) {
    //region Config

    static get defaultConfig() {
        return {
            /**
             * Default sorters, format is [{ field: '', ascending: false }, ...]
             * @config {Object[]|string[]}
             * @category Common
             */
            sorters : [],

            /**
             * Use `localeCompare()` when sorting, which lets the browser sort in a locale specific order. Set to `true`,
             * a locale string or a locale config to enable.
             *
             * Enabling this has big negative impact on sorting
             * performance. For more info on `localeCompare()`, see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).
             *
             * Examples:
             *
             * ```javascript
             * const store = new Store({
             *     // Swedish sorting
             *     useLocaleSort : 'sv-SE'
             * });
             *
             * const store = new Store({
             *     // Swedish sorting with custom casing order
             *     useLocaleSort : {
             *         locale    : 'sv-SE',
             *         caseFirst : 'upper'
             *     }
             * });
             * ```
             *
             * Can also be configured on a per sorter basis:
             *
             * ```javascript
             * store.sort({ field: 'name', useLocaleSort : 'sv-SE' });
             * ```
             *
             * @config {Boolean|String|Object}
             * @default false
             */
            useLocaleSort : null
        };
    }

    //endregion

    //region Events

    /**
     * Fired before sorting
     * @event beforeSort
     * @param {Core.data.Store} source This Store
     * @param {Object[]} sorters Sorter configs
     * @param {Core.data.Model[]} records Records to sort
     */

    /**
     * Fired after sorting
     * @event sort
     * @param {Core.data.Store} source This Store
     * @param {Object[]} sorters Sorter configs
     * @param {Core.data.Model[]} records Sorted records
     */

    //endregion

    //region Properties

    /**
     * Currently applied sorters
     * @member {Object[]} sorters
     * @readonly
     * @category Sort, group & filter
     */

    /**
     * Is store sorted?
     * true
     * @property {Boolean}
     * @readonly
     */
    get isSorted() {
        return Boolean(this.sorters.length) || this.isGrouped;
    }

    //endregion

    //region Add & remove sorters

    /**
     * Sort records, either by replacing current sorters or by adding to them.
     * A sorter can specify a **_custom sorting function_** which will be called with arguments (recordA, recordB).
     * Works in the same way as a standard array sorter, except that returning `null` triggers the stores
     * normal sorting routine.
     *
     * ```javascript
     * // single sorter
     * store.sort('age');
     *
     * // single sorter as object, descending order
     * store.sort({ field : 'age', ascending : false });
     *
     * // multiple sorters
     * store.sort(['age', 'name']);
     *
     * // using custom sorting function
     * store.sort({
     *     fn : (recordA, recordB) => {
     *         // apply custom logic, for example:
     *         return recordA.name.length < recordB.name.length ? -1 : 1;
     *     }
     * });
     *
     * // using locale specific sort (slow)
     * store.sort({ field : 'name', useLocaleSort : 'sv-SE' });
     * ```
     *
     * @param {String|Array|Object} field Field to sort by.
     * Can also be an array of sorters or a config containing a custom sorting function called `fn`.
     * @param {Boolean} [ascending] Sort order (used only if field specified as string)
     * @param {Boolean} [add] Add a sorter or use only this sorter (used only if field specified as string)
     * @param {Boolean} [silent] Set as true to not fire events
     * @category Sort, group & filter
     * @fires beforeSort
     * @fires sort
     * @fires refresh
     */
    sort(field, ascending, add = false, silent = false) {
        const
            me = this,
            records = me.allRecords,
            currentSorters = me.sorters ? me.sorters.slice() : [];

        let currentDir = null,
            curSort;

        if (field) {
            if (Array.isArray(field)) {
                me.sorters = field.map(sorter => {
                    if (typeof sorter === 'string') return { field : sorter };
                    return sorter;
                });
            }
            else {
                // extract field name if sorting by config object
                const fieldName = (typeof field === 'object') ? field.field : field;

                // check if currently sorted by this field
                curSort = me.sorters.find(sorter => sorter.field === fieldName);

                // sort in opposite direction if not specified and already sorted, default to sorting ascending
                if (ascending === undefined || ascending === null) {
                    let sameField = curSort && ((typeof field === 'string' && curSort.field === field) || (typeof field === 'object' && curSort.field === field.field));

                    ascending = sameField ? !curSort.ascending : true;
                }

                const sorter = {
                    field     : fieldName,
                    ascending : ascending
                };

                if (typeof field === 'object') {
                    sorter.fn = field.fn;
                    sorter.useLocaleSort = field.useLocaleSort;
                }

                if (add) {
                    // Field already among sorters? change sort direction instead of adding new sorter
                    if (curSort) {
                        currentDir = curSort.ascending;
                        curSort.ascending = ascending;
                    }
                    else {
                        me.sorters.push(sorter);
                    }
                }
                else {
                    me.sorters = [sorter];
                }
            }
        }

        if (!silent && me.trigger('beforeSort', { sorters : me.sorters, records, currentSorters }) === false) {
            // Restore sorters
            me.sorters = currentSorters;

            // Restore sorting direction if toggled
            if (currentDir !== null) {
                curSort.ascending = currentDir;
            }

            return;
        }

        return me.performSort(silent);
    }

    /**
     * Add a sorting level (a sorter).
     * @param {String|Object} field Field to sort by (can also be an array of sorters or a config containing a custom sort fn)
     * @param {Boolean} ascending Sort order (used only if field specified as string)
     * @category Sort, group & filter
     */
    addSorter(field, ascending = true) {
        this.sort(field, ascending, true);
    }

    /**
     * Remove a sorting level (a sorter)
     * @param field Stop sorting by this field
     * @category Sort, group & filter
     */
    removeSorter(field) {
        let me          = this,
            sorterIndex = me.sorters.findIndex(sorter => sorter.field == field);
        if (sorterIndex > -1) {
            me.sorters.splice(sorterIndex, 1);
            me.sort();
        }
    }

    /**
     * Removes all sorters, turning store sorting off.
     * @category Sort, group & filter
     */
    clearSorters() {
        const me = this;

        me.sorters.length = 0;

        me.sort();
    }

    //region

    //region Sorting logic

    /**
     * Creates a function used with Array#sort when sorting the store. Override to use your own custom sorting logic.
     * @param sorters
     * @returns {Function}
     * @category Sort, group & filter
     */
    createSorterFn(sorters) {
        const storeLocaleSort = this.useLocaleSort;

        return (lhs, rhs) => {
            // Cannot use `for ... of` here, breaks a test in IE11 were this fn is called from transpiled test code
            // which leads to iterator symbol mismatch
            for (let i = 0; i < sorters.length; i++) {
                const
                    { field, ascending = true, fn = null, useLocaleSort = storeLocaleSort } = sorters[i],
                    direction = ascending ? 1 : -1;

                if (fn) {
                    const val = fn(lhs, rhs);
                    if (val !== null) {
                        return val * direction;
                    }
                }

                const
                    lhsValue = lhs[field],
                    rhsValue = rhs[field];

                if (lhsValue == null) {
                    return -direction;
                }
                if (rhsValue == null) {
                    return direction;
                }

                if (useLocaleSort) {
                    // Use systems locale
                    if (useLocaleSort === true) {
                        return String(lhsValue).localeCompare(rhsValue) * direction;
                    }

                    // Use specified locale
                    if (typeof useLocaleSort === 'string') {
                        return String(lhsValue).localeCompare(rhsValue, useLocaleSort) * direction;
                    }

                    // Use locale config
                    if (typeof useLocaleSort === 'object') {
                        return String(lhsValue).localeCompare(rhsValue, useLocaleSort.locale, useLocaleSort) * direction;
                    }
                }

                if (lhsValue > rhsValue) {
                    return direction;
                }
                if (lhsValue < rhsValue) {
                    return -direction;
                }
            }

            return 0;
        };
    }

    /**
     * Perform sorting according to the {@link #config-sorters} configured.
     * This is the internal implementation which is overridden in {@link Core.data.AjaxStore} and
     * must not be overridden.
     * @private
     * @category Sort, group & filter
     */
    performSort(silent) {
        const
            me = this,
            { rootNode, storage, sorters } = me,
            sorter = me.createSorterFn(me.isGrouped ? me.groupers.concat(sorters) : sorters);

        // Temporarily remove group headers, will be re-added after sort
        if (me.isGrouped) {
            // Remember which groups are collapsed
            if (me.storeCollapsedGroups()) {
                storage.replaceValues(me.removeHeadersAndFooters(storage.values), true);
            }
        }

        if (me.tree) {
            rootNode.traverse(node => {
                if (node.isLoaded && node.isParent) {
                    node.children = node.children.sort(sorter);
                    // Since child nodes change order their parentIndex needs to be updated
                    node.updateChildrenIndex(node.children);
                }
            });
            storage.replaceValues(me.collectDescendants(rootNode).visible, true);
        }
        else {
            storage.replaceValues(storage.values.sort(sorter), true);
        }

        me.afterPerformSort(silent);
    }

    afterPerformSort(silent) {
        const
            me = this,
            { storage } = me;

        me._idMap = null;

        // Apply grouping
        if (me.isGrouped) {
            storage.replaceValues(me.prepareGroupRecords(storage.values), true);

            // Re-collapse the groups
            me.restoreCollapsedGroups();
        }

        if (!silent) {
            const event = {
                action  : 'sort',
                sorters : me.sorters,
                records : me.allRecords
            };
            me.trigger('sort',    event);

            // Only fire this event if it's a local sort.
            // If we are configured with sortParamName, the loadData will fire it.
            if (!me.sortParamName) {
                me.trigger('refresh', event);
            }
        }
    }

    //endregion
};

// TODO: turn into plugin instead?

/**
 * @module Core/data/mixin/StoreChained
 */
const returnTrue = () => true;

/**
 * A chained Store contains a subset of records from a master store. Which records to include is determined by a
 * filtering function, {@link #config-chainedFilterFn}.
 *
 * @example
 * masterStore.makeChained(record => record.percent < 10);
 *
 * // or
 *
 * new Store({
 *   masterStore     : masterStore,
 *   chainedFilterFn : record => record.percent < 10
 * });
 *
 * @mixin
 */
var StoreChained = Target => class StoreChained extends (Target || Base) {
    //region Config

    static get defaultConfig() {
        return {
            /**
             * Function used to filter records in the masterStore into a chained store
             * @config {Function}
             * @default () => true
             * @category Chained store
             */
            chainedFilterFn : null,

            /**
             * Array of fields that should trigger filtering of chained store when the fields are updated.
             * @config {String[]}
             * @category Chained store
             */
            chainedFields : null,

            /**
             * Master store that a chained store gets its records from.
             * @config {Store}
             * @category Chained store
             */
            masterStore : null,

            /**
             * Method names calls to which should be relayed to master store.
             * @config {String[]}
             * @category Chained store
             */
            doRelayToMaster : ['add', 'remove', 'insert', 'removeAll'],

            /**
             * Method names calls to which shouldn't be relayed to master store.
             * @config {String}
             * @category Chained store
             */
            dontRelayToMaster : [],

            /**
             * Flag showing whether to keep added/removed uncommitted records when filling the store from master.
             * @config {Boolean}
             * @category Chained store
             */
            keepUncommittedChanges : false
        };
    }

    //endregion

    construct(config) {
        const me = this;

        super.construct(config);

        if (me.masterStore) {
            me.methodNamesToRelay.forEach(fnName => me[fnName] = (...params) => me.relayToMaster(fnName, params));

            // TODO: prevent other functions?

            me.masterStore.on({
                change  : me.onMasterDataChanged,
                prio    : 1,
                thisObj : me
            });

            if (!me.masterStore.chainedStores) {
                me.masterStore.chainedStores = [];
            }
            me.masterStore.chainedStores.push(me);

            me.fillFromMaster();
        }
    }

    //region Properties

    /**
     * Is this a chained store?
     * @property {Boolean}
     * @readonly
     * @category Store
     */
    get isChained() {
        return Boolean(this.masterStore);
    }

    set chainedFilterFn(chainedFilterFn) {
        this._chainedFilterFn = this.thisObj ? chainedFilterFn.bind(this.thisObj) : chainedFilterFn;
    }

    get chainedFilterFn() {
        return this._chainedFilterFn || returnTrue;
    }

    get methodNamesToRelay() {
        const doIsArray = Array.isArray(this.doRelayToMaster),
            dontIsArray = Array.isArray(this.dontRelayToMaster);

        return doIsArray && this.doRelayToMaster.filter(name => !dontIsArray || !this.dontRelayToMaster.includes(name)) || [];
    }

    //endregion

    //region Internal

    updateChainedStores() {
        if (this.chainedStores) {
            this.chainedStores.forEach(store => store.fillFromMaster());
        }
    }

    /**
     * Updates records available in a chained store by filtering the master store records using
     * {@link #config-chainedFilterFn}
     * @internal
     */
    fillFromMaster() {
        const
            me = this,
            { masterStore } = me;

        if (!me.isChained) {
            throw new Error('fillFromMaster only allowed on chained store');
        }

        if (me.keepUncommittedChanges) {
            if (me.isTree) {
                throw new Error('Cannot use keepUncommittedChanges on a chained tree store');
            }
            me.data = [].concat(
                me.added.values.filter(r => !me.removed.includes(r)),
                masterStore.allRecords.filter(r => !me.removed.includes(r) && !me.added.includes(r) && me.chainedFilterFn(r))
            );
        }
        else {
            if (masterStore.isTree) {
                // All nodes will be registered
                me.idRegister = {};
                me.internalIdRegister = {};

                // *all* owned records have to join, as they would have done if they'd all gone through
                // the appendChild route for this store.
                masterStore.allRecords.filter(me.chainedFilterFn).forEach(r => {
                    if (r.stores.includes(me)) {
                        me.register(r);
                    }
                    else {
                        r.joinStore(me);
                    }
                });

                // But the flat storage must reflect the initial expanded status.
                const children = me.getChildren(me.masterStore.rootNode);
                me.data = me.doIncludeExclude(children, true);
            }
            else {
                me.data = masterStore.allRecords.filter(me.chainedFilterFn);
            }
        }
    }

    /**
     * Commits changes back to master.
     * - the records deleted from chained store and present in master will be deleted from master
     * - the records added to chained store and missing in master will added to master
     * Internally calls {Store#function-commit commit()}.
     * @returns {Object} Changes, see Store#changes
     * @internal
     */
    commitToMaster() {
        const
            me = this,
            master = me.masterStore;

        if (!me.isChained) {
            throw new Error('commitToMaster only allowed on chained store');
        }

        master.beginBatch();
        master.remove(me.removed.values);
        master.add(me.added.values);
        master.endBatch();

        return me.commit();
    }

    /**
     * Relays some function calls to the master store
     * @private
     */
    relayToMaster(fnName, params) {
        if (fnName === 'remove' && params.length === 4 && params[3] === true) return;
        return this.masterStore[fnName](...params);
    }

    /**
     * Handles changes in master stores data. Updates the chained store accordingly
     * @private
     */
    onMasterDataChanged({ action, changes }) {
        const me = this;

        if (action === 'update') {
            // if a field not defined in chainedFields is changed, ignore the change.
            // there is no need to refilter the store in such cases, the change will be available anyhow since data is
            // shared
            const refilter = me.chainedFields && me.chainedFields.some(field => field in changes);

            if (!refilter) return;
        }

        me.fillFromMaster();
    }

    //endregion
};

/**
 * @module Core/data/mixin/StoreState
 */

/**
 * Mixin for Store that handles store state.
 *  * sorters
 *  * groupers
 *  * filters
 * @mixin
 */
var StoreState = Target => class StoreState extends (Target || Base) {
    /**
     * Get store state. Used by State-plugin to serialize state
     * @private
     * @returns {{ sorters, groupers }}
     */
    getState() {
        const me    = this,
            state = {};

        if (me.sorters && me.sorters.length) state.sorters = me.sorters.slice();
        if (me.groupers && me.groupers.length) state.groupers = me.groupers.slice();
        if (me.filters && me.filters.values.length) state.filters = me.filterState;

        return state;
    }

    /**
     * Apply store state. Used by State-plugin to restore a previously serialized state
     * @private
     * @param {{ sorters, groupers }} state
     */
    applyState(state) {
        const me = this;
        if ('sorters' in state) me.sorters = state.sorters.slice();
        if ('groupers' in state) me.groupers = state.groupers.slice();
        if ('sorters' in state || 'groupers' in state) me.sort();

        if ('filters' in state) {
            me.filters = state.filters.slice();
            me.filter();
        }
    }
};

/**
 * @module Core/data/mixin/StoreTree
 */
const emptyArray$2 = Object.freeze([]);

/**
 * Mixin for store with tree related functionality. To learn more about working with tree nodes please see the {@link Core/data/mixin/TreeNode} class and [this guide](#guides/data/treedata.md).
 * @mixin
 */
var StoreTree = Target => class StoreTree extends (Target || Base) {
    //region Getters

    /**
     * True if this Store is configured to handle tree data (with `tree : true`) or if this is a
     * {@link Core.data.Store#function-makeChained chained store} and the master store is a tree store.
     * @property {Boolean}
     * @readonly
     * @category Tree
     */
    get isTree() {
        return this.tree || (this.masterStore && this.masterStore.tree);
    }

    /**
     * Get all leaves in store with tree data
     * @returns {Core.data.Model[]}
     * @category Tree
     */
    get leaves() {
        const me = this,
            result = [];

        if (me.isTree) {
            me.traverse(record => {
                if (record.isLeaf) {
                    result.push(record);
                }
            });

            return result;
        }
        else {
            me.allRecords.forEach(r => {
                if (r.isLeaf) {
                    result.push(r);
                }
                r.traverse(record => {
                    if (record.isLeaf) {
                        result.push(record);
                    }
                }, true);
            });
        }
        return result;
    }

    //endregion

    //region Children

    /**
     * Loads children for a parent node that uses load on demand (when expanding it). Base implementation does nothing,
     * either use AjaxStore which implements it, create your own subclass with an implementation or listen for
     * `toggleNode` and insert records when you have them available.
     * @param {Core.data.Model} parentRecord
     * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
     */
    async loadChildren(parentRecord) {

    }

    /**
     * Called from Model when adding children. Not to be called directly, use Model#appendChild() instead.
     * @internal
     * @param {Core.data.mixin.TreeNode} parent
     * @param {Core.data.mixin.TreeNode[]} children
     * @param {Number} index
     * @param {Object} isMove
     * @param {Boolean} [silent]
     * @fires add
     * @fires change
     */
    onNodeAddChild(parent, children, index, isMove, silent = false) {
        const
            me              = this,
            isRootLoad      = parent === me.rootNode && parent.isLoading,
            { storage }     = me,
            toAddToUI       = [],
            toAdd           = [],
            previousSibling = children[0].previousSibling;

        let storeInsertionPoint;

        me.collectDescendants(children, toAddToUI, toAdd, { inCollapsedBranch : !(parent.isExpanded(me) && parent.ancestorsExpanded(me)) });

        // Keep CRUD caches up to date unless it's a root load
        if (!isRootLoad && toAdd.length) {
            for (const record of toAdd) {
                // Only considered an add if not modified or moved
                if (!me.modified.includes(record) && !isMove[record.id]) {
                    me.added.add(record);
                    me.removed.remove(record);
                }
            }
        }

        // Root node inserted first
        if (isRootLoad && me.rootVisible) {
            toAddToUI.unshift(parent);
            toAdd.unshift(parent);
        }

        if (toAddToUI.length) {
            // Calculate the insertion point into the flat store.
            // If the new node is the first, then it goes after the parent node.
            if (index === 0 || !previousSibling) {
                storeInsertionPoint = storage.indexOf(parent);
            }
            // Otherwise it has to go after the previous visible node which has
            // to be calculated. See indexOfPreviousVisibleNode for explanation.
            else {
                storeInsertionPoint = storage.indexOf(previousSibling) + previousSibling.getDescendantCount(true, me);
            }

            // Insert added child nodes at correct location in storage.
            // We must not react to change - we fire the events here.
            storage.suspendEvents();
            me.storage.splice(++storeInsertionPoint, 0, toAddToUI);
            storage.resumeEvents();
        }

        // Since we do not pass through Store#onDataChange we have to handle relations manually here. And since they are
        // not tied to flat part of store, use all children
        me.updateDependentStores('add', children);

        // If it's a root level set data op, then signal 'dataset'
        if (isRootLoad && toAddToUI.length) {
            // If we have initial sorters, perform a silent sort before triggering `dataset`
            // NOTE: Records in toAddToUI will be in the original order, not affected by the sort
            if (me.sorters.length) {
                me.sort(null, null, false, true);
            }

            if (!silent) {
                const event = { action : 'dataset', data : me._data, records : toAddToUI };
                me.trigger('refresh', event);
                me.trigger('change', event);
            }
        }
        // Else, continue as before to signal a bizarre "isChild" add.
        else if (!silent) {
            const event = { action : 'add', parent, isChild : true, isMove, records : children, allRecords : toAdd, index : storeInsertionPoint };
            me.trigger('add', event);
            me.trigger('change', event);
        }
    }

    onNodeRemoveChild(parent, children, index, flags = { isMove : false, silent : false, unfiltered : false }) {
        const
            me             = this,
            { storage }    = me,
            toRemoveFromUI = [],
            toRemove       = [],
            { isMove, silent, unfiltered } = flags,
            removeUnfiltered = unfiltered && me.isFiltered,
            childrenToRemove = removeUnfiltered && parent.unfilteredChildren ? parent.unfilteredChildren : children;

        me.collectDescendants(childrenToRemove, toRemoveFromUI, toRemove, { inCollapsedBranch : !(parent.isExpanded(me) && parent.ancestorsExpanded(me)), unfiltered : removeUnfiltered });
        // test StoreTree.t.js should fail if the next line replaces the above line
        // me.collectDescendants(children, toRemoveFromUI, toRemove, { inCollapsedBranch : !(parent.isExpanded(me) && parent.ancestorsExpanded(me)) });

        if (!isMove) {
            // Unjoin is recursive, use flat children array
            for (let record of children) {
                record.unJoinStore(me);
            }

            // Keep CRUD caches up to date
            if (toRemove.length) {
                for (let record of toRemove) {
                    if (record.stores.includes(me)) {
                        record.unJoinStore(me);
                    }

                    // If was newly added, remove from added list
                    if (me.added.includes(record)) {
                        me.added.remove(record);
                    }
                    // Else add to removed list
                    else {
                        me.removed.add(record);
                    }
                }
                me.modified.remove(toRemove);
            }
        }

        // Remove removed child nodes at correct location in storage
        if (toRemoveFromUI.length) {
            index = storage.indexOf(toRemoveFromUI[0]);
            // We must not react to change - we fire the events here.
            if (index > -1) {
                storage.suspendEvents();
                storage.splice(index, toRemoveFromUI.length);
                storage.resumeEvents();
            }
        }
        else {
            // If nothing is removed from UI (storage) return -1, showing that removed node was in the collapsed branch
            index = -1;
        }

        if (!silent) {
            const event = {
                action     : 'remove',
                parent,
                isChild    : true,
                isMove,
                records    : children,
                allRecords : toRemove,
                index
            };
            me.trigger('remove', event);
            me.trigger('change', event);
        }
    }

    collectDescendants(node, visible = [], all = [], flags = { inCollapsedBranch : false, unfiltered : false }) {
        const me = this,
            { inCollapsedBranch, unfiltered } = flags,
            children = Array.isArray(node) ? node : (unfiltered ? (node && node.unfilteredChildren) : me.getChildren(node));

        if (children) {
            for (let i = 0, len = children.length, child; i < len; i++) {
                child = children[i];
                if (!inCollapsedBranch) {
                    visible.push(child);
                }
                all.push(child);
                me.collectDescendants(child, visible, all, { inCollapsedBranch : inCollapsedBranch || !child.isExpanded(me), unfiltered });
            }
        }
        return { visible, all };
    }

    /**
     * Returns the children of the passed branch node which this store owns. By default, this
     * is the entire `children` array.
     *
     * **If this store {@link Core.data.mixin.StoreChained#property-isChained isChained}**, then
     * this returns only the subset of children which are filtered into this store by the
     * {@link Core.data.mixin.StoreChained#config-chainedFilterFn chainedFilterFn}.
     * @param {Core.data.Model} parent The node to return the children of.
     */
    getChildren(parent) {
        return parent.children && parent.children.length ? (this.isChained ? parent.children.filter(this.chainedFilterFn) : parent.children) : emptyArray$2;
    }

    /**
     * Includes or excludes all records beneath parentRecord in storage. Used when expanding or collapsing
     * nodes.
     * @private
     * @param parentRecord Parent record
     * @param include Include (true) or exclude (false)
     * @category Tree
     */
    internalToggleTreeSubRecords(parentRecord, include) {
        const
            me          = this,
            { storage } = me,
            index       = storage.indexOf(parentRecord),
            children    = me.doIncludeExclude(me.getChildren(parentRecord), include);

        // If we expanded a node which is yet to load children, the collected children
        // array will be empty, so do not broadcast any change event.
        // If we are collapsing a record which isn't visible (because parent is collapsed) we won't get an index,
        // which is fine since it is already removed from processedRecords
        if (children.length && index !== false) {
            // We must not react to change - we fire the events here with a flag
            // to tell responders that it's due to an expoand or collapse.
            storage.suspendEvents();

            if (include) {
                storage.splice(index + 1, 0, ...children);

                const event = { action : 'add', isExpand : true, records : children, index : index + 1 };
                me.trigger('add', event);
                me.trigger('change', event);
            }
            else {
                storage.splice(index + 1, children.length);

                const event = { action : 'remove', isCollapse : true, records : children, index : index + 1 };
                me.trigger('remove', event);
                me.trigger('change', event);
            }
            storage.resumeEvents();
        }
    }

    doIncludeExclude(children, include, result = []) {
        const
            me         = this,
            childCount = children && children.length;

        for (let i = 0; i < childCount; i++) {
            const child = children[i];

            // Only consider child nodes who we own.
            // If we are a chained store, skip nodes that are not ours.
            if (!me.isChained || me.chainedFilterFn(child)) {
                const mapMeta = child.instanceMeta(me.id);

                if (include) {
                    // if including subrecords, add those who are not hidden by a collapsed sub parent
                    result.push(child);
                }
                else if (!mapMeta.hidden) {
                    result.push(child);
                }
                mapMeta.hidden = !include;

                if (child.isExpanded(me)) {
                    me.doIncludeExclude(me.getChildren(child), include, result);
                }
            }
        }
        return result;
    }

    /**
     * Collapse an expanded record or expand a collapsed. Optionally forcing a certain state.
     * @param {String|Number|Core.data.Model} idOrRecord Record (the record itself) or id of a record to toggle
     * @param {Boolean} [collapse] Force collapse (true) or expand (false)
     * @returns {Promise}
     * @async
     */
    async toggleCollapse(idOrRecord, collapse) {
        const
            me                 = this,
            record             = me.getById(idOrRecord),
            meta               = record.instanceMeta(me);

        if (collapse === undefined) {
            collapse = !meta.collapsed;
        }

        // Reject if we're in the middle of loading children, or it's a leaf, or it's a no-op
        if (!meta.isLoadingChildren && !record.isLeaf && record.isExpanded(me) === collapse) {
            me.trigger('beforeToggleNode', { record, collapse });
            meta.collapsed = collapse;

            if (meta.collapsed) {
                me.onNodeCollapse(record);
                return true;
            }
            else {
                me.onNodeExpand(record);
                let success = true;

                // Children not yet loaded, ask store for them.
                // It will append them. Appending to a node which
                // is expandded will insert the children into the UI.
                if (!record.isLoaded) {
                    meta.isLoadingChildren = true;

                    try {
                        await me.loadChildren(record);
                    }
                    catch (exception) {
                        // Revert to being collapsed
                        meta.collapsed = true;
                        success = false;
                        me.trigger('loadChildrenException', { record, exception });
                    }
                    finally {
                        meta.isLoadingChildren = false;
                    }
                }
                return success;
            }
        }
    }

    /**
     * Remove all records beneath parentRecord from storage.
     * @private
     * @param parentRecord Parent record
     * @category Tree
     */
    onNodeCollapse(parentRecord) {
        // We don't care about collapse if it's inside a collapsed subtree
        if (parentRecord.ancestorsExpanded(this)) {
            return this.internalToggleTreeSubRecords(parentRecord, false);
        }
    }

    /**
     * Add all records beneath parentRecord from storage.
     * @private
     * @param parentRecord Parent record
     * @category Tree
     */
    onNodeExpand(parentRecord) {
        // We don't care about expand if it's inside a collapsed subtree
        if (parentRecord.ancestorsExpanded(this)) {
            return this.internalToggleTreeSubRecords(parentRecord, true);
        }
    }

    //endregion
};

/**
 * @module Core/helper/WalkHelper
 */

/**
 * Tree walking helper
 * @internal
 */
class WalkHelper {

    /**
     * Pre-walks any hierarchical data structure
     *
     * @param data Walking starting point
     * @param {Function} childrenFn Function to return `data` children entries in an array
     *                   or null if no children exists for the entry
     * @param {Function} fn Function to call on each entry
     */
    static preWalk(data, childrenFn, fn) {

        const walkStack = [data];
        let node, children;

        while (walkStack.length) {

            node = walkStack.pop();

            fn(node);

            children = childrenFn(node);

            if (children) {
                walkStack.push.apply(walkStack, children.slice().reverse());
            }
        }
    }

    /**
     * Pre-walks any hierarchical data structure, passing along a link to the parent node
     *
     * @param data Walking starting point
     * @param {Function} childrenFn Function to return `data` children entries in an array
     *                   or null if no children exists for the entry
     * @param {Function} fn Function to call on each entry, called with `parent` and `node`
     */
    static preWalkWithParent(data, childrenFn, fn) {

        const walkStack = [{ node : data, parent : null }];

        while (walkStack.length) {
            const { parent, node } = walkStack.pop();

            fn(parent, node);

            const children = childrenFn(node);

            if (children) {
                walkStack.push(...children.slice().reverse().map(child => ({ node : child, parent : node })));
            }
        }
    }

    /**
     * Pre-walk unordered.
     *
     * Like {@link #function-preWalk-static preWalk} but doesn't reverses children before walk,
     * thus children will be walked last child first - first child last
     *
     * @param data Walking starting point
     * @param {Function} childrenFn Function to return `data` children entries in an array
     *                   or null if no children exists for the entry
     * @param {Function} fn Function to call on each entry
     */
    static preWalkUnordered(data, childrenFn, fn) {

        let walkStack = [data],
            node, children;

        while (walkStack.length) {

            node = walkStack[walkStack.length - 1];

            fn(node);

            children = childrenFn(node);

            if (children) {
                walkStack.splice(walkStack.length - 1, 1, ...children);
            }
            else {
                walkStack.length = walkStack.length - 1;
            }
        }
    }

    /**
     * Post-walks any hierarchical data structure
     *
     * @param data Walking starting point
     * @param {Function} childrenFn Function to return `data` children entries in an array
     *                   or null if no children exists for the entry
     * @param {Function} fn Function to call on each entry
     */
    static postWalk(data, childrenFn, fn) {

        let visited = new Map(),
            walkStack = [data],
            node, children;

        while (walkStack.length) {

            node = walkStack[walkStack.length - 1];

            if (visited.has(node)) {
                fn(node);
                walkStack.pop();
            }
            else {
                children = childrenFn(node);

                if (children) {
                    walkStack = walkStack.concat(children.slice().reverse());
                }

                visited.set(node, node);
            }
        }
    }

    /**
     * Pre/Post-walks any hierarchical data structure calling inFn each node when it walks in,
     * and outFn when it walks out.
     *
     * @param data Walking starting point
     * @param {Function} childrenFn Function to return `data` children entries in an array
     *                   or null if no children exists for the entry
     * @param {Function} inFn  Function to call on each entry upon enter
     * @param {Function} outFn Function to call on each entry upon exit
     */
    static prePostWalk(data, childrenFn, inFn, outFn) {

        let visited = new Map(),
            walkStack = [data],
            node, children;

        while (walkStack.length) {

            node = walkStack[walkStack.length - 1];

            if (visited.has(node)) {
                outFn(node);
                walkStack.pop();
            }
            else {
                inFn(node);

                children = childrenFn(node);

                if (children) {
                    walkStack = walkStack.concat(children.slice().reverse());
                }

                visited.set(node, node);
            }
        }
    }
}
WalkHelper._$name = 'WalkHelper';

/**
 * @module Core/data/mixin/StoreSync
 */

/**
 * Mixin that allows Store to sync a new dataset with its existing records, instead of fully replacing everything.
 * Configure Store with `syncDataOnLoad: true` to activate the functionality. Sync is performed when a new dataset
 * is loaded, either by directly assigning it to `store.data` or by loading it using Ajax (if using an AjaxStore).
 *
 * ```javascript
 * const store = new Store({
 *   syncDataOnLoad : true,
 *   data           : [
 *     { id : 1, name : 'Saitama' },
 *     { id : 2, name : 'Genos' },
 *     { id : 3, name : 'Mumen Rider' }
 *   ]
 * });
 *
 * // Sync a new dataset by assigning to data:
 * store.data = [
 *   { id : 1, name : 'Caped Baldy' },
 *   { id : 4, name : 'Horse-Bone' }
 * ];
 *
 *  // Result : Record 1 updated, record 2 & 3 removed, record 4 added
 * ```
 *
 * For more details, please see {@link #config-syncDataOnLoad}.
 *
 * @mixin
 */
var StoreSync = Target => class StoreSync extends (Target || Base) {

    static get defaultConfig() {
        return {
            /**
             * Configure with `true` to sync loaded data instead of replacing existing with a new dataset.
             *
             * By default (or when configured with `false`) assigning to `store.data` replaces the entire dataset
             * with a new one, creating all new records:
             *
             * ```javascript
             * store.data = [ { id : 1, name : 'Saitama' } ];
             *
             * const first = store.first;
             *
             * store.data = [ { id : 1, name : 'One-Punch man' } ];
             *
             * store.first !== first;
             * ```
             *
             * When configured with `true` the new dataset is instead synced against the old, figuring out what was
             * added, removed and updated:
             *
             * * ```javascript
             * store.data = [ { id : 1, name : 'Saitama' } ];
             *
             * const first = store.first;
             *
             * store.data = [ { id : 1, name : 'One-Punch man' } ];
             *
             * store.first === first;
             * ```
             *
             * After the sync, any configured sorters, groupers and filters will be reapplied.
             *
             * The sync operation has a configurable threshold, above which the operation will be treated as a
             * batch/refresh and only trigger a single `refresh` event. If threshold is not reached, individual events
             * will be triggered (single `add`, `remove` and possible multiple `update`). To enable the threshold,
             * supply a config object with a `threshold` property instead of `true`:
             *
             * ```
             * const store = new Store({
             *     syncDataOnLoad : {
             *         threshold : '20%'
             *     }
             * });
             * ```
             *
             * `threshold` accepts numbers or strings. A numeric threshold means number of affected records, while a
             * string is used as a percentage of the whole dataset (appending `%` is optional). By default no threshold
             * is used.
             *
             * @config {Boolean|Object}
             * @default false
             */
            syncDataOnLoad : null
        };
    }

    /**
     * Syncs a new dataset against the already loaded one, only applying changes.
     * Not intended to be called directly, please configure store with `syncDataOnLoad: true` and assign to
     * `store.data` as usual instead.
     *
     * ```
     * const store = new Store({
     *    syncDataOnLoad : true,
     *    data : [
     *        // initial data
     *    ]
     * });
     *
     * store.data = [ // new data ]; //  Difference between initial data and new data will be applied
     * ```
     *
     * @param {Object[]} data New dataset
     * @private
     */
    syncDataset(data) {
        const
            me = this,
            { storage } = me,
            { toAdd, toRemove, updated } = me.tree ? me.syncTreeDataset(data) : me.syncFlatDataset(data);

        let { threshold } = me.syncDataOnLoad,
            surpassed = false;

        // Check if threshold is surpassed
        if (threshold) {
            // Any string is treated as a percentage
            if (typeof threshold === 'string') {
                threshold = parseInt(threshold, 10) / 100 * me.count;
            }

            surpassed = toAdd.length + toRemove.length + updated.length > threshold;
        }

        if (me.tree) {
            // Flat data is spliced into/out of the collection, but in a tree it has to be added/removed from store
            // to end up on correct parents
            if (toAdd.length) {
                // Add all new nodes in one go, will be added to correct parent using `parentId`. Triggering multiple times
                const added = me.add(toAdd, surpassed);

                // parentId was tucked on in syncTreeDataset() to allow the single flat add above, clean it out
                added.forEach(node => {
                    delete node.data.parentId;
                    delete node.originalData.parentId;
                    node.meta.modified && delete node.meta.modified.parentId;
                });
            }

            // Remove in one go, removing from each parent. Triggering multiple times
            me.remove(toRemove, surpassed);
        }
        else {
            if (surpassed) {
                storage.suspendEvents();
            }

            // Add and remove, will trigger if below threshold/no threshold
            storage.splice(me.count - toRemove.length, toRemove, toAdd);

            if (surpassed) {
                storage.resumeEvents();
            }
        }

        // Trigger updates if using threshold, but have not surpassed it. If threshold is not used, the updates
        // are triggered when data is set (avoiding another iteration)
        if (threshold && !surpassed) {
            updated.forEach(({ record, toSet, wasSet }) => me.onModelChange(record, toSet, wasSet));
        }

        // Clear change-tracking
        me.acceptChanges();

        const event = { added : toAdd, removed : toRemove, updated, thresholdSurpassed : surpassed };

        // Trigger `batch` if threshold is surpassed, more similar to a batch than a full `dataset`
        if (surpassed) {
            this.trigger('refresh', {
                action   : 'batch',
                data     : data,
                records  : storage.values,
                syncInfo : event
            });
        }

        if (me.isFiltered) {
            // Announced filter
            me.filter();
        }

        if (me.isGrouped) {
            // Announced sort
            me.group();
        }
        else if (me.isSorted) {
            // Announced sort
            me.sort();
        }

        me.trigger('loadSync', event);
    }

    // Used by syncDataset()
    syncFlatDataset(data) {
        if (!data) {
            return;
        }

        const
            me          = this,
            idField     = me.modelClass.idField,
            toRemove    = [],
            toAdd       = [],
            updated     = [],
            usedIds     = {};

        let { threshold } = me.syncDataOnLoad,
            hitCount = 0;

        data.forEach(rawData => {
            const
                id     = rawData[idField],
                record = me.getById(id);

            // Record exists, might be an update
            if (record) {
                // Update silently if using threshold, otherwise trigger away
                const wasSet = record.set(rawData, null, Boolean(threshold));
                if (wasSet) {
                    updated.push({ record, wasSet, toSet : rawData });
                }

                hitCount++;
            }
            // Does not exist, add
            else {
                toAdd.push(me.createRecord(rawData));
            }

            usedIds[id] = 1;
        });

        // Check removals, unless all records were visited above
        if (hitCount < me.allCount) {
            me.forEach(record => {
                if (!usedIds[record.id]) {
                    toRemove.push(record);
                }
            });
        }

        return { toAdd, toRemove,  updated };
    }

    // Used by syncDataset()
    syncTreeDataset(data) {
        if (!data) {
            return;
        }

        const
            me          = this,
            { idField, parentIdField } = me.modelClass,
            toRemove    = [],
            toAdd       = [],
            updated     = [],
            usedIds     = {};

        let { threshold } = me.syncDataOnLoad;

        WalkHelper.preWalkWithParent({ isRoot : true, children : data }, n => n.children, (parent, rawData) => {
            if (parent) {
                const
                    id   = rawData[idField],
                    node = me.getById(id);

                // Record exists, might be an update
                if (node) {
                    // Update silently if using threshold, otherwise trigger away
                    const wasSet = node.set(rawData, null, Boolean(threshold));
                    if (wasSet) {
                        updated.push({ record : node, wasSet, toSet : rawData });
                    }
                }
                // Does not exist, add
                else {
                    rawData[parentIdField] = parent[idField];
                    toAdd.push(rawData);
                }

                usedIds[id] = 1;
            }
        });

        me.traverse(node => {
            if (!usedIds[node.id]) {
                toRemove.push(node);
            }
        });

        return { toAdd, toRemove,  updated };
    }
};

/**
 * @module Core/data/stm/mixin/StoreStm
 */

const STM_PROP$1 = Symbol('STM_PROP');

/**
 * Store mixin to make it compatible with {@link Core.data.stm.StateTrackingManager}.
 * @mixin
 */
var StoreStm = Target => class StoreStm extends (Target || Base) {

    static get defaultConfig() {
        return {
            /**
             * Reference to STM manager
             *
             * @config {Core.data.stm.StateTrackingManager}
             * @default
             */
            stm : null
        };
    }

    

    get stm() {
        return this[STM_PROP$1];
    }

    set stm(stm) {
        const me = this;

        if (me.stm != stm) {
            if (me.stm && me.stm.hasStore(me)) {
                me.stm.removeStore(me);
            }

            me[STM_PROP$1] = stm;

            if (me.stm && !me.stm.hasStore(me)) {
                me.stm.addStore(me);
            }
        }
    }

    /**
     * Overridden to notify STM about flat add action
     *
     * @private
     */
    add(records, silent = false) {
        let result;

        const stm = this.stm;

        // Tree adding is routed via rootNode.appendChild() it has it's own
        // STM override thus if the store is tree we ignore the action
        if (!this.tree && stm && !stm.disabled) {
            // Flat adding here only, the only data needed to undo/redo the action
            // is the list of records added.
            result = super.add(records, silent);
            // If adding wasn't vetoed and something has been added then
            // notifying the STM about the fact.
            if (result && result.length) {
                stm.onStoreModelAdd(this, result, silent);
            }
        }
        else {
            result = super.add(records, silent);
        }

        return result;
    }

    /**
     * Overridden to notify STM about flat insert action
     *
     * @private
     */
    insert(index, records, silent = false) {
        let result;

        const stm = this.stm;

        // Tree inserting is routed via rootNode.insertChild() it has it's own
        // STM override thus if the store is tree we ignore the action
        if (!this.tree && stm && !stm.disabled) {
            // Flat inserting here only, the only data needed to undo/redo the action is:
            // - the list of record inserted
            // - index they are inserted at
            // - index they have been at if they are part of this store already and are moved

            // Here we are getting indexes of records which are in this store already
            // not all records might be from this store, some might be new or from another store
            const context = (Array.isArray(records) ? records : [records]).reduce(
                (context, r) => {
                    const index = r instanceof Model ? this.indexOf(r) : undefined;

                    if (index !== undefined && index !== -1) {
                        context.set(r, index);
                    }

                    return context;
                },
                new Map()
            );

            // Result here is the array of Models inserted or undefined,
            // and it might be different from `records` we received as argument.
            result = super.insert(index, records);

            // Here we check if anything has been actually inserted.
            // The insertion action might be vetoed by event handler or something
            if (result && result.length) {
                // We can't rely on `index` we've got as argument since `result` might
                // differ from records.
                index = this.indexOf(result[0]);
                // Notifying STM manager about the insertion action providing all
                // the required data to undo/redo.
                stm.onStoreModelInsert(this, index, result, context, silent);
            }
        }
        else {
            result = super.insert(index, records, silent);
        }

        return result;
    }

    /**
     * Overridden to notify STM about flat removing action
     *
     * @private
     */
    remove(recordsOrIds, silent = false, fromRemoveChild) {

        let result;

        const stm = this.stm;

        // Tree removing is routed via rootNode.removeChild() it has it's own
        // STM override thus if the store is tree we ignore the action
        if (!this.tree && stm && !stm.disabled) {
            // Flat removing here only, the only date needed to undo/redo the actions is:
            // - the list of records removed
            // - their original index to re-insert them back correctly
            const recordsOrIdsNormalized = (Array.isArray(recordsOrIds) ? recordsOrIds : [recordsOrIds]).map(r => this.getById(r)).filter(r => !!r);

            const context = recordsOrIdsNormalized.reduce(
                (context, r) => {
                    const index = this.indexOf(r);

                    if (index !== undefined && index != -1) {
                        context.set(r, index);
                    }

                    return context;
                },
                new Map()
            );

            // Calling original store method
            result = super.remove(recordsOrIds, silent, fromRemoveChild);

            // Here we check if anything has been actually removed.
            // The removing action might be vetoed by event handler or something
            if (result && result.length) {
                stm.onStoreModelRemove(this, result, context, silent);
            }
        }
        else {
            result = super.remove(recordsOrIds, silent, fromRemoveChild);
        }

        return result;
    }

    /**
     * Overridden to notify STM about flat clear action
     *
     * @private
     */
    removeAll(silent) {
        const stm = this.stm;

        if (stm && !stm.disabled) {
            // Here we are to detect if anything has been removed
            // the only way is to check if store has anything before removing all
            // and has nothing after.
            const
                { tree, rootNode, allRecords } = this,
                wasNotEmpty                    = allRecords.length,
                // need to store children/records before super method call, otherwise those would report empty list
                records                        = tree ? rootNode.children.slice() : allRecords.slice();
    
            super.removeAll(silent);

            // The trick here is to distinguish tree and flat case
            // For the flat case it's simple we just store all records
            // For the tree we are to store root node children only
            // Upon restoring store.add() will do the right thing for the flat case and tree case regardless.
            if (wasNotEmpty && this.count === 0) {
                stm.onStoreRemoveAll(this, records, silent);
            }
        }
        else {
            super.removeAll(silent);
        }
    }
};

/**
 * @module Core/data/Store
 */

/**
 * The Store represents a data container which holds flat data or tree structures. An item in the Store is often called a ´record´ and it is simply an instance of the
 * {@link Core.data.Model} (or any subclass thereof). Typically you load data into a store to display it in a Grid or a ComboBox. The Store is the backing data component for any component that is showing data in a list style UI.
 *
 * * {@link Grid.view.Grid}
 * * {@link Grid.view.TreeGrid}
 * * {@link Core.widget.List}
 * * {@link Core.widget.Combo}
 *
 * <h3>Data format</h3>
 * Data is store in a JSON array the Store offers an API to edit, filter, group and sort the records.
 *
 * <h3>Store with flat data</h3>
 * To create a flat store simply provide an array of objects that describe your records
 *
 * ```javascript
 * let store = new Store({
 *   data : [
 *     { id : 1, name : 'ABBA', country : 'Sweden' },
 *     { id : 2, name : 'Beatles', country : 'UK' }
 *   ]
 * });
 *
 * // retrieve record by id
 * let beatles = store.getById(2);
 * ```
 *
 * <h3>Store with tree data</h3>
 * To create a tree store use `children` property for descendant records
 *
 * ```javascript
 * let store = new Store({
 *   tree: true,
 *   data : [
 *     { id : 1, name : 'ABBA', country : 'Sweden', children: [
 *       { id: 2, name: 'Agnetha' },
 *       { id: 3, name: 'Bjorn' },
 *       { id: 4, name: 'Benny' },
 *       { id: 5, name: 'Anni-Frid' }
 *     ]},
 *   ]
 * });
 *
 * // retrieve record by id
 * let benny = store.getById(4);
 * ```
 *
 * <h3>Sharing stores</h3>
 * You cannot directly share a Store between widgets, but the data in a Store can be shared. There are two different
 * approaches depending on your needs, sharing data and chaining stores:
 *
 * <h4>Shared data</h4>
 * To create 2 widgets that share data, you can create 2 separate stores and pass records of the first store as the
 * dataset of the second store.
 *
 * ```javascript
 * let combo1 = new Combo({
 *     appendTo : document.body,
 *     store    : new Store({
 *         data : [
 *             { id : 1, name : 'ABBA', country : 'Sweden' },
 *             { id : 2, name : 'Beatles', country : 'UK' }
 *         ]
 *     }),
 *     valueField   : 'id',
 *     displayField : 'name'
 * });
 *
 * let combo2 = new Combo({
 *     appendTo : document.body,
 *     store    : new Store({
 *         data : combo1.store.records
 *     }),
 *     valueField   : 'id',
 *     displayField : 'name'
 * });
 *
 * combo1.store.first.name = 'foo';
 * combo2.store.first.name; // "foo"
 * ```
 *
 * <h4>Chained stores</h4>
 * Another more powerful option to share data between widgets is to create {@link Core.data.mixin.StoreChained chained stores}.
 * The easiest way to create a chained store is to call {@link #function-chain} function.
 *
 * ```javascript
 * let combo1 = new Combo({
 *     appendTo : document.body,
 *     store    : new Store({
 *         data : [
 *             { id : 1, name : 'ABBA', country : 'Sweden' },
 *             { id : 2, name : 'Beatles', country : 'UK' }
 *         ]
 *     }),
 *     valueField   : 'id',
 *     displayField : 'name'
 * });
 *
 * let combo2 = new Combo({
 *     appendTo : document.body,
 *     store    : combo1.store.chain(),
 *     valueField   : 'id',
 *     displayField : 'name'
 * });
 *
 * combo1.store.first.name = 'foo';
 * combo2.store.first.name; // "foo"
 * ```
 *
 * A chained store can optionally be created with a filtering function, to only contain a subset of the records from
 * the main store. In addition, the chained store will reflect record removals/additions to the master store, something
 * the shared data approach will not.
 *
 * @mixes Core/data/mixin/StoreChained
 * @mixes Core/data/mixin/StoreCRUD
 * @mixes Core/data/mixin/StoreFilter
 * @mixes Core/data/mixin/StoreGroup
 * @mixes Core/data/mixin/StoreRelation
 * @mixes Core/data/mixin/StoreSearch
 * @mixes Core/data/mixin/StoreSort
 * @mixes Core/data/mixin/StoreState
 * @mixes Core/data/mixin/StoreSum
 * @mixes Core/data/mixin/StoreTree
 * @mixes Core/mixin/Events
 * @mixes Core/data/stm/mixin/StoreStm
 *
 * @extends Core/Base
 */
class Store extends base(Base).mixes(
    Events,
    Pluggable,
    State,
    StoreFilter,
    StoreCRUD,
    StoreRelation,
    StoreSum,
    StoreSearch,
    StoreSort,
    StoreGroup,
    StoreChained,
    StoreState,
    StoreTree,
    StoreStm,
    StoreSync
) {
    //region Config & properties

    static get properties() {
        return {
            relationCache         : {},
            dependentStoreConfigs : new Map()
        };
    }

    static get defaultConfig() {
        return {
            /**
             * Deprecated in favour of {@link #config-id}
             * @config {String|Number}
             * @deprecated 2.0.0
             */
            storeId : null,

            /**
             * Store's unique identifier. When set the store is added to a store map accessible through Store#getStore(id)
             * @config {String|Number}
             * @category Common
             */
            id : true,

            /**
             * An array of field definitions used to create a Model (modelClass) subclass. Optional. If the Model
             * already has fields defined, these fields will extend those.
             * @config {Object[]}
             * @category Common
             */
            fields : null,

            /**
             * Automatically detect from set data if used as tree store or flat store
             * @config {Boolean}
             * @default
             * @category Tree
             */
            autoTree : true,

            /**
             * Class used to represent records
             * @config {Core.data.Model}
             * @default
             * @category Common
             * @typings { new(data: object): Model }
             */
            modelClass : Model,

            /**
             * Raw data to load initially
             * @config {Object[]}
             * @category Common
             */
            data : null,

            /**
             * `true` to act as a tree store.
             * @config {Boolean}
             * @category Tree
             */
            tree : false,

            callOnFunctions : true,

            /**
             * A {@link Core.util.Collection Collection}, or Collection config object
             * to use to contain this Store's constituent records.
             * @config {Core.util.Collection|Object}
             */
            storage : null,

            /**
             * Retools the loaded data objects instead of making shallow copies of them. This increases performance but
             * pollutes the incoming data and does not allow remapping of fields (dataSource).
             *
             * Also allows disabling certain steps in data loading, to further improve performance. Either accepts an
             * object with the params described below or `true` which equals `disableDuplicateIdCheck` and
             * `disableTypeConversion`.
             *
             * ```javascript
             * // No duplicate id checking, no type conversions
             * new Store({ useRawData : true });
             *
             * new Store({
             *   // No type conversions only
             *   useRawData : {
             *     disableTypeConversion : true
             *   }
             * });
             * ```
             *
             * @config {Boolean|Object}
             * @param {Boolean} [disableDuplicateIdCheck] Data must not contain duplicate ids, check is bypassed.
             * @param {Boolean} [disableDefaultValue] Default values will not be applied to record fields.
             * @param {Boolean} [disableTypeConversion] No type conversions will be performed on record data.
             * @category Advanced
             */
            useRawData : false,

            /**
             * Specify `false` to prevent loading records without ids, a good practise to enforce when syncing with a
             * backend. By default Store allows loading records without ids, in which case a generated id will be
             * assigned.
             * @config {Boolean}
             * @default true
             * @category Advanced
             */
            allowNoId : true,

            /**
             * Prevent dynamically subclassing the modelClass. It does so by default to not pollute it when exposing
             * properties. Should rarely need to be used.
             * @config {Boolean}
             * @default false
             * @private
             * @category Advanced
             */
            preventSubClassingModel : null
        };
    }

    //endregion

    //region Events

    /**
     * Fired when the id of a record has changed
     * @event idChange
     * @param {Core.data.Store} source This Store
     * @param {Core.data.Model} record Modified record
     * @param {String|Number} oldValue Old id
     * @param {String|Number} value New id
     */

    /**
     * Fired before record is modified in this store.
     * Modification may be vetoed by returning `false` from a handler.
     * @event beforeUpdate
     * @param {Core.data.Store} source This Store
     * @param {Core.data.Model} record Modified record
     * @param {Object} changes Modification data
     */

    /**
     * Fired when a record is modified
     * @event update
     * @param {Core.data.Store} source This Store
     * @param {Core.data.Model} record Modified record
     * @param {Object} changes Modification data
     */

    /**
     * Fired when the root node is set
     * @event rootChange
     * @param {Core.data.Store} source This Store
     * @param {Core.data.Model} oldRoot The old root node.
     * @param {Core.data.Model} rootNode The new root node.
     */

    /**
     * Data in the store was changed. This is a catch-all event which is fired for all changes
     * which take place to the store's data.
     *
     * This includes mutation of individual records, adding and removal of records, as well as
     * setting a new data payload using the {@link #property-data} property, sorting, filtering,
     * and calling {@link Core.data.mixin.StoreCRUD#function-removeAll}.
     *
     * Simple databound widgets may use to the `change` event to refresh their UI without having to add multiple
     * listeners to the {@link #event-update}, {@link Core.data.mixin.StoreCRUD#event-add}, {@link Core.data.mixin.StoreCRUD#event-remove}, {@link #event-refresh}
     * and {@link Core.data.mixin.StoreCRUD#event-removeAll} events.
     *
     * A more complex databound widget such as a grid may use the more granular events to perform less
     * destructive updates more appropriate to each type of change. The properties will depend upon the value of the `action` property.
     * @event change
     * @param {Core.data.Store} source This Store.
     * @param {String} action Name of action which triggered the change. May be one of:
     * * `'remove'`
     * * `'removeAll'`
     * * `'add'`
     * * `'updatemultiple'`
     * * `'clearchanges'`
     * * `'filter'`
     * * `'sort'`
     * * `'update'`
     * * `'dataset'`
     * * `'replace'`
     */

    /**
     * Data in the store has completely changed, such as by a filter, or sort or load operation.
     * @event refresh
     * @param {Core.data.Store} source This Store.
     * @param {Boolean} batch Flag set to `true` when the refresh is triggered by ending a batch
     * @param {String} action Name of action which triggered the change. May be one of:
     * * `'dataset'`
     * * `'sort'`
     * * `'filter'`
     * * `'create'`
     * * `'update'`
     * * `'delete'`
     * * `'group'`.
     */

    //endregion

    //region Init

    construct(config = {}) {
        const me = this;

        Object.assign(me, {
            added              : new StoreBag(),
            removed            : new StoreBag(),
            modified           : new StoreBag(),
            idRegister         : {},
            internalIdRegister : {}
        });

        super.construct(config);

        me.initRelations();
    }

    doDestroy() {
        const
            me = this,
            allRecords = me.registeredRecords;

        for (let i = allRecords.length - 1, rec; i >= 0; i--) {
            rec = allRecords[i];
            if (rec && !rec.isDestroyed) {
                rec.unJoinStore(me);
            }
        }

        me.storage.destroy();
        delete Store.storeMap[me.id];

        // Remove from STM if added there
        if (me.stm) {
            me.stm.removeStore(me);
        }

        // Events superclass fires destroy event.
        super.doDestroy();
        //TODO abort any ongoing loads
    }

    /**
     * Stops this store from firing events until {@link #function-endBatch} is called. Multiple calls to `beginBatch`
     * stack up, and will require an equal number of `endBatch` calls to resume events.
     *
     * Upon call of {@link #function-endBatch}, a {@link #event-refresh} event is triggered to allow UIs to
     * update themselves based upon the new state of the store.
     *
     * This is extremely useful when making a large number of changes to a store. It is important not to trigger
     * too many UI updates for performance reasons. Batching the changes ensures that UIs attached to this
     * store are only updated once at the end of the updates.
     */
    beginBatch() {
        this.suspendEvents();
    }

    /**
     * Ends event suspension started by {@link #function-beginBatch}. Multiple calls to {@link #function-beginBatch}
     * stack up, and will require an equal number of `endBatch` calls to resume events.
     *
     * Upon call of `endBatch`, a {@link #event-refresh} event with `action: batch` is triggered to allow UIs to update
     * themselves based upon the new state of the store.
     *
     * This is extremely useful when making a large number of changes to a store. It is important not to trigger
     * too many UI updates for performance reasons. Batching the changes ensures that UIs attached to this
     * store are only updated once at the end of the updates.
     */
    endBatch() {
        if (this.resumeEvents()) {
            this.trigger('refresh', {
                action  : 'batch',
                data    : this.storage.values,
                records : this.storage.values
            });
        }
    }

    set storage(storage) {
        const me = this;

        if (storage && storage.isCollection) {
            me._storage = storage;
        }
        else {
            me._storage = new Collection(storage);
        }
        me._storage.autoFilter = me.reapplyFilterOnAdd;

        // Join all the constituent records to this Store
        for (const r of me._storage) {
            r.joinStore(me);
        }
        me._storage.on({
            change  : 'onDataChange',
            thisObj : me
        });
    }

    get storage() {
        if (!this._storage) {
            this.storage = {};
        }
        return this._storage;
    }

    get allRecords() {
        const me = this;

        if (me.isTree) {
            const result = me.collectDescendants(me.rootNode).all;

            if (me.rootVisible) {
                result.unshift(me.rootNode);
            }
            return result;
        }
        else {
            return me.isGrouped
                ? me.collectGroupRecords()
                : me.storage.allValues;
        }
    }

    /**
     * Responds to mutations of the underlying storage Collection
     * @param {Object} event
     * @private
     */
    onDataChange({ source : storage, action, added, removed, replaced, oldCount, item, from, to }) {
        const
            me = this,
            addedCount = added && added.length,
            removedCount = removed && removed.length;

        let record, filtersWereReapplied;

        me._idMap = null;

        if (addedCount) {
            added.forEach(added => {
                added.joinStore(me);
            });
        }

        replaced && replaced.forEach(([oldRecord, newRecord]) => {
            oldRecord.unJoinStore(me);
            newRecord.joinStore(me);
        });

        // Allow mixins to mutate the storage before firing events.
        // StoreGroup does this to introduce group records into the mix.
        super.onDataChange(...arguments);

        // Join/unjoin incoming/outgoing records unless its as a result of TreeNode operations.
        // If we are a tree, joining is done when nodes are added/removed
        // as child nodes of a joined parent.
        if (!me.isTree) {
            if (addedCount) {
                for (record of added) {
                    record.joinStore(me);
                }

                me.added.add(added);
                me.removed.remove(added);

                // Re-evaluate the current *local* filter set silently so that the
                // information we are broadcasting below is up to date.
                filtersWereReapplied = !me.filterParamName && me.filtered && me.reapplyFilterOnAdd;
                if (filtersWereReapplied) {
                    me.filter({
                        silent : true
                    });
                }

            }
            if (removedCount) {
                for (record of removed) {
                    record.unJoinStore(me);

                    // If was newly added, remove from added list
                    if (me.added.includes(record)) {
                        me.added.remove(record);
                    }
                    // Else add to removed list
                    else {
                        me.removed.add(record);
                    }
                }
                me.modified.remove(removed);

                // Re-evaluate the current *local* filter set silently so that the
                // information we are broadcasting below is up to date.
                filtersWereReapplied = !me.filterParamName && me.filtered;
                if (filtersWereReapplied) {
                    me.filter({
                        silent : true
                    });
                }
            }
        }

        switch (action) {
            case 'clear':
                // Clear our own relationCache, since we will be empty
                me.relationCache = {};

                // Signal to stores that depend on us
                me.updateDependentStores('removeall');

                me.trigger('removeAll');
                me.trigger('change', {
                    action : 'removeall'
                });
                break;

            case 'splice':
                if (addedCount) {
                    me.updateDependentStores('add', added);

                    const
                        // Collection does not handle moves, figure out if and where a record was moved from by checking
                        // previous index value stored in meta
                        oldIndex = added.reduce((lowest, record) => {
                            const { previousIndex } = record.meta;
                            if (previousIndex > -1 && previousIndex < lowest) lowest = previousIndex;
                            return lowest;
                        }, added[0].meta.previousIndex),

                        index = storage.indexOf(added[0], !storage.autoFilter),

                        params = {
                            records : added,
                            index
                        };

                    // Only include param oldIndex when used
                    if (oldIndex > -1) {
                        params.oldIndex = oldIndex;
                    }

                    me.trigger('add', params);

                    me.trigger('change', Object.assign({ action : 'add' }, params));

                    if (filtersWereReapplied) {
                        me.triggerFilterEvent({ action : 'filter', filters : me.filters, oldCount, records : me.storage.allValues });
                    }
                }

                if (removed.length) {
                    me.updateDependentStores('remove', removed);

                    me.trigger('remove', {
                        records : removed
                    });
                    me.trigger('change', {
                        action  : 'remove',
                        records : removed
                    });
                }

                if (replaced.length) {
                    // TODO: Remove in 2.2 if no problems til then
                    // me.trigger('updateMultiple', {
                    //     records : removed,
                    //     all     : me.records.length === replaced.length
                    // });
                    me.trigger('replace', {
                        records : replaced,
                        all     : me.records.length === replaced.length
                    });
                    me.trigger('change', {
                        action : 'replace',
                        replaced,
                        all    : me.records.length === replaced.length
                    });
                }
                break;

            case 'filter':
                // Reapply grouping/sorting to make sure unfiltered records get sorted correctly
                if (me.isGrouped) {
                    me.group(null, null, null, null, true);
                }
                else if (me.isSorted) {
                    me.performSort(true);
                }
                break;

            case 'move':
                // update parentIndex of records affected
                for (let allRecords = me.storage.allValues, i = Math.min(from, to); i <= Math.max(from, to); i++) {
                    allRecords[i].parentIndex = i;
                }

                /**
                 * Fired when a record has been moved within this Store
                 * @event move
                 * @param {Core.data.Store} source This Store
                 * @param {Core.data.Model} record The record moved.
                 * @param {Number} from The index from which the record was removed.
                 * @param {Number} to The index at which the record was inserted.
                 */
                me.trigger('move', {
                    record : item,
                    from,
                    to
                });
                me.trigger('change', {
                    action,
                    record : item,
                    from,
                    to
                });
        }
    }

    /**
     * This is called from Model after mutating any fields so that Stores can take any actions necessary
     * at that point, and distribute mutation event information through events.
     * @param {Core.data.Model} record The record which has just changed
     * @param {Object} toSet A map of the field names and values that were passed to be set
     * @param {Object} wasSet A map of the fields that were set. Each property is a field name, and
     * the property value is an object containing two properties: `oldValue` and `value` eg:
     * ```javascript
     *     {
     *         name {
     *             oldValue : 'Rigel',
     *             value : 'Nigel'
     *         }
     *     }
     *
     * @param {Boolean} silent Do not trigger events
     * @param {Boolean} fromRelationUpdate Update caused by a change in related model
     * @private
     */
    onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {
        const
            me      = this,
            idField = record.constructor.idField,
            event   = {
                record,
                changes : wasSet,
                // Cannot use isBatching, since change is triggered when batching has reached 0
                // (but before it is set to null)
                batch   : record.batching != null,
                fromRelationUpdate
            };

        // Add or remove from our modified Bag
        if (record.isModified) {
            if (!me.modified.includes(record) && !me.added.includes(record)) {
                me.modified.add(record);
                if (me.autoCommit) {
                    me.commit();
                }
            }
        }
        else {
            me.modified.remove(record);
        }

        if (!silent) {
            if (idField in wasSet) {
                const { oldValue, value } = toSet[idField];

                me.updateDependentRecordIds(oldValue, value);

                me.onRecordIdChange(record, oldValue, value);

                me.trigger('idChange', {
                    store : me,
                    record,
                    oldValue,
                    value
                });
            }

            me.onUpdateRecord(record, wasSet);

            me.trigger('update', event);
            me.trigger('change', Object.assign({ action : 'update' }, event));
        }
    }

    get idMap() {
        const me               = this,
            processedRecords = me.storage.values,
            needsRebuild   = !me._idMap,
            idMap          = me._idMap || (me._idMap = {});

        if (needsRebuild) {
            for (let record, index = 0, visibleIndex = 0; index < processedRecords.length; index++) {
                record = processedRecords[index];
                idMap[record.id] = { index, visibleIndex, record };
                if (!record.meta.specialRow) {
                    visibleIndex++;
                }
            }
        }
        return idMap;
    }

    /**
     * Class used to represent records. Defaults to class Model.
     * @property {Core.data.Model}
     * @category Records
     * @typings { new(data: object): Model }
     */
    get modelClass() {
        return this._modelClass;
    }

    set modelClass(ClassDef) {
        const fields = this.fields;

        // noinspection JSRedeclarationOfBlockScope
        let ClassDefEx = null;

        // Ensure our modelClass is exchanged for an extended of modelClass decorated with any configured fields.
        if (fields && fields.length) {
            ClassDefEx = class extends ClassDef {
                static get fields() {
                    return fields;
                }
            };

            ClassDefEx.exposeProperties();
        }
        // If we expose properties on Model we will pollute all other models, use internal subclass instead
        else if (!this.preventSubClassingModel) {
            ClassDefEx = class extends ClassDef {};
            
        }
        else {
            ClassDefEx = ClassDef;
        }

        // Need to properly expose relations on this new subclass
        ClassDefEx.exposeRelations();

        this._modelClass = ClassDefEx;
    }

    //endregion

    //region Store id & map

    // Deprecated.
    // TODO: Remove in 2.0 when all references have been removed from Scheduler and Gantt
    set storeId(storeId) {
        this.id = storeId;
    }

    get storeId() {
        return this.id;
    }

    /**
     * Get/set id, an unique identifier for the store.
     * Used to build a store map, use Store#getStore() to retrieve a store from the map.
     * @property {String|Number}
     * @category Store
     */
    set id(id) {
        const me = this;

        if (me._id) {
            delete Store.storeMap[me._id];
        }
        me._id = id === true ? IdHelper.generateId('store-') : id;
        if (id) {
            Store.storeMap[id] = me;
        }
    }

    get id() {
        return this._id;
    }

    get tree() {
        return this._tree;
    }

    set tree(tree) {
        this._tree = tree;

        if (tree && !this.rootNode) {
            this.rootNode = this.buildRootNode();
        }
    }

    // a hook to build a customized root node
    buildRootNode() {
        return {};
    }

    /**
     * Get a store from the store map by id.
     * @param {String|Number|Object[]} id The id of the store to retrieve, or an array of objects
     * from which to create the contents of a new Store.
     * @returns {Core.data.Store} The store with the specified id
     */
    static getStore(id, storeClass) {
        if (id instanceof Store) {
            return id;
        }
        if (this.storeMap[id]) {
            return this.storeMap[id];
        }
        if (Array.isArray(id)) {
            let storeModel;

            const storeData = id.map(item => {
                if (item instanceof Model) {
                    storeModel = item.constructor;
                }
                else if (typeof item === 'string') {
                    item = {
                        text : item
                    };
                }
                return item;
            });

            id = {
                autoCreated : true,
                data        : storeData,
                modelClass  : storeModel || class extends Model {},
                allowNoId   : true // String items have no id and are not guaranteed to be unique
            };
            if (!storeClass) {
                storeClass = Store;
            }
        }
        if (storeClass) {
            return new storeClass(id);
        }
    }

    /**
     * Get all registered stores
     * @returns {Core.data.Store[]}
     */
    static get stores() {
        return Object.values(this.storeMap);
    }

    //endregion

    //region Data

    /**
     * The invisible root node of this tree.
     * @property {Core.data.Model}
     * @readonly
     */
    get rootNode() {
        return this.masterStore ? this.masterStore.rootNode : this._rootNode;
    }

    set rootNode(rootNode) {
        const me = this,
            oldRoot = me._rootNode;

        // No change
        if (rootNode === oldRoot) {
            return;
        }

        if (oldRoot) {
            me.clear(false);
        }
        if (rootNode instanceof Model) {
            // We insist that the rootNode is expanded otherwise no children will be added
            rootNode.instanceMeta(me).collapsed = false;

            me._rootNode = rootNode;
        }
        else {
            me._rootNode = rootNode = new me.modelClass(Object.assign({
                expanded                : true,
                [me.modelClass.idField] : `${me.id}-rootNode`
            }, rootNode), me, null, true);
            rootNode.isAutoRoot = true;
        }
        me._tree = true;
        rootNode.isRoot = true;
        rootNode.joinStore(me);

        // If there are nodes to be inserted into the flat storage
        // then onNodeAddChild knows how to do that and what events
        // to fire based upon rootNode.isLoading.
        if (rootNode.children && rootNode.children.length || me.rootVisible) {
            rootNode.isLoading = true;
            me.onNodeAddChild(rootNode, rootNode.children || [], 0);
            rootNode.isLoading = false;
        }

        me.trigger('rootChange', { oldRoot, rootNode });
    }

    /**
     * Sets data in the store, called on initialization if data is in config otherwise call it yourself after
     * ajax call etc. Can also be used to get the raw original data.
     * @property {Object[]}
     * @fires refresh
     * @fires change
     * @category Records
     */
    set data(data) {
        const me = this;

        // Make sure that if the plugins have not been processed yet, we call
        // the temporary property getter which configuration injects to
        // process plugins at this point. Some plugins are required to
        // operate on incoming data.
        me._thisIsAUsedExpression(me.plugins);

        // In case someone is listening for load
        me.processConfiguredListeners();

        // Convert to being a tree store if any of the new rows have a children property
        me.tree = !me.isChained && (me.tree || Boolean(me.autoTree && data && data.some(r => r[me.modelClass.childrenField])));

        // Always load a new dataset initially
        if (!me.syncDataOnLoad || !me._data) {
            me._data = data;
            // This means load the root node
            if (me.tree) {
                const root = me.rootNode;

                // Should signal stores to clear which clears UIs
                root.clearChildren();

                root.isLoading = true;
                // Append child will detect that this is a dataset operation and trigger sort + events needed
                root.appendChild(data);

                me.updateDependentStores('dataset', [root]);

                root.isLoading = false;

                // we must re-apply filters for the filtered tree store
                if (me.isFiltered) {
                    me.filter();
                }
            }
            else {
                me.loadData(data);
            }

            // loading the store discards all tracked changes
            me.added.clear();
            me.removed.clear();
            me.modified.clear();
        }
        // Sync dataset if configured to do so
        else {
            me.syncDataset(data);
        }
    }

    loadData(data, action = 'dataset') {
        const
            me                     = this,
            { storage, allowNoId } = me,
            idField                = me.modelClass.fieldMap.id.dataSource;

        if (me.allCount) {
            // clear without marking as removed
            me.clear(false);
        }

        me._idMap = null;

        if (data) {
            // Having any of groups collapsed at the time of data reloading using the same dataset
            // makes new data look differ comparing to the data which is already in the store.
            // So here we expand all groups and save the state to collapse them later.
            // This might be expensive, but it helps to prevent Id collision failure for now.
            me.storeCollapsedGroups();

            const isRaw = !(data[0] instanceof Model);

            if (isRaw) {
                me.modelClass.exposeProperties(data[0]);

                const
                    count   = data.length,
                    records = new Array(count);

                for (let i = 0; i < count; i++) {
                    const recordData = data[i];

                    if (!allowNoId && recordData[idField] == null) {
                        throw new Error(`Id required but not found on row ${i}`);
                    }

                    records[i] = me.createRecord(recordData, true);
                    records[i].parentIndex = i;
                }
                // Allow Collection's own filters to work on the Collection by
                // passing the isNewDataset param as true.
                // The storage Collection may have been set up with its own filters
                // while we are doing remote filtering. An example is ComboBox
                // with filterSelected: true. Records which are in the selection are
                // filtered out of visibility using a filter directly in the Combobox's
                // Store's Collection.
                storage.replaceValues(records, true, true);
            }
            else {
                storage.replaceValues(data.slice(), true, true);
            }

            me.storage.allValues.forEach(r => {
                r.joinStore(me);
            });

            // Need to update group records info (headers and footers)
            me.prepareGroupRecords();

            // Restore collapsed state
            me.restoreCollapsedGroups();

            // The three operations below, filter, store and sort, all are passed
            // the "silent" parameter meaning they do not fire their own events.
            // The 'refresh' and 'change' events after are used to update UIs.
            if (!me.filterParamName && me.isFiltered) {
                me.filter({
                    silent : true
                });
            }

            // TODO: groupers must just be promoted to be the primary sorters.
            if (me.isGrouped) {
                me.group(null, null, false, !me.sorters.length, true);
            }
            if (!me.sortParamName && me.sorters.length) {
                me.sort(null, null, false, true);
            }

            // Check for duplicate ids, unless user guarantees data validity
            if (!me.useRawData.disableDuplicateIdCheck) {
                const idMap = me.idMap;
                if (Object.keys(idMap).length < me.storage.values.length) {
                    // idMap has fewer entries than expected, a duplicate id was used. pick idMap apart to find out which
                    const collisions = [];
                    me.storage.values.forEach(r => idMap[r.id] ? delete idMap[r.id] : collisions.push(r));

                    throw new Error(`Id collision on ${collisions.map(r => r.id)}`);
                }
            }

            const event = { action, data, records : me.storage.values };

            me.updateDependentStores(event.action, event.records);

            me.trigger('refresh', event);
            me.trigger('change', event);
        }
        else {
            me._data = null;
        }
    }

    get data() {
        return this._data;
    }

    /**
     * Creates an array of records from this store from the `start` to the `end' - 1
     * @param {Number} [start] The index of the first record to return
     * @param {Number} [end] The index *after* the last record to return `(start + length)`
     * @return {Core.data.Model[]} The requested records.
     * @category Records
     */
    getRange(start, end, all = true) {
        return (all ? this.storage.allValues : this.storage.values).slice(start, end);
    }

    /**
     * Creates a model instance, used internally when data is set/added. Override this in a subclass to do your own custom
     * conversion from data to record.
     * @param data Json data
     * @param skipExpose Supply true when batch setting to not expose properties multiple times
     * @category Records
     */
    createRecord(data, skipExpose = false) {
        return new this.modelClass(data, this, null, skipExpose);
    }

    refreshData() {
        this.filter();
        this.sort();
    }

    onRecordIdChange(record, oldValue, value) {
        const me = this,
            idMap = me._idMap,
            { idRegister } = me;

        me.storage._indicesInvalid = true;

        if (idMap) {
            delete idMap[oldValue];
            idMap[value] = record;
        }
        me.added.changeId(oldValue, value);
        me.removed.changeId(oldValue, value);
        me.modified.changeId(oldValue, value);

        delete idRegister[oldValue];
        idRegister[value] = record;

        record.index = me.storage.indexOf(record);
    }

    onUpdateRecord(record, changes) {
        const { internalId } = changes,
            { internalIdRegister } = this;

        if (internalId) {
            this.storage._indicesInvalid = true;
            delete internalIdRegister[internalId.oldValue];
            internalIdRegister[internalId.value] = record;
        }

        // Reapply filters when records change?
        if (this.reapplyFilterOnUpdate && this.isFiltered) {
            this.filter();
        }
    }

    get useRawData() {
        return this._useRawData;
    }

    set useRawData(options) {
        if (options === true) {
            this._useRawData = {
                enabled                 : true,
                disableDuplicateIdCheck : true,
                disableTypeConversion   : true,
                disableDefaultValue     : false
            };
        }
        else {
            this._useRawData = options ? Object.assign(options, { enabled : true }) : { enabled : false };
        }
    }

    //endregion

    //region Count

    /**
     * Number of records in the store
     * @param countProcessed Count processed (true) or real records (false)
     * @returns {Number} Record count
     * @category Records
     */
    getCount(countProcessed = true) {
        return countProcessed ? this.count : this.originalCount;
    }

    /**
     * Record count, for data records. Not including records added for group headers etc.
     * @property {Number}
     * @readonly
     * @category Records
     */
    get originalCount() {
        return this.storage.totalCount;
    }

    /**
     * Record count, including records added for group headers etc.
     * @property {Number}
     * @readonly
     * @category Records
     */
    get count() {
        return this.storage.count;
    }

    /**
     * Returns the complete dataset size regardless of tree node collapsing or filtering
     * @property {Number}
     * @readonly
     */
    get allCount() {
        return this.isTree ? this.rootNode.descendantCount : this.storage.totalCount;
    }

    //endregion

    //region Get record(s)

    /**
     * Returns all "visible" records
     * @property {Core.data.Model[]}
     * @readonly
     * @category Records
     */
    get records() {
        return this.storage.values;
    }

    /**
     * Get the first record in the store.
     * @property {Core.data.Model}
     * @readonly
     * @category Records
     */
    get first() {
        return this.storage.values[0];
    }

    /**
     * Get the last record in the store.
     * @property {Core.data.Model}
     * @readonly
     * @category Records
     */
    get last() {
        return this.storage.values[this.storage.values.length - 1];
    }

    /**
     * Get the record at the specified index
     * @param {Number} index Index for the record
     * @returns {Core.data.Model} Record at the specified index
     * @category Records
     */
    getAt(index, all = false) {
        // all means include filtered out records
        return this.storage.getAt(index, all);
    }

    // These are called by Model#join and Model#unjoin
    // register a record as a findable member keyed by id and internalId
    register(record) {
        const
            me          = this,
            // Test for duplicate IDs on register only when a tree store.
            // loadData does it in the case of a non-tree
            existingRec = me.isTree && me.idRegister[record.id];

        if (existingRec && existingRec !== record) {
            throw new Error(`Id collision on ${record.id}`);
        }
        me.idRegister[record.id] = record;
        me.internalIdRegister[record.internalId] = record;
    }

    unregister(record) {
        delete this.idRegister[record.id];
        delete this.internalIdRegister[record.internalId];
    }

    get registeredRecords() {
        return Object.values(this.idRegister);
    }

    /**
     * Get a record by id. Find the record even if filtered out, part of collapsed group or collapsed node
     * @param {Core.data.Model|String|Number} id Id of record to return.
     * @returns {Core.data.Model} A record with the specified id
     * @category Records
     */
    getById(id) {
        // In case `id` is a record, we use its ID to try to find the record in the store,
        // because if the record is removed from the store it shouldn't be found.
        // if (id instanceof Model) {
        //     id = id.id;
        // }

        if (id && id.isModel) {
            return id;
        }

        //return this.tree ? this.idRegister[id] : this.storage.get(id);
        return this.idRegister[id];
    }

    /**
     * Checks if a record is visible, in the sense that it is not filtered out,
     * hidden in a collapsed group or in a collapsed node.
     * Deprecated in 2.2.3, please use {@link #function-isAvailable} instead
     * @param {Core.data.Model|String|Number} recordOrId Record to check
     * @returns {Boolean}
     * @deprecated 2.2.3
     */
    isVisible(recordOrId) {
        return this.isAvailable(recordOrId);
    }

    /**
     * Checks if a record is available, in the sense that it is not filtered out,
     * hidden in a collapsed group or in a collapsed node.
     * @param {Core.data.Model|String|Number} recordOrId Record to check
     * @returns {Boolean}
     */
    isAvailable(recordOrId) {
        const record = this.getById(recordOrId);

        return record && this.storage.includes(record) || false;
    }

    /**
     * Get a record by internalId.
     * @param {Number} internalId The internalId of the record to return
     * @returns {Core.data.Model} A record with the specified internalId
     * @category Records
     */
    getByInternalId(internalId) {
        return this.internalIdRegister[internalId];
    }

    /**
     * Checks if the specified record is contained in the store
     * @param {Core.data.Model|String|Number} recordOrId Record, or `id` of record
     * @returns {Boolean}
     * @category Records
     */
    includes(recordOrId) {
        if (this.isTree) {
            return this.idRegister[Model.asId(recordOrId)] != null;
        }

        return this.indexOf(recordOrId) > -1;
    }

    //endregion

    //region Get index

    /**
     * Returns the index of the specified record/id, or `-1` if not found.
     * @param {Core.data.Model|String|Number} recordOrId Record, or `id` of record to return the index of.
     * @param {Boolean} [visibleRecords] Pass `true` to find the visible index.
     * as opposed to the dataset index. This omits group header records.
     * @returns {Number} Index for the record/id, or `-1` if not found.
     * @category Records
     */
    indexOf(recordOrId, visibleRecords = false) {
        const id = Model.asId(recordOrId);

        if (id == null) {
            return -1;
        }

        // When a tree, indexOf is always in the visible records - filtering is different in trees.
        if (this.isTree) {
            return this.storage.indexOf(id);
        }

        const found = this.idMap[id];

        return found ? found[visibleRecords ? 'visibleIndex' : 'index'] : -1;
    }

    allIndexOf(recordOrId) {
        if (this.isTree) {
            const record = this.getById(recordOrId);
            let result = -1;

            // Use the tree structure to get the index in tree walk order
            if (record) {
                record.bubble(n => {
                    if (n.parent) {
                        result += n.parentIndex + 1;
                    }
                    else if (n === this.rootNode && this.rootVisible) {
                        result += 1;
                    }
                });
            }
            return result;
        }
        else {
            return this.storage.indexOf(recordOrId, true);
        }
    }

    //endregion

    //region Get values

    /**
     * Gets distinct values for the specified field.
     * @param field Field to extract values for
     * @returns {Array} Array of values
     * @category Values
     */
    getDistinctValues(field) {
        const me     = this,
            values = [],
            keys   = {};
        let value;

        me.forEach(r => {
            if (!r.meta.specialRow && !r.isRoot) {
                value = r.get(field);
                if (!keys[value]) {
                    values.push(value);
                    keys[value] = 1;
                }
            }
        });

        return values;
    }

    /**
     * Counts how many times specified value appears in the store
     * @param field Field to look in
     * @param value Value to look for
     * @returns {Number} Found count
     * @category Values
     */
    getValueCount(field, value) {
        let me    = this,
            count = 0;

        me.forEach(r => {
            if (ObjectHelper.isEqual(r.get(field), value)) count++;
        });

        return count;
    }

    //endregion

    //region JSON & console

    get json() {
        return JSON.stringify(this, null, 4);
    }

    toJSON() {
        // extract entire structure.
        // If we're a tree, then that consists of the payload of the rootNode.
        return (this.isTree ? this.rootNode.children : this).map(record => record.toJSON());
    }

    

    //endregion

    //region Iteration & traversing

    /**
     * Iterates over all normal records in store. Omits group header and footer records
     * if this store is grouped.
     * @param {Function} fn A function that is called for each record. Returning false from that function cancels iteration
     * @param {Object} thisObj `this` reference for the function
     * @category Iteration
     */
    forEach(fn, thisObj = this) {
        const callback = (r, i) => {
            if (!r.isRoot && !r.meta.specialRow) {
                return fn.call(thisObj, r, i);
            }
        };

        if (this.isTree) {
            this.rootNode.traverseWhile(callback);
        }
        else {
            // native forEach cannot be aborted by returning false, have to loop "manually"
            const records = this.storage.values;
            for (let i = 0; i < records.length; i++) {
                if (callback(records[i], i) === false) {
                    return;
                }
            }
        }
    }

    /**
     * Equivalent to Array.map(). Creates a new array with the results of calling a provided function on every record
     * @param {Function} fn
     * @returns {Array}
     * @category Iteration
     */
    map(fn, thisObj = this) {
        return this.storage.values.map(fn, thisObj);
    }

    /**
     * Equivalent to Array.reduce(). Applies a function against an accumulator and each record (from left to right) to
     * reduce it to a single value.
     * @param {Function} fn
     * @param initialValue
     * @returns {*}
     * @category Iteration
     */
    reduce(fn, initialValue = [], thisObj = this) {
        if (thisObj !== this) {
            fn = fn.bind(thisObj);
        }

        return this.storage.values.reduce(fn, initialValue, thisObj);
    }

    /**
     * Iterator that allows you to do for (let record of store)
     * @category Iteration
     */
    [Symbol.iterator]() {
        return this.storage.values[Symbol.iterator]();
    }

    /**
     * Traverse all tree nodes
     * @param {Function} fn The function to call on visiting each node.
     * @param {Core.data.Model} [topNode=this.rootNode] The top node to start the traverse at.
     * @param {Boolean} [skipTopNode] Pass true to not call `fn` on the top node, but proceed directly to its children.
     * @category Traverse
     */
    traverse(fn, topNode = this.rootNode, skipTopNode = topNode === this.rootNode) {
        const me = this;

        if (me.isTree) {
            // Allow store.traverse(fn, true) to start from rootNode
            if (typeof topNode === 'boolean') {
                skipTopNode = topNode;
                topNode = me.rootNode;
            }
            if (me.isChained) {
                const passedFn = fn;

                fn = node => {
                    if (me.chainedFilterFn(node)) {
                        passedFn(node);
                    }
                };
            }
            topNode.traverse(fn, skipTopNode);
        }
        else {
            for (const record of me.storage) {
                record.traverse(fn);
            }
        }
    }

    /**
     * Traverse all tree nodes while the passed `fn` returns true
     * @param {Function} fn The function to call on visiting each node. Returning `false` from it stops the traverse.
     * @param {Core.data.Model} [topNode=this.rootNode] The top node to start the traverse at.
     * @param {Boolean} [skipTopNode] Pass true to not call `fn` on the top node, but proceed directly to its children.
     * @category Traverse
     */
    traverseWhile(fn, topNode = this.rootNode, skipTopNode = topNode === this.rootNode) {
        const me = this;

        if (me.isTree) {
            // Allow store.traverse(fn, true) to start from rootNode
            if (typeof topNode === 'boolean') {
                skipTopNode = topNode;
                topNode = me.rootNode;
            }
            if (me.isChained) {
                const passedFn = fn;

                fn = node => {
                    if (me.chainedFilterFn(node)) {
                        passedFn(node);
                    }
                };
            }
            topNode.traverseWhile(fn, skipTopNode);
        }
        else {
            for (const record of me.storage) {
                if (record.traverse(fn) === false) {
                    break;
                }
            }
        }
    }

    /**
     * Finds the next record.
     * @param recordOrId Current record or its id
     * @param {Boolean} wrap Wrap at start/end or stop there
     * @returns {Core.data.Model} Next record or null if current is the last one
     * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
     * @category Traverse
     */
    getNext(recordOrId, wrap = false, skipSpecialRows = false) {
        let me      = this,
            records = me.storage.values,
            idx     = me.indexOf(recordOrId);

        if (idx >= records.length - 1) {
            if (wrap) {
                idx = -1;
            }
            else {
                return null;
            }
        }

        const record = records[idx + 1];

        // Skip the result if it's a specialRow and we are told to skip them
        if (skipSpecialRows && record && record.meta.specialRow) {
            return me.getNext(records[idx + 1], wrap, true);
        }

        return record;
    }

    /**
     * Finds the previous record.
     * @param recordOrId Current record or id
     * @param {Boolean} wrap Wrap at start/end or stop there
     * @returns {Core.data.Model} Previous record or null if current is the last one
     * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
     * @category Traverse
     */
    getPrev(recordOrId, wrap = false, skipSpecialRows = false) {
        let me      = this,
            records = me.storage.values,
            idx     = me.indexOf(recordOrId);

        if (idx === 0) {
            if (wrap) {
                idx = records.length;
            }
            else {
                return null;
            }
        }

        const record = records[idx - 1];

        // Skip the result if it's a specialRow and we are told to skip them
        if (skipSpecialRows && record && record.meta.specialRow) {
            return me.getNext(records[idx + 1], wrap, true);
        }

        return record;
    }

    /**
     * Gets the next or the previous record. Optionally wraps from first -> last and vice versa
     * @param {String|Model} recordOrId Record or records id
     * @param {Boolean} next Next (true) or previous (false)
     * @param {Boolean} wrap Wrap at start/end or stop there
     * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
     * @returns {Core.data.Model}
     * @category Traverse
     * @internal
     */
    getAdjacent(recordOrId, next = true, wrap = false, skipSpecialRows = false) {
        return next ? this.getNext(recordOrId, wrap, skipSpecialRows) : this.getPrev(recordOrId, wrap, skipSpecialRows);
    }

    /**
     * Finds the next record among leaves (in a tree structure)
     * @param recordOrId Current record or its id
     * @param {Boolean} wrap Wrap at start/end or stop there
     * @returns {Core.data.Model} Next record or null if current is the last one
     * @category Traverse
     * @internal
     */
    getNextLeaf(recordOrId, wrap = false) {
        let me      = this,
            records = me.leaves,
            record  = me.getById(recordOrId),
            idx     = records.indexOf(record);

        if (idx >= records.length - 1) {
            if (wrap) {
                idx = -1;
            }
            else {
                return null;
            }
        }

        return records[idx + 1];
    }

    /**
     * Finds the previous record among leaves (in a tree structure)
     * @param recordOrId Current record or id
     * @param {Boolean} wrap Wrap at start/end or stop there
     * @returns {Core.data.Model} Previous record or null if current is the last one
     * @category Traverse
     * @internal
     */
    getPrevLeaf(recordOrId, wrap = false) {
        let me      = this,
            records = me.leaves,
            record  = me.getById(recordOrId),
            idx     = records.indexOf(record);

        if (idx === 0) {
            if (wrap) {
                idx = records.length;
            }
            else {
                return null;
            }
        }

        return records[idx - 1];
    }

    /**
     * Gets the next or the previous record among leaves (in a tree structure). Optionally wraps from first -> last and
     * vice versa
     * @param {String|Core.data.Model} recordOrId Record or record id
     * @param {Boolean} next Next (true) or previous (false)
     * @param {Boolean} wrap Wrap at start/end or stop there
     * @returns {Core.data.Model}
     * @category Traverse
     * @internal
     */
    getAdjacentLeaf(recordOrId, next = true, wrap = false) {
        return next ? this.getNextLeaf(recordOrId, wrap) : this.getPrevLeaf(recordOrId, wrap);
    }

    //endregion

    //region Chained store

    /**
     * Creates a chained store, a new Store instance that contains a subset of the records from current store.
     * Which records is determined by a filtering function, which is reapplied when data in the base store changes.
     *
     * If this store is a {@link Core.data.mixin.StoreTree#property-isTree tree} store, then the resulting
     * chained store will be a tree store sharing the same root node, but only child nodes which pass
     * the `chainedFilterFn` will be considered when iterating the tree through the methods such as
     * {@link #function-traverse} or {@link #function-forEach}.
     *
     * @param {Function} chainedFilterFn Function called for each records that determines if it should be included
     * (return true) or not (return false). Defaults to including all records (fn always returning true)
     * @param {String[]} chainedFields Array of fields that trigger filtering when they are updated
     * @param {Object} config Additional chained store configuration
     * @returns {Core.data.Store}
     * @example
     * let oldies = store.makeChained(record => record.age > 40);
     */
    makeChained(chainedFilterFn = () => true, chainedFields, config) {
        return new this.constructor(Object.assign(config || {}, {
            tree        : false,
            autoTree    : false,
            masterStore : this,
            chainedFilterFn,
            chainedFields
        }));
    }

    /**
     * Alias for {@link #function-makeChained}
     * @param {Function} chainedFilterFn Function called for each records that determines if it should be included
     * (return true) or not (return false). Defaults to including all records (fn always returning true)
     * @param {String[]} chainedFields Array of fields that trigger filtering when they are updated
     * @param {Object} config Additional chained store configuration
     * @returns {Core.data.Store}
     */
    chain() {
        return this.makeChained(...arguments);
    }

    //endregion
}

Store.storeMap = {};
Store._$name = 'Store';

/**
 * @module Core/data/AjaxStore
 */

const processParamEntry = (paramArray, entry) => {
        if (Array.isArray(entry[1])) {
            entry[1].forEach(value => paramArray.push(entry[0] + '=' + value));
        }
        else {
            paramArray.push(entry[0] + '=' + entry[1]);
        }
        return paramArray;
    },
    immediatePromise$2  = new Promise((resolve) => resolve());

/**
 * Store that uses the Fetch API to read data from a remote server, and optionally sends synchronization
 * requests to the server containing information about locally created, modified and deleted records.
 *
 * ### Create
 * Posts array of JSON data for newly added records to {@link #config-createUrl}, expects response containing an array of JSON objects
 * in same order with id set (uses Model#idField as id).
 *
 * ### Read
 * Reads array of JSON data from the data packet returned from the {@link #config-readUrl}. Unique id for each row is required.
 * By default looks in field 'id' but can be configured by setting {@link Core.data.Model#property-idField-static}.
 *
 * ### Update
 * Posts array of JSON data for newly modified records to {@link #config-updateUrl}.
 *
 * ### Destroy
 * Posts to {@link #config-deleteUrl} with removed records ids (for example id=1,4,7).
 *
 * ```javascript
 * new AjaxStore({
 *   createUrl  : 'php/create',
 *   readUrl    : 'php/read',
 *   updateUrl  : 'php/update',
 *   deleteUrl  : 'php/delete',
 *   modelClass : Customer
 * });
 * ```
 *
 * ### Pagination
 * Configuring an `AjaxStore` with {@link #config-pageParamName} or {@link #config-pageStartParamName} means that the store requests **pages**
 * of data from the remote source, sending the configured {@link #config-pageParamName} or {@link #config-pageStartParamName} to request the page
 * along with the {@link #config-pageSizeParamName}.
 *
 * If `pageParamName` is set, that is passed with the requested page number **(one based)**, along with the {@link #config-pageSizeParamName}.
 *
 * If `pageStartParamName` is set, that is passed with the requested page starting record index **(zero based)**, along with the {@link #config-pageSizeParamName}.
 *
 * ### Remote filtering
 * To specify that filtering is the responsibility of the server, configure the store with
 * `{@link #config-filterParamName}: 'nameOfFilterParameter'`
 *
 * When this is set, any {@link Core.data.mixin.StoreFilter#function-filter} operation causes the store to
 * reload itself, encoding the filters as JSON representations in the {@link #config-filterParamName} HTTP
 * parameter.
 *
 * The filters will look like this:
 * ```javascript
 * {
 *     "field": "country",
 *     "operator": "=",
 *     "value": "sweden",
 *     "caseSensitive": false
 * }
 * ```
 *
 * The encoding may be overridden by configuring an implementation of {@link #function-encodeFilterParams}
 * into the store which returns the value for the {@link #config-filterParamName} when passed an _Iterable_ of filters.
 *
 * ### Remote sorting
 * To specify that sorting is the responsibility of the server, configure the store with
 * `{@link #config-sortParamName}: 'nameOfSortParameter'`
 *
 * When this is set, any {@link Core.data.mixin.StoreSort#function-sort} operation causes the store to
 * reload itself, encoding the sorters as JSON representations in the {@link #config-sortParamName} HTTP
 * parameter.
 *
 * The sorters will look like this:
 * ```javascript
 * {
 *     "field": "name",
 *     "ascending": true
 * }
 * ```
 *
 * The encoding may be overridden by configuring an implementation of {@link #function-encodeSorterParams}
 * into the store which returns the value for the {@link #config-sortParamName} when passed an _Iterable_ of sorters.
 *
 * @extends Core/data/Store
 */
class AjaxStore extends Store {
    // region Events

    /**
     * Fired when a remote request fails, either at the network level, or the server returns a failure, or an invalid response.
     *
     * Note that when a {@link #function-commit} fails, more than one exception event will be triggered. The individual operation,
     * `create`, `update` or `delete` will trigger their own `exception` event, but the encapsulating commit operation will also
     * trigger an `exception` event when all the operations have finished, so if exceptions are going to be handled gracefully,
     * the event's `action` property must be examined, and the constituent operations of the event must be examined.
     * @event exception
     * @param {Core.data.Store} source This Store
     * @param {Boolean} exception `true`
     * @param {String} action Action that failed, `'create'`, `'read'`, `'update'` or `'delete'`. May also be fired
     * with '`commit'` to indicate the failure of an aggregated `create`, `update` and `delete` operation. In this case,
     * the event will contain a property for each operation of the commit named `'create'`, `'update'` and `'delete'`,
     * each containing the individual `exception` events.
     * @param {String} exceptionType The type of failure, `'network'` or `'server'`
     * @param {Response} response the `Response` object
     * @param {Object} json The decoded response object *if the exceptionType is `'server'`*
     */

    /**
     * Fired after committing added records
     * @event commitAdded
     * @param {Core.data.Store} source This Store
     */

    /**
     * Fired after committing modified records
     * @event commitModified
     * @param {Core.data.Store} source This Store
     */

    /**
     * Fired on successful load
     * @event load
     * @param {Core.data.Store} source This Store
     * @param {Object[]} data Data loaded
     * @param {Response} response the `Response` object
     * @param {Object} json The decoded response object.
     */

    /**
     * Fired on successful load of remote child nodes for a tree node.
     * @event loadChildren
     * @param {Core.data.Store} source This Store
     * @param {Object[]} data Data loaded
     * @param {Object} json The decoded response object.
     */

    /**
     * Fired after committing removed records
     * @event commitRemoved
     * @param {Core.data.Store} source This Store
     */

    /**
     * Fired before loading starts. Allows altering parameters and is cancelable
     * @event beforeLoad
     * @preventable
     * @param {Core.data.Store} source This Store
     * @param {Object} params An object containing property/name pairs which are the parameters.
     * This may be mutated to affect the parameters used in the Ajax request.
     */

    /**
     * Fired before loading of remote child nodes of a tree node starts. Allows altering parameters and is cancelable
     * @event beforeLoadChildren
     * @preventable
     * @param {Core.data.Store} source This Store
     * @param {Object} params An object containing property/name pairs which are the parameters.
     * This may be mutated to affect the parameters used in the Ajax request.
     */

    /**
     * When the store {@link #property-isPaged is paged}, this is fired before loading a page and is cancelable
     * @event beforeLoadPage
     * @preventable
     * @param {Core.data.Store} source This Store
     * @param {Object} params An object containing property/name pairs which are the parameters.
     * This may be mutated to affect the parameters used in the Ajax request.
     */

    /**
     * Fired when loading is beginning. This is not cancelable. Parameters in the event may still be
     * mutated at this stage.
     * @event loadStart
     * @param {Core.data.Store} source This Store
     * @param {Object} params An object containing property/name pairs which are the parameters.
     * This may be mutated to affect the parameters used in the Ajax request.
     */

    /**
     * Fired when loading of remote child nodes into a tree node is beginning. This is not cancelable. Parameters in the event may still be
     * mutated at this stage.
     * @event loadChildrenStart
     * @param {Core.data.Store} source This Store
     * @param {Object} params An object containing property/name pairs which are the parameters.
     * This may be mutated to affect the parameters used in the Ajax request.
     */

    /**
     * Fired before any remote request is initiated.
     * @event beforeRequest
     * @param {Core.data.Store} source This Store
     * @param {Object} params An object containing property/name pairs which are the parameters.
     * @param {Object} body The body of the request to be posted to the server.
     * @param {String} action Action that is making the request, `'create'`, `'read'`, `'update'` or `'delete'`
     */

    /**
     * Fired after any remote request has finished whether successfully or unsuccessfully.
     * @event afterRequest
     * @param {Boolean} exception `true`. *Only present if the request triggered an exception.*
     * @param {String} action Action that has finished, `'create'`, `'read'`, `'update'` or `'delete'`
     * @param {String} exceptionType The type of failure, `'network'` or `'server'`. *Only present if the request triggered an exception.*
     * @param {Response} response The `Response` object
     * @param {Object} json The decoded response object if there was no `'network'` exception.
     */

    // endregion

    //region Config

    static get defaultConfig() {
        return {
            /**
             * An object containing the HTTP headers to add to each server request issued by this Store.
             * @config {Object}
             * @default
             */
            headers : null,

            /**
             * An object containing the Fetch options to pass to each server request issued by this Store. Use this to control if credentials are sent
             * and other options, read more at [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).
             * @config {Object}
             * @default
             */
            fetchOptions : null,

            /**
             * Specify `true` to send payloads as form data, `false` to send as regular JSON.
             * @config {Boolean}
             * @default
             */
            sendAsFormData : false,

            /**
             * Specify `true` to send all model fields when committing modified records (as opposed to just the modified fields)
             * @config {Boolean}
             * @default
             */
            writeAllFields : null,

            /**
             * The name of the HTTP parameter passed to this Store's {@link #config-readUrl} to indicate the node `id` to
             * load when loading child nodes on demand if the node being expanded was created with data containing `children: true`.
             * @config {String}
             * @default
             */
            parentIdParamName : 'id',

            /**
             * The property name in JSON responses from the server that contains the data for the records
             * ```
             * {
             *   "success" : true,
             *   // The property name used here should match that of 'reponseDataProperty'
             *   "data" : [
             *     ...
             *   ]
             * }
             * ```
             * @config {String}
             * @default
             */
            responseDataProperty : 'data',

            /**
             * The property name in JSON responses from the server that contains the dataset total size
             * **when this store {@link #property-isPaged is paged}**
             * ```
             * {
             *   "success" : true,
             *   // The property name used here should match that of 'reponseDataProperty'
             *   "data" : [
             *     ...
             *   ],
             *   // The property name used here should match that of 'responseTotalProperty'
             *   "total" : 65535
             * }
             * ```
             * @config {String}
             * @default
             */
            responseTotalProperty : 'total',

            /**
             * The name of the HTTP parameter to use to pass any encoded filters when loading data from the server and a filtered response is required.
             *
             * **Note:** When this is set, filters must be defined using a field name, an operator and a value
             * to compare, **not** a comparison function.
             * @config {String}
             */
            filterParamName : null,

            /**
             * The name of the HTTP parameter to use to pass any encoded sorters when loading data from the server and a sorted response is required.
             *
             * **Note:** When this is set, sorters must be defined using a field name and an ascending flag,
             * **not** a sort function.
             * @config {String}
             */
            sortParamName : null,

            /**
             * The name of the HTTP parameter to use when requesting pages of data using the **one based** page number required.
             * @config {String}
             */
            pageParamName : null,

            /**
             * The name of the HTTP parameter to use when requesting pages of data using the **zero based** index of the required page's starting record.
             * @config {String}
             */
            pageStartParamName : null,

            /**
             * The name of the HTTP parameter to use when requesting pages of data using the **zero based** index of the required page's starting record.
             * @config {String}
             * @default
             */
            pageSizeParamName : 'pageSize',

            /**
             * When paging of data is requested by setting _either_ the {@link #config-pageParamName} _or_ the {@link #config-pageStartParamName},
             * this is the value to send in the {@link #config-pageSizeParamName}
             * @config {String}
             * @default
             */
            pageSize : 50,

            /**
             * Set to ´true´ to use restful {@link #config-httpMethods}
             * @config {String}
             * @default
             */
            useRestfulMethods : false,

            /**
             * The HTTP methods to use for CRUD requests when {@link #config-useRestfulMethods} is enabled.
             *
             * ```
             * new AjaxStore({
             *    useRestfulMethods : true,
             *    httpMethods : {
             *        create : 'POST',
             *        read : 'POST',
             *        update : 'PATCH',
             *        delete : 'DELETE'
             *    }
             * });
             *
             * ```
             * @config {Object}
             * @default
             */
            httpMethods : {
                create : 'POST',
                read   : 'GET',
                update : 'PUT',
                delete : 'DELETE'
            }
        };
    }

    /**
     * Url to post newly created records to.
     *
     * The response must be in the form:
     *
     *     {
     *         "success": true,
     *         "data": [{
     *             "id": 0, "name": "General Motors"
     *         }, {
     *             "id": 1, "name": "Apple"
     *         }]
     *     }
     *
     * Just the array of data may be returned, however that precludes the
     * orderly handling of errors encountered at the server.
     *
     * If the server encountered an error, the packet would look like this:
     *
     *     {
     *         "success": false,
     *         "message": "Some kind of database error"
     *     }
     *
     * And that packet would be available in the {@link #event-exception} handler
     * in the `response` property of the event.
     *
     * The `success` property may be ommitted, it defaults to `true`.
     *
     * @config {String} createUrl
     * @category CRUD
     */

    /**
     * Url to read data from.
     *
     * The response must be in the form:
     *
     *     {
     *         "success": true,
     *         "data": [{
     *             "id": 0, "name": "General Motors"
     *         }, {
     *             "id": 1, "name": "Apple"
     *         }]
     *     }
     *
     * If the store {@link #property-isPaged is paged}, the total dataset size must be returned
     * in the {@link #config-responseTotalProperty} property:
     *
     *     {
     *         "success": true,
     *         "data": [{
     *             "id": 0, "name": "General Motors"
     *         }, {
     *             "id": 1, "name": "Apple"
     *         }],
     *         "total": 65535
     *     }
     *
     * Just the array of data may be returned, however that precludes the
     * orderly handling of errors encountered at the server.
     *
     * If the server encountered an error, the packet would look like this:
     *
     *     {
     *         "success": false,
     *         "message": "Some kind of database error"
     *     }
     *
     * And that packet would be available in the {@link #event-exception} handler
     * in the `response` property of the event.
     *
     * The `success` property may be omitted, it defaults to `true`.
     *
     * @config {String} readUrl
     * @category CRUD
     */

    /**
     * Url to post record modifications to.
     *
     * The response must be in the form:
     *
     *     {
     *         "success": true,
     *         "data": [{
     *             "id": 0, "name": "General Motors"
     *         }, {
     *             "id": 1, "name": "Apple"
     *         }]
     *     }
     *
     * Just the array of data may be returned, however that precludes the
     * orderly handling of errors encountered at the server.
     *
     * If the server encountered an error, the packet would look like this:
     *
     *     {
     *         "success": false,
     *         "message": "Some kind of database error"
     *     }
     *
     * And that packet would be available in the {@link #event-exception} handler
     * in the `response` property of the event.
     *
     * The `success` property may be ommitted, it defaults to `true`.
     *
     * @config {String} updateUrl
     * @category CRUD
     */

    /**
     * Url for destroying records.
     *
     * The response must be in the form:
     *
     *     {
     *         "success": true
     *     }
     *
     * If the server encountered an error, the packet would look like this:
     *
     *     {
     *         "success": false,
     *         "message": "Some kind of database error"
     *     }
     *
     * And that packet would be available in the {@link #event-exception} handler
     * in the `response` property of the event.
     *
     * The `success` property may be ommitted, it defaults to `true`.
     *
     * @config {String} deleteUrl
     * @category CRUD
     */

    /**
     * True to initiate a load when the store is instantiated
     * @config {Boolean} autoLoad
     * @category Common
     */

    //endregion

    afterConstruct(config) {
        super.afterConstruct(config);

        if (this.autoLoad) {
            this.load().catch(() => {});
        }
    }

    /**
     * Returns true if the Store is currently loading
     * @property {Boolean}
     * @readonly
     * @category CRUD
     */
    get isLoading() {
        return this._isLoading;
    }

    /**
     * Returns true if the Store is currently committing
     * @property {Boolean}
     * @readonly
     * @category CRUD
     */
    get isCommitting() {
        return Boolean(this.commitPromise);
    }

    set pageParamName(pageParamName) {
        if (this.tree) {
            throw new Error('Paging cannot be supported for tree stores');
        }
        if (this.pageStartParamName) {
            throw new Error('Configs pageStartParamName and pageParamName are mutually exclusive');
        }
        this._pageParamName = pageParamName;
    }

    get pageParamName() {
        return this._pageParamName;
    }

    set pageStartParamName(pageStartParamName) {
        if (this.tree) {
            throw new Error('Paging cannot be supported for tree stores');
        }
        if (this.pageParamName) {
            throw new Error('Configs pageParamName and pageStartParamName are mutually exclusive');
        }
        this._pageStartParamName = pageStartParamName;
    }

    get pageStartParamName() {
        return this._pageStartParamName;
    }

    /**
     * Yields true if this Store is loaded page by page. This yields `true` if either of the {@link #config-pageParamName}
     * of {@link #config-pageStartParamName} configs are set.
     * @property {Boolean}
     * @readonly
     */
    get isPaged() {
        return this.pageParamName || this.pageStartParamName;
    }

    /**
     * Yields the complete dataset size. If the store is {@link #property-isPaged is paged} this is the value
     * returned in the last loaded data block in the {@link #config-responseTotalProperty} property. Otherwise it is
     * the number of records in the store's underlying storage collection.
     * @property {Number}
     * @readonly
     */
    get allCount() {
        return ('remoteTotal' in this) ? this.remoteTotal : super.allCount;
    }

    /**
     * **If the store {@link #property-isPaged is paged}**, yields the highest page number in the dataset as calculated from the {@link #config-responseTotalProperty}
     * returned in the last page data block loaded.
     * @property {Number}
     * @readonly
     */
    get lastPage() {
        if (this.isPaged) {
            return Math.floor((this.allCount + this.pageSize - 1) / this.pageSize);
        }
    }

    buildQueryString(...paramObjects) {
        const queryString = Object.entries(Object.assign({}, ...paramObjects)).reduce(processParamEntry, []).join('&');

        return queryString ? '?' + queryString : '';
    }

    performSort(silent) {
        const me = this;

        if (me.sortParamName) {
            const
                { groupRecords } = me,
                // Current collapsed state for groups
                collapsed = {};

            // Temporarily remove group headers, will be re-added after sort
            if (me.isGrouped && groupRecords && groupRecords.length) {
                groupRecords.forEach(r => {
                    if (r.meta.collapsed) {
                        me.includeGroupRecords(r);
                        collapsed[r.id] = true;
                    }
                });
            }
            // TODO: Should we cache lastParams from the load call and use them here?
            return me.internalLoad({}, '', event => {
                me.data = event.data;
                me.afterPerformSort(silent, collapsed);
            });
        }
        else {
            super.performSort(silent);
        }
    }

    performFilter(silent) {
        const me = this;

        // For remote filtering, the dataset cannot be preserved. The size may be completely different.
        // This is a reload operation.
        if (me.filterParamName) {
            const
                oldCount = me.count,
                { filters } = me;

            // load should default to page 1
            me.currentPage = 1;

            // TODO: Should we cache lastParams from the load call and use them here?
            return me.internalLoad({}, '', event => {
                me.data = event.data;
                me.afterPerformFilter(silent ? null : {
                    action  : 'filter',
                    filters,
                    oldCount,
                    records : me.storage.values
                });
            });
        }
        else {
            super.performFilter();
        }
    }

    /**
     * A provided function which creates an array of values for the {#config-filterParamName} to pass
     * any filters to the server upon load.
     *
     * By default, this creates a JSON string containing the following properties:
     *
     * ```javascript
     *    [{
     *        field         : <theFieldName>
     *        operator      : May be: `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`, `'startsWith'`, `'endsWith'`
     *        value         : The value to compare
     *        caseSensitive : true for case sensitive comparisons
     *    }]
     * ```
     * @param {Core.util.CollectionFilter[]} filters The filters to encode.
     */
    encodeFilterParams(filters) {
        const result = [];

        for (const { property, operator, value, caseSensitive } of filters) {
            result.push({
                field : property,
                operator,
                value,
                caseSensitive
            });
        }
        return  JSON.stringify(result);
    }

    /**
     * A provided function which creates an array of values for the {#config-sortParamName} to pass
     * any sorters to the server upon load.
     *
     * By default, this creates a JSON string containing the following properties:
     *
     * ```javascript
     *    [{
     *        field     : <theFieldName>
     *        ascending : true/false
     *    }]
     * ```
     *
     * @param {Object[]} sorters The sorters to encode.
     */
    encodeSorterParams(sorters) {
        return JSON.stringify(sorters.map(sorter => sorter));
    }

    internalLoad(params, eventName, successFn) {
        const
            me        = this,
            allParams = Object.assign({}, me.params, params),
            event     = { action : 'read' + eventName, params : allParams },
            result    = me.readUrl ? new Promise((resolve, reject) => {
                if (me.trigger('beforeLoad' + eventName, event) === false) {
                      return reject(false); // eslint-disable-line
                }

                me._isLoading = true;

                // This may look redundant, but it allows for two levels of event listening.
                // Granular, where the observer observes only the events of interest, and
                // catch-all, where the observer is interested in all requests.
                me.trigger(`load${eventName}Start`, event);
                me.trigger('beforeRequest', event);

                // Add filter information to the request parameters
                if (me.filterParamName && me.isFiltered) {
                    allParams[me.filterParamName] = me.encodeFilterParams(me.filters.values);
                }

                // Add sorter information to the request parameters.
                // isSorted includes grouping in its evaluation.
                if (me.sortParamName && me.isSorted) {
                    allParams[me.sortParamName] = me.encodeSorterParams(me.groupers ? me.groupers.concat(me.sorters) : me.sorters);
                }

                // Ensure our next page is passed to the server in the params if not already set.
                // Ensure our page size is always passed.
                if (me.isPaged) {
                    if (!(allParams[me.pageParamName] || allParams[me.pageStartParamName])) {
                        const page = Math.min(me.currentPage || 1, me.allCount ? me.lastPage : Infinity);

                        if (me.pageParamName) {
                            allParams[me.pageParamName] = page;
                        }
                        else {
                            allParams[me.pageStartParamName] = (page - 1) * me.pageSize;
                        }
                    }
                    allParams[me.pageSizeParamName] = me.pageSize;
                }

                const options = { headers : me.headers, parseJson : true };

                if (me.useRestfulMethods) {
                    options.method = me.httpMethods.read;
                }

                AjaxHelper.get(me.readUrl + me.buildQueryString(allParams), Object.assign(options, me.fetchOptions))
                    .then(response => {
                        const
                            data    = response.parsedJson,
                            isArray = Array.isArray(data),
                            success = isArray || (data && (data.success !== false));

                        me._isLoading  = false;
                        event.response = response;
                        event.json     = data;

                        if (success) {
                            if (me.responseTotalProperty in data) {
                                me.remoteTotal = parseInt(data[me.responseTotalProperty], 10);
                            }

                            // If we are issuing paged requests, work out what page we are on based
                            // on the requested page and the size of the dataset declared.
                            if (me.isPaged) {
                                if (me.remoteTotal >= 0) {
                                    const requestedPage = me.pageParamName ? allParams[me.pageParamName] : allParams[me.pageStartParamName] / me.pageSize + 1;

                                    me.currentPage = Math.min(requestedPage, me.lastPage);
                                }
                                else {
                                    throw new Error('A paged store must receive its responseTotalProperty in each data packet');
                                }
                            }
                            event.data = isArray ? data : data[me.responseDataProperty];
                            successFn(event);
                            me.trigger('load' + eventName, event);
                            resolve(event);
                        }
                        else {
                            event.exception     = true;

                            event.exceptionType = 'server';
                            me.trigger('exception', event);
                            reject(event);
                        }

                        // finally
                        me.trigger('afterRequest', event);
                    }).catch(responseOrError => {
                        me._isLoading = false;

                        event.exception = true;

                        if (responseOrError instanceof Response) {
                            event.exceptionType = responseOrError.ok ? 'server' : 'network';
                            event.response = responseOrError;
                            event.error = responseOrError.error;
                        }
                        else {
                            event.exceptionType = 'server';
                            event.error = responseOrError;
                        }

                        me.trigger('exception', event);
                        reject(event);

                        // finally
                        me.trigger('afterRequest', event);
                    });
            }) : null;

        return result;
    }

    /**
     * Load data from the {@link #config-readUrl}.
     * @param {Object} params A hash of parameters to append to querystring (will also append Store#params)
     * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
     * vetoed by a {@link #event-beforeLoad} handler, or if an {@link #event-exception} is detected.
     * The resolved function is passed the event object passed to any event handlers.
     * The rejected function is passed the {@link #event-exception} event if an exception occurred,
     * or `false` if the load was vetoed by a {@link #event-beforeLoad} handler.
     * @fires beforeLoad
     * @fires loadStart
     * @fires beforeRequest
     * @fires load
     * @fires exception
     * @fires afterRequest
     * @category CRUD
     * @async
     * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.
     */
    load(params) {
        const me = this;

        if (me.isPaged) {
            return me.loadPage((me.currentPage || 0) + 1, params);
        }
        else {
            return me.internalLoad(params, '', (event) => {
                // The set Data setter will trigger the refresh event with { action: 'dataset' }
                me.data = event.data;
            });
        }
    }

    /**
     * Loads children into specified parent record. Parent records id is sent as a param (param name configured with
     * {@link #config-parentIdParamName}.
     * @param {Core.data.Model} parentRecord Parent record
     * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
     * vetoed by a {@link #event-beforeLoadChildren} handler, or if an {@link #event-exception} is detected.
     * The resolved function is passed the event object passed to any event handlers.
     * The rejected function is passed the {@link #event-exception} event if an exception occurred,
     * or `false` if the load was vetoed by a {@link #event-beforeLoadChildren} handler.
     * @fires beforeLoadChildren
     * @fires loadChildrenStart
     * @fires beforeRequest
     * @fires loadChildren
     * @fires exception
     * @fires afterRequest
     * @category CRUD
     * @async
     * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.
     */
    async loadChildren(parentRecord) {
        const me = this;

        return me.internalLoad({ [me.parentIdParamName] : parentRecord.id }, 'Children', (event) => {
            event.parentRecord = parentRecord;
            // Append received children
            parentRecord.data[parentRecord.constructor.childrenField] = event.data;
            parentRecord.processChildren(parentRecord.stores);
        });
    }

    /**
     * Loads a page of data from the {@link #config-readUrl}.
     * @param {Number} page The *one based* page number to load.
     * @param {Object} params A hash of parameters to append to querystring (will also append Store#params)
     * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
     * vetoed by a {@link #event-beforeLoadPage} handler, or if an {@link #event-exception} is detected.
     * The resolved function is passed the event object passed to any event handlers.
     * The rejected function is passed the {@link #event-exception} event if an exception occurred,
     * or `false` if the load was vetoed by a {@link #event-beforeLoadPage} handler.
     * @fires beforeLoadPage
     * @fires loadPageStart
     * @fires beforeRequest
     * @fires loadPage
     * @fires exception
     * @fires afterRequest
     * @category CRUD
     * @async
     * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.
     */
    async loadPage(page, params) {
        if (this.allCount) {
            page = Math.min(page, this.lastPage);
        }
        const
            me        = this,
            pageParam = me.pageParamName ? {
                [me.pageParamName] : page
            } : {
                [me.pageStartParamName] : (page - 1) * me.pageSize
            };

        pageParam[me.pageSizeParamName] = me.pageSize;
        return me.internalLoad(Object.assign(pageParam, params), 'Page', (event) => {
            // We go directly to loadPage because paging a tree store is unsupportable.
            // loadPage will trigger the refresh event with { action: 'pageLoad' }
            me.loadData(event.data, 'pageLoad');
        });
    }

    /**
     * If this store {@link #property-isPaged is paged}, and is not already at the {@link #property-lastPage}
     * then this will load the next page of data.
     * @fires beforeLoadPage
     * @fires loadPageStart
     * @fires beforeRequest
     * @fires loadPage
     * @fires exception
     * @fires afterRequest
     * @category CRUD
     * @async
     * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.
     */
    async nextPage(params) {
        return this.isPaged && this.currentPage !== this.lastPage ? this.loadPage(this.currentPage + 1, params) : immediatePromise$2;
    }

    /**
     * If this store {@link #property-isPaged is paged}, and is not already at the first page
     * then this will load the previous page of data.
     * @fires beforeLoadPage
     * @fires loadPageStart
     * @fires beforeRequest
     * @fires loadPage
     * @fires exception
     * @fires afterRequest
     * @category CRUD
     * @async
     * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.
     */
    async previousPage(params) {
        return this.isPaged && this.currentPage !== 1 ? this.loadPage(this.currentPage - 1, params) : immediatePromise$2;
    }

    /**
     * Commits all changes (added, modified and removed) using corresponding urls ({@link #config-createUrl},
     * {@link #config-updateUrl} and {@link #config-deleteUrl})
     * @fires beforeCommit
     * @returns {Promise} A Promise which is resolved only if all pending changes (Create, Update and Delete) successfully resolve.
     * Both the resolve and reject functions are passed a `commitState` object which is stored the {@link #event-afterRequest}
     * event for each request. Each event contains the `exception`, `request` and `response` properties eg:
     *
     *     {
     *          success: true,                  // If *all* commits succeeded
     *          changes: {
     *              added: [records...],
     *              modified: [records...],
     *              removed: [records...],
     *          },
     *          added: {
     *              source: theStore,
     *              exception: true,            // Only if the add request triggered an exception
     *              exceptionType: 'server'/'network', // Only if the add request triggered an exception
     *              response: Response,
     *              json: parsedResponseObject
     *          },
     *          modified: {},                   // Same format as added
     *          removed: {}                     // Same format as added
     *     }
     *
     * If there were no pending changes, the resolve and reject functions are passed no parameters.
     *
     * Returns `false` if a commit operation is already in progress.
     * The resolved function is passed the event object passed to any event handlers.
     * The rejected function is passed the {@link #event-exception} event if an exception occurred,
     * @category CRUD
     * @async
     * @returns {Promise} A promise which is resolved when all the Ajax requests complete and have been processed.
     */
    commit() {
        const me          = this,
            changes     = me.changes,
            allPromises = [];

        // not allowing additional commits while in progress
        // TODO: should queue
        if (me.commitPromise) return false;

        // No outstanding changes, return a Promise that resolves immediately.
        if (!changes) {
            return immediatePromise$2;
        }

        // Flag all affected records as being committed
        [...changes.added, ...changes.modified, ...changes.removed].forEach(record => record.meta.committing = true);

        // TODO: do we need a general way of disabling plugins?
        if (!me.disabled && me.trigger('beforeCommit', { changes }) !== false) {
            let commitState = {
                    action    : 'commit',
                    exception : false,
                    changes
                },
                p           = me.commitRemoved(commitState);

            if (p) {
                allPromises.push(p);
            }
            p = me.commitAdded(commitState);
            if (p) {
                allPromises.push(p);
            }
            p = me.commitModified(commitState);
            if (p) {
                allPromises.push(p);
            }

            // If there were no urls configured, behave as a local store
            if (!allPromises.length) {
                me.modified.forEach(r => r.clearChanges(false));
                me.modified.clear();

                me.added.forEach(r => r.clearChanges(false));
                me.added.clear();

                me.removed.clear();
                me.trigger('commit', { changes });
                return immediatePromise$2;
            }

            // The Promises from the commit methods all resolve whether the request
            // succeeded or not. They each contribute their afterrequest event to the
            // commitState which can be used to detect overall success or failure
            // and granular inspection of which operations succeeded or failed.
            // If there's only one operation, wait for it.
            // If there's more than one operation, we have to wait for allPromises to resolve.
            p = allPromises.length === 1 ? allPromises[0] : Promise.all(allPromises);

            return me.commitPromise = new Promise((resolve, reject) => {
                p.then(() => {
                    me.commitPromise = null;
                    if (commitState.exception) {
                        me.trigger('exception', commitState);
                        reject(commitState);
                    }
                    else {
                        me.trigger('commit', { changes });
                        resolve(commitState);
                    }
                }).catch(() => {
                    me.commitPromise = null;
                    reject(commitState);
                });
            });
        }
    }

    // TODO: need a way to abort commits

    /**
     * Commits added records by posting to {@link #config-createUrl}.
     * Server should return a JSON object with a 'success' property indicating whether the operation was succesful.
     * @param {Object} commitState An object into which is added a `delete` property being the {@link #event-afterRequest} event.
     * @returns {Promise} If there are added records, a Promise which will be resolved whether the commit
     * succeeds or fails. The resulting event is placed into the `add` property of the passed `commitState`
     * parameter. If there are no added records, `null` is returned.
     * The resolved function is passed the event object passed to any event handlers.
     * @private
     * @fires beforeRequest
     * @fires commitAdded
     * @fires refresh
     * @fires exception
     * @fires afterRequest
     * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.
     * @async
     */
    commitAdded(commitState) {
        const me     = this,
            added  = me.added,
            event  = { action : 'create', params : me.params },
            result = added.count && me.createUrl ? new Promise((resolve) => {
                const toAdd = added.values.map(r => r.persistableData);
                commitState.create = event;

                let dataToSend = event.body = { data : toAdd };

                me.trigger('beforeRequest', event);

                if (me.sendAsFormData) {
                    const formData = new FormData();

                    formData.append('data', JSON.stringify(toAdd));
                    dataToSend = formData;
                }

                const options = { headers : me.headers, parseJson : true };

                if (me.useRestfulMethods) {
                    options.method = me.httpMethods.create;
                }

                AjaxHelper.post(me.createUrl + me.buildQueryString(me.params), dataToSend, Object.assign(options, me.fetchOptions)).then(response => {
                    const
                        data    = response.parsedJson,
                        isArray = Array.isArray(data),
                        success = isArray || (data && (data.success !== false));

                    event.json     = data;
                    event.response = response;

                    if (success) {
                        // Copy updated fields and updated ID back into records.
                        // This also calls clearChanges on each record.
                        me.processReturnedData(added.values, isArray ? data : data[me.responseDataProperty]);

                        // Clear down added records cache
                        added.clear();

                        me.trigger('commitAdded');

                        // We must signal a full refresh because any number of records could have recieved any number of field updates
                        // back from the server, so a refresh is more efficient than picking through the received updates.
                        me.trigger('refresh', event);

                        resolve(commitState);
                    }
                    else {
                        // Clear committing flag
                        added.forEach(r => r.meta.committing = false);

                        commitState.exception = event.exception = true;

                        commitState.exceptionType = event.exceptionType = 'server';

                        me.trigger('exception', event);
                        resolve(commitState);
                    }

                    // finally
                    me.trigger('afterRequest', event);
                }).catch(responseOrError => {
                    // Clear committing flag
                    added.forEach(r => r.meta.committing = false);

                    commitState.exception = event.exception = true;

                    if (responseOrError instanceof Response) {
                        event.exceptionType = responseOrError.ok ? 'server' : 'network';
                        event.response = responseOrError;
                        event.error = responseOrError.error;
                    }
                    else {
                        event.exceptionType = 'server';
                        event.error = responseOrError;
                    }

                    me.trigger('exception', event);
                    resolve(commitState);

                    // finally
                    me.trigger('afterRequest', event);
                });
            }) : null;

        return result;
    }

    /**
     * Commits modified records by posting to {@link #config-updateUrl}.
     * Server should return a JSON object with a 'success' property indicating whether the operation was succesful.
     * @param {Object} commitState An object into which is added a `delete` property being the {@link #event-afterRequest} event.
     * @returns {Promise} If there are added records, a Promise which will be resolved whether the commit
     * succeeds or fails. The resulting event is placed into the `update` property of the passed `commitState`
     * parameter. If there are no added records, `null` is returned.
     * The resolved function is passed the event object passed to any event handlers.
     * @private
     * @fires beforeRequest
     * @fires commitModified
     * @fires refresh
     * @fires exception
     * @fires afterRequest
     * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.
     * @async
     */
    commitModified(commitState) {
        const
            me       = this,
            modified = me.modified,
            event    = { action : 'update', params : me.params },
            result   = modified.count && me.updateUrl ? new Promise((resolve) => {
                // Use the record's modificationData, not modifications.
                // modifications returns a map using *field names*
                // The server will expect a map using the original dataSource properties.
                const modifications = modified.map(r => me.writeAllFields ? r.persistableData : r.modificationData);
                commitState.update  = event;

                let dataToSend = event.body = { data : modifications };

                me.trigger('beforeRequest', event);

                if (me.sendAsFormData) {
                    const formData = new FormData();

                    formData.append('data', JSON.stringify(modifications));
                    dataToSend = formData;
                }

                const options = { headers : me.headers, parseJson : true };

                if (me.useRestfulMethods) {
                    options.method = me.httpMethods.update;
                }

                AjaxHelper.post(
                    me.updateUrl + me.buildQueryString(me.params),
                    dataToSend,
                    Object.assign(options, me.fetchOptions)
                ).then(response => {
                    const
                        data    = response.parsedJson,
                        isArray = Array.isArray(data),
                        success = isArray || (data && (data.success !== false));

                    event.json = data;
                    event.response = response;

                    if (success) {
                        // Copy updated fields and updated ID back into records.
                        // This also calls clearChanges on each record.
                        me.processReturnedData(me.modified.values, isArray ? data : data[me.responseDataProperty], true);

                        // Clear down modified records cache
                        modified.clear();

                        me.trigger('commitModified');

                        // We must signal a full refresh because any number of records could have recieved any number of field updates
                        // back from the server, so a refresh is more efficient than picking through the received updates.
                        me.trigger('refresh', event);

                        resolve(commitState);
                    }
                    else {
                        // Clear committing flag
                        modified.forEach(r => r.meta.committing = false);

                        commitState.exception = event.exception = true;
                        event.exceptionType = 'server';
                        me.trigger('exception', event);
                        resolve(commitState);
                    }

                    // finally
                    me.trigger('afterRequest', event);
                }).catch(responseOrError => {
                    // Clear committing flag
                    modified.forEach(r => r.meta.committing = false);

                    commitState.exception = event.exception = true;

                    if (responseOrError instanceof Response) {
                        event.exceptionType = responseOrError.ok ? 'server' : 'network';
                        event.response = responseOrError;
                        event.error = responseOrError.error;
                    }
                    else {
                        event.exceptionType = 'server';
                        event.error = responseOrError;
                    }

                    me.trigger('exception', event);
                    resolve(commitState);

                    // finally
                    me.trigger('afterRequest', event);
                });
            }) : null;

        return result;
    }

    processReturnedData(localRecords, returnedData, isUpdating = false) {
        const me = this,
            Model = me.modelClass,
            idDataSource = Model.fieldMap.id.dataSource;

        returnedData.forEach((recData, i) => {
            const record = localRecords[i];

            // Must clear changed state before syncId goes through store.onModelChange
            record.clearChanges(false);

            // Using syncId to update record's id with no flagging the property as modified.
            record.syncId(recData[idDataSource]);

            // When updating, only want to apply the actual changes and not reapply defaults. When adding, also
            // apply the defaults
            Object.assign(localRecords[i].data, Model.processData(recData, isUpdating));
        });
    }

    /**
     * Commits removed records by posting to {@link #config-deleteUrl}.
     * Server should return a JSON object with a 'success' property indicating whether the operation was succesful.
     * @param {Object} commitState An object into which is added a `delete` property being the {@link #event-afterRequest} event.
     * @returns {Promise} If there are added records, a Promise which will be resolved whether the commit
     * succeeds or fails. The resulting event is placed into the `delete` property of the passed `commitState`
     * parameter. If there are no added records, `null` is returned.
     * The resolved function is passed the event object passed to any event handlers.
     * @private
     * @fires beforerequest
     * @fires commitremoved
     * @fires refresh
     * @fires exception
     * @fires afterrequest
     * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.
     * @async
     */
    commitRemoved(commitState) {
        const me      = this,
            removed = me.removed,
            event   = { action : 'delete', params : me.params },
            result  = removed.count && me.deleteUrl ? new Promise((resolve) => {
                commitState.delete = event;

                let dataToSend = event.body = { ids : removed.map(r => r.id) };

                me.trigger('beforeRequest', event);

                if (me.sendAsFormData) {
                    const formData = new FormData();

                    formData.append('id', JSON.stringify(dataToSend.ids));
                    dataToSend = formData;
                }

                const options = { headers : me.headers, parseJson : true };

                if (me.useRestfulMethods) {
                    options.method = me.httpMethods.delete;
                }

                AjaxHelper.post(
                    me.deleteUrl + me.buildQueryString(me.params),
                    dataToSend,
                    Object.assign(options, me.fetchOptions)
                ).then(response => {
                    const
                        data    = response.parsedJson,
                        isArray = Array.isArray(data),
                        success = isArray || (data && (data.success !== false));

                    event.json = data;
                    event.response = response;

                    if (success) {
                        removed.forEach(record => record.meta.committing = false); // In case used by other store etc.
                        removed.clear();

                        me.trigger('commitRemoved');
                        me.trigger('refresh', event);

                        resolve(commitState);
                    }
                    else {
                        // Clear committing flag
                        removed.forEach(r => r.meta.committing = false);

                        commitState.exception = event.exception = true;

                        event.exceptionType = 'server';
                        me.trigger('exception', event);
                        resolve(commitState);
                    }

                    // finally
                    me.trigger('afterRequest', event);
                }).catch(responseOrError => {
                    // Clear committing flag
                    removed.forEach(r => r.meta.committing = false);

                    commitState.exception = event.exception = true;

                    if (responseOrError instanceof Response) {
                        event.exceptionType = responseOrError.ok ? 'server' : 'network';
                        event.response = responseOrError;
                        event.error = responseOrError.error;
                    }
                    else {
                        event.exceptionType = 'server';
                        event.error = responseOrError;
                    }

                    me.trigger('exception', event);
                    resolve(commitState);

                    // finally
                    me.trigger('afterRequest', event);
                });
            }) : null;

        return result;
    }
}
AjaxStore._$name = 'AjaxStore';

//TODO: label should be own element

/**
 * @module Core/widget/TextField
 */

/**
 * Textfield widget. Wraps native &lt;input type="text"&gt;
 *
 * This field can be used as an {@link Grid.column.Column#config-editor editor} for the {@link Grid.column.Column Column}.
 * It is used as the default editor for the {@link Grid.column.Column Column}, {@link Grid.column.TemplateColumn TemplateColumn},
 * {@link Grid.column.TreeColumn TreeColumn}, and for other columns if another editor is not specified explicitly,
 * or disabled by setting `false` value.
 *
 * @extends Core/widget/Field
 *
 * @example
 * let textField = new TextField({
 *   placeholder: 'Enter some text'
 * });
 *
 * @classType textfield
 * @externalexample widget/TextField.js
 */
class TextField extends Field {

    static get defaultConfig() {
        return {
            /**
             * The tab index of the input field
             * @config {Number} tabIndex
             */

            /**
             * The min number of characters for the input field
             * @config {Number} minLength
             */

            /**
             * The max number of characters for the input field
             * @config {Number} maxLength
             */

            attributes : [
                'placeholder',
                'autoComplete',
                'minLength',
                'maxLength',
                'tabIndex'
            ],

            localizableProperties : ['label', 'title', 'placeholder']
        };
    }

    static get $name() {
        return 'TextField';
    }

    inputTemplate() {
        const
            me = this,
            style = 'inputWidth' in me ? `style="width:${DomHelper.setLength(me.inputWidth)}"` : '';

        return TemplateHelper.tpl`<input type="${me.inputType || 'text'}"
            reference="input"
            class="${me.inputCls || ''}"
            name="${me.name || me.id}"
            id="${me.id + '_input'}"
            ${style}
            ${me.attributeString}/>`;
    }

    set value(value) {
        super.value = (this.$name === 'TextField' && value == null) ? '' : value;
    }

    get value() {
        return super.value;
    }

    set placeholder(value) {
        this._placeholder = value;
        if (this.input) {
            this.input.placeholder = value;
        }
    }

    get placeholder() {
        return this._placeholder;
    }
}

TextField._$name = 'TextField'; BryntumWidgetAdapterRegister.register('textfield', TextField);
BryntumWidgetAdapterRegister.register('text', TextField);

/**
 * @module Core/widget/PickerField
 */

/**
 * Base class used for {@link Core.widget.Combo Combo}, {@link Core.widget.DateField DateField}, and {@link Core.widget.TimeField TimeField}.
 * Displays a picker ({@link Core.widget.List List}, {@link Core.widget.DatePicker DatePicker}) anchored to the field.
 * Not intended to be used directly.
 *
 * This field's subclasses can be used as editors for the {@link Grid.column.Column Column}.
 *
 * When focused by means of *touch* tapping on the trigger element (eg, the down arrow on a Combo)
 * on a tablet, the keyboard will not be shown by default to allow for interaction with the dropdown.
 *
 * A second tap on the input area will then show the keyboard is required.
 *
 * @extends Core/widget/TextField
 * @abstract
 */
class PickerField extends TextField {
    //region Config
    static get $name() {
        return 'PickerField';
    }

    static get defaultConfig() {
        return {

            /**
             * User can edit text in text field (otherwise only pick from attached picker)
             * @config {Boolean}
             * @default
             */
            editable : true,

            /**
             * The name of the element property to which the picker should size and align itself.
             * @config {String}
             * @default element
             */
            pickerAlignElement : 'inputWrap',

            // Does not get set, but prevents PickerFields inheriting value:'' from Field.
            value : null,

            triggers : {
                expand : {
                    cls : 'bars'
                }
            },

            /**
             * By default PickerFiled's picker is transient, and will {@link #function-hidePicker} when the user clicks or
             * taps outside or when focus moves outside picker.
             *
             * Configure as `false` to make picker non-transient.
             * @config {Boolean}
             * @default
             */
            autoClose : true,

            /**
             * Configure as `true` to have the picker expand upon focus enter.
             * @config {Boolean}
             */
            autoExpand : null,

            /**
             * A config object which is merged into the generated picker configuration to allow specific use cases
             * to override behaviour. For example:
             *
             *     picker: {
             *         align: {
             *             anchor: true
             *         }
             *     }
             *
             * @config {Object}
             * @default
             */
            picker : null,

            inputType : 'text',

            // We need to realign the picker if we resize (eg a multiSelect Combo's ChipView wrapping)
            monitorResize : true
        };
    }

    //endregion

    //region Init & destroy

    doDestroy() {
        // Remove touch keyboard showing listener if we added it
        this.globalTapListener && this.globalTapListener();

        // Destroys the picker
        this.picker = null;

        super.doDestroy();
    }

    finalizeInit() {
        super.finalizeInit();

        const
            me          = this,
            element     = me.element;

        if (me.editable === false) {
            element.classList.add('b-not-editable');
            EventHelper.on({
                element : me.input,
                click   : 'onTriggerClick',
                thisObj : me
            });
        }
        else {
            // In case the field was temporarily set to readOnly="true" to prevent
            // the intrusive keyboard (This happens when tapping the trigger
            // and when focused by the container in response to a touch tap),
            // allow a subsequent touch tap to show the keyboard.
            me.globalTapListener = GlobalEvents.on({
                globaltap : 'showKeyboard',
                thisObj   : me
            });
        }
    }

    //endregion

    //region Picker

    get picker() {
        let { _picker } = this;

        // Lazily convert picker config into a picker widget. This field may never be used.
        if (!(_picker instanceof Widget)) {
            this.picker = _picker = this.createPicker(_picker || {});
        }
        return _picker;
    }

    set picker(picker) {
        const { _picker } = this;

        if (_picker && _picker.destroy) {
            _picker.hide();
            _picker.destroy();
        }
        this._picker = picker;
    }

    createPicker() {
        throw new Error('createPicker must be implemented in PickerField subclass implementations');
    }

    //endregion

    //region Events

    /**
     * Check if field value is valid
     * @internal
     */
    onEditComplete() {
        super.onEditComplete();
        this.autoClosePicker();
    }

    onElementResize(resizedElement) {
        const me = this;

        // If the field changes size while the picker is visible, the picker
        // must be kept in alignment. For example a multiSelect: true
        // ComboBox with a wrapped ChipView.
        if (me.pickerVisible) {
            // Push realignment out to the next AF, because this picker itself may move in
            // response to the element resize, and the picker must realign *after* that happens.
            // For example a multiSelect: true ComboBox with a wrapped ChipView inside
            // a Popup that is aligned *above* an element. When the ChipView gains or
            // loses height, the Popup must realign first, and then the List must align to the
            // new position of the ComboBox.
            me.picker.requestAnimationFrame(me.picker.realign, null, me.picker);
        }

        super.onElementResize(resizedElement);
    }

    /**
     * Allows using arrow keys to open/close list. Relays other keypresses to list if open.
     * @private
     */
    internalOnKeyPress(event) {
        const me = this;

        let callSuper = true;

        if (event.type === 'keydown' && !me.disabled) {
            if (me.pickerVisible) {
                const { picker } = me;

                if (event.key === 'Escape') {
                    event.stopImmediatePropagation();
                    me.hidePicker();

                    // EC has multiple effects. First stage is hide the picker.
                    // If we do this, then the superclass's ESC handling must
                    // not be called.
                    callSuper = false;
                }
                else if (picker.onInternalKeyDown) {
                    // if picker is visible, give it a shot at the event
                    picker.onInternalKeyDown(event);
                }
                else if (event.key === 'ArrowDown') {
                    if (picker.focusable) {
                        picker.focus();
                    }
                }
            }
            else if (event.key === 'ArrowDown') {
                me.onTriggerClick(event);
            }
        }

        if (callSuper) {
            super.internalOnKeyPress(event);
        }
    }

    onFocusIn(e) {
        super.onFocusIn(e);
        if (this.autoExpand) {
            // IE triggers an input event on focus.
            // If expand is configured for focus, minChars should be zero.
            this.minChars = 0;
            this.onTriggerClick(e);
        }
    }

    onFocusOut(e) {
        this.autoClosePicker();
        super.onFocusOut(e);
    }

    /**
     * User clicked trigger icon, toggle list.
     * @private
     */
    onTriggerClick(event) {
        if (!this.disabled) {
            // Pass focus flag as true if invoked by a key event
            this.togglePicker('key' in event);
        }
    }

    /**
     * User clicked on an editable input field. If it's a touch event
     * ensure that the keyboard is shown.
     * @private
     */
    showKeyboard({ event }) {
        const input = this.input;

        if (DomHelper.isTouchEvent && document.activeElement === input && event.target === input) {
            GlobalEvents.suspendFocusEvents();
            input.blur();
            input.focus();
            GlobalEvents.resumeFocusEvents();
        }
    }

    //endregion

    //region Toggle picker

    /**
     * Toggle picker display
     */
    togglePicker(focusPicker) {
        if (this.pickerVisible) {
            this.hidePicker();
        }
        else {
            this.showPicker(focusPicker);
        }
    }

    /**
     * Show picker
     */
    showPicker(focusPicker) {
        const me = this,
            picker = me.picker;

        if (!me.pickerHideShowListenersAdded) {
            picker.on({
                show    : 'onPickerShow',
                hide    : 'onPickerHide',
                thisObj : me
            });
            me.pickerHideShowListenersAdded = true;
        }

        picker.autoClose = me.autoClose;
        picker.show();

        // Not been vetoed
        if (picker.isVisible) {
            if (focusPicker) {
                me.focusPicker();
            }
        }
    }

    onPickerShow() {
        const me = this;

        me.pickerVisible = true;
        me.element.classList.add('b-open');
        me.trigger('togglePicker', { show : true });
        me.pickerTapOutRemover = GlobalEvents.on({
            globaltap : 'onPickerTapOut',
            thisObj   : me
        });
        me.pickerKeyDownRemover = EventHelper.on({
            element : me.picker.element,
            keydown : 'onPickerKeyDown',
            thisObj : me
        });
    }

    onPickerHide() {
        const me = this;

        me.pickerVisible = false;
        me.element.classList.remove('b-open');
        me.trigger('togglePicker', { show : false });
        me.pickerTapOutRemover && me.pickerTapOutRemover();
        me.pickerKeyDownRemover && me.pickerKeyDownRemover();
    }

    onPickerTapOut({ event }) {
        if (!this.owns(event.target)) {
            this.autoClosePicker();
        }
    }

    onPickerKeyDown(event) {
        if (event.key === 'Tab') {
            const
                activeEl = document.activeElement,
                forwardedEvent = new KeyboardEvent('keydown', event);

            // Offer our own element a shot at the TAB event.
            // Some widgets or plugins may actively navigate.
            this.input.dispatchEvent(forwardedEvent);

            // Somebody might preventDefault on the synthesized event. We must honour that.
            // For example if we are the field for a cell Editor, and it started an edit on the adjacent cell.
            if (forwardedEvent.defaultPrevented) {
                event.preventDefault();
            }

            // No listener intervened, point the TAB event at the input,
            // and user agent default navigation will proceed.
            if (document.activeElement === activeEl) {
                this.input.focus();
            }
            // Some listener *did* navigate, prevent user agent default.
            else {
                event.preventDefault();
            }

            // If listeners have not destroyed us, close our picker.
            if (!this.isDestroyed) {
                this.hidePicker();
            }
        }
    }

    //endregion

    //region Visibility

    autoClosePicker() {
        if (this.autoClose) {
            this.hidePicker();
        }
    }

    /**
     * Hide picker
     */
    hidePicker() {
        if (this.pickerVisible) {
            this.picker.hide();
        }
    }

    focusPicker() {

    }

    focus() {
        const input = this.input;

        // If we are focusing an editable PickerField from a touch event, temporarily
        // set it to readOnly to prevent the showing of the intrusive keyboard.
        // It's more likely that a user on a touch device will interact with the picker
        // rather than the input field.
        // A second touch tap on an already focused input will show the keyboard;
        // see the showKeyboard method.
        if (DomHelper.isTouchEvent && this.editable) {
            input.readOnly = true;
            this.setTimeout(() => input.readOnly = false, 500);
        }
        super.focus();
    }

    //endregion

}
PickerField._$name = 'PickerField';

/**
 * @module Core/helper/util/Navigator
 */

/**
 * A helper class which allows keyboard navigation within the {@link #config-target} element.
 * @private
 */
class Navigator extends Events(Base) {
    static get defaultConfig() {
        return {
            /**
             * The owning Widget which is using this Navigator.
             * @config {Core.widget.Widget}
             */
            ownerCmp : null,

            /**
             * The encapsulating element in which navigation takes place.
             * @config {HTMLElement}
             */
            target : null,

            /**
             * The element which provides key events for navigation. Optional. Defaults to the {@link #config-target} element.
             * @config {HTMLElement}
             */
            keyEventTarget : null,

            /**
             * An optional key event processor which may preprocess the key event. Returning `null` prevents processing of the event.
             * @config {Function}
             */
            processEvent : null,

            /**
             * A query selector which identifies descendant elements within the {@link #config-target} which are navigable.
             * @config {String}
             */
            itemSelector : null,

            /**
             * A CSS class name to add to focused elements.
             * @config {String}
             * @default
             */
            focusCls : 'b-active',

            /**
             * An object containing key definitions keys by the key name eg:
             *
             * ```javascript
             *  keys : {
             *      "CTRL+SPACE" : 'onCtrlSpace',
             *      ENTER        : 'onEnterKey'
             *  }```
             *
             * The {@link #config-ownerCmp} is used as the `this` reference and to resolve string method names.
             *
             * Modified key names must be created prepending one or more `'CTRL+'`, `'SHIFT+'`, `'ALT+'`
             * in that order, for example `"CTRL+SHIFT+ENTER" : 'showMenu'`
             * @config {Object}
             * @default
             */
            keys : null,

            /**
             * Configure as `true` to also navigate when the `CTRL` modifier key is used along with
             * navigation keys.
             * @config {Boolean}
             * @default false
             */
            allowCtrlKey : null,

            /**
             * Configure as `true` to also navigate when the `SHIFT` modifier key is used along with
             * navigation keys.
             * @config {Boolean}
             * @default false
             */
            allowShiftKey : null,

            scrollDuration : 50,

            testConfig : {
                scrollDuration : 1
            }
        };
    }

    set itemSelector(itemSelector) {
        this._itemSelector = itemSelector;
    }

    get itemSelector() {
        // Defaults to the itemCls of the owning Component (Most likely a List which must have itemCls)
        return this._itemSelector || `.${this.ownerCmp.itemCls}`;
    }

    onKeyDown(keyEvent) {
        const
            me              = this,
            ownerCmp        = me.ownerCmp,
            activeItem      = me.activeItem,
            firstItem       = me.target.querySelector(me.itemSelector),
            // Not all key events have 'key'
            keyName         = (keyEvent.key || '').trim() || keyEvent.code,
            composedKeyName = `${keyEvent.ctrlKey ? 'CTRL+' : ''}${keyEvent.shiftKey ? 'SHIFT+' : ''}${keyEvent.altKey ? 'ALT+' : ''}${keyName}`;

        if (firstItem && me.target.offsetParent) {
            // Detect whether the navigable items flow inline or downwards.
            if (me.inlineFlow == null) {
                const
                    itemContainer     = firstItem.parentNode,
                    itemPositionStyle = DomHelper.getStyleValue(firstItem, 'position'),
                    itemDisplayStyle  = DomHelper.getStyleValue(firstItem, 'display'),
                    itemFloatStyle    = DomHelper.getStyleValue(firstItem, 'float');

                // This is how we know that RIGHT and LEFT arrow should be used for next and previous.
                // If inlineFlow is false, we use UP and DOWN. Consider tabs in a tab bar.
                me.inlineFlow = (
                    itemPositionStyle === 'absolute' ||
                    itemDisplayStyle === 'inline' || itemDisplayStyle === 'inline-block' ||
                    itemFloatStyle === 'left' || itemFloatStyle === 'right' ||
                    (DomHelper.getStyleValue(itemContainer, 'display') === 'flex' && DomHelper.getStyleValue(itemContainer, 'flex-direction') === 'row')
                );

                if (me.inlineFlow) {
                    me.prevKey = 'ArrowLeft';
                    me.nextKey = 'ArrowRight';
                }
                else {
                    me.prevKey = 'ArrowUp';
                    me.nextKey = 'ArrowDown';
                }
            }

            // Feed the key event through our configured processor, process the event that returns if any.
            if (me.processEvent) {
                keyEvent = me.processEvent.call(ownerCmp, keyEvent);
                if (!keyEvent) {
                    return;
                }
            }

            if (activeItem) {
                switch (keyName) {
                    case me.prevKey:
                        if (me.disabled || keyEvent.ctrlKey && !me.allowCtrlKey) {
                            return;
                        }
                        if (keyEvent.shiftKey && !me.allowShiftKey) {
                            return;
                        }
                        keyEvent.preventDefault();
                        me.navigatePrevious(keyEvent);
                        break;
                    case me.nextKey:
                        if (me.disabled || keyEvent.ctrlKey && !me.allowCtrlKey) {
                            return;
                        }
                        if (keyEvent.shiftKey && !me.allowShiftKey) {
                            return;
                        }
                        keyEvent.preventDefault();
                        me.navigateNext(keyEvent);
                        break;
                    default:
                        let keyHandler = me.keys && me.keys[composedKeyName];

                        if (keyHandler && !me.disabled) {
                            me.callback(keyHandler, me.thisObj || ownerCmp, [keyEvent]);
                        }
                        // Note that even if this.disabled, the ownerCmp will expect
                        // to have its key down hander invoked.
                        else if (ownerCmp.onInternalKeyDown) {
                            ownerCmp.onInternalKeyDown(keyEvent);
                        }
                }
            }
            else {
                me.activeItem = me.previousActiveItem || me.getDefaultNavigationItem(keyEvent);
            }

            if (me.activeItem !== activeItem) {
                /**
                 * Fired when a user gesture causes the active item to change _or become `null`_.
                 * @event navigate
                 * @param {Event} event The browser event which instigated navigation. May be a click or key or focus move event.
                 * @param {HTMLElement} item The newly active item, or `null` if focus moved out.
                 */
                me.trigger('navigate', {
                    event : keyEvent,
                    item  : me.activeItem
                });
            }
        }
    }

    getDefaultNavigationItem(keyEvent) {
        const { target, itemSelector, prevKey,  nextKey } = this;

        // Navigating backwards from after the component, we default to last item
        if (target.compareDocumentPosition(keyEvent.target) & 4 && keyEvent.key === prevKey) {
            return target.querySelector(`${itemSelector}:last-of-type`);
        }
        // Navigating forwards from before the component we default to the first item
        if (target.compareDocumentPosition(keyEvent.target) & 2 && keyEvent.key === nextKey) {
            return target.querySelector(`${itemSelector}`);
        }
    }

    navigatePrevious(keyEvent) {
        const me = this,
            previous = me.previous;

        keyEvent.preventDefault();
        if (previous) {
            me.ownerCmp.scrollable.scrollIntoView(previous, { animate : me.scrollDuration }).then(() => {
                me.activeItem = previous;
                me.trigger('navigate', {
                    event : keyEvent,
                    item  : me.activeItem
                });
            });
        }
    }

    navigateNext(keyEvent) {
        const me = this,
            next = me.next;

        keyEvent.preventDefault();
        if (next) {
            me.ownerCmp.scrollable.scrollIntoView(next, { animate : me.scrollDuration }).then(() => {
                me.activeItem = next;
                me.trigger('navigate', {
                    event : keyEvent,
                    item  : me.activeItem
                });
            });
        }
    }

    get owner() {
        return this.ownerCmp;
    }

    get previous() {
        const treeWalker = this.treeWalker;

        treeWalker.currentNode = this.activeItem;
        treeWalker.previousNode();
        if (treeWalker.currentNode !== this.activeItem) {
            return treeWalker.currentNode;
        }
    }

    get next() {
        const treeWalker = this.treeWalker;

        treeWalker.currentNode = this.activeItem;
        treeWalker.nextNode();
        if (treeWalker.currentNode !== this.activeItem) {
            return treeWalker.currentNode;
        }
    }

    onTargetFocusIn(focusInEvent) {
        if (focusInEvent.target.matches(this.itemSelector)) {
            // We may need to know this in downstream code.
            // for example set activeItem must not scrollintoView on click
            this.skipScrollIntoView = true;

            this.activeItem = focusInEvent.target;

            this.skipScrollIntoView = false;
        }
    }

    onTargetFocusOut(focusOutEvent) {
        if (!focusOutEvent.relatedTarget || !this.target.contains(focusOutEvent.relatedTarget)) {
            this.activeItem = null;
        }
    }

    onTargetMouseDown(mousedownEvent) {
        // Mousedown is the focus gesture.
        // This holds true even on touch platforms
        // where the mousedown event is synthesized -
        // preventing default prevents focus on the upcoming touchend.
        if (this.ownerCmp.itemsFocusable === false) {
            this.onFocusGesture(mousedownEvent);
        }
        else {
            const target = mousedownEvent.target.closest(this.itemSelector);

            if (target) {
                mousedownEvent.preventDefault();
                DomHelper.focusWithoutScrolling(target);
            }
        }
    }

    onTargetClick(clickEvent) {
        const me = this;

        if (me.disabled) {
            return;
        }

        // We may need to know this in downstream code.
        // for example set activeItem must not scrollintoView on click
        me.skipScrollIntoView = true;

        // ownerCmp's preprocessing of any navigate event.
        if (me.processEvent) {
            clickEvent = me.processEvent.call(me.ownerCmp, clickEvent);
        }

        if (clickEvent) {
            me.activeItem = clickEvent.target.closest(me.itemSelector);
            me.trigger('navigate', {
                event : clickEvent,
                item  : me.activeItem
            });
        }
        me.skipScrollIntoView = false;
    }

    // We have to prevent focus moving from eg, an input field when we mousedown
    // or touchtap a non focusable item when ownerCmp has itemsFocusable: false.
    // If the event was not on an item, we must allow it through to allow Lists
    // to contain other widgets.
    onFocusGesture(event) {
        if (event.target === this.ownerCmp.contentElement || (event.target.closest(this.itemSelector) && this.ownerCmp.itemsFocusable === false)) {
            event.preventDefault();
        }
    }

    acceptNode(node) {
        return node.offsetParent && node.matches && node.matches(this.itemSelector) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }

    get activeItem() {
        return this._activeItem;
    }
    set activeItem(activeItem) {
        const
            me                = this,
            { ownerCmp }      = me,
            currentActiveItem = me.activeItem,
            isActive          = currentActiveItem && me.target.contains(currentActiveItem);

        if (isActive) {
            me.previousActiveItem = currentActiveItem;
        }

        // This may be set to null on focusout of the target element.
        // Cannot use truthiness test because index zero may be passed.
        if (activeItem != null) {
            // List and Menu's getItem API allows number, or node or record or record id to be passed
            if (ownerCmp.getItem) {
                activeItem = me.ownerCmp.getItem(activeItem);
            }

            // Unable to find an item to activate so do nothing.
            if (!activeItem) {
                return;
            }

            // If the user was able to click the event, they will not expect it to attempt to scroll.
            if (!me.skipScrollIntoView) {
                ownerCmp.scrollable.scrollIntoView(activeItem, {
                    block  : 'nearest',
                    // If we are being called in response to focus movement, it will already be the document.activeElement
                    // so in that case, behave is if we were in non-focusing mode, and just add the focused class.
                    focus  : DomHelper.isFocusable(activeItem) && activeItem !== document.activeElement,
                    silent : me.scrollSilently
                });
            }

            // No change in active item, do nothing after we've ensured it's fully in view.
            if (activeItem === currentActiveItem && isActive) {
                return;
            }

            if (currentActiveItem) {
                me.activeItem.classList.remove(me.focusCls);
            }

            activeItem.classList.add(me.focusCls);
            me._activeItem = activeItem;
        }
        else {
            if (currentActiveItem) {
                currentActiveItem.classList.remove(me.focusCls);

                // If we are clearing the activeItem, and it's focused, keep focus
                // close by actively reverting it.
                if (currentActiveItem === document.activeElement) {
                    me.ownerCmp.revertFocus();
                }
            }
            me._activeItem = null;
        }
    }

    get target() {
        return this._target;
    }
    set target(target) {
        const me = this,
            listeners = {
                element   : target,
                thisObj   : me,
                focusin   : 'onTargetFocusIn',
                focusout  : 'onTargetFocusOut',
                mousedown : 'onTargetMouseDown',
                click     : 'onTargetClick'
            };

        

        me._target = target;

        if (!me.hasOwnProperty('acceptNode')) {
            me.acceptNode = me.acceptNode.bind(me);
            // https://github.com/webcomponents/webcomponentsjs/issues/556
            // Work around Internet Explorer wanting a function instead of an object.
            // IE also *requires* this argument where other browsers don't.
            me.acceptNode.acceptNode = me.acceptNode;
        }

        EventHelper.on(listeners);

        // This Navigator object acts as the filter for the TreeWalker. We must implement acceptNode(node)
        me.treeWalker = document.createTreeWalker(target, NodeFilter.SHOW_ELEMENT, me.acceptNode, false);

        // If we were not configured with an outside key event provider (think the input field providing UP/DOWN keys for the dropdown)
        // then use the target element as the source.
        if (!me.keyEventTarget) {
            me.keyEventTarget = target;
        }

        // If the activeItem gets removed, we must know, and deactivate.
        (me.targetMutationMonitor = new MutationObserver(me.onTargetChildListChange.bind(me))).observe(target, {
            childList : true
        });
    }

    onTargetChildListChange() {
        const activeItem = this.activeItem;

        // On DOM mutation, if the activeItem got changed, pull the one with the same ID out again.
        if (activeItem && !this.target.contains(activeItem)) {
            this.activeItem = this.target.querySelector(`${this.itemSelector}[data-id="${activeItem.dataset.id}"]`);
        }
    }

    get keyEventTarget() {
        return this._keyEventTarget;
    }

    set keyEventTarget(keyEventTarget) {
        this._keyEventTarget = keyEventTarget;

        EventHelper.on({
            element : keyEventTarget,
            keydown : 'onKeyDown',
            thisObj : this
        });
    }
}
Navigator._$name = 'Navigator';

/**
 * @module Core/widget/List
 */

const itemRange = document.createRange();

/**
 * Displays a list of items which the user can navigate using the keyboard and select using either pointer gestures or the keyboard.
 * @extends Core/widget/Widget
 *
 * @classType list
 * @externalexample widget/List.js
 */
class List extends Widget {
    //region Config
    static get $name() {
        return 'List';
    }

    static get defaultConfig() {
        return {
            itemCls : 'b-list-item',

            selectedCls : 'b-selected',

            /**
             * An array of Objects which are converted into records and used to create this
             * List's {@link #config-store}
             * @config {Object[]}
             */
            items : null,

            /**
             * A {@link Core.data.Store} which provides the records which map to List items. Each record is passed through the
             * {@link #config-itemTpl} to produce the DOM structure of the List. May be generated from an array of {@link #config-items}.
             * @config {Object|Core.data.Store}
             */
            store : null,

            navigator : true,

            scrollable : {
                x : false,
                y : true
            },

            itemsFocusable : true,

            multiSelect : false,

            /**
             * Template function which, when passed a record, returns the textual HTML for that item. Defaults to a
             * function returning the value of records `text` field
             * @config {Function} itemTpl
             */
            itemTpl : record => record.text,

            /**
             * A {@link Core.util.Collection Collection}, or Collection config object
             * to use to contain this List's selected records.
             * @config {Core.util.Collection|Object}
             */
            selected : {},

            /**
             * Configure as `true` to activate items on mouseover. This is used by the Combo
             * field when using a List as its dropdown.
             * @config {Boolean}
             */
            activateOnMouseover : null
        };
    }

    //endregion

    //region Events

    /**
     * User activated an item in the list either by pointer or keyboard.
     * The active record, list item index, and the triggering event are passed.
     * @event item
     * @property {Object} record - Activated record
     * @property {Number} index - List item index
     * @property {Event} event - Triggering event
     */

    //endregion

    construct(config, ...args) {
        const me = this;

        // We can be created from a raw array. It becomes our items which we translate to a Store.
        if (Array.isArray(config)) {
            config = {
                items : config
            };
        }

        super.construct(config, ...args);

        const
            element        = me.element,
            classList      = element.classList;

        if (me.multiSelect) {
            classList.add('b-multiselect');
        }
        if (me.store.count) {
            me.refresh();
        }
        else {
            classList.add('b-empty');
        }

        EventHelper.on({
            element,
            delegate  : me.itemSelector,
            mouseover : 'onMouseOver',
            click     : 'onClick',
            thisObj   : me
        });
    }

    doDestroy() {
        this.detachListeners('store');
        super.doDestroy();
    }

    contentTpl() {
        return TemplateHelper.tpl`${this.store.records.map((record, i) => this.itemWrapperTpl(record, i))}`;
    }

    itemWrapperTpl(record, i) {
        return TemplateHelper.tpl`<div class="${this.getItemClasses(record, i)}" data-index="${i}" data-id="${record.id}" ${this.itemsFocusable ? 'tabindex="-1"' : ''}>
            ${this.itemContentTpl(record, i)}
            </div>`;
    }

    itemContentTpl(record, i) {
        return TemplateHelper.tpl`${this.multiSelect ? '<div class="b-selected-icon b-icon b-icon-check"></div>' : ''}${this.itemTpl(record, i)}`;
    }

    getItemClasses(record) {
        const me = this,
            activeItem = me._navigator && me._navigator.activeItem,
            isActive = activeItem && activeItem.dataset.id == record.id,
            isSelected = me.selected.includes(record);

        return `${me.itemCls} ${record.cls || ''} ${isSelected ? me.selectedCls : ''} ${isActive ? me.navigator.focusCls : ''}`;
    }

    onBeforeStoreLoad() {
        this.mask(this.L('loading'));
    }

    onAfterStoreRequest() {
        this.unmask();
    }

    onStoreChange({ source : store, action, records, record }) {
        switch (action) {
            case 'remove':
                this.selected.remove(records);
                break;
            case 'clear':
                this.selected.clear();
                break;
            case 'update':
                this.refreshItem(record);
                return;
        }
        this.refresh();
    }

    onStoreRefresh() {
        this.refresh();
    }

    refresh() {
        const me = this;

        if (me.isVisible) {
            const { activeItem } = me.navigator;

            // Ensure that the next call to refresh when not visible queues a refresh
            me.paintListener = null;

            me.clearItems().insertNode(DomHelper.createElementFromTemplate(me.contentTpl(), { fragment : true }));

            // The item elements will be all new, so restore the active item.
            // Navigator will reacquire it by its id.
            if (activeItem) {
                me.restoreActiveItem(activeItem);
            }
            me.refreshCount = (me.refreshCount || 0) + 1;
            me.element.classList[me.store.count > 0 ? 'remove' : 'add']('b-empty');
        }
        // Only queue a refresh if not already queued
        else if (!me.paintListener) {
            me.paintListener = me.on({
                paint   : 'refresh',
                thisObj : me,
                once    : true
            });
        }
    }

    clearItems() {
        const me = this,
            firstItem = me.contentElement.querySelector(me.itemSelector),
            lastChild = me.contentElement.lastChild;

        if (firstItem) {
            // Can't use :last-of-type when other elements of same type may be present.
            // Have to pluck the last element of the NodeList.
            const items = me.contentElement.querySelectorAll(`${me.itemSelector}:not(.b-mask)`);

            itemRange.setStartBefore(firstItem);
            itemRange.setEndAfter(items[items.length - 1]);
            itemRange.deleteContents();
        }
        else {
            // Allow a static set of elements to be at the top of the list
            if (lastChild) {
                itemRange.setStartAfter(lastChild);
                itemRange.setEndAfter(lastChild);
            }
            else {
                itemRange.setStart(me.contentElement, 0);
                itemRange.setEnd(me.contentElement, 0);
            }
        }
        return itemRange;
    }

    refreshItem(...records) {
        for (const record of records) {
            const item = this.getItem(record);

            // Maybe a record which is filtered out announces a change.
            // There will be no item.
            if (item) {
                const index = this.store.indexOf(record),
                    newItem = DomHelper.createElementFromTemplate(this.itemWrapperTpl(record, index));

                DomHelper.sync(newItem, item);
            }
        }
    }

    getItem(recordOrId) {
        // Cannot use truthiness test because index zero may be passed.
        if (recordOrId != null) {
            if (typeof recordOrId === 'number') {
                return this.contentElement.querySelector(`[data-index="${recordOrId}"]`);
            }
            else if (recordOrId.nodeType === 1) {
                recordOrId = recordOrId.dataset.id;
            }
            if (recordOrId.id != null) {
                recordOrId = recordOrId.id;
            }
            return this.contentElement.querySelector(`[data-id="${recordOrId}"]`);
        }
    }

    getRecord(dom) {
        if (dom.target) {
            dom = dom.target;
        }
        dom = dom.closest(this.itemSelector);

        return this.store.getAt(parseInt(dom.dataset.index));
    }

    //region getters/setters

    /**
     * May be *set* as an array of Objects which are converted into records and used to create this
     * List's {@link #config-store}
     * @property {Object[]}
     */
    set items(items) {
        const me = this;

        if (me.store && me.store.autoCreated) {
            me.store.destroy();
        }

        me.store = Store.getStore(items);
    }

    set selected(selected) {
        if (!(selected && selected instanceof Collection)) {
            selected = new Collection(selected);
        }
        this._selected = selected;
        selected.on({
            change  : 'onSelectionChange',
            thisObj : this
        });
    }

    get itemSelector() {
        return `.${this.itemCls}`;
    }

    get selected() {
        return this._selected;
    }

    /**
     * Get the backing store, a {@link Core.data.Store} holding the records used to generate list items
     * @property {Core.data.Store}
     * @readonly
     */
    get store() {
        // Ensure any configured items is processed into a store before we try to return it.
        this._thisIsAUsedExpression(this.items);

        return this._store;
    }

    set store(store) {
        const me = this;

        if (!(store instanceof Store)) {
            store = new Store(store);
        }

        me._store = store;

        me.detachListeners('store');

        if (store) {
            const storeListeners = {
                name    : 'store',
                change  : 'onStoreChange',
                refresh : 'onStoreRefresh',
                thisObj : me
            };

            if (store.readUrl) {
                storeListeners.beforeLoad   = 'onBeforeStoreLoad';
                storeListeners.afterRequest = 'onAfterStoreRequest';
            }

            me.store.on(storeListeners);
        }

        me.refresh();
    }

    get navigator() {
        return this._navigator;
    }

    set navigator(navigator) {
        const me = this,
            { element } = me;

        if (element) {
            me._navigator = new (navigator.class || Navigator)(Object.assign({
                ownerCmp       : me,
                target         : element,
                keyEventTarget : element
            }, navigator));
        }
        else {
            me._navigator = navigator;
        }
    }

    get minHeight() {
        return super.minHeight;
    }

    set minHeight(minHeight) {
        super.minHeight = this._minHeight = minHeight;
    }

    get minAlignHeight() {
        const lastItem = this.element.lastElementChild,
            minHeight = this.minHeight;

        // No minHeight specified, always defer to the items height
        if (minHeight != null) {
            return this.store.count ? Math.min(lastItem.offsetTop + lastItem.offsetHeight, minHeight) : 0;
        }
    }

    //endregion

    //region Hide/Show

    alignTo(...args) {
        // When aligning, if the items total height is less than minHeight, use that.
        super.minHeight = this.minAlignHeight;
        super.alignTo(...args);
    }

    hide(...args) {
        this.navigator.activeItem = null;
        super.hide(...args);
    }

    show() {
        const
            { refreshCount } = this,
            { previousActiveItem } = this.navigator;

        // Restore the configured minHeight
        super.minHeight = this._minHeight;

        super.show();

        // If no refresh on paint took place, we need to restore the activeItem.
        // Refresh does that itself.
        if (this.refreshCount === refreshCount) {
            this.restoreActiveItem(previousActiveItem, true);
        }
    }

    /**
     * Sets the passed record as the current focused record for keyboard navigation and selection purposes.
     * @param {Core.data.Model} activeItem The item to highlight as the active ("focused") item.
     * @param {String|boolean} [block='nearest'] The block scroll specification to scroll
     * the item into view. Defaults to `'nearest'` which means a minimal scroll, only if
     * the item is actually out of view. Passing `true` is for when the List is aligned
     * to a picker and the selected item should be scrolled to be close to the picker,
     * however that is aligned. See `Combo.showPicker` for usage.
     * @internal
     */
    restoreActiveItem(activeItem = this.navigator.previousActiveItem, block = 'nearest') {
        const
            me = this,
            { navigator, lastAlignSpec } = me;

        // Zero may be passed to select first item, so cannot use thruthiness.
        // This won't mean *clear* the active item if any. Falsy means
        // nothing to restore so leave it as is.
        if (activeItem != null) {
            if (typeof block !== 'string') {
                const alignZone = lastAlignSpec ? lastAlignSpec.zone : 1;

                // Scroll item into view appropriately, meaning closest to any align target.
                // Align zones are T,R,B,L => 0,1,2,3
                // If 1 or 3 (right or left), align nearest.
                // if 0 (above) align end.
                // else, we're below so align start.
                block = alignZone & 1 ? 'nearest' : alignZone ? 'start' : 'end';
            }

            activeItem = me.getItem(activeItem);

            if (activeItem) {
                // If we are aligned to a target, first, scroll the required item to the optimal
                // position to avoid Navigator's default minimal scroll to block: 'nearest'.
                // If we are aligned below a combo, move the point of interest to the top.
                // If we are aligned above a combo, move the point of interest to the bottom.
                me.scrollable.scrollIntoView(activeItem, {
                    block
                });

                navigator.activeItem = activeItem;
            }
        }
    }

    //endregion

    //region Events

    /**
     * Focuses list items on hover.
     * @private
     */
    onMouseOver(event) {
        const me        = this,
            itemElement = event.currentTarget;

        // Activate soon in case they're moving fast over items.
        if (!DomHelper.isTouchEvent && itemElement && me.navigator && me.activateOnMouseover) {
            me.setTimeout({
                fn                : 'handleMouseOver',
                delay             : 30,
                args              : [itemElement],
                cancelOutstanding : true
            });
        }
    }

    handleMouseOver(itemElement) {
        this.navigator.activeItem = itemElement;
    }

    /**
     * Selects list items on click.
     * @private
     */
    onClick(event) {
        const itemElement = event.target.closest(this.itemSelector);

        if (itemElement) {
            this.onItemClick(itemElement, event);
        }
    }

    /**
     * Key events which are not navigation are delegated up to here by the Navigator
     * @private
     */
    onInternalKeyDown(event) {
        const me     = this,
            active   = me.navigator.activeItem;

        switch (event.key) {
            case ' ':
                if (!event.target.readOnly) {
                    break; // eslint-disable-line
                }
            case 'Enter': // eslint-disable-line
                if (active) {
                    this.onItemClick(active, event);

                    // Stop the keydown from bubbling.
                    // And stop it from creating a keypress event.
                    // No further action should be taken after item selection.
                    event.stopImmediatePropagation();
                    event.preventDefault();
                }
        }
    }

    //endregion

    onItemClick(item, event) {
        const me = this,
            index = parseInt(item.dataset.index),
            record = me.store.getAt(index),
            selected = me.selected,
            isSelected = selected.includes(record);

        me.trigger('item', {
            item,
            record,
            index,
            event
        });

        // Clicking on any element with the data-noselect attribute means no selection
        if (!item.contains(event.target.closest('[data-noselect]'))) {
            if (me.multiSelect) {
                selected[isSelected ? 'remove' : 'add'](record);
            }
            else {
                selected.splice(0, selected.count, record);
            }
        }

        me.lastClicked = record;
    }

    /**
     * Handles items being added or removed from the selected Collection
     * @param {Object} changeEvent
     * @private
     */
    onSelectionChange({ action, removed, added, replaced }) {
        const me = this,
            { selectedCls } = me;

        let record, item;

        if (action === 'clear') {
            for (item of me.element.querySelectorAll(`.${selectedCls}`)) {
                item.classList.remove(selectedCls);
            }
        }
        else {
            for (record of removed) {
                item = me.getItem(record);
                item && item.classList.remove(selectedCls);
            }
            for (record of added) {
                item = me.getItem(record);
                item && item.classList.add(selectedCls);
            }
        }
    }
}

List.prototype.navigatorClass = Navigator;

List._$name = 'List'; BryntumWidgetAdapterRegister.register('list', List);

/**
 * @module Core/widget/ChipView
 */

/**
 * Displays an inline series of Chips which may be navigated to, selected and deleted.
 * @extends Core/widget/List
 *
 * @classType chipview
 */
class ChipView extends List {
    //region Config
    static get $name() {
        return 'ChipView';
    }

    static get defaultConfig() {
        return {
            itemCls : 'b-chip',

            /**
             * Configure as `true` to display a clickable close icon after the {@link Core.widget.List#config-itemTpl}.
             * When tapped, the configured {@link #config-closeHandler} is called passing the
             * associated record.
             *
             * Chips may also be selected using the `LEFT` and `RIGHT` arrows (And the `Shift` key to
             * do multiple, contiguous election). Pressing the `DELETE` or `BACKSPACE` key passes the
             * selected records to the {@link #config-closeHandler}
             * @config {Boolean}
             * @default
             */
            closable : true,

            /**
             * A template function, which, when passed a record, returns the markup which
             * encapsulates a chip's icon to be placed before the {@link Core.widget.List#config-itemTpl}.
             * @config {Function}
             */
            iconTpl : null,

            /**
             * If {@link #config-closable} is `true`, this is the name of a callback function
             * to handle what the "close" action means.
             * @config {String|Function}
             */
            closeHandler : null
        };
    }

    itemContentTpl(record, i) {
        const me = this;

        return TemplateHelper.tpl`${me.iconTpl ? this.iconTpl(record) : ''}
            ${me.itemTpl(record, i)}
            ${me.closable ? '<div class="b-icon b-close-icon b-icon-clear" data-noselect></div>' : ''}`;
    }

    onInternalKeyDown(event) {
        if (event.key === 'Delete' || event.key === 'Backspace' && this.selected.count) {
            this.callback(this.closeHandler, this.owner, [this.selected.values, { isKeyEvent : true }]);
        }
        else {
            super.onInternalKeyDown(event);
        }
    }

    onClick(event) {
        const me = this,
            item = event.target.closest(`.${me.itemCls}`);

        if (me.closable && event.target.classList.contains('b-close-icon')) {
            const record = me.store.getAt(parseInt(item.dataset.index));

            me.callback(me.closeHandler, me.owner, [[record]]);
        }
        else {
            super.onClick(event);
        }
    }
}

ChipView._$name = 'ChipView'; BryntumWidgetAdapterRegister.register('chipview', ChipView);

const
    comboQueryAll  = Symbol('Combo.queryAll'),
    comboQueryLast = Symbol('Combo.queryLast'),
    fieldRequiredErrorName = 'fieldRequired',
    fieldvalidateFilterErrorName = 'validateFilter';

/**
 * @module Core/widget/Combo
 */

/**
 * Combo (dropdown) widget. Consists of a text field with a trigger icon, which displays a List. Can be
 * populated from a Store.
 *
 * This field can be used as an {@link Grid.column.Column#config-editor editor} for the {@link Grid.column.Column Column}.
 *
 * @extends Core/widget/PickerField
 *
 * @example
 * // items as strings
 * let combo = new Combo({
 *   items: ['Small', 'Smaller', 'Really small', 'Tiny', 'Super tiny', '?'],
 *   placeholder: 'Pick size of diamond for ring'
 * });
 *
 * @example
 * // items as configs
 * let combo = new Combo({
 *   items: [{ value: 'a', text: 'First' }, { value: 'z', text: 'Last' }]
 * });
 *
 * @example
 * // items from store
 * let combo = new Combo({
 *   store: memberStore,
 *   valueField: 'id',
 *   displayField: 'name'
 * });
 *
 * @classType combo
 * @externalexample widget/Combo.js
 */
class Combo extends PickerField {
    //region Config
    static get $name() {
        return 'Combo';
    }

    static get defaultConfig() {
        return {
            /**
             * Rows to display in the dropdown (list items).
             *
             * If an object, the property names provide the {@link #config-value} for the Combo, and
             * the property values provide the displayed test in the list and input area eg:
             *
             *     items : {
             *         small  : 'Small',
             *         medium : 'Medium',
             *         large  : 'Large'
             *     }
             *
             * If an array, each entry may be
             *  - an object containing properties which must include
             * the {@link #config-valueField} and {@link #config-displayField} which populates the dropdown
             * with text and provides the corresponding field value.
             *  - An array whos first value provides the {@link #config-value} for the Combo and whos
             * second value provides the displayed test in the list and input area.
             *  - An array of values where the {@link #config-valueField} and {@link #config-displayField} are the same.
             *
             * eg:
             *
             *     items : [
             *         {value : 'small',  text : 'Small'},
             *         {value : 'medium', text : 'Medium'},
             *         {value : 'large',  text : 'Large'},
             *     ]
             *
             * or
             *
             *     items : [
             *         ['small',  'Small'],
             *         ['medium', 'Medium'],
             *         ['large',  'Large'],
             *     ]
             *
             * or
             *
             *     items : [ 'Small', 'Medium', 'Large' ]
             *
             * @config {Object[]|String[]|Object}
             */
            items : null,

            /**
             * A store used to populate items
             * @config {Core.data.Store}
             */
            store : null,

            /**
             * Field used for item value when populating from store
             * @config {String}
             */
            valueField : null,

            /**
             * Field used for item text when populating from store
             * @config {String}
             */
            displayField : 'text',

            /**
             * Width of picker, defaults to this combo's {@link #config-pickerAlignElement} width
             * @config {Number}
             */
            pickerWidth : null,

            /**
             * The minimum string length to trigger the filtering, only relevant when {@link #config-editable} is `true`.
             *
             * This defaults to `1` in the case of local filtering, but `4` if the
             * {@link #config-filterParamName} is set to cause remote dropdown loading.
             *
             * @config {Number}
             * @default
             */
            minChars : null,

            selected : null,

            /**
             * Template for rendering list items contents
             * @config {Function}
             */
            listItemTpl : null,

            /**
             * Template function that can be used to customize the displayed value
             * @config {Function}
             */
            displayValueRenderer : null,

            /**
             * CSS class to add to picker
             * @config {String}
             */
            listCls : null,

            triggers : {
                expand : {
                    cls     : 'b-icon-picker',
                    handler : 'onTriggerClick'
                }
            },

            /**
             * If the dropdown is to be populated with a filtered query to a remote server, specify the
             * name of the parameter to pass the typed string here. By default, the string is simply sent
             * as the value of the parameter. For special encoding, configure the combo with {@link #config-encodeFilterParams}
             * @config {String}
             */
            filterParamName : null,

            /**
             * A function which creates an array of values for the {#config-filterParamName} to pass
             * any filters to the server upon load.
             *
             * The default behaviour is just to set the parameter value to the filter's `value`,
             * but the filter can be fully encoded for example:
             *
             * ```javascript
             *    {
             *        encodeFilterParams(filters) {
             *            const result = [];
             *
             *            for (const { property, operator, value, caseSensitive } of filters) {
             *                result.push(JSON.stringify({
             *                    field : property,
             *                    operator,
             *                    value,
             *                    caseSensitive
             *                }));
             *           }
             *        return result;
             *    }
             * ```
             * @config {Function}
             */
            encodeFilterParams : null,

            /**
             * Configure as `true` to hide the expand trigger. This is automatically set to `true` if
             * remote filtering is enabled by setting the {@link #config-filterParamName} config.
             * @config {Boolean}
             * @default false
             */
            hideTrigger : null,

            /**
             * This implies that the picker will display an anchor pointer, but also means that the picker will align closer
             * to the input field so that the pointer pierces the {@link #config-pickerAlignElement}
             * @config {Boolean}
             * @default false
             */
            overlayAnchor : null,

            /**
             * The delay in milliseconds to wait after the last keystroke before filtering the list.
             * @config {Number}
             * @default
             */
            keyStrokeFilterDelay : null,

            defaultAction : 'select',

            /**
             * How to query the store upon click of the expand trigger. There are two constants provided:
             *
             * * `Combo.queryAll` - Clear the filter and display the whole dataset in the dropdown.
             * * `Combo.queryLast` - Filter the dataset using the last filter value.
             * * `null`/any other - Use the value in the input field to filter the dataset.
             *
             * @config {Object}
             * @default Combo.QueryAll
             */
            triggerAction : comboQueryAll,

            /**
             * The name of an operator type as implemented in {@link Core.util.CollectionFilter#config-operator}
             * to use when filtering the dropdown list based upon the typed value.
             *
             * This defaults to `'startsWith'`, but the `'*'` operator may be used to match all
             * values which _contain_ the typed value.
             *
             * Not used when {@link #config-filterParamName} is set to cause remote dropdown loading.
             * The exact filtering operation is up to the server.
             *
             * @config {String}
             */
            filterOperator : 'startsWith',

            /**
             * Configure as `true` to force case matching when filtering the dropdown list based upon the typed value.
             *
             * @config {Boolean}
             * @default false
             */
            caseSensitive : false,

            /**
             * Configure as `true` to allow selection of multiple values from the dropdown list.
             *
             * Each value is displayed as a "Chip" to the left of the input area. Chips may be
             * selected using the `LEFT` and `RIGHT` arrow keys and deleted using the `DELETE` key
             * to remove values from the field. There is also a clickable close icon in each chip.
             *
             * @config {Boolean}
             * @default false
             */
            multiSelect : null,

            /**
             * By default, the picker is hidden on selection in single select mode, and
             * remains to allow more selections when {@link #config-multiSelect} is `true`.
             * Setting this to a `Boolean` value can override that default.
             */
            hidePickerOnSelect : null,

            /**
             * A config object to configure the {@link Core.widget.ChipView} to display the
             * selected value set when {@link #config-multiSelect} is `true.
             *
             * For example the {@link Core.widget.List#config-itemTpl} or
             * {@link Core.widget.ChipView#config-iconTpl} might be configured to display
             * richer chips for selected items.
             * @config {Boolean}
             */
            chipView : null,

            /**
             * When {@link #config-multiSelect} is `true`, you may configure `filterSelected` as
             * `true` to hide items in the dropdown when they are added to the selection.
             * It will appear as if the requested item has "moved" into the field's
             * {@link #config-chipView ChipView}.
             *
             * @config {Boolean}
             * @default false
             */
            filterSelected : null,

            /**
             * Text to display in the drop down when there are no items in the underlying store
             * @config {String}
             * @default
             */
            emptyText : null,

            /**
             * The initial value of this Combo box. In single select mode (default) it's a simple string value, for {@link #config-multiSelect} mode, it should be an array of record ids.
             * @config {String|Number[]|String[]}
             * @default
             */
            value : null,

            /**
             * `true` to cause the field to be in an invalid state while the typed filter string does not match a record in the store.
             * @config {Boolean}
             * @default
             */
            validateFilter : true,

            /**
             * `true` to clear value typed to a multiselect combo when picker is collapsed
             * @config {Boolean}
             * @default
             */
            clearTextOnPickerHide : true
        };
    }

    //endregion

    afterConfigure() {
        super.afterConfigure();
        if (!('_value' in this)) {
            this._value = this.valueField === this.displayField ? '' : null;
        }
    }

    encodeFilterParams(filters) {
        return filters.map(f => f.value);
    }

    eachWidget(fn, deep = true) {
        for (const widget of [this.chipView, this._picker]) {
            if (widget) {
                if (fn(widget) === false) {
                    return;
                }
                if (deep && widget.eachWidget) {
                    widget.eachWidget(fn, deep);
                }
            }
        }
    }

    set element(element) {
        const me = this;

        super.element = element;

        // If we are multiSelect, create a ChipView who's store is backed
        // by our valueCollection - the collection of selected records.
        if (me.multiSelect) {
            me.element.classList.add('b-multiselect');
            me.chipView = new MultiSelectChipView(ObjectHelper.assign({
                parent       : me,
                insertBefore : me.input,
                store        : me.chipStore = new Store({
                    storage : me.valueCollection
                }),
                navigator : {
                    class          : MultiSelectChipNavigator,
                    keyEventTarget : me.input
                }
            }, me.chipView));

            // Insert the input field
            me.chipView.element.appendChild(me.input);

            // Focus must flow into this field from the ChipView
            EventHelper.on({
                element   : me.chipView.element,
                mousedown : 'onChipViewMousedown',
                thisObj   : me
            });
        }
    }

    onChipViewMousedown(mousedownEvent) {
        mousedownEvent.preventDefault();
        if (!this.containsFocus) {
            this.focus();
        }
    }

    onChipClose(records, options = {}) {
        // Do not clean value collection if input field is not empty - probably text is selected
        // and user just wants to remove it, not the picked values
        if (options.isKeyEvent && this.input.value === '' || !options.isKeyEvent) {
            this.valueCollection.remove(records);
        }
    }

    get element() {
        return super.element;
    }

    set filterParamName(filterParamName) {
        this._filterParamName = filterParamName;

        if (this.hideTrigger !== false) {
            this.hideTrigger = Boolean(filterParamName);
        }
    }

    get filterParamName() {
        return this._filterParamName;
    }

    set hideTrigger(hideTrigger) {
        this._hideTrigger = hideTrigger;
        this.element.classList[hideTrigger ? 'add' : 'remove']('b-hide-trigger');
    }

    get hideTrigger() {
        return this._hideTrigger;
    }

    //region Getters/setters

    set keyStrokeFilterDelay(delay) {
        const me = this;

        if (delay) {
            me.filterList = me.buffer(me.doFilter, delay);
        }
        me._keyStrokeFilterDelay = delay;
    }

    get keyStrokeFilterDelay() {
        return this._keyStrokeFilterDelay;
    }

    set minChars(minChars) {
        this._minChars = minChars;
    }

    get minChars() {
        if ('_minChars' in this) {
            return this._minChars;
        }

        // If it's not actually set, default differently for remote filtering.
        return this.filterParamName ? 4 : 1;
    }

    /**
     * Prepares items to work in attached menu (converts strings to items)
     * @private
     */
    set items(items) {

        const me = this;

        

        if (items == null) {
            if (me.store && !me.store.isItemStore) {
                return;
            }
            items = [];
        }

        if (items instanceof Store) {
            return me.store = items;
        }

        const displayField = me.displayField;

        let itemModel,
            valueField = me.valueField,
            storeData;

        if (Array.isArray(items)) {
            storeData = items.map(item => {
                let result = item;

                if (item instanceof Model) {
                    itemModel = item.constructor;
                    if (!valueField) {
                        me.valueField = valueField = itemModel.idField;
                    }
                }
                else {
                    if (typeof item === 'string' || typeof item === 'number') {
                        if (!valueField) {
                            me.valueField = valueField = me.displayField;
                        }
                        result = {
                            [valueField]   : item,
                            [displayField] : item
                        };
                    }
                    else {
                        if (!valueField) {
                            me.valueField = valueField = 'value';
                        }
                        if (Array.isArray(item)) {
                            result = {
                                [valueField]   : item[0],
                                [displayField] : item[1]
                            };
                        }
                    }
                }

                if (result.selected) {
                    me.value = result;
                }
                return result;
            });
        }
        // Must be a value -> text map
        else {
            if (!valueField) {
                me.valueField = valueField = 'value';
            }
            storeData = [];
            Object.entries(items).forEach(([key, value]) => {
                storeData.push({
                    [valueField]   : key,
                    [displayField] : value
                });
            });
        }

        // Allow reconfiguring with a new set of items
        if (me.store) {
            me.store.data = storeData;
        }
        else {
            const valueFieldDefinition = valueField === displayField ? {
                name       : 'value',
                dataSource : displayField
            } : valueField;

            me.store = new Store({
                isItemStore : true,
                data        : storeData,
                idField     : valueField,
                modelClass  : itemModel || class extends Model {
                    static get idField() {
                        // Need to use instance var and not rely on closure for cases where valueField changes
                        // (like first assigning [] and then ['a'] without configured valueField
                        return me.valueField;
                    }

                    static set idField(idField) {
                        super.idField = idField;
                    }

                    static get fields() {
                        return [valueFieldDefinition, displayField];
                    }
                }
            });
        }
    }

    get items() {
        return this.store.allRecords;
    }

    /**
     * Get/sets combo value, selects corresponding item in the list
     * Setting null clears the field.
     *
     * If {@link #config-multiSelect} is `true`, then multiple values may be passed as an array.
     * If the values are records, these become the selected record set held by {@link #property-valueCollection},
     * and the `value` yielded by this field is an array of all the {@link #config-valueField}s from the records.
     * @fires select
     * @fires action
     * @property {Object}
     */
    set value(value) {
        const me = this;

        if (value === me.value) {
            // Sync without highlight
            me.syncInputFieldValue(true);
            return;
        }

        if (!me.multiSelect && Array.isArray(value) && value.length > 1) {
            throw new Error('Multiple values cannot be set to a non-multiselect Combo');
        }

        // This forces promotion of the items config into a Store if it has not already been injected
        me._thisIsAUsedExpression(me.items);

        const
            {
                valueField,
                displayField,
                store,
                valueCollection
            } = me;

        // It's a remote filter store, so we have to do a filter down to just match(es)
        // and add the result to the valueCollection
        if (me.filterParamName) {
            // The null case will drop through and be processed as for local just by clearing the valueCollection
            if (value != null) {
                const wasConfiguring = me.isConfiguring;

                me.primaryFilter.setConfig({
                    value,
                    disabled : false
                });
                return store.performFilter(true).then(() => {
                    const { isConfiguring } = me;

                    // Carry the wasConfiguring flag from the set value call frame so that
                    // if it's the configuring set value, we do not now fire the change event.
                    me.isConfiguring = wasConfiguring;
                    valueCollection.splice(0, valueCollection.count, store.allRecords);
                    me.isConfiguring = isConfiguring;
                });
            }
        }
        // Else, if it's a *locally* filtered store, then
        // unfilter it so we can do the value lookup.
        else if (store.filtered) {
            me.primaryFilter.disabled = true;
            store.filter();
        }

        let record;

        if (value != null) {
            // If value is set as an array, make sure to slice it to not mutate original array below
            const values = Array.isArray(value) ? value.slice() : [value];

            for (let i = 0, len = values.length; i < len; i++) {
                let value = values[i];

                if (value instanceof Model) {
                    // The required record value may not yet be in the store. Add it if not.
                    if (!store.storage.includes(value)) {
                        store.add(value);
                    }
                }
                else {
                    const isObject = value instanceof Object;

                    // If they passed a data object, match the valueField
                    if (isObject) {
                        value = value[valueField];
                    }

                    // Use the Store Collection's extra indices to quickly find a match
                    record = store.storage.getBy(displayField, value) ||
                        store.storage.getBy(valueField, value);

                    if (record) {
                        // If the incoming value was a matched object, use it to update the record
                        if (isObject) {
                            record.set(values[i]);
                        }
                        values[i] = record;
                    }
                    else {
                        values.splice(i, 1);
                        len--;
                        i--;
                    }
                }
            }

            // Remove all old values, add new values in one shot.
            const vcGen = valueCollection.generation;
            valueCollection.splice(0, valueCollection.count, values);

            // If no change has fed through to onValueCollectionChange, just ensure the input matches
            if (valueCollection.generation === vcGen) {
                me.syncInputFieldValue();
            }

            // If we got no matches, onValueCollectionChange will set the _value to null.
            // Tests specify that the _value should be set to the incoming unmatched value
            if (!values.length) {
                me._value = value;
            }
        }
        else {
            if (valueCollection.count) {
                valueCollection.clear();
            }
            else {
                const oldValue = me._value;

                // Cache the value for use by our change handler next time, and also so that
                // when get value yields null, the fallback to ._value will be correct
                me._value = null;

                me.syncInputFieldValue();
                me.updateEmpty();
                if (!me.isConfiguring) {
                    me.trigger('change', {
                        value,
                        oldValue,
                        userAction : me._isUserAction,
                        valid      : me.isValid
                    });
                }
            }
        }
    }

    get value() {
        const me = this;

        return me.multiSelect ? me.valueCollection.map(r => r[me.valueField]) : me.valueCollection.count ? me.valueCollection.first[me.valueField] : me._value;
    }

    syncInputFieldValue(skipHighlight) {
        // We only sync the input's value if we are not multiselecting.
        // If we are multiselecting, our value is represented by a ChipView.
        // The ChipView automatically syncs itself with our valueCollection.
        if (!this.multiSelect) {
            super.syncInputFieldValue(skipHighlight);
        }
    }

    get isEmpty() {
        return this.valueCollection.count === 0;
    }

    get isValid() {
        const me = this;

        // Invalid if empty and required, but not during configuration to not start red
        if (!me.isConfiguring && me.required && !me.valueCollection.count) {
            me.setError(fieldRequiredErrorName, true);
        }
        else {
            me.clearError(fieldRequiredErrorName, true);
        }

        return super.isValid;
    }

    get inputValue() {
        // This must be evaluated first, and NOT moved to be directly used as the
        // second expression in the ternary. If called during configuration, this
        // will import the configured value from the config object and ensure the
        // value is matched against the store, and that the "selected" property is set.
        let me = this,
            result = me.value;

        result = me.selected ? me.selected[me.displayField] : result;

        if (me.displayValueRenderer) {
            result = me.displayValueRenderer(me.selected);
        }

        return result == null ? '' : result;
    }

    set displayValueRenderer(value) {
        this._displayValueRenderer = value;
    }

    get displayValueRenderer() {
        return this._displayValueRenderer;
    }

    /**
     * A {@link Core.util.Collection Collection} which holds the currently seleted records
     * from the store which dictates this field's value.
     *
     * Usually, this will contain one record, the record selected.
     *
     * When {@link #config-multiSelect} is `true`, there may be several records selected.
     */
    get valueCollection() {
        if (!this._valueCollection) {
            this._valueCollection = new Collection({
                listeners : {
                    noChange : 'onValueCollectionNoChange',
                    change   : 'onValueCollectionChange',
                    prio     : -1000, // The ChipView must react to changes first.
                    thisObj  : this
                }
            });
        }

        return this._valueCollection;
    }

    /**
     * Get/set store to display items from. Also accepts a Store config object
     * @property {Core.data.Store|Object}
     */
    set store(store) {
        const
            me                  = this,
            { filterParamName } = me,
            storeFilters        = [],
            storeListeners      = {
                thisObj : this
            };

        if (Array.isArray(store)) {
            me.initialConfig.store = null;
            return me.items = store;
        }

        // Config object supplied, create a store
        if (store && !(store instanceof Store)) {
            store = new (store.readUrl ? AjaxStore : Store)(store);
        }

        if (filterParamName) {
            store.filterParamName = filterParamName;
            if (me.encodeFilterParams) {
                store.encodeFilterParams = me.encodeFilterParams;
            }
            storeListeners.filter = 'onRemoteFilter';
        }

        if (!me.valueField) {
            me.valueField = store.modelClass.idField;
        }

        // This is the filter that performs filtering on typing.
        if (!me.primaryFilter) {
            // Need an id to replace any existing combo filter on the store. Precommit hook wont allow it to be set
            // directly...
            const id = 'primary';
            me.primaryFilter = new CollectionFilter({
                id,
                property      : me.displayField,
                operator      : me.filterOperator,
                disabled      : true,
                caseSensitive : me.caseSensitive
            });
        }
        storeFilters.push(me.primaryFilter);

        if (filterParamName) {
            if (me.filterSelected) {
                store.storage.autoFilter = true;
                store.storage.addFilter({
                    id       : `${me.id}-selected-filter`,
                    filterBy : r => !me.valueCollection.includes(r)
                });
            }
        }
        else {
            if (me.filterSelected) {
                me.selectedItemsFilter = r => !me.valueCollection.includes(r);
                storeFilters.push(me.selectedItemsFilter);
                store.reapplyFilterOnAdd = true;
            }
        }
        store.filter(storeFilters);

        me._store = store;

        if (me._picker) {
            me.picker.store = store;
        }

        // Allow fast lookup by value or displayed value
        store.storage.addIndex(me.displayField);
        store.storage.addIndex(me.valueField);

        if (me.displayValueRenderer) {
            storeListeners.change = 'syncInputFieldValue';
            me.syncInputFieldValue();
        }

        store.on(storeListeners);
    }

    get store() {
        return this._store;
    }

    /**
     * Get selected record.
     * @property {Core.data.Model[]}
     * @readonly
     */
    get record() {
        return this.selected;
    }

    /**
     * Get the selected record(s).
     * @property {Core.data.Model[]}
     * @readonly
     */
    get records() {
        return this.valueCollection.values.slice();
    }

    get selected() {
        return this.valueCollection.first;
    }

    //endregion

    //region Value handling

    /**
     * Check if field value is valid
     * @internal
     */
    onEditComplete() {
        const me = this,
            selectionCount = me.valueCollection.count;

        super.onEditComplete();

        // Ensure the input area matches the selected value
        if (selectionCount) {
            me.clearError(fieldvalidateFilterErrorName);
            me.syncInputFieldValue();
        }
        if (me.required && !selectionCount) {
            me.setError(fieldRequiredErrorName);
        }
    }

    //endregion

    //region Events

    /**
     * User clicked trigger icon, toggle list.
     * @private
     */
    onTriggerClick() {
        const me = this;

        if (me.pickerVisible) {
            me.hidePicker();
        }
        else {
            if (!me.readOnly && !me.disabled) {
                switch (me.triggerAction) {
                    case comboQueryAll:
                        me.doFilter(null);
                        break;
                    case comboQueryLast:
                        me.doFilter(me.lastQuery);
                        break;
                    default:
                        me.doFilter(me.input.value);
                }
            }
        }
    }

    /**
     * User types into input field in editable combo, show list and filter it.
     * @private
     */
    internalOnInput(event) {
        const me = this,
            value = me.input.value,
            inputLen = value.length;

        // IE11 triggers input event on focus for some reason, ignoring it if not editable
        if (!me.editable) {
            return;
        }

        me.updateEmpty();
        me.syncInputWidth();

        if (inputLen >= me.minChars) {
            me.filterList(value);
        }
        else {
            // During typing, the field is invalid
            if (me.validateFilter && !me.filterParamName) {
                me[inputLen ? 'setError' : 'clearError'](fieldvalidateFilterErrorName);
            }
            me.hidePicker();
        }

        /**
         * User typed into the field. Please note that the value attached to this event is the raw input field value and
         * not the combos value
         * @event input
         * @param {Core.widget.Combo} source - The combo
         * @param {String} value - Raw input value
         */
        me.trigger('input', { value, event });
    }

    syncInputWidth() {
        const me = this;

        if (me.multiSelect) {
            const
                input = me.input,
                // padding on the input el won't change, so cache the measurement:
                inputPadding = me._inputPadding ||
                    (me._inputPadding = DomHelper.getEdgeSize(input, 'padding', 'lr')),
                value = input.value || '',
                width =
                    // +'W' to avoid text getting clipped or horizontal scrolling
                    DomHelper.measureText(value + 'W', input, false, me.element) +
                    inputPadding.width;

            // Normally the input is given "flex: 1 1 0px" so it will fill the space
            // so we just need to adjust the flex-basis to ensure the input is at least
            // as long as the text. Since it is also flex-shrink, it will not become
            // any larger than one "row".
            input.style.flex = `1 1 ${Math.ceil(width)}px`;
        }
    }

    // This is potentially a buffered function to respond to keystrokes in a buffered manner.
    // This only becomes useful as a saving when using remote querying where each filter is an Ajax request.
    filterList(queryString) {
        this.doFilter(queryString);
    }

    doFilter(queryString) {
        const me                       = this,
            { store, filterParamName } = me,
            disableFilter              = queryString == null || queryString == '';

        me.lastQuery = queryString;

        me.primaryFilter.setConfig({
            value    : queryString,
            disabled : disableFilter
        });

        if (filterParamName) {
            store.clear(true);
        }

        store.filter();

        me.showPicker();

        if (store.count) {
            // If we are filtering, activate the first match
            if (!disableFilter) {
                me.picker.navigator.activeItem = 0;
            }
        }
        // If we were actively *locally* filtering on a string but there were no matches
        // and we are validateFilter: true, then mark as invalid even though we
        // may have an underlying valid selected value.
        else if (!filterParamName && !disableFilter && me.validateFilter) {
            me.setError(fieldvalidateFilterErrorName);
        }
    }

    onRemoteFilter() {
        const
            me     = this,
            picker = me._picker;

        // If we are filtering, activate the first match
        if (me.store.count) {
            if (picker) {
                picker.navigator.activeItem = 0;
            }
        }
        // Invalid if no matches after filtering
        else {
            if (me.validateFilter) {
                me.setError(fieldvalidateFilterErrorName);
            }
        }

        // If we have selection, evict selected items from the newly remote-filtered list
        if (me.filterSelected && me.valueCollection.count) {
            me.store.storage.onFiltersChanged();

            // Store does not react to Collection filtering yet because it does its own filtering and
            // then fires its own event. So we have to refresh the picker to hide the selected items.
            if (picker) {
                picker.refresh();
            }
        }
    }

    /**
     * This reacts to our {@link #property-valueCollection} being mutated in any way.
     * The `change`, `select` and `action` events are fired here.
     *
     * This could happen in four ways:
     *
     *  - User selected or deselected an item in the dropdown list.
     *  - `set value` changes the content.
     *  - The {@link #config-multiSelect} Chip view (which uses this in its store) deletes a record.
     *  - The application programmatically mutates the {@link #property-valueCollection}.
     *
     * @private
     */
    onValueCollectionChange({ source : valueCollection }) {
        const me = this,
            { multiSelect } = me,
            hidePicker = ('hidePickerOnSelect' in me) ? me.hidePickerOnSelect : !multiSelect,
            record = multiSelect ? valueCollection.values.slice() : valueCollection.first,
            records = valueCollection.values.slice(),
            isUserAction = me._isUserAction ||  hidePicker && me.pickerVisible || false,
            oldValue = me._value;

        if (hidePicker) {
            me.hidePicker();
        }

        if (!valueCollection.count && me.required) {
            me.setError(fieldRequiredErrorName);
        }
        else {
            me.clearError(fieldRequiredErrorName);
            me.clearError(fieldvalidateFilterErrorName);
        }

        if (me.validateFilter && record) {
            me.clearError(fieldvalidateFilterErrorName);
        }

        // Re-evaluate *local* filtering so that selected items are filtered out of the dropdown.
        // For remote filtering, we programatically add a filter to the store's storage
        if (me.filterSelected) {
            if (me.filterParamName) {
                me.store.storage.onFiltersChanged();

                // Store does not react to Collection filtering yet because it does its own filtering and
                // then fires its own event. So we have to refresh the picker to hide the selected items.
                if (me._picker) {
                    me._picker.refresh();
                }
            }
            else {
                me.store.filter();
            }
        }

        // Clear the cached value so that there's no fallback when we read back the value below
        me._value = null;

        // Cache the value for use by our change handler next time, and also so that
        // if we just cleared the valueCollection, the fallback to ._value will be correct
        const value = me._value = me.value;

        me.syncInputFieldValue();
        me.updateEmpty();

        if (!me.isConfiguring) {
            me.trigger('change', {
                value,
                oldValue,
                userAction : isUserAction,
                valid      : me.isValid
            });

            /**
             * User selected an item in the list
             * @event select
             * @property {Combo} combo - Combo
             * @property {Core.data.Model} record - Selected record
             * @property {Core.data.Model} records - Selected records as an array if {@link #config-multiSelect} is `true`
             * @property {Boolean} userAction - `true` if the value change is due to user interaction.
             */
            me.trigger('select', { record, records, userAction : me.containsFocus });

            /**
             * User performed the default action in the list (selected an item)
             * @event action
             * @property {Combo} combo - Combo
             * @property {Mixed} value - The {@link #valueField} of the selected record
             * @property {Core.data.Model} record - Selected record
             * @property {Core.data.Model} records - Selected records as an array if {@link #config-multiSelect} is `true`
             */
            if (me.defaultAction === 'select') {
                me.trigger('action', { value, record, records });
            }
        }
    }

    /**
     * This listens for when a record from the list is selected, but is already part of
     * the selection and so the {@link #property-valueCollection} rejects that as a no-op.
     * At this point, the user will still expect the picker to hide.
     * @param {Object} event The noChange event containing the splice parameters
     * @private
     */
    onValueCollectionNoChange({ toAdd }) {
        if (!this.multiSelect && toAdd.length && this.pickerVisible) {
            this.picker.hide();
        }
    }

    //endregion

    //region Picker

    showPicker() {
        const me = this,
            { picker } = me;

        super.showPicker();

        // Once we have access to the anchor size, overlay the anchor pointer over the target if configured to do so.
        if (me.overlayAnchor && !picker.align.offset) {
            picker.align.offset = -picker.anchorSize[1];
            picker.realign();
        }

        // Activate and make visible the *single* selected item.
        // Not valid if multiselect because the user's interest will not be focused on any one item.
        if (!me.multiSelect && me.selected) {
            picker.restoreActiveItem(me.selected, true);
        }

        me.input.focus();
    }

    /**
     * Creates default picker widget
     *
     * @internal
     */
    createPicker(pickerConfig) {
        const me = this,
            { multiSelect } = me,
            pickerWidth = me.pickerWidth || pickerConfig.width,
            picker = WidgetHelper.createWidget(ObjectHelper.merge({
                type                : 'list',
                owner               : me,
                floating            : true,
                scrollAction        : 'realign',
                itemsFocusable      : false,
                activateOnMouseover : true,
                store               : me.store,
                selected            : me.valueCollection,
                multiSelect,
                cls                 : me.listCls,
                itemTpl             : me.listItemTpl || (item => item[me.displayField]),
                forElement          : me[me.pickerAlignElement],
                align               : {
                    align     : 't-b',
                    axisLock  : true,
                    matchSize : pickerWidth == null,
                    anchor    : me.overlayAnchor,
                    target    : me[me.pickerAlignElement]
                },
                width     : pickerWidth,
                navigator : {
                    keyEventTarget : me.input
                },
                maxHeight  : 324,
                scrollable : {
                    overflowY : true
                },
                autoShow     : false,
                focusOnHover : false
            }, pickerConfig));

        picker.element.dataset.emptyText = me.emptyText || me.L('No results');

        return picker;
    }

    onPickerHide() {
        const me = this;

        super.onPickerHide();

        // https://app.assembla.com/spaces/bryntum/tickets/7736
        if (me.multiSelect && me.clearTextOnPickerHide) {
            me.input.value = '';
        }
    }

    //endregion
}

// Constants for how to query on clicking the trigger.
// queryAll means disable the primaryFilter
// queryLast means query using the last query string
// Any other value means use the input field's content

/**
 * A constant value for the {@link #config-triggerAction} config to indicate that clicking the trigger should
 * clear the filter and display the whole dataset in the dropdown.
 * @member {Symbol} queryAll
 * @readonly
 * @static
 */
Combo.queryAll = comboQueryAll;

/**
 * A constant value for the {@link #config-triggerAction} config to indicate that clicking the trigger should
 * filter the dataset usiong the last filter query string, *not* the input field value.
 * @member {Symbol} queryLast
 * @readonly
 * @static
 */
Combo.queryLast = comboQueryLast;

class MultiSelectChipView extends ChipView {
    static get $name() {
        return 'MultiSelectChipView';
    }

    static get defaultConfig() {
        return {
            itemsFocusable : false,

            multiSelect : true,

            closeHandler : 'up.onChipClose',

            itemTpl : function(record) {
                return record[this.owner.displayField];
            }
        };
    }
}

class MultiSelectChipNavigator extends Navigator {
    static get defaultConfig() {
        return {
            allowShiftKey : true
        };
    }

    onTargetClick(clickEvent) {
        const item = clickEvent.target.closest(this.itemSelector);

        if (item && !clickEvent.shiftKey && !item.contains(clickEvent.target.closest('[data-noselect]'))) {
            this.ownerCmp.selected.clear();
        }
        // Our own set activeItem also selects because on superclass *key* navigation
        // (which is async on scroll end), it sets activeItem, and we select at that time.
        // So on click we skip this class and go straight to the superclass because the
        // List's onItemClick must run, and that does selection.
        super.activeItem = item;
    }

    onKeyDown(keyEvent) {
        // ENTER does not toggle selectedness in a ChipView.
        // ChipView's selection is bound to navigation.
        if (keyEvent.key !== 'Enter') {
            super.onKeyDown(keyEvent);
        }
    }

    set activeItem(activeItem) {
        const chipView = this.ownerCmp;

        // List's getItem API allows number, or node or record or record id to be passed
        activeItem = chipView.getItem(activeItem);

        super.activeItem = activeItem;

        // Selection simply follows navigation in a ChipView
        if (activeItem) {
            chipView.selected.add(chipView.getRecord(activeItem));
        }
    }

    get activeItem() {
        return super.activeItem;
    }

    navigatePrevious(keyEvent) {
        const chipView = this.ownerCmp;

        if (chipView.navigator.activeItem && !keyEvent.shiftKey) {
            chipView.selected.clear();
        }
        if (this.previous) {
            super.navigatePrevious(keyEvent);
        }
        else {
            this.activeItem = null;
        }
    }

    navigateNext(keyEvent) {
        const chipView = this.ownerCmp;

        // SHIFT+navigate preserves selection
        if (chipView.navigator.activeItem && !keyEvent.shiftKey) {
            chipView.selected.clear();
        }
        if (this.next) {
            super.navigateNext(keyEvent);
        }
        else {
            this.activeItem = null;
        }
    }
}

Combo._$name = 'Combo'; BryntumWidgetAdapterRegister.register('combo', Combo);
BryntumWidgetAdapterRegister.register('combobox', Combo);
BryntumWidgetAdapterRegister.register('dropdown', Combo);

/**
 * @module Core/util/Month
 */

/**
 * A class which encapsulates a calendar view of a month, and offers information about 
 * the weeks and days within that calendar view.
 * ```
 *   const m = new Month({
 *       date         : '2018-12-01',
 *       weekStartDay : 1
 *   }) // December 2018 using Monday as week start
 *   m.eachWeek((week, dates) => console.log(dates.map(d => d.getDate())))
 * ```
 */
class Month {
    /**
     * Constructs a Month from a config object which *must* contain a `date` property.
     * @param {Object} config An object containing initialization properties.
     * @param {Date|String|Number} config.date The date which the month should encapsulate. May be
     * a `Date` object, or a value, which, when passed to the `Date` constructor yields a
     * valid `Date` object. Mutating a passed `Date` after initializing a `Month` object
     * has no effect on the `Month` object.
     * @param {Number} [config.weekStartDay] Optional. Week start day override. Defaults to the
     * locale's {@link Core.helper.DateHelper#property-weekStartDay-static}.
     * @param {Boolean} [config.sixWeeks] Optional. Pass `true` to always have the month encapsulate six weeks.
     * This is ueful for UIs which must be a fixed height.
     * @function constructor
     */
    constructor(config) {
        let { date, weekStartDay, sixWeeks } = config;

        this.constructor.updateDayNumbers(weekStartDay);
        this.sixWeeks = sixWeeks;
        this.date = date;
    }

    set date(date) {
        const isString = typeof date === 'string';

        date = new Date(date);
 
        // Edge parses YYYY-MM-DD as UTC, not local, so in other locales, the value
        // may end up not being 00:00:00 in the date, so remove any time zone offset.
        if (isString) {
            if (isNaN(date)) {
                throw new Error('CalendarPanel date ingestion must be passed a Date, or a valid argument to the Date constructor');
            }
            date = DateHelper.add(date, date.getTimezoneOffset(), 'minute');
        }

        const me = this,
            monthStart    = DateHelper.getFirstDateOfMonth(date),
            monthEnd      = DateHelper.getLastDateOfMonth(monthStart),
            startWeekDay  = me.dayNumbers[monthStart.getDay()],
            endWeekDay    = me.dayNumbers[monthEnd.getDay()];

        me._date = date;
    
        // These comments assume ISO standard of Monday as week start day.
        //
        // This is the date of month that is the beginning of the first week row.
        // So this may be -ve. Eg: for Dec 2018, Monday 26th Nov is the first
        // cell on the calendar which is the -4th of December. Note that the 0th
        // of December was 31st of November, so needs -4 to get back to the 26th.
        me.startDayOfMonth = 1 - startWeekDay;
            
        // This is the date of month that is the end of the last week row.
        // So this may be > month end. Eg: for Dec 2018, Sunday 6th Jan is the last
        // cell on the calendar which is the 37th of December.
        me.endDayOfMonth = monthEnd.getDate() + (6 - endWeekDay);

        if (me.sixWeeks) {
            while (me.weekCount < 6) {
                me.endDayOfMonth += 7;
            }
        }

        const jan1 = new Date(me.year, 0, 1),
            dec31 = new Date(me.year, 1, 31),
            january = me.month ? new Month({
                date         : jan1,
                weekStartDay : me.weekStartDay
            }) : me;

        // First 7 days are in last week of previous year if the year
        // starts after our 4th day of week.
        if (me.dayNumbers[jan1.getDay()] > 3) {
            // Week base is calculated from the year start
            me.weekBase = january.startDate;
        }
        // First 7 days are in week 1 of this year
        else {
            // Week base is the start of week before
            me.weekBase = new Date(me.year, 0, january.startDayOfMonth - 7);
        }

        // Our year only has a 53rd week if the year ends before our week's 5th day
        me.has53weeks = dec31.getDay() < 4;
    }

    set year(year) {
        this.date.setFullYear(year);
        this.date = this.date;
    }

    get year() {
        return this.date.getFullYear();
    }

    set month(month) {
        this.date.setMonth(month);
        this.date = this.date;
    }

    get month() {
        return this.date.getMonth();
    }

    get date() {
        return this._date;
    }

    /**
     * The number of days in the calendar for this month. This will always be
     * a multiple of 7, because this represents the number of calendar cells
     * occupied by this month.
     * @property {Number}
     * @readonly
     */
    get dayCount() {
        // So for the example month, Dec 2018 has 42 days, from Mon 26th Nov (-4th Dec) 2018
        // to Sun 6th Jan (37th Dec) 2019
        return (this.endDayOfMonth + 1) - this.startDayOfMonth;
    }

    /**
     * The number of weeks in the calendar for this month.
     * @property {Number}
     * @readonly
     */
    get weekCount() {
        return this.dayCount / 7;
    }

    /**
     * The date of the first cell in the calendar view of this month.
     * @property {Date}
     * @readonly
     */
    get startDate() {
        return new Date(this.year, this.month, this.startDayOfMonth);
    }

    /**
     * The date of the last cell in the calendar view of this month.
     * @property {Date}
     * @readonly
     */
    get endDate() {
        return new Date(this.year, this.month, this.endDayOfMonth);
    }

    /**
     * Iterates through all calendar cells in this month, calling the passed function
     * for each date.
     * @param {Function} fn The function to call.
     * <h4>Parameters</h4>
     *  - date [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) The date for the cell.
     */
    eachDay(fn) {
        const me = this;

        for (let dayOfMonth = me.startDayOfMonth; dayOfMonth <= me.endDayOfMonth; dayOfMonth++) {
            fn(new Date(me.year, me.month, dayOfMonth));
        }
    }

    /**
     * Iterates through all weeks in this month, calling the passed function
     * for each week. The function is passed the following parameters:
     * @param {Function} fn The function to call.
     * <h4>Parameters</h4>
     *  - week [Number[]](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number) An array containing `[year, weekNumber]`.
     *  - date [Date[]](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) The dates for the week.
     */
    eachWeek(fn) {
        const me = this,
            { weekCount } = me;

        for (let dayOfMonth = me.startDayOfMonth, week = 0; week < weekCount; week++) {
            const weekDates  = [],
                weekOfYear = me.getWeekNumber(new Date(me.year, me.month, Math.max(dayOfMonth, 1)));

            for (let day = 0; day < 7; day++, dayOfMonth++) {
                weekDates.push(new Date(me.year, me.month, dayOfMonth));
            }
            fn(weekOfYear, weekDates);
        }
    }

    getWeekNumber(date) {
        const me = this,
            { weekStartDay } = me;

        date = DateHelper.clearTime(date);

        // If it's a date that our known year does not contain
        // create a new Month to find the answer.
        if (date < me.startDate || date > me.endDate) {
            return new Month({
                date,
                weekStartDay
            }).getWeekNumber(date);
        }

        let weekNo = Math.floor(((date - me.weekBase) / 86400000) / 7),
            year = date.getFullYear();

        // No week 0. It's the last week of last year
        if (!weekNo) {
            const lastDec31 = new Date(me.year, 0, 0);

            // Week is the week of last year's 31st Dec
            return new Month({
                date : lastDec31,
                weekStartDay
            }).getWeekNumber(lastDec31);
        }
        // Only week 53 if year ends before our week's 5th day
        else if (weekNo === 53 && !me.has53weeks) {
            weekNo = 1;
            year++;
        }

        // Return array of year and week number
        return [year, weekNo];
    }

    static applyLocale() {
        this.updateDayNumbers();
    }

    static updateDayNumbers(weekStartDay = DateHelper.weekStartDay) {
        const me = this.prototype,
            dayNumbers = me.dayNumbers = [],
            canonicalDayNumbers = me.canonicalDayNumbers = [];

        me.weekStartDay = weekStartDay;

        // So, if they set weekStartDay to 1 meaning Monday which is ISO standard, we will
        // have mapping of internal day number to canonical day number (as used by Date class)
        // and to abbreviated day name like this:
        // canonicalDayNumbers = [1, 2, 3, 4, 5, 6, 0] // Use for translation from our day number to Date class's day number
        // dayNumbers          = [6, 0, 1, 2, 3, 4, 5] // Use for translation from Date object's day number to ours
        for (let i = 0; i < 7; i++) {
            const canonicalDay = (weekStartDay + i) % 7;

            canonicalDayNumbers[i] = canonicalDay;
            dayNumbers[canonicalDay] = i;
        }
    }
}

// Update when changing locale
LocaleManagerSingelton.on({
    locale  : 'applyLocale',
    thisObj : Month
});
Month._$name = 'Month';

/**
 * @module Core/widget/CalendarPanel
 */

/**
 * A Panel which can display a month of date cells.
 *
 * This is a base class for UI widgets which need to make use of a calendar layout
 * and should not be used directly.
 */
class CalendarPanel extends Panel {
    static get $name() {
        return 'CalendarPanel';
    }

    static get defaultConfig() {
        return {
            /**
             * The week start day, 0 meaning Sunday, 6 meaning Saturday.
             * Defaults to the locale's week start day.
             * @config {Number}
             */
            weekStartDay : null,

            /**
             * Configure as `true` to always show a six week calendar.
             * @config {Boolean}
             * @default
             */
            sixWeeks : true,

            /**
             * Configure as `true` to show a week number column at the start of the calendar block.
             * @config {Boolean}
             */
            showWeekNumber : false,

            /**
             * Either an array of `Date` objects which are to be disabled, or
             * a function, which, when passed a `Date` returns `true` if the
             * date is disabled.
             * @config {Function|Date[]}
             */
            disabledDates : null,

            /**
             * A function which creates content in, and may mutate a day header element.
             * The following parameters are passed:
             *  - cell [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement) The header element.
             *  - day [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number) The day number conforming to the specified {@link #config-weekStartDay}. Will be in the range 0 to 6.
             * @config {Function}
             */
            headerRenderer : null,

            /**
             * A function which creates content in, and may mutate the week cell element at the start of a week row.
             * The following parameters are passed:
             *  - cell [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement) The header element.
             *  - week [Number[]](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number) An array containing `[year, weekNumber]`.
             * @config {Function}
             */
            weekRenderer : null,

            /**
             * A function which creates content in, and may mutate a day cell element.
             * The following parameters are passed:
             *  - cell [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement) The header element.
             *  - date [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) The date for the cell.
             * @config {Function}
             */
            cellRenderer : null,

            /**
             * Configure as `true` to render weekends as {@link #config-disabledDates}.
             * @config {Boolean}
             */
            disableWeekends : null,

            /**
             * A config object to create a tooltip which will show on hover of a date cell
             * including disabled, weekend, and "other month" cells.
             *
             * It is the developer's responsibility to hook the `beforeshow` event
             * to either veto the show by returning `false` or provide contextual
             * content for the date.
             *
             * The tip instance will be primed with a `currentDate` property.
             * @config {Object}
             */
            tip : null,

            /**
             * The class name to add to calendar cells.
             * @config {String}
             * @private
             */
            cellCls : 'b-calendar-cell',

            /**
             * The class name to add to disabled calendar cells.
             * @config {String}
             * @private
             */
            disabledCls : 'b-disabled-date',

            /**
             * The class name to add to calendar cells which are in the previous or next month.
             * @config {String}
             * @private
             */
            otherMonthCls : 'b-other-month',

            /**
             * The class name to add to calendar cells which are weekend dates.
             * @config {String}
             * @private
             */
            weekendCls : 'b-weekend',

            /**
             * The class name to add to the calendar cell which contains today's date.
             * @config {String}
             * @private
             */
            todayCls : 'b-today'
        };
    }

    construct(config) {
        LocaleManagerSingelton.on({
            locale : calculateDayNames
        });
        calculateDayNames();
        super.construct(config);
        this.refresh();
    }

    doDestroy() {
        this.tip && this.tip.destroy();

        super.doDestroy();
    }

    ingestDate(date) {
        if (!(date instanceof Date)) {
            date = new Date(date);
            if (isNaN(date)) {
                throw new Error('CalendarPanel date ingestion must be passed a Date, or a valid argument to the Date constructor');
            }
            // Edge parses YYYY-MM-DD as UTC, not local, so in other locales, the value
            // may end up not being 00:00:00 in the date, so remove any time zone offset.
            const tzo = date.getTimezoneOffset();
            if (tzo) {
                date = DateHelper.add(date, tzo, 'minute');
            }
        }
        return DateHelper.clearTime(date);
    }

    set tip(tip) {
        this._tip = new Tooltip(Object.assign({
            forElement  : this.element,
            forSelector : '.b-calendar-cell'
        }, tip));
        this._tip.on({
            pointerOver : 'onTipOverCell',
            thisObj     : this
        });
    }

    get tip() {
        return this._tip;
    }

    get element() {
        return super.element;
    }

    set element(element) {
        const me = this;

        super.element = element;
        me.weekElements = Array.from(me.element.querySelectorAll('.b-calendar-week'));
        me.cellElements = Array.from(me.element.querySelectorAll('.b-calendar-week > div'));
    }

    /**
     * The date which this CalendarPanel encapsulates. Setting this causes the
     * content to be refreshed.
     * @property {Date}
     */
    set date(date) {
        const me = this;

        date = me._date = me.ingestDate(date);
        if (!me.month || me.month.month !== date.getMonth()) {
            me.month = new Month({
                date,
                weekStartDay : me.weekStartDay,
                sixWeeks     : me.sixWeeks
            });
        }
        me.refresh();
    }

    get date() {
        return this._date;
    }

    set month(month) {
        if (month instanceof Month) {
            this._month = month;
        }
        else {
            this.month.month = month;
            this.refresh();
        }
    }

    get month() {
        return this._month;
    }

    set year(year) {
        this.month.year = year;
        this.refresh();
    }

    get year() {
        return this.month.year;
    }

    set showWeekNumber(showWeekNumber) {
        const me = this;

        me.element.classList[showWeekNumber ? 'add' : 'remove']('b-show-week-number');
        if (me.floating) {
            // Must realign because content change might change dimensions
            if (!me.isAligning) {
                me.realign();
            }
        }
    }

    refresh() {
        const me = this,
            today = DateHelper.clearTime(new Date()),
            { cellElements, weekElements, date, month, cellCls, disabledCls, otherMonthCls, weekendCls, todayCls } = me;

        // If we have not been initialized with a current date, use today
        if (!date) {
            return me.date = today;
        }

        // Clear all content and CSS
        for (let i = 0, len = cellElements.length; i < len; i++) {
            cellElements[i].className = cellElements[i].innerHTML = '';
        }

        for (let i = 0; i < 7; i++) {
            const cell = me.weekdayCells[i];

            cell.className = cell.innerHTML = '';
            if (me.headerRenderer) {
                me.headerRenderer(cell, i);
            }
            else {
                cell.innerHTML = shortDayNames[me.canonicalDayNumbers[i]];
            }
            cell.classList.add('b-calendar-day-header');
        }

        // Create cell content
        let weekIndex = 0,
            cellIndex = 0;

        month.eachWeek((week, dates) => {
            const weekElement = weekElements[weekIndex],
                weekCells = weekElement.children;

            weekCells[0].className = 'b-week-number-cell';
            if (me.weekRenderer) {
                me.weekRenderer(weekCells[0], week);
            }
            else {
                weekCells[0].innerHTML = week[1];
            }

            for (let i = 0; i < 7; i++) {
                const cellDate = dates[i],
                    cellDay = cellDate.getDay(),
                    cell = weekCells[i + 1],
                    cellClassList = cell.classList;

                cellClassList.add(cellCls);
                if (me.isDisabledDate(cellDate)) {
                    cellClassList.add(disabledCls);
                }
                if (cellDate.getMonth() !== month.month) {
                    cellClassList.add(otherMonthCls);
                }
                if (cellDay === 0 || cellDay === 6) {
                    cellClassList.add(weekendCls);
                }
                if (cellDate.getTime() === today.getTime()) {
                    cellClassList.add(todayCls);
                }
                cell.dataset.date = DateHelper.format(cellDate, 'YYYY-MM-DD');
                cell.dataset.cellIndex = cellIndex;

                if (me.cellRenderer) {
                    me.cellRenderer(cell, cellDate);
                }
                else {
                    cell.innerHTML = cellDate.getDate();
                }
                cellIndex++;
            }

            weekIndex++;
        });
        if (me.floating) {
            // Must realign because content change might change dimensions
            if (!me.isAligning) {
                me.realign();
            }
        }
    }

    isDisabledDate(date) {
        const day = date.getDay(),
            disabledDates = this.disabledDates;

        if (this.disableWeekends && (day === 0 || day === 6)) {
            return true;
        }

        if (disabledDates) {
            if (typeof disabledDates === 'function') {
                return disabledDates(date);
            }
            if (Array.isArray(disabledDates)) {
                return disabledDates.some(d => DateHelper.clearDate(d, true).getTime() === DateHelper.clearDate(date, true).getTime());
            }
        }
    }

    get bodyConfig() {
        const result = super.bodyConfig,
            weeksContainerChildren = [];

        result.children = [{
            tag       : 'div',
            className : 'b-calendar-row b-calendar-weekdays',
            children  : this.dayNameCells
        }, {
            // `notranslate` prevents google translate messing up the DOM, https://github.com/facebook/react/issues/11538
            className : 'b-weeks-container notranslate',
            reference : 'weeksElement',
            children  : weeksContainerChildren
        }];
        for (let i = 0; i < 6; i++) {
            let weekRow = {
                className : 'b-calendar-row b-calendar-week',
                children  : []
            };
            // Generate cells for week number plus seven day cells
            for (let j = 0; j < 8; j++) {
                weekRow.children.push({});
            }
            weeksContainerChildren.push(weekRow);
        }

        return result;
    }

    /**
     * Set to 0 for Sunday (the default), 1 for Monday etc.
     */
    set weekStartDay(weekStartDay) {
        const me = this;
        me.dayNames = [];
        me.dayNumbers = [];
        me.canonicalDayNumbers = [];
        me._weekStartDay = weekStartDay != null ? weekStartDay : DateHelper.weekStartDay;

        // So, if they set weekStartDay to 1 meaning Monday which is ISO standard, we will
        // have mapping of internal day number to canonical day number (as used by Date class)
        // and to abbreviated day name like this:
        // canonicalDayNumbers = [1, 2, 3, 4, 5, 6, 0] // Use for translation from our day number to Date class's day number
        // dayNumbers          = [6, 0, 1, 2, 3, 4, 5] // Use for translation from Date object's day number to ours
        // dayNames            = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
        for (let i = 0; i < 7; i++) {
            const canonicalDay = (me._weekStartDay + i) % 7;
            me.canonicalDayNumbers[i] = canonicalDay;
            me.dayNumbers[canonicalDay] = i;
            me.dayNames[i] = shortDayNames[canonicalDay];
        }
    }

    get weekStartDay() {
        if (!this.hasOwnProperty('_weekStartDay')) {
            this.weekStartDay = undefined;
        }
        return this._weekStartDay;
    }

    get dayNameCells() {
        const me = this,
            weekNumberHeader = document.createElement('div'),
            result = [weekNumberHeader],
            weekdayCells = me.weekdayCells = [];

        weekNumberHeader.className = 'b-week-number-cell';

        // Ensure our week is initialized by set weekStartDay
        me._thisIsAUsedExpression(me.weekStartDay);

        for (let i = 0; i < 7; i++) {
            const cell = document.createElement('div');
            result.push(cell);
            weekdayCells.push(cell);
        }
        return result;
    }

    onTipOverCell({ source : tip, target }) {
        tip.date = DateHelper.parse(target.dataset.date, 'YYYY-MM-DD');
    }
}

function calculateDayNames() {
    shortDayNames.length = 0;
    for (let date = 2; date < 9; date++) {
        d.setDate(date);
        shortDayNames.push(DateHelper.format(d, 'ddd'));
    }
}

// In the Date class, 0=Sunday, 6=Saturday. 2nd Jan 2000 is Sunday.
// Collect local shortDayNames in default order.
const d = new Date('2000-01-01T00:00:00'),
    shortDayNames = [];

CalendarPanel._$name = 'CalendarPanel'; BryntumWidgetAdapterRegister.register('calendarpanel', CalendarPanel);

/**
 * @module Core/widget/layout/Fit
 */

/**
 * A helper class for containers which must manage a single child widget which must fit the container's
 * {@link Core.widget.Widget#property-contentElement contentElement}.
 */
class Fit extends Layout {
    static get $name() {
        return 'Fit';
    }

    static get defaultConfig() {
        return {
            containerCls : 'b-fit-container',

            itemCls : 'b-fit-item'
        };
    }
}

// Layouts must register themselves so that the static layout instantiation
// in Layout knows what to do with layout type names
Fit._$name = 'Fit'; Layout.registerLayout(Fit);

/**
 * @module Core/widget/Editor
 */

/**
 * Displays an input field, optionally editing a field of a record at a particular position.
 *
 * Offers events to signal edit completion upon `ENTER` or focus loss (if configured to do so),
 * or edit cancellation on `ESC`, or focus loss if configured that way.
 * @extends Core/widget/Container
 *
 * @classType Editor
 */
class Editor extends Container {
    //region Config
    static get $name() {
        return 'Editor';
    }

    static get defaultConfig() {
        return {
            positioned : true,

            hidden : true,

            layout : 'fit',

            /**
             * A config object, or the `type` string of the widget (usually a {@link Core.widget.Field Field} subclass,
             * i.e. {@link Core.widget.TextField TextField}) which this editor will encapsulate.
             * @config {Object|String}
             * @default
             */
            inputField : 'textfield',

            /**
             * What action should be taken when focus moves out of the editor, either by `TAB` or clicking outside.
             * May be `'complete'` or `'cancel`'. Any other value results in no action being taken upon focus leaving the editor
             * leaving the application to listen for the {@link Core.widget.Widget#event-focusout focusout} event.
             * @config {String}
             * @default
             */
            blurAction : 'complete',

            /**
             * The name of the `key` which completes the edit.
             *
             * See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values for key names.
             * @config {String}
             * @default
             */
            completeKey : 'Enter',

            /**
             * The name of the `key` which cancels the edit.
             *
             * See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values for key names.
             * @config {String}
             * @default
             */
            cancelKey : 'Escape',

            /**
             * Configure as `true` to allow editing to complete when the field is invalid. Editing may always be _canceled_.
             * This is deprecated and has been replaced by the more flexible {@link #config-invalidAction} option.
             * @config {Boolean}
             * @deprecated 2.4
             * @default false
             */
            allowInvalid : null,

            /**
             * How to handle a request to complete the edit if the field is invalid. There are three choices:
             *  - `block` The default. The edit is not exited, the field remains focused.
             *  - `allow` Allow the edit to be completed.
             *  - `revert` The field value is reverted and the edit is completed.
             * @config {String}
             * @default
             */
            invalidAction : 'block',

            /**
             * Configure as `true` to have editing complete as soon as the field fires its `change` event.
             * @config {Boolean}
             * @default false
             */
            completeOnChange : null
        };
    }

    //endregion

    //region Events

    /**
     * Fired before the editor is shown to start an edit operation. Returning `false` from a handler vetoes the edit operation.
     * @event beforestart
     * @param {Object} value - The value to be edited.
     * @preventable
     */
    /**
     * Fired when an edit operation has begun.
     * @event start
     * @param {Object} value - The starting value of the field.
     * @param {Core.widget.Editor} source - The Editor that triggered the event.
     */
    /**
     * Fired when an edit completion has been requested, either by `ENTER`, or focus loss (if configured to complete on blur).
     * The completion may be vetoed, in which case, focus is moved back into the editor.
     * @event beforeComplete
     * @param {Object} oldValue - The original value.
     * @param {Object} value - The new value.
     * @param {Core.widget.Editor} source - The Editor that triggered the event.
     * @param {Function} [finalize] An async function may be injected into this property
     * which performs asynchronous finalization tasks such as complex validation of confirmation. The
     * value `true` or `false` must be returned.
     * @param {Object} [finalize.context] An object describing the editing context upon requested completion of the edit.
     * @preventable
     */
    /**
     * Edit has been completed, and any associated record or element has been updated.
     * @event complete
     * @param {Object} oldValue - The original value.
     * @param {Object} value - The new value.
     * @param {Core.widget.Editor} source - The Editor that triggered the event.
     */
    /**
     * Fired when cancellation has been requested, either by `ESC`, or focus loss (if configured to cancel on blur).
     * The cancellation may be vetoed, in which case, focus is moved back into the editor.
     * @event beforeCancel
     * @param {Object} oldValue - The original value.
     * @param {Object} value - The new value.
     * @param {Core.widget.Editor} source - The Editor that triggered the event.
     * @preventable
     */
    /**
     * Edit has been canceled without updating the associated record or element.
     * @event cancel
     * @param {Object} oldValue - The original value.
     * @param {Object} value - The value of the field.
     * @param {Core.widget.Editor} source - The Editor that triggered the event.
     */
    /**
     * Fire to relay a `keypress` event from the field.
     * @event keypress
     * @param {Event} event - The key event.
     */

    //endregion

    afterConfigure() {
        const me = this;
        super.afterConfigure();

        if (me.completeKey || me.cancelKey) {
            EventHelper.on({
                element : me.element,
                keydown : 'onKeyDown',
                thisObj : me
            });
        }

        LocaleManagerSingelton.on({
            locale  : 'onLocaleChange',
            thisObj : me
        });
    }

    onLocaleChange() {
        const { inputField } = this;

        if (inputField && !inputField.isDestroyed) {
            // All Field subclasses have this method, but if `inputField` is a custom widget,
            // `syncInputFieldValue` has to be implemented
            if (inputField.syncInputFieldValue) {
                inputField.syncInputFieldValue(true);
            }
        }
    }

    /**
     * Start editing
     * @param {Object} editObject An object containing details about what to edit.
     * @param {HTMLElement|Core.helper.util.Rectangle} editObject.target the element or Rectangle to align to.
     * @param {String} [editObject.align=t0-t0] How to align to the target.
     * @param {Boolean} [editObject.matchSize=true] Match editor size to target size.
     * @param {Boolean} [editObject.matchFont=true] Match editor's font-size size to target's font-size.
     * @param {Core.data.Model} [editObject.record] The record to edit.
     * @param {String} [editObject.field] The field name in the record to edit. This defaults to the `name` of the {@link #config-inputField}.
     * Also if record has method set + capitalized field, method will be called, e.g. if record has method named
     * `setFoobar` and this config is `foobar`, then instead of `record.foobar = value`, `record.setFoobar(value)` will be called.
     * @param {Object} [editObject.value] The value to edit.
     * @param {Boolean} [editObject.focus=true] Focus the field.
     * @param {Boolean} [editObject.fitTargetContent] Pass `true` to allow the Editor to expand beyond the
     * width of its target element if its content overflows horizontally. This is useful if the editor has
     * triggers to display, such as a combo.
     */
    startEdit({
        target,
        align = 't0-t0',
        hideTarget = false,
        matchSize = true,
        matchFont = true,
        fitTargetContent = false,
        value,
        record,
        field = this.inputField.name,
        focus = true
    }) {
        const
            me               = this,
            { inputField }   = me,
            targetRect       = (target instanceof Rectangle) ? target : Rectangle.inner(target),
            targetFontSize   = DomHelper.getStyleValue(target, 'font-size'),
            targetFontFamily = DomHelper.getStyleValue(target, 'font-family');

        if (me.trigger('beforestart', { value }) !== false) {
            if (record && field && value === undefined) {
                me.record = record;
                me.dataField = field;
                value = record[field];
            }
            if (matchSize) {
                me.width = targetRect.width;
                me.height = targetRect.height;
            }
            if (inputField.input) {
                if (matchFont) {
                    inputField.input.style.fontSize = targetFontSize;
                    inputField.input.style.fontFamily = targetFontFamily;
                }
                else {
                    inputField.input.style.fontSize = inputField.input.style.fontFamily = '';
                }
            }

            // In case our finalize code set it to invalid, start it clear of errors.
            if (inputField.clearError) {
                inputField.clearError();
            }

            inputField.value = value;

            // The initialValue is what the revertOnEscape uses by preference before it uses its valueOnFocus.
            // In an Editor, it can focus in and out but still need that correct initial value.
            inputField.initialValue = inputField.value;

            me.showBy({
                target,
                align
            });

            if (fitTargetContent) {
                // Input doesn't fit, so widen it
                const overflow = inputField.input.scrollWidth - inputField.input.clientWidth;
                if (overflow > 0) {
                    me.width += overflow + DomHelper.scrollBarWidth;
                }
            }

            if (focus && me.inputField.focus) {
                me.inputField.focus();
            }
            if (target.nodeType === 1) {
                target.classList.add('b-editing');
                if (hideTarget) {
                    target.classList.add('b-hide-visibility');
                }
            }
            // Passed value may have been '10/06/2019', send the live field value to startedit
            me.trigger('start', { value : inputField.value });
            me.oldValue = inputField.value;

            // If the value from th value getter is an array, we must clone it because
            // if it's the same *instance*, the ObjectHelper.isEqual test in completeEdit
            // will find that there are no changes.
            if (Array.isArray(me.oldValue)) {
                me.oldValue = me.oldValue.slice();
            }
            return true;
        }
        return false;
    }

    refreshEdit() {
        if (this.isVisible) {
            const { record, dataField, inputField } = this;

            if (record && dataField) {
                const value = record[dataField];

                // Only update the field if the value has changed
                if (!ObjectHelper.isEqual(inputField.value, value)) {
                    inputField.value = value;
                }
            }
        }
    }

    onKeyDown(event) {
        const me = this;

        switch (event.key) {
            case me.completeKey:
                me.completeEdit();
                event.stopImmediatePropagation();
                break;
            case me.cancelKey:
                me.cancelEdit();
                event.stopImmediatePropagation();
                break;
        }
        me.trigger('keydown', { event });
    }

    onFocusOut(event) {
        super.onFocusOut(event);

        if (!this.isFinishing) {
            const method = this[`${this.blurAction}Edit`];

            if (method) {
                method.call(this);
            }
        }
    }

    set allowInvalid(allowInvalid) {
        this._allowInvalid = allowInvalid;
        this.invalidAction = allowInvalid ? 'allow' : 'block';
    }

    get allowInvalid() {
        return this._allowInvalid;
    }

    /**
     * Complete the edit, and, if associated with a record, update the record if possible.
     * If editing is completed, the editor is hidden.
     *
     * If the field is invalid, the `{@link #config-invalidAction}` config is used to decide
     * upon the course of action.
     *
     * If a {@link #event-beforeComplete} handler returns `false` then editing is not completed.
     *
     * If the field's valus has not been changed, then editing is terminated through {@link #function-cancelEdit}.
     *
     * @returns `true` if editing ceased, `false` if the editor is still active.
     * @async
     */
    async completeEdit(finalize) {
        const me = this,
            { inputField, oldValue, record } = me,
            invalidAction = inputField.invalidAction || (inputField.allowInvalid === false ? 'block' : me.invalidAction),
            { value } = inputField;

        // If we're configured not to allow invalid values, refocus the field in case complete was triggered by focusout.
        if (!inputField.isValid) {
            if (invalidAction === 'block') {
                inputField.focus && inputField.focus();
                return false;
            }
            else if (invalidAction === 'revert') {
                me.cancelEdit();
                return true;
            }
        }
        // No change means a cancel.
        else if (ObjectHelper.isEqual(value, oldValue)) {
            me.cancelEdit();
            return true;
        }
        // Allow veto of the completion
        else {
            const context = { inputField, record, value, oldValue };

            if (me.trigger('beforeComplete', context) === false) {
                inputField.focus && inputField.focus();
            }
            else {
                // CellEdit#onEditorBeforeComplete injects editorContext into the basic context
                if (!finalize) {
                    finalize = context.finalize || (context.editorContext && context.editorContext.finalize);
                }

                // Allow async finalization of the editing, implementer may want to show a confirmation popup etc
                if (finalize) {
                    let result = await finalize(context);

                    if (result === true) {
                        me.onEditComplete();
                    }
                    else {
                        if (inputField.setError) {
                            const
                                error = result || inputField.L('invalidValue'),
                                clearError = () => {
                                    listeners();
                                    inputField.clearError(error);
                                },
                                listeners = inputField.on({
                                    change : clearError,
                                    input  : clearError
                                });

                            // Mark as invalid. Because this is decided upon without the knowledge
                            // of the field, this state will be rescinded upon the next change of
                            // input field.
                            inputField.setError(error);
                        }
                        if (invalidAction === 'block') {
                            inputField.focus && inputField.focus();
                        }
                        else if (invalidAction === 'revert') {
                            inputField.value = oldValue;
                            result = true;
                        }
                        result = false;
                    }
                    return result;
                }
                // Successful completion
                else {
                    me.onEditComplete();
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Cancel the edit and hide the editor.
     */
    cancelEdit() {
        const me = this,
            { inputField, oldValue, lastAlignSpec } = me,
            { target } = lastAlignSpec,
            { value } = inputField;

        if (!me.isFinishing && me.trigger('beforeCancel', { value : value, oldValue }) !== false) {
            // Hiding must not trigger our blurAction
            me.isFinishing = true;
            me.hide();
            me.trigger('cancel', { value, oldValue });
            if (target.nodeType === 1) {
                target.classList.remove('b-editing');
                target.classList.remove('b-hide-visibility');
            }
            me.isFinishing = false;
        }
    }

    // Handle updating what needs to be updated.
    onEditComplete() {
        const me = this,
            { record, dataField, inputField, oldValue, lastAlignSpec } = me,
            { target } = lastAlignSpec,
            { value } = inputField;

        if (!me.isFinishing) {
            // Hiding must not trigger our blurAction
            me.isFinishing = true;
            me.hide();

            if (record) {
                const setterName = `set${StringHelper.capitalizeFirstLetter(dataField)}`;
                if (record[setterName]) {
                    record[setterName](value);
                }
                else {
                    record[dataField] = value;
                }
            }
            me.trigger('complete', { value, oldValue });
            if (target.nodeType === 1) {
                target.classList.remove('b-editing');
                target.classList.remove('b-hide-visibility');
            }

            me.isFinishing = false;
        }
    }

    doDestroy() {
        if (this.createdInputField) {
            this.inputField.destroy();
        }
        super.doDestroy();
    }

    set owner(owner) {
        this._owner = owner;
    }

    // This is a positioned widget appended to a Widget's contentElement. It may have no owner link.
    // Grab the owner by finding what widget it is inside.
    get owner() {
        return this._owner || IdHelper.fromElement(this.element.parentNode);
    }

    set inputField(inputField) {
        const me = this;

        if (me._inputField) {
            me._inputField.destroy();
        }
        if (typeof inputField === 'string') {
            inputField = {
                type : inputField
            };
        }
        if (inputField instanceof Widget) {
            me._inputField = inputField;
        }
        else {
            me._inputField = WidgetHelper.createWidget(inputField);
            me.createdInputField = true; // So we know we can destroy it
        }

        if (me.completeOnChange) {
            me._inputField.on({
                change  : 'onInputFieldChange',
                thisObj : me
            });
        }

        me._inputField.parent = me;

        me.removeAll();
        me.add(inputField);
    }

    get inputField() {
        return this.items[0];
    }

    onInputFieldChange() {
        if (this.containsFocus) {
            this.completeEdit();
        }
    }
}

Editor._$name = 'Editor'; BryntumWidgetAdapterRegister.register('editor', Editor);

/**
 * @module Core/widget/DatePicker
 */

/**
 * A Panel which can display a month of date cells, which navigates between the cells,
 * fires events upon user selection actions, optionally navigates to other months
 * in response to UI gestures, and optionally displays information about each date cell.
 *
 * This class is not intended for use in applications. It is used internally by the
 * {@link Core.widget.DateField} class.
 *
 * @classtype datepicker
 */
class DatePicker extends CalendarPanel {
    static get $name() {
        return 'DatePicker';
    }

    static get defaultConfig() {
        return {
            focusable : true,

            tools : {
                prevMonth : {
                    align   : 'start',
                    cls     : 'b-icon b-icon-angle-left',
                    handler : 'gotoPrevMonth'
                },
                nextMonth : {
                    align   : 'end',
                    cls     : 'b-icon b-icon-angle-right',
                    handler : 'gotoNextMonth'
                }
            },

            header : {
                title      : '<div class="b-editable b-datepicker-month" reference="monthElement"></div> <div class="b-editable b-datepicker-year" reference="yearElement"></div>',
                titleAlign : 'center'
            },

            /**
             * The minimum selectable date. Selection of and navigtion to dates prior
             * to this date will not be possible.
             * @config {Date}
             */
            minDate : null,

            /**
             * The maximum selectable date. Selection of and navigtion to dates after
             * this date will not be possible.
             * @config {Date}
             */
            maxDate : null,

            /**
             * The class name to add to the calendar cell whose date which is outside of the
             * {@link #config-minDate}/{@link #config-maxDate} range.
             * @config {String}
             * @private
             */
            outOfRangeCls : 'b-out-of-range',

            /**
             * The class name to add to the currently focused calendar cell.
             * @config {String}
             * @private
             */
            activeCls : 'b-active-date',

            /**
             * The class name to add to selected calendar cells.
             * @config {String}
             * @private
             */
            selectedCls : 'b-selected-date',

            /**
             * By default, disabled dates cannot be navigated to, and they are skipped over
             * during keyboard navigation. Configure this as `true` to enable navigation to
             * disabled dates.
             * @config {Boolean}
             * @default
             */
            focusDisabledDates : null,

            /**
             * Configure as `true` to enable selecting a single date range by selecting a
             * start and end date.
             * @config {Boolean}
             * @default
             */
            multiSelect : false,

            /**
             * By default, the month and year show their editor on hover instead of click.
             * On a touch platform, they both show the editor on tap.
             * @config
             * @default
             */
            editOnHover : true
        };
    }

    /**
     * Fires when a date is selected. If {@link #config-multiSelect} is specified, this
     * will fire upon deselection and selection of dates.
     * @event selectionChange
     * @param {Date[]} selection The selected date. If {@link #config-multiSelect} is specified
     * this may be a two element array specifying start and end dates.
     */

    construct(config) {
        const me = this;

        LocaleManagerSingelton.on({
            locale  : 'onLocaleChange',
            thisObj : me
        });
        me.selection = [];
        me.refresh = me.createOnFrame(me.refresh);
        super.construct(config);
        me.element.setAttribute('aria-activedescendant', `${me.id}-active-day`);

        EventHelper.on({
            element   : me.element,
            mouseover : 'onPickerMouseover',
            mousedown : 'onPickerMousedown',
            click     : 'onPickerClick',
            keydown   : 'onPickerKeyDown',
            thisObj   : me
        });
    }

    doDestroy() {
        if (this._yearEditor) {
            this._yearEditor.destroy();
        }
        if (this._monthEditor) {
            this._monthEditor.destroy();
        }
        super.doDestroy();
    }

    get focusElement() {
        return this.element;
    }

    eachWidget(fn, deep) {
        const widgets = this.items || [];

        if (this._yearEditor) {
            widgets.unshift(this._yearEditor);
        }
        if (this._monthEditor) {
            widgets.unshift(this._monthEditor);
        }

        for (let i = 0; i < widgets.length; i++) {
            const widget = widgets[i];

            if (fn(widget) === false) {
                return;
            }

            if (deep && widget.eachWidget) {
                widget.eachWidget(fn, deep);
            }
        }
    }

    refresh() {
        const
            me  = this,
            sbw = DomHelper.scrollBarWidth;

        super.refresh();
        me.monthElement.style.minWidth = `calc(${me.maxMonthLength + 1}ch + ${sbw}px)`;
        me.monthElement.innerHTML = DateHelper.format(me.month.date, 'MMMM');
        me.yearElement.style.minWidth = sbw ? `calc(3ch + ${sbw}px` : '7ch';
        me.yearElement.innerHTML = DateHelper.format(me.month.date, 'YYYY');
    }

    cellRenderer(cell, cellDate) {
        const me = this,
            { activeCls, selectedCls } = me,
            cellClassList = cell.classList;

        cell.innerHTML = cellDate.getDate();
        cell.setAttribute('aria-label', DateHelper.format(cellDate, 'MMMM D, YYYY'));

        if (me.isActiveDate(cellDate)) {
            cellClassList.add(activeCls);
            cell.id = `${me.id}-active-day`;
        }
        if (me.isSelectedDate(cellDate)) {
            cellClassList.add(selectedCls);
        }
        if (me.minDate && cellDate < me.minDate) {
            cellClassList.add(me.outOfRangeCls);
        }
        else if (me.maxDate && cellDate > me.maxDate) {
            cellClassList.add(me.outOfRangeCls);
        }
    }

    onPickerMousedown(event) {
        event.preventDefault();
    }

    onPickerMouseover(event) {
        if (this.editOnHover) {
            const editable   = DomHelper.up(event.target, '.b-editable');

            if (editable) {
                return this.onEditGesture(event);
            }
        }
    }

    onPickerClick(event) {
        const
            me         = this,
            { target } = event,
            cell       = DomHelper.up(target, `.${me.cellCls}:not(.${me.disabledCls}):not(.${me.outOfRangeCls})`),
            editable   = DomHelper.up(target, '.b-editable');

        if (cell) {
            return me.onCellClick(event);
        }
        if ((!me.editOnHover || DomHelper.isTouchEvent) && editable) {
            return me.onEditGesture(event);
        }
        if (me._monthEditor && !me._monthEditor.owns(event)) {
            me._monthEditor.cancelEdit();
        }
        if (me._yearEditor && !me._yearEditor.owns(event)) {
            me._yearEditor.cancelEdit();
        }
    }

    onCellClick(event) {
        this.onDateActivate(DateHelper.parse(event.target.dataset.date, 'YYYY-MM-DD'), event);
    }

    onEditGesture(event) {
        const
            me         = this,
            { month }  = me,
            { target } = event;

        if (target === me.monthElement) {
            me.monthEditor.startEdit({
                target,
                value            : month.month,
                fitTargetContent : false,
                hideTarget       : true
            });
        }
        else if (target === me.yearElement) {
            me.yearEditor.minWidth = `calc(50px + ${DomHelper.scrollBarWidth}px)`;
            me.yearEditor.startEdit({
                target,
                value            : month.year,
                fitTargetContent : true,
                hideTarget       : true
            });
        }
    }

    onDateActivate(date, event) {
        const me = this,
            { lastClickedDate, selection } = me;

        me.activeDate = date;
        me.lastClickedDate = date;

        // Handle multi selecting.
        // * single contiguous date range, eg: an event start and end
        // * multiple discontiguous ranges
        if (me.multiSelect) {
            if (me.multiRange) ;
            else if (!lastClickedDate || date.getTime() !== lastClickedDate.getTime()) {
                if (lastClickedDate && event.shiftKey) {
                    selection[1] = date;
                    selection.sort();
                }
                else {
                    selection.length = 0;
                    selection[0] = date;
                }

                me.trigger('selectionChange', {
                    selection
                });
            }
        }
        else {
            if (!me.value || me.value.getTime() !== date.getTime()) {
                me.value = date;
            }
            else {
                me.hide();
            }
        }
    }

    onPickerKeyDown(keyEvent) {
        const
            me = this,
            keyName = keyEvent.key.trim() || keyEvent.code,
            activeDate = me.activeDate,
            newDate = new Date(activeDate);

        if (activeDate) {
            do {
                switch (keyName) {
                    case 'Escape':
                        me.hide();
                        break;
                    case 'ArrowLeft':
                        // Disable browser use of this key.
                        // Ctrl+ArrowLeft navigates back.
                        // ArrowLeft scrolls if there is horizontal scroll.
                        keyEvent.preventDefault();

                        if (keyEvent.ctrlKey) {
                            newDate.setMonth(newDate.getMonth() - 1);
                        }
                        else {
                            newDate.setDate(newDate.getDate() - 1);
                        }
                        break;
                    case 'ArrowUp':
                        // Disable browser use of this key.
                        // ArrowUp scrolls if there is vertical scroll.
                        keyEvent.preventDefault();

                        newDate.setDate(newDate.getDate() - 7);
                        break;
                    case 'ArrowRight':
                        // Disable browser use of this key.
                        // Ctrl+ArrowRight navigates forwards.
                        // ArrowRight scrolls if there is horizontal scroll.
                        keyEvent.preventDefault();

                        if (keyEvent.ctrlKey) {
                            newDate.setMonth(newDate.getMonth() + 1);
                        }
                        else {
                            newDate.setDate(newDate.getDate() + 1);
                        }
                        break;
                    case 'ArrowDown':
                        // Disable browser use of this key.
                        // ArrowDown scrolls if there is vertical scroll.
                        keyEvent.preventDefault();

                        newDate.setDate(newDate.getDate() + 7);
                        break;
                    case 'Enter':
                        me.onDateActivate(activeDate, keyEvent);
                        break;
                }
            } while (me.isDisabledDate(newDate) && !me.focusDisabledDates);

            // Don't allow navigation to outside of date bounds.
            if (me.minDate && newDate < me.minDate) {
                return;
            }
            if (me.maxDate && newDate > me.maxDate) {
                return;
            }
            me.activeDate = newDate;
        }
    }

    set minDate(minDate) {
        this._minDate = minDate ? this.ingestDate(minDate) : null;
        this.refresh();
    }

    get minDate() {
        return this._minDate;
    }

    set maxDate(maxDate) {
        this._maxDate = maxDate ? this.ingestDate(maxDate) : null;
        this.refresh();
    }

    get maxDate() {
        return this._maxDate;
    }

    set activeDate(activeDate) {
        const me = this;

        if (activeDate) {
            me._activeDate = me.ingestDate(activeDate);
        }
        else {
            me._activeDate = DateHelper.clearTime(new Date());
        }

        // New active date is in another month
        if (me.month.month !== me._activeDate.getMonth()) {
            me.month.date = me._activeDate;
        }
        me.refresh();
    }

    get activeDate() {
        return this._activeDate;
    }

    set value(date) {
        const me = this,
            { selection } = me;

        let changed;

        if (date) {
            date = me.ingestDate(date);
            if (!me.value || date.getTime() !== me.value.getTime()) {
                selection.length = 0;
                selection[0] = date;
                changed = true;
            }
            me.date = date;
        }
        else {
            changed = selection.length;
            selection.length = 0;

            // Clearing the value - go to today's calendar
            me.date = new Date();
        }

        if (changed) {
            me.trigger('selectionChange', {
                selection
            });
        }
    }

    get value() {
        return this.selection[this.selection.length - 1];
    }

    gotoPrevMonth() {
        const date = this.date;

        date.setMonth(date.getMonth() - 1);
        this.date = date;
    }

    gotoNextMonth() {
        const date = this.date;

        date.setMonth(date.getMonth() + 1);
        this.date = date;
    }

    isActiveDate(date) {
        return this.activeDate && this.ingestDate(date).getTime() === this.activeDate.getTime();
    }

    isSelectedDate(date) {
        return this.selection.some(d => d.getTime() === date.getTime());
    }

    get monthEditor() {
        const me = this;

        if (!me._monthEditor) {
            me._monthEditor = new Editor({
                owner      : me,
                appendTo   : me.element,
                inputField : me.monthInput = new Combo({
                    editable                : false,
                    autoExpand              : !me.editOnHover,
                    items                   : me.monthItems,
                    highlightExternalChange : false,
                    picker                  : {
                        align : {
                            align : 't0-b0'
                        },
                        cls        : 'b-month-picker-list',
                        scrollable : {
                            overflowX : false
                        }
                    }
                }),
                completeOnChange : true,
                listeners        : {
                    complete : 'onMonthPicked',
                    thisObj  : me
                }
            });
        }

        return me._monthEditor;
    }

    onMonthPicked({ value }) {
        this.month = value;
    }

    get yearEditor() {
        const me = this;

        if (!me._yearEditor) {
            me._yearEditor = new Editor({
                owner      : me,
                appendTo   : me.element,
                inputField : me.yearInput = new Combo({
                    editable                : false,
                    autoExpand              : !me.editOnHover,
                    items                   : me.yearItems,
                    highlightExternalChange : false,
                    picker                  : {
                        cls        : 'b-year-picker-list',
                        scrollable : {
                            overflowX : false
                        }
                    }
                }),
                completeOnChange : true,
                listeners        : {
                    complete : 'onYearPicked',
                    thisObj  : me
                }
            });
        }

        return me._yearEditor;
    }

    onYearPicked({ value }) {
        this.year = value;
    }

    get monthItems() {
        return DateHelper.getMonthNames().map((m, i) => [i, m]);
    }

    get yearItems() {
        const
            result = [],
            middle = new Date().getFullYear();

        for (let y = middle - 20; y < middle + 21; y++) {
            result.push(y);
        }

        return result;
    }

    get maxMonthLength() {
        if (!this._maxMonthLength) {
            this._maxMonthLength = 0;

            for (let i = 0, months = this.monthItems; i < 12; i++) {
                this._maxMonthLength = Math.max(this._maxMonthLength, months[i][1].length);
            }
        }

        return this._maxMonthLength;
    }

    onLocaleChange() {
        if (this._monthEditor) {
            this._monthEditor.doDestroy();
            this._monthEditor = null;
        }
        if (this._yearEditor) {
            this._yearEditor.doDestroy();
            this._yearEditor = null;
        }
        this._maxMonthLength = 0;
    }
}

DatePicker._$name = 'DatePicker'; BryntumWidgetAdapterRegister.register('datepicker', DatePicker);

//TODO: picker icon (calendar) should show day number

/**
 * @module Core/widget/DateField
 */

/**
 * Date field widget (text field + date picker).
 *
 * This field can be used as an {@link Grid.column.Column#config-editor editor} for the {@link Grid.column.Column Column}.
 * It is used as the default editor for the {@link Grid.column.DateColumn DateColumn}.
 *
 * @extends Core/widget/PickerField
 *
 * @example
 * // minimal DateField config with date format specified
 * let dateField = new DateField({
 *   format: 'YYMMDD'
 * });
 *
 * @classType datefield
 * @externalexample widget/DateField.js
 */
class DateField extends PickerField {
    //region Config
    static get $name() {
        return 'DateField';
    }

    static get defaultConfig() {
        return {
            /**
             * Format for date displayed in field. Defaults to using long date format, as defined by current locale (`L`)
             * @config {String}
             * @default
             */
            format : 'L',

            // same for all languages
            fallbackFormat : 'YYYY-MM-DD',
            timeFormat     : 'HH:mm:ss:SSS',

            /**
             * A flag which indicates what time should be used for selected date.
             * `false` by default which means time is reset to midnight.
             *
             * Possible options are:
             * - `false` to reset time to midnight
             * - `true` to keep original time value
             * - `17:00` a string which is parsed automatically
             * - `new Date(2020, 0, 1, 17)` a date object to copy time from
             *
             * @config {Boolean|Date|String}
             * @default
             */
            keepTime : false,

            /**
             * Format for date in picker. Uses localized format per default
             * @config {String}
             */
            pickerFormat : null,

            triggers : {
                expand : {
                    cls     : 'b-icon-calendar',
                    handler : 'onTriggerClick',
                    weight  : 200
                }
            },

            stepTriggers : {
                back : {
                    cls     : 'b-icon-angle-left b-step-trigger',
                    handler : 'onBackClick',
                    align   : 'start',
                    weight  : 100
                },

                forward : {
                    cls     : 'b-icon-angle-right b-step-trigger',
                    handler : 'onForwardClick',
                    align   : 'end',
                    weight  : 100
                }
            },

            // An optional extra CSS class to add to the picker container element
            calendarContainerCls : '',

            /**
             * Min value
             * @config {String|Date}
             */
            min : null,

            /**
             * Max value
             * @config {String|Date}
             */
            max : null,

            /**
             * Time increment duration value. If specified, `forward` and `back` triggers are displayed.
             * The value is taken to be a string consisting of the numeric magnitude and the units.
             * The units may be a recognised unit abbreviation of this locale or the full local unit name.
             * For example `'1d'` or `'1w'` or `'1 week'`. This may be specified as an object containing
             * two properties: `magnitude`, a Number, and `unit`, a String
             * @config {String|Number|Object}
             */
            step : null,

            /**
             * A config object used to configure the {@link Core.widget.DatePicker datePicker}.
             * ```javascript
             * dateField = new DateField({
             *      picker    : {
             *          multiSelect : true
             *      }
             *  });
             * ```
             * @config {Object}
             */
            picker : null,

            /**
             * Value, which can be a Date or a string. If a string is specified, it will be converted using the
             * specified {@link #config-format}
             * @config {String|Date}
             */
            value : null
        };
    }

    //endregion

    //region Init & destroy

    inputTemplate() {
        const me = this;
        return TemplateHelper.tpl`<input type="${me.inputType || 'text'}"
            reference="input"
            class="${me.inputCls || ''}"
            min="${me.min}"
            max="${me.max}"
            placeholder="${me.placeholder}"
            name="${me.name || me.id}"
            id="${me.id + '_input'}"/>`;
    }

    /**
     * Creates default picker widget
     *
     * @internal
     */
    createPicker(picker) {
        const me = this;

        picker = new DatePicker(Object.assign({
            owner        : me,
            forElement   : me[me.pickerAlignElement],
            floating     : true,
            scrollAction : 'realign',
            align        : {
                align    : 't0-b0',
                axisLock : true,
                anchor   : me.overlayAnchor,
                target   : me[me.pickerAlignElement]
            },
            value   : me.value,
            minDate : me.min,
            maxDate : me.max,

            onSelectionChange : ({ selection, source : picker }) => {
                // We only care about what DatePicker does if it has been opened
                if (picker.isVisible) {
                    me._isUserAction = true;
                    me.value = selection[0];
                    me._isUserAction = false;
                    picker.hide();
                }
            }
        }, picker));

        if (me.calendarContainerCls) {
            picker.element.classList.add(me.calendarContainerCls);
        }

        return picker;
    }

    //endregion

    set triggers(triggers) {
        super.triggers = ObjectHelper.assign(triggers, this.stepTriggers);
    }

    get triggers() {
        return super.triggers;
    }

    //region Click listeners

    onBackClick() {
        const
            me      = this,
            { min } = me;

        if (!me.readOnly && me.value) {
            const newValue = DateHelper.add(me.value, -1 * me._step.magnitude, me._step.unit);
            if (!min || min.getTime() <= newValue) {
                me.value = newValue;
            }
        }
    }

    onForwardClick() {
        const
            me      = this,
            { max } = me;

        if (!me.readOnly && me.value) {
            const newValue = DateHelper.add(me.value, me._step.magnitude, me._step.unit);
            if (!max || max.getTime() >= newValue) {
                me.value = newValue;
            }
        }
    }

    //endregion

    //region Toggle picker

    showPicker(focusPicker) {
        this.picker.value = this.picker.activeDate = this.value;
        super.showPicker(focusPicker);
    }

    focusPicker() {
        this.picker.focus();
    }

    //endregion

    // region Validation

    get isValid() {
        const me  = this,
            min = me.min,
            max = me.max;

        me.clearError('minimumValueViolation', true);
        me.clearError('maximumValueViolation', true);

        let value = me.value;

        if (value) {
            value = value.getTime();
            if (min && min.getTime() > value) {
                me.setError('minimumValueViolation', true);
                return false;
            }

            if (max && max.getTime() < value) {
                me.setError('maximumValueViolation', true);
                return false;
            }
        }

        return super.isValid;
    }

    //endregion

    //region Getters/setters
    transformDateValue(value) {
        if (value != null) {
            if (!DateHelper.isDate(value)) {
                if (typeof value === 'string') {
                    // If date cannot be parsed with set format, try fallback - the more general one
                    value = DateHelper.parse(value, this.format) || DateHelper.parse(value, this.fallbackFormat);
                }
                else {
                    value = new Date(value);
                }
            }

            // We insist on a *valid* Date as the value
            if (DateHelper.isValidDate(value)) {
                return this.transformTimeValue(value);
            }
        }
        return null;
    }

    transformTimeValue(value) {
        const keep = this.keepTime;

        value = DateHelper.clone(value);

        if (!keep) {
            DateHelper.clearTime(value, false);
        }
        else {
            const timeValue = DateHelper.parse(keep, this.timeFormat);

            // if this.keepTime is a valid date or a string describing valid time copy from it
            if (DateHelper.isValidDate(timeValue)) {
                DateHelper.copyTimeValues(value, timeValue);
            }
            // otherwise try to copy from the current value
            else if (DateHelper.isValidDate(this.value)) {
                DateHelper.copyTimeValues(value, this.value);
            }
            // else don't change time
        }

        return value;
    }

    /**
     * Get/set min value, which can be a Date or a string. If a string is specified, it will be converted using the
     * specified {@link #config-format}
     * @property {String|Date}
     */
    set min(value) {
        const me = this;
        me._min = me.transformDateValue(value);
        me.input && (me.input.min = me._min);

        if (me._picker) {
            me._picker.minDate = me._min;
        }
        me.updateInvalid();
    }

    get min() {
        return this._min;
    }

    /**
     * Get/set max value, which can be a Date or a string. If a string is specified, it will be converted using the
     * specified {@link #config-format}
     * @property {String|Date}
     */
    set max(value) {
        const me = this;
        me._max = me.transformDateValue(value);
        me.input && (me.input.max = me._max);

        if (me._picker) {
            me._picker.maxDate = me._max;
        }
        me.updateInvalid();
    }

    get max() {
        return this._max;
    }

    /**
     * Get/set value, which can be a Date or a string. If a string is specified, it will be converted using the
     * specified {@link #config-format}
     * @property {String|Date}
     */
    set value(value) {
        const me = this,
            oldValue = me.value,
            picker   = me._picker,
            newValue = me.transformDateValue(value);

        // A value we could not parse
        if (value && !newValue) {
            // setError uses localization
            me.setError('invalidDate');
            return;
        }
        me.clearError('invalidDate');

        // Reject non-change
        if (!me.hasChanged(oldValue, newValue)) {
            // But we must fix up the display in case it was an unparseable string
            // and the value therefore did not change.
            if (!me.inputting) {
                me.syncInputFieldValue();
            }
            return;
        }

        if (picker && !me.inputting) {
            picker.value = newValue;
        }
        super.value = newValue;
    }

    get value() {
        return super.value;
    }

    /**
     *  The `step` property may be set in Object form specifying two properties,
     * `magnitude`, a Number, and `unit`, a String.
     *
     * If a Number is passed, the steps's current unit is used (or `day` if no current step set)
     * and just the magnitude is changed.
     *
     * If a String is passed, it is parsed in accordance with (see {@link Core.helper.DateHelper#function-format-static}.
     * The string is taken to be the numeric magnitude then an abbreviation, or name of the unit.
     *
     * Upon read, the value is always returned in object form containing `magnitude` and `unit`.
     * @property {String|Number|Object}
     */
    set step(value) {
        const me = this;

        // If a step is configured, show the steppers
        me.element.classList[value ? 'add' : 'remove']('b-show-steppers');

        if (typeof value === 'number') {
            value = {
                magnitude : value,
                unit      : me._step ? me._step.unit : 'day'
            };
        }
        else if (typeof value !== 'object') {
            value = DateHelper.parseDuration(value);
        }

        if (value && value.magnitude && value.unit) {
            value.magnitude = Math.abs(value.magnitude);
            me._step = value;
            me.updateInvalid();
        }
    }

    get step() {
        return this._step;
    }

    hasChanged(oldValue, newValue) {
        if (oldValue && oldValue.getTime && newValue && newValue.getTime) {
            return oldValue.getTime() !== newValue.getTime();
        }

        return super.hasChanged(oldValue, newValue);
    }

    get inputValue() {
        // Do not use the _value property. If called during configuration, this
        // will import the configured value from the config object.
        const date = this.value;

        return date ? DateHelper.format(date, this.format) : '';
    }

    /**
     * Get/Set format for date displayed in field (see {@link Core.helper.DateHelper#function-format-static} for formatting options)
     * @property {String}
     */
    set format(value) {
        const me = this;
        me._format = value;
        me.syncInputFieldValue(true);
    }

    get format() {
        return this._format;
    }

    //endregion

    //region Localization

    updateLocalization() {
        super.updateLocalization();
        this.syncInputFieldValue(true);
    }

    //endregion

    //region Other

    internalOnKeyPress(event) {
        super.internalOnKeyPress(event);

        if (event.key === 'Enter' && this.isValid) {
            this.picker.hide();
        }
    }

    //endregion
}

DateField._$name = 'DateField'; BryntumWidgetAdapterRegister.register('datefield', DateField);
BryntumWidgetAdapterRegister.register('date', DateField);

/**
 * @module Core/widget/NumberField
 */

const decimalSeparators  = /[.,]/;

/**
 * Number field widget. Wraps native `<input type="number">`.
 *
 * This field can be used as an {@link Grid.column.Column#config-editor editor} for the {@link Grid.column.Column Column}.
 * It is used as the default editor for the {@link Grid.column.NumberColumn NumberColumn},
 * {@link Grid.column.PercentColumn PercentColumn}, {@link Grid.column.AggregateColumn AggregateColumn}.
 *
 * @extends Core/widget/Field
 *
 * @example
 * let number = new NumberField({
 *   min: 1,
 *   max: 5,
 *   value: 3
 * });
 *
 * @classType numberfield
 * @externalexample widget/NumberField.js
 */
class NumberField extends Field {

    //region Config

    static get $name() {
        return 'NumberField';
    }

    static get defaultConfig() {
        return {

            /**
             * Min value
             * @config {Number}
             */
            min : null,

            /**
             * Max value
             * @config {Number}
             */
            max : null,

            /**
             * Step size for spin button clicks.
             * @config {Number}
             * @default
             */
            step : 1,

            /**
             * Initial value
             * @config {Number}
             */
            value : 0,

            /**
             * The number of decimal places to allow. Defaults to no constraint.
             * @config {Number}
             * @default
             */
            decimalPrecision : null,

            /**
             * The maximum number of leading zeroes to show. Defaults to no constraint.
             * @config {Number}
             * @default
             */
            leadingZeroes : null,

            triggers : {
                spin : {
                    type : 'spintrigger'
                }
            },

            attributes : [
                'placeholder',
                'autoComplete',
                'min',
                'max',
                'tabIndex'
            ],

            /**
             * Controls how change events are triggered when stepping the value up or down using either spinners or
             * arrow keys.
             *
             * Configure with:
             * * `true` to trigger a change event per step
             * * `false` to not trigger change while stepping. Will trigger on blur/Enter
             * * A number of milliseconds to buffer the change event, triggering when no steps are performed during that
             *   period of time.
             *
             * @config {Boolean|Number}
             * @default
             */
            changeOnSpin : true
        };
    }

    //endregion

    //region Init

    construct(config) {
        const me = this;

        super.construct(config);

        // Support for selecting all by double click in empty input area
        // Browsers work differently at this case
        me.input.addEventListener('dblclick', () => {
            me.select();
        });

        if (typeof me.changeOnSpin === 'number') {
            me.bufferedSpinChange = me.buffer(me.triggerChange, me.changeOnSpin);
        }
    }

    //endregion

    //region Template

    inputTemplate() {
        const
            me    = this,
            style = 'inputWidth' in me
                ? `style="width:${me.inputWidth}${typeof me.inputWidth === 'number' ? 'px' : ''}"`
                : '';

        return TemplateHelper.tpl`
            <input type="number"
                reference="input"
                value="${me._value}"
                name="${me.name || me.id}"
                id="${me.id}_input"
                step="any"
                ${style}
                ${me.attributeString}/>
            `;
    }

    //endregion

    //region Internal functions

    internalOnKeyPress(e) {
        // Overriding native arrow key spin behaviour, which differs between browsers
        if (e.type === 'keydown') {
            if (e.key === 'ArrowUp') {
                this.doSpinUp();
                e.preventDefault();
            }
            else if (e.key === 'ArrowDown') {
                this.doSpinDown();
                e.preventDefault();
            }
        }

        super.internalOnKeyPress(e);
    }

    doSpinUp() {
        const
            me           = this,
            { min, max } = me;

        let newValue = (me.value || 0) + me.step;

        if (!isNaN(min) && newValue < min) {
            newValue = min;
        }

        if (isNaN(max) || newValue <= max) {
            me.applySpinChange(newValue);
        }
    }

    doSpinDown() {
        const
            me           = this,
            { min, max } = me;

        let newValue = (me.value || 0) - me.step;

        if (!isNaN(max) && newValue > max) {
            newValue = max;
        }

        if (isNaN(min) || newValue >= min) {
            me.applySpinChange(newValue);
        }
    }

    applySpinChange(newValue) {
        const me = this;

        me._isUserAction = true;

        // Should not trigger change immediately?
        if (me.changeOnSpin !== true) {
            // Silence the change
            me.silenceChange = true;
            // Optionally buffer the change
            me.bufferedSpinChange && me.bufferedSpinChange(null, true);
        }

        me.value = newValue;

        me._isUserAction = false;
        me.silenceChange = false;
    }

    triggerChange() {
        if (!this.silenceChange) {
            super.triggerChange(...arguments);
        }
    }

    internalOnInput(event) {
        const
            me = this,
            { input } = me,
            value = me.formatValue(input.value);

        if (input.value !== value) {
            input.value = value;
        }

        super.internalOnInput(event);
    }

    static formatValue(value, leadingZeroes, decimalPrecision) {
        if (typeof value !== 'string') {
            return value;
        }
        let [integer, decimal] = value.split(decimalSeparators);

        if (decimalPrecision && decimal && decimal.length > decimalPrecision) {
            // Trim back to the configured decimals
            decimal = decimal.substr(0, decimalPrecision);
        }

        if (leadingZeroes && integer && integer.length < leadingZeroes) {
            // Put zeros to the beginning
            integer = integer.padStart(leadingZeroes, '0');
        }
        return [integer, decimal].filter(v => v).join('.');
    }

    formatValue(value) {
        return NumberField.formatValue(value, this.leadingZeroes, this.decimalPrecision);
    }

    //endregion

    //region Getters/Setters

    /**
     * Step size for spin button clicks.
     * @property {Number}
     */

    set step(step) {
        this.element.classList[step ? 'remove' : 'add']('b-hide-spinner');
        this._step = step;
    }

    get step() {
        return this._step;
    }

    /**
     * Min value
     * @property {Number}
     */
    set min(min) {
        this._min = min;

        if (this.input) {
            this.input.min = min;
        }
    }

    get min() {
        return this._min;
    }

    /**
     * Max value
     * @property {Number}
     */
    set max(max) {
        this._max = max;

        if (this.input) {
            this.input.max = max;
        }
    }

    get max() {
        return this._max;
    }

    /**
     * Get/set the NumberField's value
     * @property {Number}
     */
    set value(value) {
        const me = this;

        if (value || value === 0) {
            let valueIsNaN;

            // We insist on a number as the value
            if (typeof value !== 'number') {
                value = (typeof value === 'string') ? parseFloat(value) : Number(value);

                valueIsNaN = isNaN(value);
                if (valueIsNaN) {
                    value = '';
                }
            }
            if (!valueIsNaN && me.decimalPrecision != null) {
                value = ObjectHelper.round(value, me.decimalPrecision);
            }
        }
        else {
            value = me.clearable ? undefined : 0;
        }

        // Reject non-changes & not interested in non-number values
        if (me.value !== value) {
            super.value = value;
            if (me.leadingZeroes) {
                me.input.value = me.formatValue(value.toString());
            }
        }
    }

    get value() {
        return super.value;
    }

    //endregion
}

NumberField._$name = 'NumberField'; BryntumWidgetAdapterRegister.register('numberfield', NumberField);
BryntumWidgetAdapterRegister.register('number', NumberField);

/**
 * @module Core/widget/Slider
 */

/**
 * Wraps native &lt;input type="range"&gt;
 *
 * @extends Core/widget/Widget
 *
 * @example
 * let slider = new Slider({
 *   text: 'Choose value'
 * });
 *
 * @classType slider
 * @externalexample widget/Slider.js
 */
class Slider extends Widget {
    //region Config
    static get $name() {
        return 'Slider';
    }

    static get defaultConfig() {
        return {
            /**
             * Slider label text
             * @config {String}
             */
            text : '',

            /**
             * Show value in label (appends in () if text is set)
             * @config {Boolean}
             * @default
             */
            showValue : true,

            /**
             * Show value in tooltip
             * @config {Boolean}
             * @default
             */
            showTooltip : false,

            /**
             * Minimum value
             * @config {Number}
             * @default
             */
            min : 0,

            /**
             * Maximum value
             * @config {Number}
             * @default
             */
            max : 100,

            /**
             * Step size
             * @config {Number}
             * @default
             */
            step : 1,

            /**
             * Initial value
             * @config {Number}
             */
            value : null,

            // The value is set in the Light theme. The Material theme will have different value.
            thumbSize : 20,

            localizableProperties : ['text']
        };
    }

    //endregion

    //region Init

    construct(config) {
        const me = this;

        super.construct(config);

        me.updateLabel();

        if (me.showTooltip) {
            me.tip = new Tooltip({
                forElement : me.input,
                anchor     : false, // No anchor displayed since thumbSize is different for different themes
                align      : 'b-t',
                axisLock   : true
            });
        }

        me.input.addEventListener('input', me.onInternalInput.bind(me));
        me.input.addEventListener('change', me.onInternalChange.bind(me));
        me.input.addEventListener('mouseover', me.onInternalMouseOver.bind(me));
        me.input.addEventListener('mouseout', me.onInternalMouseOut.bind(me));
    }

    template(widget) {
        return TemplateHelper.tpl`
            <div class="${widget.text ? 'b-text b-has-label' : ''}">
                <input type="range"
                   reference="input"
                   id="${widget.id}_input"
                   min="${widget.min}"
                   max="${widget.max}"
                   step="${widget.step}"
                   value="${widget.value}">
                <label reference="label" for="${widget.id}_input">${widget.text}</label>
            </div>
        `;
    }

    get focusElement() {
        return this.input;
    }

    //endregion

    //region Events

    onInternalInput(event) {
        const me = this;

        me._value = parseInt(me.input.value);

        me.updateUI();
        me.trigger('input', { value : me.value });
    }

    onInternalChange(event) {
        const me = this;
        me.updateUI();
        me.triggerChange(true);
        me.trigger('action', { value : me.value });
    }

    onInternalMouseOver(event) {
        const me = this;

        me.updateLabel();

        if (me.tip) {
            me.tip.showBy({
                target : me.calcThumbPosition(),
                offset : 5
            });
        }
    }

    onInternalMouseOut(event) {
        if (this.tip) {
            this.tip.hide();
        }
    }

    triggerChange(userAction) {
        this.trigger('change', {
            value : this.value,
            userAction
        });
    }

    //endregion

    //region Getters/setters

    /**
     * Get/Set text. Appends value if Slider.showValue is true
     * @property {String}
     */
    get text() {
        return this._text;
    }

    set text(text) {
        const me = this;

        me._text = text;

        if (me.label) {
            if (me.showValue) {
                text = text ? `${text} (${me.value})` : me.value;
            }

            me.label.innerHTML = text;
        }

        if (me.tip) {
            me.tip.html = me.value;
        }
    }

    /**
     * Get/set value
     * @property {Number}
     */
    get value() {
        return this.input ? parseInt(this.input.value) : this._value;
    }

    set value(value) {
        const me = this;

        if (me._value !== value) {
            if (me.input) {
                me.input.value = value;
                me.updateUI();
                me.triggerChange(false);
            }
            me._value = value;
        }
    }

    /**
     * Get/set min value
     * @property {Number}
     */
    get min() {
        return this.input ? this.input.min : this._min;
    }

    set min(min) {
        const me = this;

        if (me.input) {
            me.input.min = min;
            if (me._value < min) {
                me.value = min;
                me.trigger('input', { value : me.value });
            }
        }

        me._min = min;
    }

    /**
     * Get/set max value
     * @property {Number}
     */
    get max() {
        return this.input ? this.input.max : this._max;
    }

    set max(max) {
        const me = this;

        if (me.input) {
            me.input.max = max;
            if (me._value > max) {
                me.value = max;
                me.trigger('input', { value : me.value });
            }
        }

        me._max = max;
    }

    /**
     * Get/set step size
     * @property {Number}
     */
    get step() {
        return this.input ? this.input.step : this._step;
    }

    set step(step) {
        if (this.input) this.input.step = step;
        this._step = step;
    }

    //endregion

    //region Util

    /**
     * Refresh label text
     * @private
     */
    updateLabel() {
        this.text = this._text;
    }

    /**
     * Refresh tooltip position
     * @private
     */
    updateTooltipPosition() {
        if (this.tip) {
            this.tip.alignTo({
                target : this.calcThumbPosition(),
                offset : 5
            });
        }
    }

    /**
     * Refresh slider UI
     * @private
     */
    updateUI() {
        this.updateLabel();
        this.updateTooltipPosition();
    }

    calcThumbPosition() {
        const me = this,
            inputRect = Rectangle.from(me.input),
            offset = (inputRect.width - me.thumbSize) * me.calcPercentProgress() / 100;

        return new Rectangle(
            inputRect.x + offset,
            inputRect.y + inputRect.height / 2 - me.thumbSize / 2,
            me.thumbSize,
            me.thumbSize
        );
    }

    calcPercentProgress() {
        return (this.value - this.min) / (this.max - this.min) * 100;
    }

    //endregion
}

Slider._$name = 'Slider'; BryntumWidgetAdapterRegister.register('slider', Slider);

/**
 * @module Core/widget/layout/Card
 */

const animationClasses = [
    'b-slide-out-left',
    'b-slide-out-right',
    'b-slide-in-left',
    'b-slide-in-right'
];

/**
 * A helper class for containers which must manage multiple child widgets, of which only one may be visible at once such
 * as a {@link Core.widget.TabPanel}. This class offers an active widget switching API, and optional slide-in,
 * slide-out animations from child to child.
 */
class Card extends Layout {
    static get $name() {
        return 'Card';
    }

    static get defaultConfig() {
        return {
            containerCls : 'b-card-container',

            itemCls : 'b-card-item',

            /**
             * Specifies whether to slide tabs in and out of visibility.
             * @config {Boolean}
             * @default
             */
            animateCardChange : true
        };
    }

    /**
     * Get/set active item, using index or the Widget to activate
     * @param {Core.widget.Widget|Number} activeItem
     * @returns {Object} An object describing the card change containing the following properties:
     *
     *  - `prevActiveIndex` The previously active index.
     *  - `prevActiveItem ` The previously active child item.
     *  - `activeIndex    ` The newly active index.
     *  - `activeItem     ` The newly active child item.
     *  - `promise        ` A promise which completes when the slide-in animation finishes and the child item contains
     * focus if it is focusable.
     */
    setActiveItem(activeIndex) {
        const me                    = this,
            { owner }                 = me,
            { contentElement, items } = owner,
            widgetPassed              = activeIndex instanceof Widget,
            prevActiveIndex           = parseInt(contentElement.dataset.activeIndex),
            prevActiveItem            = items[prevActiveIndex],
            newActiveItem             = owner.items[activeIndex = widgetPassed ? (activeIndex = items.indexOf(activeIndex)) : parseInt(activeIndex)],
            event = {
                prevActiveIndex,
                prevActiveItem
            };

        // There's a child widget at that index to activate
        if (newActiveItem && newActiveItem !== prevActiveItem) {
            const prevItemElement = prevActiveItem && prevActiveItem.element,
                newActiveElement = newActiveItem && newActiveItem.element;

            event.activeIndex = activeIndex;
            event.activeItem = newActiveItem;

            // A previous card change is in progress, abort it and clean the items it was operating upon
            if (me.animateDetacher) {
                const abortedEvent = me.animateDetacher.event;
                me.animateDetacher();
                abortedEvent.prevActiveItem.element.classList.remove(animationClasses);
                abortedEvent.activeItem.element.classList.remove('b-active', ...animationClasses);
                me.animateDetacher = null;
            }

            event.promise = new Promise((resolve, reject) => {
                // If there's something to slide out, slide it out, and slide the new item in
                if (prevItemElement && me.animateCardChange) {
                    prevItemElement.classList.add(activeIndex > prevActiveIndex ? 'b-slide-out-left' : 'b-slide-out-right');
                    newActiveElement.classList.add('b-active', activeIndex < prevActiveIndex ? 'b-slide-in-left' : 'b-slide-in-right');
                    owner.isAnimating = true;

                    // Paint early, to have contents in place when sliding in
                    newActiveItem.triggerPaint();

                    // When the new widget is in place, clean up
                    me.animateDetacher = EventHelper.on({
                        element      : newActiveElement,
                        animationend : () => {
                            me.animateDetacher = null;
                            owner.isAnimating = false;

                            // Clean incoming widget's animation classes
                            newActiveElement.classList.remove(...animationClasses);

                            // If there's an outgoing item, clean its animation classes and hide it
                            if (prevItemElement) {
                                prevItemElement.classList.remove('b-active', ...animationClasses);
                            }
                            contentElement.dataset.activeIndex = activeIndex;

                            // Note that we have to call focus *after* the element is in its new position
                            // because focus({preventScroll:true}) is not supported everywhere
                            // and crazy browser scrolling behaviour on focus breaks the animation.
                            newActiveItem.focus();
                            resolve(event);
                        },
                        once : true
                    });
                    me.animateDetacher.reject = reject;
                    me.animateDetacher.event = event;
                }
                // Nothing to slide out or we are not animating.
                else {
                    if (prevItemElement) {
                        prevItemElement.classList.remove('b-active');
                    }
                    newActiveElement.classList.add('b-active');
                    contentElement.dataset.activeIndex = activeIndex;
                    newActiveItem.focus();
                    newActiveItem.triggerPaint();
                    resolve(event);
                }
            });
        }

        return event;
    }

    renderChildren() {
        const { owner } = this,
            activeIndex = owner.activeIndex;

        // The usual; not working on IE11
        if (BrowserHelper.isIE11) {
            this.animateCardChange = false;
        }

        // Ensure activeIndex of the owning Container at render time is honoured.
        if (owner.items && activeIndex != null && owner.items[activeIndex]) {
            owner.contentElement.dataset.activeIndex = activeIndex;
            owner.items[activeIndex].element.classList.add('b-active');
        }
        super.renderChildren();
    }

    /**
     * The active child index. Setting must be done through {@link #function-setActiveItem}
     * @property {Number}
     * @readonly
     */
    get activeIndex() {
        return parseInt(this.owner.contentElement.dataset.activeIndex);
    }

    /**
     * The active child item. Setting must be done through {@link #function-setActiveItem}
     * @property {Core.widget.Widget}
     * @readonly
     */
    get activeItem() {
        return this.owner.items[parseInt(this.owner.contentElement.dataset.activeIndex)];
    }
}

// Layouts must register themselves so that the static layout instantiation
// in Layout knows what to do with layout type names
Card._$name = 'Card'; Layout.registerLayout(Card);

/**
 * @module Core/widget/TabPanel
 */

/**
 * Tab panel widget, displays a collection of tabs which each can contain other widgets. Layout is handled using css
 *
 * @extends Core/widget/Widget
 * @example
 * let tabPanel = new TabPanel({
 *  items: [
 *      {
 *          title: 'First',
 *          items: [
 *              { type: 'textfield', label: 'Name' },
 *              ...
 *          ]
 *      }, {
 *          title: 'Last',
 *          items: [
 *              ...
 *          ]
 *      }
 *  ]
 * });
 *
 * @classType tabpanel
 * @externalexample widget/TabPanel.js
 */
class TabPanel extends Container {
    //region Config
    static get $name() {
        return 'TabPanel';
    }

    static get defaultConfig() {
        return {
            template : me => TemplateHelper.tpl`
                <div>
                    <div class="b-tabpanel-tabs" reference="tabStrip">
                        ${me.items.map((tab, i) => `
                        <div tabindex="-1" data-index="${i}" class="b-tabpanel-tab ${(i === me.activeIndex) ? 'b-active' : ''} ${tab.cls || ''} ${tab.hidden ? 'b-hidden' : ''}" style="${me.tabMinWidth ? 'min-width:' + DomHelper.setLength(me.tabMinWidth) + ';' : ''} ${me.tabMaxWidth ? 'max-width:' + DomHelper.setLength(me.tabMaxWidth) + ';' : ''}" >
                            <span class="b-tabpanel-tab-title">${tab.title}</span>
                        </div>
                        `)}
                    </div>
                    <div class="b-tabpanel-body" reference="tabPanelBody" data-activeIndex="${me.activeIndex}">
                    </div>
                </div>
            `,

            itemCls : 'b-tabpanel-item',

            defaultType : 'container',

            /**
             * The index of the initially active tab.
             * @config {Number}
             * @default
             */
            activeTab : 0,

            /**
             * Min width of a tab title. 0 means no minimum width. This is default.
             * @config {Number}
             * @default
             */
            tabMinWidth : null,

            /**
             * Max width of a tab title. 0 means no maximum width. This is default.
             * @config {Number}
             * @default
             */
            tabMaxWidth : null,

            /**
             * Specifies whether to slide tabs in and out of visibility.
             * @config {Boolean}
             * @default
             */
            animateTabChange : true,

            layout : 'card',

            // Prevent child panels from displaying a header unless explicitly configured with one
            suppressChildHeaders : true
        };
    }

    //endregion

    //region Init

    construct(config) {
        const me = this;

        super.construct(config);

        // assign elements to titleElement, so they can get updated automatically when title is changed
        me.items.forEach((tab, i) => {
            tab.titleElement = me.element.querySelector(`div.b-tabpanel-tab[data-index="${i}"] span`);
        });

        EventHelper.on({
            element  : me.tabStrip,
            delegate : '.b-tabpanel-tab',
            click    : 'onTabElementClick',
            thisObj  : this
        });
    }

    createWidget(tab) {
        const me = this;

        tab = super.createWidget(tab);

        tab.on({
            hide    : me.onTabVisibilityChange,
            show    : me.onTabVisibilityChange,
            thisObj : me
        });

        return tab;
    }

    //endregion

    set tabMinWidth(width) {
        this._tabMinWidth = width;

        this.element && DomHelper.forEachSelector(this.element, '.b-tabpanel-tab', tab => {
            DomHelper.setLength(tab, 'minWidth', width || null);
        });
    }

    get tabMinWidth() {
        return this._tabMinWidth;
    }

    set tabMaxWidth(width) {
        this._tabMaxWidth = width;

        this.element && DomHelper.forEachSelector(this.element, '.b-tabpanel-tab', tab => {
            DomHelper.setLength(tab, 'maxWidth', width || null);
        });
    }

    get tabMaxWidth() {
        return this._tabMaxWidth;
    }

    set layout(layout) {
        super.layout = layout;
        this.layout.animateCardChange = this.animateTabChange;
    }

    get layout() {
        return super.layout;
    }

    //region Tabs

    get contentElement() {
        return this.tabPanelBody;
    }

    get focusElement() {
        const
            me              = this,
            activeTab       = me.items[me.activeTab || 0],
            tabFocusElement = activeTab && activeTab.focusElement;

        return tabFocusElement || me.tabStrip.children[me.activeTab];
    }

    /**
     * Get/set active tab, using index or the Widget to activate.
     * @property {Core.widget.Widget|Number}
     */
    set activeTab(index) {
        const me = this;

        if (index < 0 || index >= me.items.length) {
            throw new Error('Invalid tab index: ' + index);
        }

        if (me.isConfiguring) {
            me._activeTab = index;
        }
        else {
            const tabchangeEvent = me.layout.setActiveItem(index),
                { promise, activeIndex, activeItem } = tabchangeEvent;

            // If the layout successfully activated a new item...
            if (activeItem) {
                const { tabStrip } = me,
                    prevTabElement = tabStrip.children[me._activeTab];

                // Our UI changes immediately, our state must be accurate
                me._activeTab = activeIndex;

                // Deactivate previous active tab
                if (prevTabElement) {
                    prevTabElement.classList.remove('b-active');
                }

                // Activate the new tab
                tabStrip.children[activeIndex].classList.add('b-active');

                promise.then(() => {
                    /**
                     * The active tab has changed.
                     * @event tabchange
                     * @param {Core.widget.Widget} prevActiveItem - The previous active child widget.
                     * @param {Number} prevActiveIndex - The previous active index.
                     * @param {Core.widget.Widget} activeItem - The new active child widget.
                     * @param {Number} activeIndex - The new active index.
                     */
                    me.trigger('tabchange', tabchangeEvent);
                });
            }
        }
    }

    /**
     * The active tab index. Setting must be done through {@link #property-activeTab}
     * @property {Number}
     * @readonly
     */
    get activeIndex() {
        return this.activeTab;
    }

    get activeTab() {
        return this._activeTab;
    }

    /**
     * The active child widget. Setting must be done through {@link #property-activeTab}
     * @property {Core.widget.Widget}
     * @readonly
     */
    get activeItem() {
        return this.layout.activeItem;
    }

    //endregion

    //region Events

    onTabElementClick(event) {
        this.activeTab = event.currentTarget.dataset.index;
    }

    onTabVisibilityChange({ source }) {
        const tabBarEl = this.element.querySelector(`div.b-tabpanel-tab[data-index="${this.items.indexOf(source)}"]`);

        tabBarEl.classList[source.hidden ? 'add' : 'remove']('b-hidden');
    }

    //endregion
}

TabPanel._$name = 'TabPanel'; BryntumWidgetAdapterRegister.register('tabpanel', TabPanel);
BryntumWidgetAdapterRegister.register('tabs', TabPanel);

/**
 * @module Core/widget/TextAreaField
 */

/**
 * TextAreaField widget. Wraps native &lt;input type="text"&gt;
 *
 * This field can be used as an {@link Grid.column.Column#config-editor editor} for the {@link Grid.column.Column Column}.
 *
 * @extends Core/widget/Field
 *
 * @example
 * let textAreaField = new TextAreaField({
 *   placeholder: 'Enter some text'
 * });
 *
 * @classType textareafield
 */
class TextAreaField extends PickerField {
    static get $name() {
        return 'TextAreaField';
    }

    static get defaultConfig() {
        return {
            triggers : null, // Override PickerField. We don't have a trigger by default

            /**
             * Configure as `false` to have the field render as a non-editable picker field which
             * shows a `<textarea>` input when expanded.
             * @config {Boolean}
             * @default
             */
            inline : true,

            /**
             * The resize style to apply to the `<textarea>` element.
             * @config {String}
             * @default
             */
            resize : 'none'
        };
    }

    startConfigure(config) {
        // Read the inline config which will force evaluation of triggers.
        this._thisIsAUsedExpression(this.inline);
        super.startConfigure(config);
    }

    inputTemplate() {
        const me = this;

        if (me.inline) {
            return TemplateHelper.tpl`<textarea
                reference="input"
                class="${me.inputCls || ''}"
                placeholder="${me.placeholder}"
                name="${me.name || me.id}"
                style="resize:${me.resize}"
                id="${me.id + '_input'}"></textarea>`;
        }
        else {
            return TemplateHelper.tpl`<input type="text"
                readOnly="readonly"
                reference="displayElement"
                placeholder="${me.placeholder}"/>`;
        }
    }

    get focusElement() {
        return this.inline || this._picker && this._picker.isVisible ? this.input : this.displayElement;
    }

    showPicker() {
        const { picker } = this;

        picker.width = this.pickerWidth || this[this.pickerAlignElement].offsetWidth;

        // Always focus the picker.
        super.showPicker(true);
    }

    focusPicker() {
        this.input.focus();
    }

    onPickerKeyDown(keyEvent) {
        const
            me = this,
            realInput = me.input;

        switch (keyEvent.key.trim() || keyEvent.code) {
            case 'Escape':
                // TODO: revert value?
                me.picker.hide();
                return;
            case 'Enter':
                if (keyEvent.ctrlKey) {
                    me.syncInputFieldValue();
                    me.picker.hide();
                }
                break;
        }

        // Super's onPickerKeyDown fires through this.input, so avoid infinite recursion
        // by redirecting it through the displayElement.
        me.input = me.displayElement;
        const result = super.onPickerKeyDown(keyEvent);
        me.input = realInput;

        return result;
    }

    syncInputFieldValue(skipHighlight) {
        if (this.displayElement) {
            this.displayElement.value = this.inputValue;
        }
        super.syncInputFieldValue(skipHighlight);
    }

    set value(value) {
        super.value = value == null ? '' : value;
    }

    get value() {
        return super.value;
    }

    set inline(inline) {
        this._inline = inline;
        if (!inline && !this.triggers) {
            this.triggers = {};
        }
    }

    set triggers(triggers) {
        if (!this.inline) {
            (triggers || (triggers = {})).expand = {
                cls     : 'b-icon-picker',
                handler : 'onTriggerClick'
            };
        }
        super.triggers = triggers;
    }

    get triggers() {
        return super.triggers;
    }

    get inline() {
        return this._inline;
    }

    createPicker(picker) {
        const me = this;

        // Allow configuring pickerWidth in one go. Setting `picker = { width : 300 }` will otherwise be overridden by
        // pickerWidth or fields width.
        if (picker.width) {
            me.pickerWidth = picker.width;
        }

        picker = new Widget(ObjectHelper.merge({
            cls          : 'b-textareafield-picker',
            owner        : me,
            floating     : true,
            scrollAction : 'realign',
            forElement   : me[me.pickerAlignElement],
            align        : {
                align    : 't-b',
                axisLock : true,
                anchor   : me.overlayAnchor,
                target   : me[me.pickerAlignElement]
            },
            html     : `<textarea id="${me.id + '_input'}" style="resize:${me.resize}">${me.value}</textarea>`,
            autoShow : false
        }, picker));

        const input = me.input = picker.element.querySelector(`#${me.id}_input`);

        me.inputListenerRemover = EventHelper.on({
            element  : input,
            thisObj  : me,
            focus    : 'internalOnInputFocus',
            change   : 'internalOnChange',
            input    : 'internalOnInput',
            keydown  : 'internalOnKeyPress',
            keypress : 'internalOnKeyPress',
            keyup    : 'internalOnKeyPress'
        });

        return picker;
    }
}

TextAreaField._$name = 'TextAreaField'; BryntumWidgetAdapterRegister.register('textareafield', TextAreaField);
BryntumWidgetAdapterRegister.register('textarea', TextAreaField);

/**
 * @module Core/widget/TimePicker
 */

/**
 * A Popup which displays hour and minute number fields and AM/PM switcher buttons for 12 hour time format.
 * Fires timeChange event upon user changes time.
 *
 * This class is not intended for use in applications. It is used internally by the
 * {@link Core.widget.TimeField} class.
 *
 * @classType timepicker
 * @private
 */
class TimePicker extends Popup {

    //region Config
    static get $name() {
        return 'TimePicker';
    }

    static get defaultConfig() {
        return {
            items : [
                {
                    type                    : 'number',
                    ref                     : 'fieldHours',
                    min                     : 0,
                    max                     : 23,
                    highlightExternalChange : false
                },
                { html : '<label>:</label>' },
                {
                    type                    : 'number',
                    ref                     : 'fieldMinutes',
                    min                     : 0,
                    max                     : 59,
                    highlightExternalChange : false
                },
                {
                    type        : 'button',
                    text        : 'AM',
                    toggleGroup : 'am-pm',
                    ref         : 'buttonAM',
                    cls         : 'b-blue'
                },
                {
                    type        : 'button',
                    text        : 'PM',
                    toggleGroup : 'am-pm',
                    ref         : 'buttonPM',
                    cls         : 'b-blue'
                }
            ],

            float : '1',

            autoShow : false,

            trapFocus : true,

            /**
             * Default time value
             * @config {Date}
             */
            value : DateHelper.getTime(0),

            /**
             * Time format. Used to set appropriate 12/24 hour format to display.
             * See Core.helper.DateHelper#format for formatting options.
             * @config {String}
             */
            format : null
        };
    }

    //endregion

    //region Init

    /**
     * Fires when a time is changed.
     * @event timeChange
     * @param {Date} time The selected time.
     */
    construct(config) {
        const me = this;
        super.construct(config);

        me._pm = false;
        me.fieldHours.on('change', me.onFieldChange, me);
        me.fieldMinutes.on('change', me.onFieldChange, me);
        me.buttonAM.on('click', me.onButtonAMClick, me);
        me.buttonPM.on('click', me.onButtonPMClick, me);

        EventHelper.on({
            element : me.element,
            keydown : 'onPickerKeyDown',
            thisObj : me
        });

        EventHelper.on({
            element : me.fieldHours.element,
            keydown : 'onPickerKeyDown',
            thisObj : me
        });

        EventHelper.on({
            element : me.fieldMinutes.element,
            keydown : 'onPickerKeyDown',
            thisObj : me
        });

        me.refresh();
    }

    //endregion

    //region Event listeners

    onFieldChange() {
        const me = this;
        if (me._time) {
            me.value = me.pickerToTime();
        }
    }

    onButtonAMClick() {
        const me = this;
        me._pm = false;
        if (me._time) {
            me.value = me.pickerToTime();
        }
    }

    onButtonPMClick() {
        const me = this;
        me._pm = true;
        if (me._time) {
            me.value = me.pickerToTime();
        }
    }

    onPickerKeyDown(keyEvent) {
        const me = this,
            keyName = (keyEvent.key && keyEvent.key.trim()) || keyEvent.code;

        switch (keyName) {
            case 'Escape':
                // Support for undefined initial time
                me.triggerTimeChange(me._initialValue);
                me.hide();
                keyEvent.preventDefault();
                break;
            case 'Enter':
                me.value = me.pickerToTime();
                me.hide();
                keyEvent.preventDefault();
                break;
        }
    }

    //endregion

    //region Internal functions

    pickerToTime() {
        const me = this,
            pm = me._pm;
        let hours = me.fieldHours.value,
            newValue = new Date(me._time);

        if (!me._is24Hour) {
            if (pm && hours < 12) hours = hours + 12;
            if (!pm && hours === 12) hours = 0;
        }

        newValue.setHours(hours);
        newValue.setMinutes(me.fieldMinutes.value);

        if (me._min) {
            newValue = DateHelper.max(me._min, newValue);
        }
        if (me._max) {
            newValue = DateHelper.min(me._max, newValue);
        }

        return newValue;
    }

    triggerTimeChange(time) {
        this.trigger('timeChange', { time });
    }

    //endregion

    //region Getters / Setters

    /**
     * Get/set value, which can be a Date or a string. If a string is specified, it will be converted using the
     * specified {@link #config-format}
     * @property {Date|String}
     */
    set value(newTime) {
        const me = this;
        let changed = false;

        if (!newTime || !me._time) {
            me._time = TimePicker.defaultConfig.value;
            changed  = true;
        }
        else if (newTime.getTime() !== me._time.getTime()) {
            me._time = newTime;
            changed  = true;
        }

        if (changed) {
            if (me.isVisible) {
                me.triggerTimeChange(me.value);
            }
            me.refresh();
        }
    }

    get value() {
        return this._time;
    }

    /**
     * Get/Set format for time displayed in field (see Core.helper.DateHelper#format for formatting options)
     * @property {String}
     */
    set format(value) {
        const me = this;
        me._format = value;
        me._is24Hour = DateHelper.is24HourFormat(me._format);
        me.refresh();
    }

    get format() {
        return this._format;
    }

    /**
     * Get/set max value, which can be a Date or a string. If a string is specified, it will be converted using the
     * specified {@link #config-format}
     * @property {Date|String}
     */
    set min(value) {
        this._min = value;
    }

    get min() {
        return this._min;
    }

    /**
     * Get/set min value, which can be a Date or a string. If a string is specified, it will be converted using the
     * specified {@link #config-format}
     * @property {Date|String}
     */
    set max(value) {
        this._max = value;
    }

    get max() {
        return this._max;
    }

    /**
     * Get/set initial value and value, which can be a Date or a string. If a string is specified,
     * it will be converted using the specified {@link #config-format}. Initial value is restored on Escape click
     * @property {Date|String}
     */
    set initialValue(value) {
        this.value = value;
        this._initialValue = value;
    }

    get initialValue() {
        return this._initialValue;
    }

    //endregion

    //region Internal widgets getters

    get buttonAM() {
        return this.widgetMap.buttonAM;
    }

    get buttonPM() {
        return this.widgetMap.buttonPM;
    }

    get fieldHours() {
        return this.widgetMap.fieldHours;
    }

    get fieldMinutes() {
        return this.widgetMap.fieldMinutes;
    }

    //endregion

    //region Display

    refresh() {
        const me = this;
        if (!me.isConfiguring) {
            const time       = me._time,
                is24       = me._is24Hour,
                hours      = time.getHours(),
                pm         = me._pm = hours >= 12,
                fieldHours = me.fieldHours;

            me.element.classList[is24 ? 'add' : 'remove']('b-24h');

            fieldHours.min = is24 ? 0 : 1;
            fieldHours.max = is24 ? 23 : 12;
            fieldHours.value = is24 ? hours : (hours % 12) || 12;
            me.fieldMinutes.value = time.getMinutes();
            me.buttonAM.pressed = !pm;
            me.buttonPM.pressed = pm;
            me.buttonAM.hidden = me.buttonPM.hidden = is24;
        }
    }

    //endregion

}

TimePicker._$name = 'TimePicker'; BryntumWidgetAdapterRegister.register('timepicker', TimePicker);

//TODO: picker icon (clock) should be clock that shows actual time

/**
 * @module Core/widget/TimeField
 */

/**
 * Time field widget (text field + time picker).
 *
 * This field can be used as an {@link Grid.column.Column#config-editor editor} for the {@link Grid.column.Column Column}.
 * It is used as the default editor for the {@link Grid.column.TimeColumn TimeColumn}.
 *
 * @extends Core/widget/PickerField
 *
 * @example
 * let field = new TimeField({
 *   format: 'HH'
 * });
 *
 * @classType timefield
 * @externalexample widget/TimeField.js
 */
class TimeField extends PickerField {
    //region Config
    static get $name() {
        return 'TimeField';
    }

    static get defaultConfig() {
        return {

            /**
             * Format for date displayed in field (see Core.helper.DateHelper#function-format-static for formatting options)
             * @config {String}
             * @default
             */
            format : 'LT',

            triggers : {
                back : {
                    cls     : 'b-icon b-icon-angle-left',
                    handler : 'onBackClick',
                    align   : 'start'
                },
                expand : {
                    template : () => `<div class="b-align-${this.align || 'end'}"><div class="b-icon-clock-live"></div></div>`,
                    handler  : 'onTriggerClick',
                    align    : 'end'
                },
                forward : {
                    cls     : 'b-icon b-icon-angle-right',
                    handler : 'onForwardClick',
                    align   : 'end'
                }
            },

            /**
             * Min time value
             * @config {String|Date}
             */
            min : null,

            /**
             * Max time value
             * @config {String|Date}
             */
            max : null,

            /**
             * Time increment duration value. Defaults to 5 minutes.
             * The value is taken to be a string consisting of the numeric magnitude and the units.
             * The units may be a recognised unit abbreviation of this locale or the full local unit name.
             * For example `"10m"` or `"5min"` or `"2 hours"`

             * @config {String}
             */
            step : '5m',

            /**
             * Value, which can be a Date or a string. If a string is specified, it will be converted using the
             * specified {@link #config-format}
             * @config {String|Date}
             */
            value : null
        };
    }

    //endregion

    //region Init & destroy

    createPicker(picker) {
        const me = this;

        return new TimePicker(Object.assign({
            owner      : me,
            floating   : true,
            forElement : me[me.pickerAlignElement],
            align      : {
                align    : 't0-b0',
                axisLock : true,
                anchor   : me.overlayAnchor,
                target   : me[me.pickerAlignElement]
            },
            value  : me.value,
            format : me.format,
            onTimeChange({ time }) {
                me._isUserAction = true;
                me.value = time;
                me._isUserAction = false;
            }
        }, picker));
    }

    //endregion

    //region Click listeners

    onBackClick() {
        const
            me      = this,
            { min } = me;

        if (!me.readOnly && me.value) {
            const newValue = DateHelper.add(me.value, -1 * me.step.magnitude, me.step.unit);
            if (!min || min.getTime() <= newValue) {
                me._isUserAction = true;
                me.value = newValue;
                me._isUserAction = false;
            }
        }
    }

    onForwardClick() {
        const
            me      = this,
            { max } = me;

        if (!me.readOnly && me.value) {
            const newValue = DateHelper.add(me.value, me.step.magnitude, me.step.unit);
            if (!max || max.getTime() >= newValue) {
                me._isUserAction = true;
                me.value = newValue;
                me._isUserAction = false;
            }
        }
    }

    //endregion

    // region Validation

    get isValid() {
        const me  = this;

        me.clearError('minimumValueViolation', true);
        me.clearError('maximumValueViolation', true);

        let value = me.value;
        if (value) {
            value = value.getTime();
            if (me._min && me._min.getTime() > value) {
                me.setError('minimumValueViolation', true);
                return false;
            }

            if (me._max && me._max.getTime() < value) {
                me.setError('maximumValueViolation', true);
                return false;
            }
        }

        return super.isValid;
    }

    hasChanged(oldValue, newValue) {
        if (oldValue && oldValue.getTime && newValue && newValue.getTime) {
            return oldValue.getTime() !== newValue.getTime();
        }

        return super.hasChanged(oldValue, newValue);
    }

    //endregion

    //region Toggle picker

    /**
     * Show picker
     */
    showPicker(focusPicker) {
        const me = this,
            picker = me.picker;

        picker.initialValue = me.value;
        picker.format = me.format;
        picker.maxTime = me.max;
        picker.minTime = me.min;

        // Show valid time from picker while editor has undefined value
        me.value = picker.value;

        super.showPicker(focusPicker);
    }

    onPickerShow() {
        const me = this;
        super.onPickerShow();
        // Remove PickerField key listener
        me.pickerKeyDownRemover && me.pickerKeyDownRemover();
    }

    /**
     * Focus time picker
     */
    focusPicker() {
        this.picker.focus();
    }

    //endregion

    //region Getters/setters

    transformTimeValue(value) {
        if (value != null) {
            if (!DateHelper.isDate(value)) {
                if (typeof value === 'string') {
                    value = DateHelper.parse(value, this.format);
                }
                else {
                    value = new Date(value);
                }
            }

            // We insist on a *valid* Time as the value
            if (DateHelper.isValidDate(value)) {
                // Clear date part back to zero so that all we have is the time part of the epoch.
                value = DateHelper.clone(value);
                value.setFullYear(1970, 0, 1);
                return value;
            }
        }
        return null;
    }

    /**
     * Get/set min value, which can be a Date or a string. If a string is specified, it will be converted using the
     * specified {@link #config-format}
     * @property {String|Date}
     */
    set min(value) {
        const me = this;
        me._min = me.transformTimeValue(value);
        me.input && (me.input.min = me._min);
        me.updateInvalid();
    }

    get min() {
        return this._min;
    }

    /**
     * Get/set max value, which can be a Date or a string. If a string is specified, it will be converted using the
     * specified {@link #config-format}
     * @property {String|Date}
     */
    set max(value) {
        const me = this;
        me._max = me.transformTimeValue(value);
        me.input && (me.input.max = me._max);
        me.updateInvalid();
    }

    get max() {
        return this._max;
    }

    /**
     * Get/set value, which can be a Date or a string. If a string is specified, it will be converted using the
     * specified {@link #config-format}
     * @property {String|Date}
     */
    set value(value) {
        const me = this,
            oldValue = me.value,
            newValue = me.transformTimeValue(value);

        // A value we could not parse
        if (value && !newValue || value === '') {
            // setError uses localization
            me.setError('invalidTime');
            return;
        }
        me.clearError('invalidTime');

        // Reject non-change
        if (!me.hasChanged(oldValue, newValue)) {
            // But we must fix up the display in case it was an unparseable string
            // and the value therefore did not change.
            if (!me.inputting) {
                me.syncInputFieldValue();
            }
            return;
        }

        // This makes to clock icon show correct time
        if (me.triggers.expand && newValue) {
            me.triggers.expand.element.firstElementChild.style.animationDelay = -((newValue.getHours() * 60 + newValue.getMinutes()) / 10) + 's';
        }

        super.value = newValue;
    }

    get value() {
        return super.value;
    }

    /**
     *  The `step` property may be set in Object form specifying two properties,
     * `magnitude`, a Number, and `unit`, a String.
     *
     * If a Number is passed, the steps's current unit is used and just the magnitude is changed.
     *
     * If a String is passed, it is parsed in accordance with (see {@link Core.helper.DateHelper#function-format-static}.
     * The string is taken to be the numeric magnitude then an abbreviation, or name of the unit.
     *
     * Upon read, the value is always returned in object form containing `magnitude` and `unit`.
     * @property {String|Number|Object}
     */
    set step(value) {
        const me = this;

        if (typeof value === 'number') {
            value = {
                magnitude : value,
                unit      : me._step.unit
            };
        }
        else if (typeof value !== 'object') {
            value = DateHelper.parseDuration(value);
        }

        if (value && value.magnitude && value.unit) {
            value.magnitude = Math.abs(value.magnitude);
            me._step = value;
            me.updateInvalid();
        }
    }

    get step() {
        return this._step;
    }

    /**
     * Get/Set format for time displayed in field (see {@link Core.helper.DateHelper#function-format-static} for formatting options)
     * @property {String}
     */
    set format(value) {
        const me = this;
        me._format = value;
        me.syncInputFieldValue(true);
    }

    get format() {
        return this._format;
    }

    get inputValue() {
        return DateHelper.format(this.value, this.format);
    }

    //endregion

    //region Localization

    updateLocalization() {
        super.updateLocalization();
        this.syncInputFieldValue(true);
    }

    //endregion
}

TimeField._$name = 'TimeField'; BryntumWidgetAdapterRegister.register('timefield', TimeField);
BryntumWidgetAdapterRegister.register('time', TimeField);

/**
 * @module Core/adapter/widget/BryntumWidgetAdapter
 */

/**
 * Adapter that allows {@link Core.helper.WidgetHelper} to use Bryntums widgets.
 * You should not use this class directly, but you need to import it in your application to be able to work with Bryntum widgets.
 * This class is a part of our bundles, but if you import sources from files like shown in this [guide](#guides/gettingstarted/sources.md),
 * please do not forget to import BryntumWidgetAdapter manually, for example:
 *
 * ```javascript
 * import '../../lib/Core/adapter/widget/BryntumWidgetAdapter.js';
 * import WidgetHelper from '../../lib/Core/helper/WidgetHelper.js';
 *
 * WidgetHelper.append([{
 *     type : 'button',
 *     text : 'test'
 * }], { insertFirst : document.body });
 * ```
 */
class BryntumWidgetAdapter {
    // region Create, insert, append
    createWidget(config) {
        return BryntumWidgetAdapterRegister.createWidget(config.type, config);
    }

    getClass(type) {
        return BryntumWidgetAdapterRegister.getClass(type);
    }

    appendWidget(config) {
        return this.createWidget(config);
    }

    appendWidgets(configArray, config) {
        // Prototype chained objects may be passed, so use ObjectHelper.
        return configArray.map(item => this.appendWidget(ObjectHelper.assign({}, config || {}, item)));
    }

    //endregion

    //region Window & popup

    openPopup(element, config) {
        // Prototype chained objects may be passed, so use ObjectHelper.
        return new Popup(ObjectHelper.assign({
            forElement : element
        }, typeof config === 'string' ? {
            html : config
        } : config));
    }

    //endregion

    //region Menu

    showContextMenu(element, config) {
        const me = this;

        if (me.currentContextMenu) {
            me.currentContextMenu.destroy();
        }

        if (element instanceof HTMLElement) {
            config.forElement = element;
        }
        else if (Array.isArray(element)) {
            config.forElement = {
                target : new Point(...element)
            };
        }
        else if (element instanceof Point) {
            config.forElement = {
                target : element
            };
        }

        me.currentContextMenu = new Menu(config);

        me.currentContextMenu.on('destroy', () => {
            me.currentContextMenu = null;
        });

        return me.currentContextMenu;
    }

    //endregion

    //region Tooltip

    attachTooltip(element, configOrText) {
        if (typeof configOrText === 'string') configOrText = { html : configOrText };

        // TODO: refactor this
        // eslint-disable-next-line no-new
        new Tooltip(Object.assign({
            forElement : element
        }, configOrText));

        return element;
    }

    hasTooltipAttached(element) {
        return Tooltip.hasTooltipAttached(element);
    }

    destroyTooltipAttached(element) {
        return Tooltip.destroyTooltipAttached(element);
    }

    //endregion

    //region Mask

    mask(config, text = 'Loading') {
        if (config) {
            // Config object normalization
            if (config instanceof HTMLElement) {
                config = {
                    element : config,
                    text
                };
            }

            return Mask.mask(config, config.element);
        }
    }

    unmask(element, close = true) {
        if (element.mask) {
            if (close) {
                element.mask.close();
            }
            else {
                element.mask.hide();
            }
        }
    }

    //endregion

    //region Toast

    toast(msg) {
        return Toast.show(msg);
    }

    //endregion

    //region Style

    // moved from WidgetHelper to avoid circular reference

    set defaultStyle(style) {
        this._defaultStyle = style;
    }

    get defaultStyle() {
        return this._defaultStyle;
    }

    //endregion
}

if (!WidgetHelper._adapter) WidgetHelper.adapter = BryntumWidgetAdapter;
BryntumWidgetAdapter._$name = 'BryntumWidgetAdapter';

/**
 * @module Core/data/DomDataStore
 */

/**
 * Stores data on a dom element (by setting element._domData).
 * Instead of using HTML5:s element.dataset, which turned out to be slow.
 * @private
 */
class DomDataStore {
    /**
     * Get data that is connected to specified element.
     * @param {HTMLElement} element DOM element
     * @param {String} [key] The name of the property in the element data to return;
     * @returns {Object} Data
     */
    static get(element, key) {
        const result = (element._domData || (element._domData = {}));

        if (key != null) {
            return result[key];
        }
        return result;
    }

    /**
     * Set data connected to specified element (completely replacing any existing).
     * To update data, use DomDataStore#assign instead.
     * @param {HTMLElement} element DOM element
     * @param {Object|String} data Data object to set, or property name to set
     * @param {*} [value] If the previous parameter was a property name, this is the value to set.
     */
    static set(element, data, value) {
        if (arguments.length === 3) {
            (element._domData || (element._domData = {}))[data] = value;
        }
        else {
            element._domData = data;
        }
    }

    /**
     * Updates data connected to specified element.
     * @param element DOM element
     * @param data Data to assign
     */
    static assign(element, data) {
        Object.assign((element._domData || (element._domData = {})), data);
    }
}
DomDataStore._$name = 'DomDataStore';

/**
 * @module Core/data/Duration
 */

/**
 * Class which represents a duration object.
 * ```
 * {
 *    unit: String,
 *    magnitude: Number
 * }
 * ```
 */
class Duration {

    /**
     * Duration constructor.
     * @param {Number} magnitude Duration magnitude value
     * @param {String} unit Duration uni value
     */
    constructor(magnitude, unit) {
        if (typeof magnitude === 'number') {
            this._magnitude = magnitude;
            this._unit = unit;
        }
        else if (typeof magnitude === 'object') {
            Object.assign(this, magnitude);
        }
    }

    /**
     * Get/Set numeric magnitude `value`.
     * @property {Number}
     */
    get magnitude() {
        return this._magnitude;
    }

    set magnitude(value) {
        this._magnitude = (typeof value === 'number') && value;
    }

    /**
     * Get/Set duration unit to use with the current magnitude value.
     * Valid values are:
     * - "millisecond" - Milliseconds
     * - "second" - Seconds
     * - "minute" - Minutes
     * - "hour" - Hours
     * - "day" - Days
     * - "week" - Weeks
     * - "month" - Months
     * - "quarter" - Quarters
     * - "year"- Years
     *
     * @property {String}
     */
    get unit() {
        return this._unit;
    }

    set unit(value) {
        this._unit = DateHelper.parseTimeUnit(value);
    }

    get isValid() {
        return this._magnitude && this._unit;
    }

    /**
     * The `milliseconds` property is a read only property which returns the number of milliseconds in this Duration
     * @property {Number}
     * @readonly
     */
    get milliseconds() {
        return this.isValid ? DateHelper.asMilliseconds(this._magnitude, this._unit) : 0;
    }

    /**
     * Returns truthy value if this Duration equals to passed value
     * @param value
     * @return {Boolean}
     */
    isEqual(value) {
        return Boolean(value && this._magnitude === value.magnitude && this._unit === value.unit);
    }

    toString(useAbbreviation) {
        const
            me             = this,
            abbreviationFn = me.useAbbreviation ? 'getShortNameOfUnit' : 'getLocalizedNameOfUnit';
        return me.isValid ? `${me._magnitude} ${DateHelper[abbreviationFn](me._unit, me._magnitude !== 1)}` : '';
    }
}Duration._$name = 'Duration';

/**
 * @module Core/data/stm/state/StateBase
 */

const throwAbstractMethodCall = () => {
    throw new Error('Abstract method call!');
};

const throwInvalidMethodCall = () => {
    throw new Error('Method cannot be called at this state!');
};

/**
 * Abstract class for STM states
 *
 * Every on* method should return a state for the STM which it should switch to
 * or throw an exception that this call at this state is illegal.
 *
 * Interface of this class mirrors interface of {@link Core.data.stm.StateTrackingManager}.
 *
 * @abstract
 */
class StateBase extends Base {

    canUndo(stm) {
        throwAbstractMethodCall();
    }

    canRedo(stm) {
        throwAbstractMethodCall();
    }

    onUndo(stm) {
        throwAbstractMethodCall();
    }

    onRedo(stm) {
        throwAbstractMethodCall();
    }

    onStartTransaction(stm) {
        throwAbstractMethodCall();
    }

    onStopTransaction(stm) {
        throwAbstractMethodCall();
    }

    onStopTransactionDelayed(stm) {
        throwAbstractMethodCall();
    }

    onRejectTransaction(stm) {
        throwAbstractMethodCall();
    }

    onEnable(stm) {
        throwAbstractMethodCall();
    }

    onDisable(stm) {
        throwAbstractMethodCall();
    }

    onAutoRecordOn(stm) {
        throwAbstractMethodCall();
    }

    onAutoRecordOff(stm) {
        throwAbstractMethodCall();
    }

    onResetQueue(stm) {
        throwAbstractMethodCall();
    }

    onModelUpdate(stm) {
        throwAbstractMethodCall();
    }

    onStoreModelAdd(stm) {
        throwAbstractMethodCall();
    }

    onStoreModelInsert(stm) {
        throwAbstractMethodCall();
    }

    onStoreModelRemove(stm) {
        throwAbstractMethodCall();
    }

    onStoreModelRemoveAll(stm) {
        throwAbstractMethodCall();
    }

    onModelInsertChild(stm) {
        throwAbstractMethodCall();
    }

    onModelRemoveChild(stm) {
        throwAbstractMethodCall();
    }
}
StateBase._$name = 'StateBase';

/**
 * @module Core/data/stm/Props.js
 * @internal
 */

const STATE_PROP             = Symbol('STATE_PROP');
const STORES_PROP            = Symbol('STORES_PROP');
const QUEUE_PROP             = Symbol('QUEUE_PROP');
const POS_PROP               = Symbol('POS_PROP');
const TRANSACTION_PROP       = Symbol('TRANSACTION_PROP');
const TRANSACTION_TIMER_PROP = Symbol('TRANSACTION_TIMER_PROP');
const AUTO_RECORD_PROP       = Symbol('AUTO_RECORD_PROP');
const PROPS                  = Object.freeze([STATE_PROP, STORES_PROP, QUEUE_PROP, POS_PROP, TRANSACTION_PROP, TRANSACTION_TIMER_PROP, AUTO_RECORD_PROP]);

/**
 * @module Core/data/stm/state/Registry
 *
 * Provides map of registered STM states.
 *
 * Needed to remove states circular dependency.
 *
 * @internal
 */
const registry = new Map();

/**
 * Registers STM state class with the given name.
 *
 * @private
 *
 * @param {string} name
 * @param {Core.data.stm.state.StateBase} state
 */
const registerStmState = (name, state) => {
    

    registry.set(name, state);
};

/**
 * Resolves STM state class with the given name.
 *
 * @private
 *
 * @param {string} name
 * @return {Core.data.stm.state.StateBase} state
 */
const resolveStmState = (state) => {
    if (typeof state === 'string') {
        state = registry.get(state);
    }

    

    return state;
};

// UMD/module compatible export
// NOTE: the most compatible way of exporting is:
//       import registry from './Registry.js';
//       { registerStmState, resolveStmState } = registry;
//          or
//       registry.registerStmState(...);
var Registry = {
    registerStmState,
    resolveStmState
};

const resetQueue = (stm, options) => {
    const { undo, redo } = options;

    let newProps;

    if (undo && !redo) {
        newProps = {
            [QUEUE_PROP] : stm[QUEUE_PROP].slice(stm.position),
            [POS_PROP]   : 0
        };
    }
    else if (redo && !undo) {
        newProps = {
            [QUEUE_PROP] : stm[QUEUE_PROP].slice(0, stm.position)
        };
    }
    else {
        newProps = {
            [QUEUE_PROP] : [],
            [POS_PROP]   : 0
        };
    }
    return [
        newProps,
        () => {
            stm.notifyStoresAboutQueueReset(options);
        }
    ];
};

/**
 * @module Core/data/stm/state/DisabledState
 */

/**
 * STM disabled state class.
 *
 * @internal
 */
class DisabledStateClass extends StateBase {

    canUndo() {
        return false;
    }

    canRedo() {
        return false;
    }

    onUndo() {
        throwInvalidMethodCall();
    }

    onRedo() {
        throwInvalidMethodCall();
    }

    onEnable(stm) {
        return stm.autoRecord ? 'autoreadystate' : 'readystate';
    }

    onDisable() {
        throwInvalidMethodCall();
    }

    onAutoRecordOn() {
        return {
            [AUTO_RECORD_PROP] : true
        };
    }

    onAutoRecordOff() {
        return {
            [AUTO_RECORD_PROP] : false
        };
    }

    onStartTransaction() {
        throwInvalidMethodCall();
    }

    onStopTransaction()  {
        throwInvalidMethodCall();
    }

    onStopTransactionDelayed() {
        throwInvalidMethodCall();
    }

    onRejectTransaction() {
        throwInvalidMethodCall();
    }

    onResetQueue(stm, options) {
        return resetQueue(stm, options);
    }

    onModelUpdate()      {}
    onModelInsertChild() {}
    onModelRemoveChild() {}
    onStoreModelAdd()    {}
    onStoreModelInsert() {}
    onStoreModelRemove() {}
    onStoreRemoveAll()   {}
}

/**
 * STM disabled state.
 *
 * @internal
 */
const DisabledState = new DisabledStateClass();

Registry.registerStmState('disabledstate', DisabledState);

/**
 * @module Core/data/stm/Transaction
 */

const ACTION_QUEUE_PROP = Symbol('ACTION_QUEUE_PROP');

/**
 * STM transaction class, holds list of actions constituting a transaction.
 *
 * A transaction can be undone and redone. Upon undo all the actions being held
 * are undone in reverse order. Upon redo all the actions being held are redone
 * in forward order.
 */
class Transaction extends Base {

    get defaultConfig() {
        return {
            /**
             * Transaction title
             *
             * @config {String}
             * @default
             */
            title : null
        };
    }

    construct(...args) {
        this[ACTION_QUEUE_PROP] = [];

        super.construct(...args);
    }

    /**
     * Gets transaction's actions queue
     *
     * @property {Core.data.stm.action.ActionBase[]}
     */
    get queue() {
        return this[ACTION_QUEUE_PROP].slice(0);
    }

    /**
     * Gets transaction's actions queue length
     *
     * @property {Number}
     */
    get length() {
        return this[ACTION_QUEUE_PROP].length;
    }

    /**
     * Adds an action to the transaction.
     *
     * @param {Core.data.stm.action.ActionBase|Object} action
     */
    addAction(action) {
        

        this[ACTION_QUEUE_PROP].push(action);
    }

    /**
     * Undoes actions held
     */
    undo() {
        const queue = this[ACTION_QUEUE_PROP];

        for (let i = queue.length - 1; i >= 0; --i) {
            queue[i].undo();
        }
    }

    /**
     * Redoes actions held
     */
    redo() {
        const queue = this[ACTION_QUEUE_PROP];

        for (let i = 0, len = queue.length; i < len; ++i) {
            queue[i].redo();
        }
    }
}
Transaction._$name = 'Transaction';

/**
 * @module Core/data/stm/state/ReadyState
 */

/**
 * STM ready state class.
 *
 * @internal
 */
class ReadyStateClass extends StateBase {

    canUndo(stm) {
        //      v
        // |*|*|
        return 0 < stm.position && stm.position <= stm.length;
    }

    canRedo(stm) {
        //  v
        // |*|*|
        return 0 <= stm.position && stm.position < stm.length;
    }

    onUndo(stm, steps) {
        const queue = stm[QUEUE_PROP];

        let curPos = stm.position,
            newPos = Math.max(0, curPos - steps);

        const next = () => {
            stm.notifyStoresAboutStateRestoringStart();

            while (curPos != newPos) {
                queue[--curPos].undo();
            }

            return [stm.autoRecord ? 'autoreadystate' : 'readystate', () => {
                stm.notifyStoresAboutStateRestoringStop();
            }];
        };

        return [{
            [STATE_PROP] : 'restoringstate',
            [POS_PROP]   : newPos
        }, next];
    }

    onRedo(stm, steps) {
        const queue = stm[QUEUE_PROP];

        let curPos = stm.position,
            newPos = Math.min(queue.length, curPos + steps);

        const next = () => {
            stm.notifyStoresAboutStateRestoringStart();

            do {
                queue[curPos++].redo();
            }
            while (curPos != newPos);

            return [stm.autoRecord ? 'autoreadystate' : 'readystate', () => {
                stm.notifyStoresAboutStateRestoringStop();
            }];
        };

        return [{
            [STATE_PROP] : 'restoringstate',
            [POS_PROP]   : newPos
        }, next];
    }

    onEnable() {
        throwInvalidMethodCall();
    }

    onDisable() {
        return 'disabledstate';
    }

    onAutoRecordOn() {
        return {
            [STATE_PROP]       : 'autoreadystate',
            [AUTO_RECORD_PROP] : true
        };
    }

    onAutoRecordOff() {
        throwInvalidMethodCall();
    }

    onStartTransaction(stm, title) {
        const transaction = new Transaction({ title : title });

        return [{
            [STATE_PROP]       : 'recordingstate',
            [TRANSACTION_PROP] : transaction
        }, () => {
            stm.notifyStoresAboutStateRecordingStart(transaction);
        }];
    }

    onStopTransaction() {
        throwInvalidMethodCall();
    }

    onStopTransactionDelayed() {
        throwInvalidMethodCall();
    }

    onRejectTransaction() {
        throwInvalidMethodCall();
    }

    onResetQueue(stm, options) {
        return resetQueue(stm, options);
    }

    onModelUpdate()      {}
    onModelInsertChild() {}
    onModelRemoveChild() {}
    onStoreModelAdd()    {}
    onStoreModelInsert() {}
    onStoreModelRemove() {}
    onStoreRemoveAll()   {}
}

/**
 * STM ready state.
 *
 * @internal
 */
let ReadyState = new ReadyStateClass();

Registry.registerStmState('readystate', ReadyState);

/**
 * @module Core/data/stm/state/RecordingState
 */

/**
 * STM recording state class.
 *
 * @internal
 */
class RecordingStateClass extends StateBase {

    canUndo() {
        return false;
    }

    canRedo() {
        return false;
    }

    onEnable() {}

    onDisable(stm) {
        const transaction = stm[TRANSACTION_PROP];

        stm.notifyStoresAboutStateRecordingStop(transaction, { disabled : true });

        return {
            [STATE_PROP]       : 'disabledstate',
            [TRANSACTION_PROP] : null
        };
    }

    onAutoRecordOn(stm) {
        return [{
            [STATE_PROP]       : 'autorecordingstate',
            [AUTO_RECORD_PROP] : true
        }, () => {
            stm[STATE_PROP].onStopTransactionDelayed(stm);
        }];
    }

    onAutoRecordOff() {
        throwInvalidMethodCall();
    }

    onStartTransaction() {
        throwInvalidMethodCall();
    }

    onStopTransaction(stm, title) {
        const transaction = stm[TRANSACTION_PROP];
        let position      = stm[POS_PROP];
        let queue         = stm[QUEUE_PROP];

        if (transaction.length) {

            if (!transaction.title && !title && stm.getTransactionTitle) {
                transaction.title = stm.getTransactionTitle(transaction);
            }
            else if (title) {
                transaction.title = title;
            }

            queue[position] = transaction;
            queue.length    = ++position;
        }

        return [{
            [STATE_PROP]       : 'readystate',
            [POS_PROP]         : position,
            [TRANSACTION_PROP] : null
        }, () => {
            stm.notifyStoresAboutStateRecordingStop(transaction, { stop : true });
        }];
    }

    onRejectTransaction(stm) {
        const transaction = stm[TRANSACTION_PROP];

        return [{
            [STATE_PROP]       : 'restoringstate',
            [TRANSACTION_PROP] : null
        }, () => {

            if (transaction.length) {
                transaction.undo();
            }

            return [
                'readystate',
                () => {
                    stm.notifyStoresAboutStateRecordingStop(transaction, { rejected : true });
                }
            ];
        }];
    }

    onStopTransactionDelayed() {
        throwInvalidMethodCall();
    }

    onQueueReset() {
        throwInvalidMethodCall();
    }

    onModelUpdate(stm, model, newData, oldData) {
        const transaction = stm[TRANSACTION_PROP];
        transaction.addAction(stm.makeModelUpdateAction(model, newData, oldData));
    }

    onModelInsertChild(stm, parentModel, index, childModel, previousParent, previousIndex) {
        const transaction = stm[TRANSACTION_PROP];
        transaction.addAction(stm.makeModelInsertChildAction(parentModel, index, childModel, previousParent, previousIndex));
    }

    onModelRemoveChild(stm, parentModel, childModels, context) {
        const transaction = stm[TRANSACTION_PROP];
        transaction.addAction(stm.makeModelRemoveChildAction(parentModel, childModels, context));
    }

    onStoreModelAdd(stm, store, models, silent)    {
        const transaction = stm[TRANSACTION_PROP];
        transaction.addAction(stm.makeStoreModelAddAction(store, models, silent));
    }

    onStoreModelInsert(stm, store, index, models, context, silent) {
        const transaction = stm[TRANSACTION_PROP];
        transaction.addAction(stm.makeStoreModelInsertAction(store, index, models, context, silent));
    }

    onStoreModelRemove(stm, store, models, context, silent) {
        const transaction = stm[TRANSACTION_PROP];
        transaction.addAction(stm.makeStoreModelRemoveAction(store, models, context, silent));
    }

    onStoreRemoveAll(stm, store, allRecords, silent)   {
        const transaction = stm[TRANSACTION_PROP];
        transaction.addAction(stm.makeStoreRemoveAllAction(store, allRecords, silent));
    }
}

/**
 * STM recording state.
 *
 * @internal
 */
const RecordingState = new RecordingStateClass();

Registry.registerStmState('recordingstate', RecordingState);

/**
 * @module Core/data/stm/state/RestoringState
 */

/**
 * STM restoring state class.
 *
 * @internal
 */
class RestoringStateClass extends StateBase {

    canUndo() {
        return false;
    }

    canRedo() {
        return false;
    }

    onUndo() {
        throwInvalidMethodCall();
    }

    onRedo() {
        throwInvalidMethodCall();
    }

    onEnable() {
        throwInvalidMethodCall();
    }

    onDisable() {
        throwInvalidMethodCall();
    }

    onAutoRecordOn() {
        return {
            [AUTO_RECORD_PROP] : true
        };
    }

    onAutoRecordOff() {
        return {
            [AUTO_RECORD_PROP] : false
        };
    }

    onStartTransaction() {
        throwInvalidMethodCall();
    }

    onStopTransaction()  {
        throwInvalidMethodCall();
    }

    onStopTransactionDelayed() {
        throwInvalidMethodCall();
    }

    onRejectTransaction() {
        throwInvalidMethodCall();
    }

    onQueueReset() {
        throwInvalidMethodCall();
    }

    onModelUpdate()      {}
    onModelInsertChild() {}
    onModelRemoveChild() {}
    onStoreModelAdd()    {}
    onStoreModelInsert() {}
    onStoreModelRemove() {}
    onStoreRemoveAll()   {}
}

/**
 * STM restoring state.
 *
 * @internal
 */
const RestoringState = new RestoringStateClass();

Registry.registerStmState('restoringstate', RestoringState);

/**
 * @module Core/data/stm/state/AutoReadyState
 */

/**
 * STM transaction autostart ready state class.
 *
 * @internal
 */
class AutoReadyStateClass extends ReadyStateClass {

    onAutoRecordOn() {
        throwInvalidMethodCall();
    }

    onAutoRecordOff() {
        return {
            [STATE_PROP]       : 'readystate',
            [AUTO_RECORD_PROP] : false
        };
    }

    onStartTransaction(stm, title) {
        const transaction = new Transaction({ title : title });

        return [{
            [STATE_PROP]       : 'autorecordingstate',
            [TRANSACTION_PROP] : transaction
        }, () => {
            stm.notifyStoresAboutStateRecordingStart(transaction);
            stm.stopTransactionDelayed();
        }];
    }

    onModelUpdate(stm, model, newData, oldData) {
        stm.startTransaction();
        stm.onModelUpdate(model, newData, oldData);
    }

    onModelInsertChild(stm, parentModel, index, childModels, context) {
        stm.startTransaction();
        stm.onModelInsertChild(parentModel, index, childModels, context);
    }

    onModelRemoveChild(stm, parentModel, childModels, context) {
        stm.startTransaction();
        stm.onModelRemoveChild(parentModel, childModels, context);
    }

    onStoreModelAdd(stm, store, models, silent) {
        stm.startTransaction();
        stm.onStoreModelAdd(store, models, silent);
    }

    onStoreModelInsert(stm, store, index, models, context, silent) {
        stm.startTransaction();
        stm.onStoreModelInsert(store, index, models, silent);
    }

    onStoreModelRemove(stm, store, models, context, silent) {
        stm.startTransaction();
        stm.onStoreModelRemove(store, models, context, silent);
    }

    onStoreRemoveAll(stm, store, allRecords, silent) {
        stm.startTransaction();
        stm.onStoreRemoveAll(store, allRecords, silent);
    }
}

/**
 * STM transaction autostart ready state.
 *
 * @internal
 */
const AutoReadyState = new AutoReadyStateClass();

Registry.registerStmState('autoreadystate', AutoReadyState);

/**
 * @module Core/data/stm/state/AutoRecordingState
 */

/**
 * STM recording state class.
 *
 * @internal
 */
class AutoRecordingStateClass extends Delayable(RecordingStateClass) {

    onDisable(stm) {
        const transaction = stm[TRANSACTION_PROP];
        const timer       = stm[TRANSACTION_TIMER_PROP];

        if (timer) {
            this.clearTimeout(timer);
        }

        stm.notifyStoresAboutStateRecordingStop(transaction, { disabled : true });

        return {
            [STATE_PROP]             : 'disabledstate',
            [TRANSACTION_PROP]       : null,
            [TRANSACTION_TIMER_PROP] : null
        };
    }

    onAutoRecordOn(stm) {
        throwInvalidMethodCall();
    }

    onAutoRecordOff(stm) {
        const timer       = stm[TRANSACTION_TIMER_PROP];

        if (timer) {
            this.clearTimeout(timer);
        }

        return {
            [STATE_PROP]             : 'recordingstate',
            [AUTO_RECORD_PROP]       : false,
            [TRANSACTION_TIMER_PROP] : null
        };
    }

    onStopTransaction(stm, title) {
        const transaction = stm[TRANSACTION_PROP];
        const timer       = stm[TRANSACTION_TIMER_PROP];
        let position      = stm[POS_PROP];
        let queue         = stm[QUEUE_PROP];

        if (timer) {
            this.clearTimeout(timer);
        }

        if (transaction.length) {

            if (!transaction.title && !title && stm.getTransactionTitle) {
                transaction.title = stm.getTransactionTitle(transaction);
            }
            else if (title) {
                transaction.title = title;
            }

            queue[position] = transaction;
            queue.length    = ++position;
        }

        return [{
            [STATE_PROP]             : 'autoreadystate',
            [POS_PROP]               : position,
            [TRANSACTION_PROP]       : null,
            [TRANSACTION_TIMER_PROP] : null
        }, () => {
            stm.notifyStoresAboutStateRecordingStop(transaction, { stop : true });
        }];
    }

    onStopTransactionDelayed(stm) {
        let timer = stm[TRANSACTION_TIMER_PROP];

        if (timer) {
            this.clearTimeout(timer);
        }

        timer = this.setTimeout(
            () => {
                stm.stopTransaction();
            },
            stm.autoRecordTransactionStopTimeout
        );

        return {
            [STATE_PROP]             : AutoRecordingState,
            [TRANSACTION_TIMER_PROP] : timer
        };
    }

    onRejectTransaction(stm) {
        const transaction = stm[TRANSACTION_PROP],
            timer = stm[TRANSACTION_TIMER_PROP];

        if (timer) {
            this.clearTimeout(timer);
        }

        return [{
            [STATE_PROP]             : 'restoringstate',
            [TRANSACTION_PROP]       : null,
            [TRANSACTION_TIMER_PROP] : null
        }, () => {

            if (transaction.length) {
                transaction.undo();
            }

            return [
                'autoreadystate',
                () => {
                    stm.notifyStoresAboutStateRecordingStop(transaction, { rejected : true });
                }
            ];
        }];
    }

    onModelUpdate(stm, ...rest) {
        super.onModelUpdate(stm, ...rest);
        stm.stopTransactionDelayed();
    }

    onModelInsertChild(stm, ...rest) {
        super.onModelInsertChild(stm, ...rest);
        stm.stopTransactionDelayed();
    }

    onModelRemoveChild(stm, ...rest) {
        super.onModelRemoveChild(stm, ...rest);
        stm.stopTransactionDelayed();
    }

    onStoreModelAdd(stm, ...rest)    {
        super.onStoreModelAdd(stm, ...rest);
        stm.stopTransactionDelayed();
    }

    onStoreModelInsert(stm, ...rest) {
        super.onStoreModelInsert(stm, ...rest);
        stm.stopTransactionDelayed();
    }

    onStoreModelRemove(stm, ...rest) {
        super.onStoreModelRemove(stm, ...rest);
        stm.stopTransactionDelayed();
    }

    onStoreRemoveAll(stm, ...rest)   {
        super.onStoreRemoveAll(stm, ...rest);
        stm.stopTransactionDelayed();
    }
}

/**
 * STM recording state.
 *
 * @internal
 */
const AutoRecordingState = new AutoRecordingStateClass();

Registry.registerStmState('autorecordingstate', AutoRecordingState);

/**
 * @module Core/data/stm/action/ActionBase
 */

const throwAbstractMethodCall$1 = () => {
    throw new Error('Abstract method call!');
};

/**
 * Base class for STM actions.
 *
 * @abstract
 */
class ActionBase extends Base {

    /**
     * Gets the type of the action (stringified class name).
     *
     * @return {String}
     */
    get type() {
        return this.constructor.name;
    }

    /**
     * Undoes an action
     */
    undo() {
        throwAbstractMethodCall$1();
    }

    /**
     * Redoes an action
     */
    redo() {
        throwAbstractMethodCall$1();
    }
}
ActionBase._$name = 'ActionBase';

/**
 * @module Core/data/stm/action/UpdateAction
 */

const MODEL_PROP    = Symbol('MODEL_PROP');
const NEW_DATA_PROP = Symbol('NEW_DATA_PROP');
const OLD_DATA_PROP = Symbol('OLD_DATA_PROP');

/**
 * Action to record the fact that a model has been updated.
 */
class UpdateAction extends ActionBase {

    static get defaultConfig() {
        return {
            /**
             * Reference to a model which has been updated.
             *
             * @config {Core.data.Model}
             * @default
             */
            model : undefined,

            /**
             * Map of updated properties with new values.
             *
             * @config {Object}
             * @default
             */
            newData : undefined,

            /**
             * Map of updated properties with old values.
             *
             * @config {Object}
             * @default
             */
            oldData : undefined
        };
    }

    get type() {
        return 'UpdateAction';
    }

    

    get model() {
        return this[MODEL_PROP];
    }

    set model(value) {
        
        this[MODEL_PROP] = value;
    }

    get newData() {
        return this[NEW_DATA_PROP];
    }

    set newData(value) {
        
        this[NEW_DATA_PROP] = Object.assign({}, value);
    }

    get oldData() {
        return this[OLD_DATA_PROP];
    }

    set oldData(value) {
        
        this[OLD_DATA_PROP] = Object.assign({}, value);
    }

    undo() {
        this.model.set(this.oldData);
    }

    redo() {
        this.model.set(this.newData);
    }
}
UpdateAction._$name = 'UpdateAction';

/**
 * @module Core/data/stm/action/InsertChildAction
 */

const PARENT_MODEL_PROP    = Symbol('PARENT_MODEL_PROP');
const CHILD_MODELS_PROP    = Symbol('CHILD_MODELS_PROP');
const INSERT_INDEX_PROP    = Symbol('INSERT_INDEX_PROP');
const CONTEXT_PROP         = Symbol('CONTEXT_PROP');

/**
 * Action to record the fact of adding a children models into a parent model.
 */
class InsertChildAction extends ActionBase {

    static get defaultConfig() {
        return {
            /**
             * Reference to a parent model a child model has been added to.
             *
             * @config {Core.data.Model}
             * @default
             */
            parentModel : undefined,

            /**
             * Children models inserted.
             *
             * @config {Core.data.Model[]}
             * @default
             */
            childModels : undefined,

            /**
             * Index a children models are inserted at
             *
             * @config {Number}
             * @default
             */
            insertIndex : undefined,

            /**
             * Map having children models as keys and values containing previous parent
             * of each model and index at the previous parent.
             *
             * @config {Object}
             * @default
             */
            context : undefined
        };
    }

    get type() {
        return 'InsertChildAction';
    }

    

    get parentModel() {
        return this[PARENT_MODEL_PROP];
    }

    set parentModel(model) {
        

        this[PARENT_MODEL_PROP] = model;
    }

    get childModels() {
        return this[CHILD_MODELS_PROP];
    }

    set childModels(models) {
        

        this[CHILD_MODELS_PROP] = models.slice(0);
    }

    get insertIndex() {
        return this[INSERT_INDEX_PROP];
    }

    set insertIndex(index) {
        

        this[INSERT_INDEX_PROP] = index;
    }

    get context() {
        return this[CONTEXT_PROP];
    }

    set context(ctx) {
        

        this[CONTEXT_PROP] = ctx;
    }

    undo() {
        const { parentModel, context, childModels } = this;

        // Let's sort models by parent index such that models with lesser index
        // were inserted back first, thus making valid parent index of models following.
        childModels.sort((lhs, rhs) => {
            const { lhsParent, lhsIndex } = context.get(lhs) || {},
                { rhsParent, rhsIndex } = context.get(rhs) || {};

            return lhsParent && lhsParent === rhsParent ? (lhsIndex - rhsIndex) : 0;
        });

        // Now let's re-insert records back to where they were or remove them
        // if they weren't anywhere
        childModels.forEach(m => {
            const { parent, index } = context.get(m) || {};

            if (parent) {
                // If we move within same parent then index must be adjusted
                if (parent === parentModel) {
                    let adjustedIndex;
                    
                    // we need to increment index if the node was moved up
                    adjustedIndex = index > m.parentIndex ? index + 1 : index;
                    
                    // null index if we need to move to the end
                    adjustedIndex = index === parent.children.length - 1 ? null : adjustedIndex;
                    
                    // undefined insertBefore is needed to append the node to the end
                    const insertBefore = adjustedIndex === null ? undefined : parent.children[adjustedIndex];
                    
                    parent.insertChild(m, insertBefore);
                }
                else {
                    // Insert at previous index
                    parent.insertChild(m, parent.children[index]);
                }
            }
            else {
                // Just remove
                parentModel.removeChild(m);
            }
        });
    }

    redo() {
        const { parentModel, insertIndex, childModels } = this,
            insertBefore = parentModel.children[insertIndex];

        parentModel.insertChild(childModels, insertBefore);

    }
}
InsertChildAction._$name = 'InsertChildAction';

const PARENT_MODEL_PROP$1    = Symbol('PARENT_MODEL_PROP');
const CHILD_MODELS_PROP$1    = Symbol('CHILD_MODELS_PROP');
const CONTEXT_PROP$1         = Symbol('CONTEXT_PROP');

class RemoveChildAction extends ActionBase {

    static get defaultConfig() {
        return {
            /**
             * Reference to a parent model a child model has been removed to.
             *
             * @config {Core.data.Model}
             * @default
             */
            parentModel : undefined,

            /**
             * Children models removed.
             *
             * @config {Core.data.Model[]}
             * @default
             */
            childModels : undefined,

            /**
             * Map having children models as keys and values containing previous parent
             * index at the parent.
             *
             * @config {Object}
             * @default
             */
            context : undefined
        };
    }

    get type() {
        return 'RemoveChildAction';
    }

    

    get parentModel() {
        return this[PARENT_MODEL_PROP$1];
    }

    set parentModel(model) {
        

        this[PARENT_MODEL_PROP$1] = model;
    }

    get childModels() {
        return this[CHILD_MODELS_PROP$1];
    }

    set childModels(models) {
        

        this[CHILD_MODELS_PROP$1] = models.slice(0);
    }

    get context() {
        return this[CONTEXT_PROP$1];
    }

    set context(ctx) {
        

        this[CONTEXT_PROP$1] = ctx;
    }

    undo() {
        const { parentModel, context, childModels } = this;

        // Let's sort models by parent index such that models with lesser index
        // were inserted back first, thus making valid parent index of models following.

        childModels.sort((lhs, rhs) => {
            const lhsIndex = context.get(lhs),
                rhsIndex = context.get(rhs);

            return (lhsIndex - rhsIndex);
        });

        // Now let's re-insert records back to where they were
        childModels.forEach(m => {
            parentModel.insertChild(context.get(m), m);
        });
    }

    redo() {
        this.parentModel.removeChild(this.childModels);
    }
}
RemoveChildAction._$name = 'RemoveChildAction';

/**
 * @module Core/data/stm/action/AddAction
 */
const STORE_PROP      = Symbol('STORE_PROP');
const MODEL_LIST_PROP = Symbol('MODEL_LIST_PROP');

/**
 * Action to record the fact of models adding to a store.
 */
class AddAction extends ActionBase {

    static get defaultConfig() {
        return {
            /**
             * Reference to a store models have been added into.
             *
             * @config {Core.data.Store}
             * @default
             */
            store : undefined,

            /**
             * List of models added into the store.
             *
             * @config {Core.data.Model[]}
             * @default
             */
            modelList : undefined,

            /**
             * Flag showing if undo/redo should be done silently i.e. with events suppressed
             *
             * @config {Boolean}
             * @default
             */
            silent : false
        };
    }

    get type() {
        return 'AddAction';
    }

    

    get store() {
        return this[STORE_PROP];
    }

    set store(store) {
        

        this[STORE_PROP] = store;
    }

    get modelList() {
        return this[MODEL_LIST_PROP];
    }

    set modelList(list) {
        

        this[MODEL_LIST_PROP] = list.slice(0);
    }

    undo() {
        const me = this;
        me.store.remove(me.modelList, me.silent);
    }

    redo() {
        const me = this;
        me.store.add(me.modelList, me.silent);
    }
}
AddAction._$name = 'AddAction';

/**
 * @module Core/data/stm/action/InsertAction
 */

const STORE_PROP$1        = Symbol('STORE_PROP');
const MODEL_LIST_PROP$1   = Symbol('MODEL_LIST_PROP');
const INSERT_INDEX_PROP$1 = Symbol('INSERT_INDEX_PROP');
const CONTEXT_PROP$2      = Symbol('CONTEXT_PROP');

/**
 * Action to record the fact of models inserting into a store.
 */
class InsertAction extends ActionBase {

    static get defaultConfig() {
        return {
            /**
             * Reference to a store models have been inserted into.
             *
             * @config {Core.data.Store}
             * @default
             */
            store : undefined,

            /**
             * List of models inserted into the store.
             *
             * @config {Core.data.Model[]}
             * @default
             */
            modelList : undefined,

            /**
             * Index the models have been inserted at.
             *
             * @config {Number}
             * @default
             */
            insertIndex : undefined,

            /**
             * Models move context (if models has been moved), if any.
             * Map this {@link Core/data/Model} instances as keys and their
             * previous index as values
             *
             * @config {Map}
             * @default
             */
            context : undefined,

            /**
             * Flag showing if undo/redo should be done silently i.e. with events suppressed
             *
             * @config {Boolean}
             * @default
             */
            silent : false
        };
    }

    get type() {
        return 'InsertAction';
    }

    

    get store() {
        return this[STORE_PROP$1];
    }

    set store(store) {
        

        this[STORE_PROP$1] = store;
    }

    get modelList() {
        return this[MODEL_LIST_PROP$1];
    }

    set modelList(list) {
        

        this[MODEL_LIST_PROP$1] = list.slice(0);
    }

    get insertIndex() {
        return this[INSERT_INDEX_PROP$1];
    }

    set insertIndex(index) {
        

        this[INSERT_INDEX_PROP$1] = index;
    }

    get context() {
        return this[CONTEXT_PROP$2];
    }

    set context(context) {
        

        this[CONTEXT_PROP$2] = context;
    }

    undo() {
        const { store, modelList, context, silent } = this;

        // Let's sort models by index such that models with lesser index
        // were inserted back first, thus making valid index of models following.

        modelList.sort((lhs, rhs) => {
            const lhsIndex = context.get(lhs),
                rhsIndex = context.get(rhs);

            return lhsIndex !== undefined && rhsIndex !== undefined ? lhsIndex - rhsIndex : 0;
        });

        modelList.forEach(m => {
            const index = context.get(m);

            if (index !== undefined) {
                // Insert at previous index
                store.insert(index, m, silent);
            }
            else {
                // Just remove
                store.remove(m, silent);
            }
        });
    }

    redo() {
        const me = this;
        me.store.insert(me.insertIndex, me.modelList, me.silent);
    }
}
InsertAction._$name = 'InsertAction';

/**
 * @module Core/data/stm/action/RemoveAction
 */

const STORE_PROP$2 = Symbol('STORE_PROP');
const MODEL_LIST_PROP$2 = Symbol('MODEL_LIST_PROP');
const CONTEXT_PROP$3 = Symbol('CONTEXT_PROP');

/**
 * Action to record the fact of models removed from a store.
 */
class RemoveAction extends ActionBase {

    static get defaultConfig() {
        return {
            /**
             * Reference to a store models have been removed from.
             *
             * @config {Core.data.Store}
             * @default
             */
            store : undefined,

            /**
             * List of models removed from the store.
             *
             * @config {Core.data.Model[]}
             * @default
             */
            modelList : undefined,

            /**
             * Models removing context.
             *
             * @config {Object}
             * @default
             */
            context : undefined,

            /**
             * Flag showing if undo/redo should be done silently i.e. with events suppressed
             *
             * @config {Boolean}
             * @default
             */
            silent : false
        };
    }

    get type() {
        return 'RemoveAction';
    }

    

    get store() {
        return this[STORE_PROP$2];
    }

    set store(store) {
        

        this[STORE_PROP$2] = store;
    }

    get modelList() {
        return this[MODEL_LIST_PROP$2];
    }

    set modelList(list) {
        

        this[MODEL_LIST_PROP$2] = list.slice(0);
    }

    get context() {
        return this[CONTEXT_PROP$3];
    }

    set context(context) {
        

        this[CONTEXT_PROP$3] = context;
    }

    undo() {
        const { store, context, modelList, silent } = this;

        // Let's sort models by index such that models with lesser index
        // were inserted back first, thus making valid index of models following.
        modelList.sort((lhs, rhs) => {
            const lhsIndex = context.get(lhs),
                rhsIndex = context.get(rhs);

            // Here, in contrast to InsertAction, index is always present
            return lhsIndex - rhsIndex;
        });

        modelList.forEach(m => {
            const index = context.get(m);

            // Insert at previous index
            store.insert(index, m, silent);
        });
    }

    redo() {
        const me = this;
        me.store.remove(me.modelList, me.silent);
    }
}
RemoveAction._$name = 'RemoveAction';

/**
 * @module Core/data/stm/action/RemoveAllAction
 */

const STORE_PROP$3       = Symbol('STORE_PROP');
const ALL_RECORDS_PROP = Symbol('ALL_RECORDS_PROP');

/**
 * Action to record store remove all operation.
 */
class RemoveAllAction extends ActionBase {

    static get defaultConfig() {
        return {
            /**
             * Reference to a store cleared.
             *
             * @config {Core.data.Store}
             * @default
             */
            store : undefined,

            /**
             * All store records removed
             *
             * @config {Core.data.Model[]}
             * @default
             */
            allRecords : undefined,

            /**
             * Flag showing if undo/redo should be done silently i.e. with events suppressed
             *
             * @config {Boolean}
             * @default
             */
            silent : false
        };
    }

    get type() {
        return 'RemoveAllAction';
    }

    

    get store() {
        return this[STORE_PROP$3];
    }

    set store(store) {
        

        this[STORE_PROP$3] = store;
    }

    get allRecords() {
        return this[ALL_RECORDS_PROP];
    }

    set allRecords(records) {
        

        this[ALL_RECORDS_PROP] = records.slice(0);
    }

    undo() {
        const { store, allRecords, silent } = this;
        store.add(allRecords, silent);
    }

    redo() {
        const me = this;
        me.store.removeAll(me.silent);
    }
}
RemoveAllAction._$name = 'RemoveAllAction';

/**
 * @module Core/data/stm/StateTrackingManager
 */

const makeModelUpdateAction = (model, newData, oldData) => {
    return new UpdateAction({
        model,
        newData,
        oldData
    });
};

const makeModelInsertChildAction = (parentModel, insertIndex, childModels, context) => {
    return new InsertChildAction({
        parentModel,
        childModels,
        insertIndex,
        context
    });
};

const makeModelRemoveChildAction = (parentModel, childModels, context) => {
    return new RemoveChildAction({
        parentModel,
        childModels,
        context
    });
};

const makeStoreModelAddAction = (store, modelList, silent) => {
    return new AddAction({
        store,
        modelList,
        silent
    });
};

const makeStoreModelInsertAction = (store, insertIndex, modelList, context, silent) => {
    return new InsertAction({
        store,
        insertIndex,
        modelList,
        context,
        silent
    });
};

const makeStoreModelRemoveAction = (store, modelList, context, silent) => {
    return new RemoveAction({
        store,
        modelList,
        context,
        silent
    });
};

const makeStoreRemoveAllAction = (store, allRecords, silent) => {
    return new RemoveAllAction({
        store,
        allRecords,
        silent
    });
};

const stateTransition = (stm, event, ...args) => {
    const newState = event.call(stm[STATE_PROP], stm, ...args);

    if (typeof newState === 'string') {
        stm[STATE_PROP] = Registry.resolveStmState(newState);
    }
    else if (newState instanceof StateBase) {
        stm[STATE_PROP] = newState;
    }
    else if (Array.isArray(newState)) {
        const [state, next] = newState;

        if (typeof state === 'string') {
            stm[STATE_PROP] = Registry.resolveStmState(state);
        }
        else if (state instanceof StateBase) {
            stm[STATE_PROP] = state;
        }
        else if (state && typeof state === 'object') {
            stm = Object.assign(stm, state);
            stm[STATE_PROP] = Registry.resolveStmState(stm[STATE_PROP]);
        }

        if (typeof next === 'function') {
            stateTransition(stm, next, ...args);
        }
    }
    else if (newState && typeof newState === 'object') {
        stm = Object.assign(stm, newState);
        stm[STATE_PROP] = Registry.resolveStmState(stm[STATE_PROP]);
    }
};

/**
 * State Tracking Manager.
 *
 * When enabled tracks state of every store registered via {@link #function-addStore}.
 * Use {@link #function-undo} / {@link #function-redo} method calls to restore state to a particular
 * point in time
 *
 * @example
 *
 * stm = new StateTrackingManager({
 *     autoRecord : true,
 *     listeners  : {
 *        'recordingstop' : () => {
 *            // your custom code to update undo/redo GUI controls
 *            updateUndoRedoControls();
 *        },
 *        'restoringstop' : ({ stm }) => {
 *            // your custom code to update undo/redo GUI controls
 *            updateUndoRedoControls();
 *        }
 *    },
 *    getTransactionTitle : (transaction) => {
 *        // your custom code to analyze the transaction and return custom transaction title
 *        const lastAction = transaction.queue[transaction.queue.length - 1];
 *
 *        if (lastAction instanceof AddAction) {
 *            let title = 'Add new record';
 *        }
 *
 *        return title;
 *    }
 * });
 *
 * stm.addStore(userStore);
 * stm.addStore(companyStore);
 * stm.addStore(otherStore);
 *
 * stm.enable();
 */
class StateTrackingManager extends Events(Base) {

    static get defaultConfig() {
        return {
            /**
             * Default manager disabled state
             *
             * @config {Boolean}
             * @default
             */
            disabled : true,

            /**
             * Whether to start transaction recording automatically in case the Manager is enabled.
             *
             * In the auto recording mode, the manager waits for the first change in any store being managed and starts a transaction, i.e.
             * records any changes in its monitored stores. The transaction lasts for {@link #config-autoRecordTransactionStopTimeout} and
             * afterwards creates one undo/redo step, including all changes in the stores during that period of time.
             *
             * In non auto recording mode you have to call {@link #function-startTransaction} / {@link #function-stopTransaction} to start and end
             * a transaction.
             *
             * @config {Boolean}
             * @default
             */
            autoRecord : false,

            /**
             * The transaction duration (in ms) for the auto recording mode {@link #config-autoRecord}
             *
             * @config {Number}
             * @default
             */
            autoRecordTransactionStopTimeout : 100,

            /**
             * Store model update action factory
             *
             * @config {Function}
             * @default
             * @private
             */
            makeModelUpdateAction : makeModelUpdateAction,

            /**
             * Store insert child model action factory.
             *
             * @config {Function}
             * @default
             * @private
             */
            makeModelInsertChildAction : makeModelInsertChildAction,

            /**
             * Store remove child model action factory.
             *
             * @config {Function}
             * @default
             * @private
             */
            makeModelRemoveChildAction : makeModelRemoveChildAction,

            /**
             * Store add model action factory.
             *
             * @config {Function}
             * @default
             * @private
             */
            makeStoreModelAddAction : makeStoreModelAddAction,

            /**
             * Store insert model action factory.
             *
             * @config {Function}
             * @default
             * @private
             */
            makeStoreModelInsertAction : makeStoreModelInsertAction,

            /**
             * Store remove model action factory.
             *
             * @config {Function}
             * @default
             * @private
             */
            makeStoreModelRemoveAction : makeStoreModelRemoveAction,

            /**
             * Store remove all models action factory.
             *
             * @config {Function}
             * @default
             * @private
             */
            makeStoreRemoveAllAction : makeStoreRemoveAllAction,

            /**
             * Function to create a transaction title if none is provided.
             *
             * The function receives a transaction and should return a title.
             *
             * @config {Function}
             * @default
             */
            getTransactionTitle : null
        };
    }

    construct(...args) {
        const me = this;

        Object.assign(me, {
            [STATE_PROP]             : ReadyState,
            [STORES_PROP]            : [],
            [QUEUE_PROP]             : [],
            [POS_PROP]               : 0,
            [TRANSACTION_PROP]       : null,
            [TRANSACTION_TIMER_PROP] : null,
            [AUTO_RECORD_PROP]       : false
        });

        super.construct(...args);
    }

    doDestroy() {
        super.doDestroy();
        this.destroyProperties(STATE_PROP);
    }

    /**
     * Gets current state of the manager
     *
     * @return {Core.data.stm.state.StateBase}
     */
    get state() {
        return this[STATE_PROP];
    }

    /**
     * Gets current undo/redo queue position
     *
     * @return {Number}
     */
    get position() {
        return this[POS_PROP];
    }

    /**
     * Gets current undo/redo queue length
     *
     * @return {Number}
     */
    get length() {
        return this[QUEUE_PROP].length;
    }

    /**
     * Gets all the stores registered in STM
     *
     * @return {Core.data.Store[]}
     */
    get stores() {
        return Array.from(this[STORES_PROP]);
    }

    /**
     * Checks if a store has been added to the manager
     *
     * @param  {Core.data.Store} store
     * @return {Boolean}
     */
    hasStore(store) {
        return this[STORES_PROP].includes(store);
    }

    /**
     * Adds a store to the manager
     *
     * @param {Core.data.Store} store
     */
    addStore(store) {
        

        if (!this.hasStore(store)) {

            this[STORES_PROP].push(store);

            store.stm = this;
        }
    }

    /**
     * Removes a store from the manager
     *
     * @param {Core.data.Store} store
     */
    removeStore(store) {
        

        if (this.hasStore(store)) {
            this[STORES_PROP] = this[STORES_PROP].filter(s => s !== store);
            store.stm = null;
        }
    }

    /**
     * Returns previously added store by it's id or undefined if store with the given id isn't added.
     *
     * @param  {String|Number} id
     * @return {Core.data.Store}
     * @deprecated 2.1
     */
    getStoreById(id) {
        return this[STORES_PROP].find(s => s.id === id);
    }

    /**
     * Calls `fn` for each store registered in STM.
     *
     * @param {Function} fn (store, id) => ...
     */
    forEachStore(fn) {
        this[STORES_PROP].forEach(s => fn(s, s.id));
    }

    /**
     * Get/set manager disabled state
     *
     * @property {Boolean}
     */
    get disabled() {
        return this.state === DisabledState;
    }

    set disabled(val) {
        const me = this;

        if (me.disabled != val) {
            if (val) {
                stateTransition(me, me.state.onDisable, me);
            }
            else {
                stateTransition(me, me.state.onEnable, me);
            }
        }
    }

    /**
     * Enables manager
     */
    enable() {
        this.disabled = false;
    }

    /**
     * Disables manager
     */
    disable() {
        this.disabled = true;
    }

    /**
     * Checks manager ready state
     *
     * @return {Boolean}
     */
    get isReady() {
        return this.state === ReadyState || this.state === AutoReadyState;
    }

    /**
     * Checks manager recording state
     *
     * @return {Boolean}
     */
    get isRecording() {
        return this.state === RecordingState || this.state === AutoRecordingState;
    }

    /**
     * Gets/sets manager auto record option
     *
     * @property {Boolean}
     */
    get autoRecord() {
        return this[AUTO_RECORD_PROP];
    }

    set autoRecord(value) {
        const me = this;

        if (me.autoRecord != value) {
            if (value) {
                stateTransition(me, me.state.onAutoRecordOn, me);
            }
            else {
                stateTransition(me, me.state.onAutoRecordOff, me);
            }
        }
    }

    /**
     * Starts undo/redo recording transaction.
     *
     * @param {String} [title=nul]
     */
    startTransaction(title = null) {
        stateTransition(this, this.state.onStartTransaction, title);
    }

    /**
     * Stops undo/redo recording transaction
     *
     * @param {String} [title=null]
     */
    stopTransaction(title = null) {
        stateTransition(this, this.state.onStopTransaction, title);
    }

    /**
     * Stops undo/redo recording transaction after {@link #config-autoRecordTransactionStopTimeout} delay.
     *
     * @private
     */
    stopTransactionDelayed() {
        stateTransition(this, this.state.onStopTransactionDelayed);
    }

    /**
     * Rejects currently recorded transaction.
     */
    rejectTransaction() {
        stateTransition(this, this.state.onRejectTransaction);
    }

    /**
     * Gets currently recording STM transaction.
     *
     * @return {Core.data.stm.Transaction}
     */
    get transaction() {
        return this[TRANSACTION_PROP];
    }

    /**
     * Gets titles of all recorded undo/redo transactions
     *
     * @return {String[]}
     */
    get queue() {
        return this[QUEUE_PROP].map((t) => t.title);
    }
    
    

    /**
     * Gets manager restoring state.
     *
     * @return {Boolean}
     */
    get isRestoring() {
        return this.state === RestoringState;
    }

    /**
     * Checks if the manager can undo.
     *
     * @return {Boolean}
     */
    get canUndo() {
        return this.state.canUndo(this);
    }

    /**
     * Checks if the manager can redo.
     *
     * @return {Boolean}
     */
    get canRedo() {
        return this.state.canRedo(this);
    }

    /**
     * Undoes current undo/redo transaction.
     *
     * @param {Number} [steps=1]
     */
    undo(steps = 1) {
        stateTransition(this, this.state.onUndo, steps);
    }

    /**
     * Undoes all transactions.
     */
    undoAll() {
        this.undo(this.length);
    }

    /**
     * Redoes current undo/redo transaction.
     *
     * @param {Number} [steps=1]
     */
    redo(steps = 1) {
        stateTransition(this, this.state.onRedo, steps);
    }

    /**
     * Redoes all transactions.
     */
    redoAll() {
        this.redo(this.length);
    }

    /**
     * Resets undo/redo queue.
     */
    resetQueue(/* private */options = { undo : true, redo : true }) {
        stateTransition(this, this.state.onResetQueue, options);
    }

    /**
     * Resets undo queue.
     */
    resetUndoQueue() {
        this.resetQueue({ undo : true });
    }

    /**
     * Resets redo queue.
     */
    resetRedoQueue() {
        this.resetQueue({ redo : true });
    }

    notifyStoresAboutStateRecordingStart(transaction) {
        this.forEachStore((store) => {
            store.onStmRecordingStart && store.onStmRecordingStart(this, transaction);
        });
        /**
         * Fired upon state recording operation starts.
         *
         * @event recordingStart
         * @param {Core.data.stm.StateTrackingManager} stm
         * @param {Core.data.stm.Transaction} transaction
         */
        this.trigger('recordingStart', { stm : this, transaction });
    }

    notifyStoresAboutStateRecordingStop(transaction, reason) {
        this.forEachStore((store) => {
            store.onStmRecordingStop && store.onStmRecordingStop(this, transaction, reason);
        });
        /**
         * Fired upon state recording operation stops.
         *
         * @event recordingStop
         * @param {Core.data.stm.StateTrackingManager} stm
         * @param {Core.data.stm.Transaction} transaction
         * @param {Object} reason Transaction stop reason
         * @param {Boolean} reason.stop Transaction recording has been stopped in a normal way.
         * @param {Boolean} reason.disabled Transaction recording has been stopped due to STM has been disabled.
         * @param {Boolean} reason.rejected Transaction recording has been stopped due to transaction has been rejected.
         */
        this.trigger('recordingStop', { stm : this, transaction, reason });
    }

    notifyStoresAboutStateRestoringStart() {
        this.forEachStore((store) => {
            store.onStmRestoringStart && store.onStmRestoringStart(this);
        });
        /**
         * Fired upon state restoration operation starts.
         *
         * @event restoringStart
         * @param {Core.data.stm.StateTrackingManager} stm
         */
        this.trigger('restoringStart', { stm : this });
    }

    notifyStoresAboutStateRestoringStop() {
        this.forEachStore((store) => {
            store.onStmRestoringStop && store.onStmRestoringStop(this);
        });
        /**
         * Fired upon state restoration operation stops.
         *
         * @event restoringStop
         * @param {Core.data.stm.StateTrackingManager} stm
         */
        this.trigger('restoringStop', { stm : this });
    }

    notifyStoresAboutQueueReset(options) {
        this.forEachStore((store) => {
            store.onStmQueueReset && store.onStmQueueReset(this, options);
        });
        /**
         * Fired upon state undo/redo queue reset.
         *
         * @event queueReset
         * @param {Core.data.stm.StateTrackingManager} stm
         */
        this.trigger('queueReset', { stm : this, options });
    }

    /**
     * Method to call from model STM mixin upon model update
     *
     * @param {Core.data.Model} model
     * @param {Object} newData
     * @param {Object} oldData
     *
     * @private
     */
    onModelUpdate(model, newData, oldData) {
        stateTransition(this, this.state.onModelUpdate, model, newData, oldData);
    }

    /**
     * Method to call from model STM mixin upon tree model child insertion
     *
     * @param {Core.data.Model} parentModel Parent model
     * @param {Number} index Insertion index
     * @param {Core.data.Model[]} childModels Array of models inserted
     * @param {Map} context Map with inserted models as keys and objects with previous parent,
     *                      and index at previous parent.
     *
     * @private
     */
    onModelInsertChild(parentModel, index, childModels, context) {
        stateTransition(this, this.state.onModelInsertChild, parentModel, index, childModels, context);
    }

    /**
     * Method to call from model STM mixin upon tree model child removal
     *
     * @param {Core.data.Model} parentModel
     * @param {Core.data.Model[]} childModels
     * @param {Map} context
     *
     * @private
     */
    onModelRemoveChild(parentModel, childModels, context) {
        stateTransition(this, this.state.onModelRemoveChild, parentModel, childModels, context);
    }

    /**
     * Method to call from store STM mixin upon store models adding
     *
     * @param {Core.data.Store} store
     * @param {Core.data.Model[]} models
     * @param {Boolean} silent
     *
     * @private
     */
    onStoreModelAdd(store, models, silent) {
        stateTransition(this, this.state.onStoreModelAdd, store, models, silent);
    }

    /**
     * Method to call from store STM mixin upon store models insertion
     *
     * @param {Core.data.Store} store
     * @param {Number} index
     * @param {Core.data.Model[]} models
     * @param {Map} context
     * @param {Boolean} silent
     *
     * @private
     */
    onStoreModelInsert(store, index, models, context, silent) {
        stateTransition(this, this.state.onStoreModelInsert, store, index, models, context, silent);
    }

    /**
     * Method to call from store STM mixin upon store models removal
     *
     * @param {Core.data.Store} store
     * @param {Core.data.Model[]} models
     * @param {Object} context
     * @param {Boolean} silent
     *
     * @private
     */
    onStoreModelRemove(store, models, context, silent) {
        stateTransition(this, this.state.onStoreModelRemove, store, models, context, silent);
    }

    /**
     * Method to call from store STM mixin upon store clear
     *
     * @param {Core.data.Store} store
     * @param {Core.data.Model[]} allRecords
     * @param {Boolean} silent
     *
     * @private
     */
    onStoreRemoveAll(store, allRecords, silent) {
        stateTransition(this, this.state.onStoreRemoveAll, store, allRecords, silent);
    }
}
StateTrackingManager._$name = 'StateTrackingManager';

/**
 * @module Core/helper/CSSHelper
 */

/**
 * Provides methods to add and manipulate CSS style rules.
 *
 * Note that this class is incompatible with [CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)
 *
 * ```
 * this.criticalRule = CSSHelper.insertRule(`#${this.id} .b-sch-event.critical {background-color:${this.criticalColor}}`);
 * ```
 */
class CSSHelper {
    /**
     * Inserts a CSS style rule based upon the passed text
     * @param {String} cssText The text of the rule including selector and rule body just as it would
     * be specified in a CSS file.
     * @returns {CSSRule} The resulting CSS Rule object if the add was successful.
     */
    static insertRule(cssText) {
        const
            { styleSheet } = this,
            oldCount = styleSheet.cssRules.length;

        styleSheet.insertRule(cssText, 0);

        // Only return element zero if the add was successful.
        if (styleSheet.cssRules.length > oldCount) {
            return styleSheet.cssRules[0];
        }
    }

    /**
     * Looks up the first rule which matched the passed selector.
     * @param {String|Function} selector Either the selector string to exactly match or a function which
     * when passed a required selector, returns `true`.
     * @returns {CSSRule} The first matching CSS Rule object if any found.
     */
    static findRule(selector) {
        let result,
            isFn = typeof selector === 'function';

        // Array#find will stop when the function returns true, stop when the inner
        // find call yields a value from the search string.
        // Array#find better: to http://www.andygup.net/fastest-way-to-find-an-item-in-a-javascript-array/
        Array.prototype.find.call(document.head.querySelectorAll('link[rel=stylesheet],style[type*=css]'), element => {
            result = Array.prototype.find.call(element.sheet.rules || element.sheet.cssRules, r => {
                return isFn ? selector(r) : r.selectorText === selector;
            });
            if (result) {
                return true;
            }
        });

        return result;
    }

    static get styleSheet() {
        if (!this._stylesheet) {
            this._stylesheet = DomHelper.createElement({
                tag    : 'style',
                id     : 'bryntum-private-styles',
                type   : 'text/css',
                parent : document.head
            }).sheet;
        }
        return this._stylesheet;
    }
}
CSSHelper._$name = 'CSSHelper';

/**
 * @module Core/helper/DomSync
 */

const
    arraySlice$1            = Array.prototype.slice,
    // Used in sync to give ObjectHelper.isDeeplyEqual() some domain knowledge
    syncEqualityEvaluator = {
        // Attributes used during creation that should not be compared
        ignore : {
            '_element'    : 1,
            'parent'      : 1,
            'elementData' : 1,
            'ns'          : 1
        },
        // Function to evaluate 'compareHtml' property instead of 'html' for DocumentFragments
        evaluate(property, a, b) {
            if (property === 'html' && typeof a.value !== 'string' && `compareHtml` in a.object) {
                // DocumentFragment, compare separately supplied html
                return (a.object.compareHtml === b.object.compareHtml);
            }
        }
    },
    // Attributes to ignore on sync
    syncIgnoreAttributes  = {
        tag           : 1,
        html          : 1,
        children      : 1,
        tooltip       : 1,
        parent        : 1,
        nextSibling   : 1,
        ns            : 1,
        reference     : 1,
        _element      : 1,
        elementData   : 1,
        retainElement : 1,
        compareHtml   : 1,
        syncOptions   : 1,
        isReleased    : 1
    },
    isClass               = {
        'class'   : 1,
        className : 1,
        classname : 1
    },
    emptyArray$3            = Object.freeze([]);

/**
 * A utility class for syncing DOM config objects to DOM elements. Syncing compares the new config with the previously
 * used for that element, only applying the difference. Very much like a virtual DOM approach on a per element basis
 * (element + its children).
 *
 * Usage example:
 *
 * ```javascript
 * DomSync.sync({
 *     domConfig: {
 *         className : 'b-outer',
 *         children : [
 *             {
 *                 className : 'b-child',
 *                 html      : 'Child 1',
 *                 dataset   : {
 *                     custom : true
 *                 }
 *             },
 *             {
 *                 className : 'b-child',
 *                 html      : 'Child 2',
 *                 style     : {
 *                     fontWeight : 'bold',
 *                     color      : 'blue'
 *                 }
 *             }
 *         ]
 *     },
 *     targetElement : target
 * });
 * ```
 */
class DomSync {
    /**
     * Sync a DOM config to a target element
     * @param {Object} options Options object
     * @param {Object} options.domConfig A DOM config object
     * @param {HTMLElement} options.targetElement Target element to apply to
     * @param {String} [options.syncIdField] Field in dataset to use to match elements for re-usage
     * @param {Function} [options.callback] A function that will be called on element re-usage, creation and similar
     * @param {Boolean} [options.configEquality] A function that will be called to compare an incoming config to
     * the last config applied to the `targetElement`. Defaults to {@link Core.helper.ObjectHelper#function-isDeeplyEqual-static isDeeplyEqual}.
     * @returns {HTMLElement} Returns the updated target element (which is also updated in place)
     */
    static sync(options) {
        this.performSync(options, options.targetElement);

        return options.targetElement;
    }

    static performSync(options, targetElement) {
        const
            { domConfig, callback } = options,
            configIsEqual           = options.configEquality ?
                options.configEquality(domConfig, targetElement.lastDomConfig, syncEqualityEvaluator) :
                ObjectHelper.isDeeplyEqual(domConfig, targetElement.lastDomConfig, syncEqualityEvaluator);

        if (!configIsEqual) {
            if (domConfig) {
                // Sync without affecting the containing element?
                if (!domConfig.onlyChildren) {
                    this.syncAttributes(domConfig, targetElement);
                    this.syncContent(domConfig, targetElement);
                }

                this.syncChildren(options, targetElement);

                // Link the element for easy retrieval later
                domConfig._element = targetElement;
            }
            // Allow null to clear html
            else {
                targetElement.innerHTML = null;
                targetElement.syncIdMap = null;
            }

            // Cache the config on the target for future comparison
            targetElement.lastDomConfig = domConfig;

            return true;
        }
        else {
            // Maintain link to element (deep)
            this.relinkElements(domConfig, targetElement);
            // Sync took no action, notify the world
            callback && callback({
                action : 'none',
                domConfig,
                targetElement
            });
        }

        return false;
    }

    // Called from sync when there is no change to elements, to set up link between new config and existing element.
    // Plucks the element from the last applied config, no need to hit DOM so is cheap
    static relinkElements(domConfig, targetElement) {
        domConfig._element = targetElement;

        // Since there was no change detected, there is a 1 to 1 ratio between new config and last config, should be
        // safe to do a straight mapping
        domConfig.children && domConfig.children.forEach((childDomConfig, i) => {
            // Skip null entries, allowed for convenience, neat with map.
            // Also skip text nodes
            if (childDomConfig && typeof childDomConfig !== 'string') {
                this.relinkElements(childDomConfig, targetElement.lastDomConfig.children[i]._element);
            }
        });
    }

    //region Attributes

    static syncDataset(domConfig, targetElement) {
        const
            { lastDomConfig } = targetElement,
            sameConfig        = domConfig === lastDomConfig,
            source            = Object.keys(domConfig.dataset),
            target            = lastDomConfig && lastDomConfig.dataset && Object.keys(lastDomConfig.dataset),
            delta             = ArrayHelper.delta(source, target);

        // New attributes in dataset
        for (let i = 0; i < delta.onlyInA.length; i++) {
            const attr = delta.onlyInA[i];
            targetElement.setAttribute(`data-${StringHelper.hyphenate(attr)}`, domConfig.dataset[attr]);
        }

        // Might have changed
        for (let i = 0; i < delta.inBoth.length; i++) {
            const attr = delta.inBoth[i];
            // Intentional != since dataset is always string but want numbers to match
            // noinspection EqualityComparisonWithCoercionJS
            if (sameConfig || domConfig.dataset[attr] != lastDomConfig.dataset[attr]) {
                targetElement.setAttribute(`data-${StringHelper.hyphenate(attr)}`, domConfig.dataset[attr]);
            }
        }

        // Removed
        for (let i = 0; i < delta.onlyInB.length; i++) {
            targetElement.removeAttribute(`data-${StringHelper.hyphenate(delta.onlyInB[i])}`);
        }
    }

    static syncClassList(domConfig, targetElement) {
        const
            attr            = domConfig.className || domConfig.class,
            classNameString = typeof attr === 'object' ?
                ObjectHelper.getTruthyKeys(attr).join(' ') :
                attr;

        targetElement.setAttribute('class', classNameString);
    }

    // Attributes as map { attr : value, ... }
    static getSyncAttributes(domConfig) {
        const
            attributes = {},
            // Attribute names, simplifies comparisons and calls to set/removeAttribute
            names      = [];

        // On a first sync, there are no domConfig on the target element yet
        if (domConfig) {
            Object.keys(domConfig).forEach(attr => {
                if (!syncIgnoreAttributes[attr]) {
                    const name = attr.toLowerCase();
                    attributes[name] = domConfig[attr];
                    names.push(name);
                }
            });
        }

        return { attributes, names };
    }

    static syncAttributes(domConfig, targetElement) {
        const
            { lastDomConfig } = targetElement,
            // If the same config has come through, due to configEquality, we must update all attrs.
            sameConfig        = domConfig === lastDomConfig,
            sourceSyncAttrs   = this.getSyncAttributes(domConfig),
            // Extract attributes from elements (sourceElement might be a config)
            {
                attributes : sourceAttributes,
                names      : sourceNames
            }                 = sourceSyncAttrs,
            {
                attributes : targetAttributes,
                names      : targetNames
            }                 = sameConfig ? sourceSyncAttrs : this.getSyncAttributes(lastDomConfig),
            // Intersect arrays to determine what needs adding, removing and syncing
            {
                onlyInA : toAdd,
                onlyInB : toRemove,
                inBoth  : toSync
            }                 = sameConfig ? {
                onlyInA : emptyArray$3,
                onlyInB : emptyArray$3,
                inBoth  : sourceNames
            } : ArrayHelper.delta(sourceNames, targetNames);

        // Add new attributes
        for (let i = 0; i < toAdd.length; i++) {
            const
                attr       = toAdd[i],
                sourceAttr = sourceAttributes[attr];

            // Style requires special handling
            if (attr === 'style') {
                // TODO: Do diff style apply also instead of this replace
                DomHelper.applyStyle(targetElement, sourceAttr, true);
            }
            // So does dataset
            else if (attr === 'dataset') {
                this.syncDataset(domConfig, targetElement);
            }
            // And class, which might be an object
            else if (isClass[attr]) {
                this.syncClassList(domConfig, targetElement);
            }
            // Other attributes are set using setAttribute (since it calls toString() DomClassList works fine)
            else {
                targetElement.setAttribute(attr, sourceAttr);
            }
        }

        // Removed no longer used attributes
        for (let i = 0; i < toRemove.length; i++) {
            targetElement.removeAttribute(toRemove[i]);
        }

        // TODO: toAdd and toSync are growing very alike, consider merging
        // Sync values for all other attributes
        for (let i = 0; i < toSync.length; i++) {
            const
                attr       = toSync[i],
                sourceAttr = sourceAttributes[attr],
                targetAttr = targetAttributes[attr];

            // Attribute value null means remove attribute
            if (sourceAttr == null) {
                targetElement.removeAttribute(attr);
            }
            // Set all attributes that has changed, with special handling for style.
            else if (attr === 'style') {
                if (sameConfig || !ObjectHelper.isEqual(sourceAttr, targetAttr, true)) {
                    // TODO: Do diff style apply also instead of this replace
                    DomHelper.applyStyle(targetElement, sourceAttr, true);
                }
            }
            // And dataset
            else if (attr === 'dataset') {
                this.syncDataset(domConfig, targetElement);
            }
            // And class, which might be an object
            else if (isClass[attr]) {
                this.syncClassList(domConfig, targetElement);
            }
            else if (sameConfig || sourceAttr !== targetAttr) {
                targetElement.setAttribute(attr, sourceAttr);
            }
        }
    }

    //endregion

    //region Content

    static syncContent(domConfig, targetElement) {

        const { html } = domConfig;

        // elementData holds custom data that we want to attach to the element (not visible in dom)
        if (domConfig.elementData) {
            targetElement.elementData = domConfig.elementData;
        }

        // Apply html from config
        if (html != null) {
            // If given a DocumentFragment, replace content with it
            if (html instanceof DocumentFragment) {
                // Syncing a textNode to a textNode? Use shortcut
                if (
                    targetElement.childNodes.length === 1 &&
                    targetElement.childElementCount === 0 &&
                    html.childNodes.length === 1 &&
                    html.childElementCount === 0
                ) {
                    DomHelper.setInnerText(targetElement, html.firstChild.data);
                }
                else {
                    targetElement.innerHTML = '';
                    targetElement.appendChild(html);
                }
            }
            // Something that might be html, set innerHTML
            else if (String(html).includes('<')) {
                targetElement.innerHTML = html;
            }
            // Plain text, prefer setting data on first text node
            else {
                DomHelper.setInnerText(targetElement, html);
            }
        }
    }

    static appendTextNode(text, targetElement, callback) {
        const newNode = document.createTextNode(text);
        targetElement.appendChild(newNode);

        callback && callback({
            action        : 'newNode',
            domConfig     : text,
            targetElement : newNode
        });

    }

    static insertElement(domConfig, targetElement, targetNode, syncId, options) {
        // Create a new element
        const newElement = options.ns ?
            document.createElementNS(options.ns, domConfig.tag || 'svg') :
            document.createElement(domConfig.tag || 'div');

        // Insert (or append if no targetNode)
        targetElement.insertBefore(newElement, targetNode);

        // Sync to it
        this.performSync(options, newElement);

        if (syncId != null) {
            targetElement.syncIdMap[syncId] = newElement;
        }

        options.callback && options.callback({
            action        : 'newElement',
            domConfig,
            targetElement : newElement,
            syncId
        });
    }

    //endregion

    //region Children

    static syncChildren(options, targetElement) {
        let { domConfig, syncIdField, callback, releaseThreshold, configEquality, ns } = options;

        // Having specified html replaces all inner content, no point in syncing
        if (domConfig.html) {
            return;
        }

        const
            me            = this,
            sourceConfigs = arraySlice$1.call(domConfig.children || []),
            targetNodes   = arraySlice$1.call(targetElement.childNodes),
            syncIdMap     = targetElement.syncIdMap || {},
            syncOptions   = domConfig.syncOptions || {};

        // Each level can optionally specify its own syncIdField and callback, if left out parent levels will be used
        syncIdField = syncOptions.syncIdField || syncIdField;
        callback = syncOptions.callback || callback;
        configEquality = syncOptions.configEquality || configEquality;
        // Make sure releaseThreshold 0 is respected...
        releaseThreshold = 'releaseThreshold' in syncOptions ? syncOptions.releaseThreshold : releaseThreshold;

        let syncId;

        // Always repopulate the map, since elements might get used by other syncId below
        if (syncIdField) {
            targetElement.syncIdMap = {};
        }

        // Settings to use in all syncs below
        const syncChildOptions = {
            syncIdField,
            releaseThreshold,
            callback,
            configEquality
        };

        while (sourceConfigs.length) {
            const sourceConfig = sourceConfigs.shift();

            syncId = null;

            // Allowing null, convenient when using Array.map() to generate children
            if (!sourceConfig) {
                continue;
            }

            const isTextNode = typeof sourceConfig === 'string';

            // Used in all syncs
            syncChildOptions.domConfig = sourceConfig;
            syncChildOptions.ns = sourceConfig.ns || ns;

            if (!isTextNode) {
                // If syncIdField was supplied, we should first try to reuse element with matching "id"
                if (syncIdField && sourceConfig.dataset) {
                    syncId = sourceConfig.dataset[syncIdField];
                    // We have an id to look for
                    if (syncId != null && !sourceConfig.unmatched) {
                        // Find any matching element
                        const syncTargetElement = syncIdMap[syncId];
                        if (syncTargetElement) {
                            if (
                                // Ignore if flagged with `retainElement` (for example during dragging)
                                !sourceConfig.retainElement &&
                                // Otherwise sync with the matched element
                                me.performSync(syncChildOptions, syncTargetElement)
                            ) {
                                // Sync took some action, notify the world
                                callback && callback({
                                    action        : 'reuseOwnElement',
                                    domConfig     : sourceConfig,
                                    targetElement : syncTargetElement,
                                    syncId
                                });
                            }

                            // Since it wont sync above when flagged to be retained, we need to apply the flag here
                            if (sourceConfig.retainElement) {
                                syncTargetElement.retainElement = true;
                                // Normally linked in performSync(), but for retained elements that fn is not called
                                sourceConfig._element = syncTargetElement;
                            }
                            // And remove it when no longer needed
                            else if (syncTargetElement.retainElement) {
                                syncTargetElement.retainElement = false;
                            }

                            // Cache the element on the syncId for faster retrieval later
                            targetElement.syncIdMap[syncId] = syncTargetElement;

                            // Remove our target from targetElements, no-one else is allowed to sync with it
                            ArrayHelper.remove(targetNodes, syncTargetElement);

                            syncTargetElement.isReleased = false;
                        }
                        else {
                            // No match, move to end of queue to not steal some one else's element
                            sourceConfigs.push(sourceConfig);
                            // Also flag as unmatched to know that when we reach this element again
                            sourceConfig.unmatched = true;
                        }
                        // Node handled, carry on with next one
                        continue;
                    }
                }

                // Avoid polluting the config object when done
                if (sourceConfig.unmatched) {
                    delete sourceConfig.unmatched;
                }
            }

            // Skip over any retained elements
            let targetNode;

            for (let i = 0; i < targetNodes.length && !targetNode; i++) {
                if (!targetNodes[i].retainElement) {
                    targetNode = targetNodes[i];
                    // shift is much faster than splice...
                    if (i === 0) {
                        targetNodes.shift();
                    }
                    else {
                        targetNodes.splice(i, 1);
                    }
                }
            }

            // Out of target nodes, add to target
            if (!targetNode) {
                if (isTextNode) {
                    this.appendTextNode(sourceConfig, targetElement, callback);
                }
                else {
                    // Will append
                    this.insertElement(sourceConfig, targetElement, null, syncId, syncChildOptions);
                }
            }
            // We have targets left
            else {
                // Matching element tag, sync it
                if (
                    targetNode.nodeType === Node.ELEMENT_NODE &&
                    (sourceConfig.tag || 'div').toLowerCase() === targetNode.tagName.toLowerCase()
                ) {
                    const
                        { lastDomConfig } = targetNode,
                        result            = me.performSync(syncChildOptions, targetNode);

                    if (syncId != null) {
                        targetElement.syncIdMap[syncId] = targetNode;
                    }

                    targetNode.isReleased = false;

                    // Only use callback if sync succeeded (anything changed)
                    result && callback && callback({
                        action        : 'reuseElement',
                        domConfig     : sourceConfig,
                        lastDomConfig,
                        targetElement : targetNode,
                        syncId
                    });
                }
                // Text node to text node, change text :)
                else if (isTextNode && targetNode.nodeType === Node.TEXT_NODE) {
                    targetNode.data = sourceConfig;

                    // Not using callback for updating text of node, have no usecase for it currently
                }
                // Not matching, replace it
                else {
                    if (isTextNode) {
                        this.appendTextNode(sourceConfig, targetElement, callback);
                    }
                    else {
                        // Will insert
                        this.insertElement(sourceConfig, targetElement, targetNode, syncId, syncChildOptions);
                    }

                    targetNode.remove();
                }
            }
        }

        let releaseCount = 0;

        // Out of source nodes, remove remaining target nodes
        targetNodes.forEach(targetNode => {
            const { lastDomConfig } = targetNode;

            // Element might be retained, hands off (for example while dragging)
            if (!targetNode.retainElement) {
                // When using syncId to reuse elements, "release" left over elements instead of removing them, up to a
                // limit specified as releaseThreshold, above which elements are removed instead
                if (syncIdField && (releaseThreshold == null || releaseCount < releaseThreshold)) {
                    // Prevent releasing already released element
                    if (!targetNode.isReleased) {
                        targetNode.className = 'b-released';
                        targetNode.isReleased = true;

                        callback && callback({
                            action        : 'releaseElement',
                            domConfig     : lastDomConfig,
                            lastDomConfig,
                            targetElement : targetNode
                        });

                        // Done after callback on purpose, to allow checking old className
                        if (lastDomConfig) {
                            // Make sure lastDomConfig differs even from the same domConfig applied again
                            // Do not want to discard it completely since it is needed for diff when reused later
                            lastDomConfig.isReleased = true;

                            // To force reapply of classes on reuse
                            if (lastDomConfig.className) {
                                lastDomConfig.className = 'b-released';
                            }
                        }

                        targetNode.elementData = targetNode.lastConfig = null;
                    }

                    releaseCount++;
                }
                // In normal sync mode, remove left overs
                else {
                    targetNode.remove();

                    callback && callback({
                        action        : 'removeElement',
                        domConfig     : targetNode.lastDomConfig,
                        lastDomConfig : targetNode.lastDomConfig,
                        targetElement : targetNode
                    });
                }
            }
            else if (syncIdField) {
                // Keep retained element in map
                if (targetNode.lastDomConfig) {
                    targetElement.syncIdMap[targetNode.dataset[syncIdField]] = targetNode;
                }
            }
        });
    }

    //endregion
}
DomSync._$name = 'DomSync';

// TODO: Use mousedown pos and not center too reposition

/**
 * @module Core/helper/mixin/DragHelperContainer
 */

/**
 * Mixin for DragHelper that handles dragging elements between containers (or rearranging within)
 *
 * @mixin
 */
var DragHelperContainer = Target => class DragHelperContainer extends (Target || Base) {
    //region Init

    /**
     * Initialize container drag mode.
     * @private
     */
    initContainerDrag() {
        const me = this;
        //use container drag as default mode
        if (!me.mode) me.mode = 'container';
        if (me.mode === 'container' && !me.containers) throw new Error('Container drag mode must specify containers');
    }

    //endregion

    //region Grab, update, finish

    /**
     * Grab an element which can be dragged between containers.
     * @private
     * @param event
     * @returns {Boolean}
     */
    grabContainerDrag(event) {
        const me = this;

        // allow specified selectors to prevent drag
        if (!me.ignoreSelector || !DomHelper.up(event.target, me.ignoreSelector)) {
            // go up from "handle" to draggable element
            const element = DomHelper.getAncestor(event.target, me.containers, me.outerElement);

            if (element) {
                const box = element.getBoundingClientRect();

                me.context = {
                    element,
                    valid            : true,
                    action           : 'container',
                    offsetX          : event.pageX - box.left,
                    offsetY          : event.pageY - box.top,
                    originalPosition : {
                        parent : element.parentElement,
                        prev   : element.previousElementSibling,
                        next   : element.nextElementSibling
                    }
                };
            }

            return true;
        }

        return false;
    }

    /**
     * Starts dragging, called when mouse moves first time after grabbing
     * @private
     * @param event
     */
    startContainerDrag(event) {
        const
            { context } = this,
            { element : dragElement } = context,
            div      = dragElement.cloneNode(true),
            box      = dragElement.getBoundingClientRect();

        // init drag proxy
        div.classList.add(this.dragProxyCls);
        div.classList.add(this.draggingCls);
        document.body.appendChild(div);
        context.dragProxy = div;

        // Always set the proxy element width manually, drag target could be sized with flex or % width
        div.style.width  = box.width + 'px';
        div.style.height = box.height + 'px';
        DomHelper.setTranslateXY(context.dragProxy, box.left, box.top);

        // style dragged element
        context.dragging = dragElement;
        dragElement.classList.add(this.dropPlaceholderCls);
    }

    /**
     * Move the placeholder element into its new position on valid drag.
     * @private
     * @param event
     */
    updateContainerDrag(event) {
        const me       = this,
            context = me.context;

        if (!context.started || !context.targetElement) return;

        const containerElement = DomHelper.getAncestor(context.targetElement, me.containers, 'b-grid'),
            willLoseFocus = context.dragging && context.dragging.contains(document.activeElement);

        if (containerElement && DomHelper.isDescendant(context.element, containerElement)) {
            // dragging over part of self, do nothing
            return;
        }

        // The dragging element contains focus, and moving it within the DOM
        // will cause focus loss which might affect an encapsulating autoClose Popup.
        // Prevent focus loss handling during the DOM move.
        if (willLoseFocus) {
            GlobalEvents.suspendFocusEvents();
        }
        if (containerElement && context.valid) {
            me.moveNextTo(containerElement, event);
        }
        else {
            // dragged outside of containers, revert position
            me.revertPosition();
        }
        if (willLoseFocus) {
            GlobalEvents.resumeFocusEvents();
        }

        event.preventDefault();
    }

    /**
     * Finalize drag, fire drop.
     * @private
     * @param event
     * @fires drop
     */
    finishContainerDrag(event) {
        const me       = this,
            context = me.context,
            // extracting variables to make code more readable
            { dragging, dragProxy, valid, draggedTo, insertBefore, originalPosition } = context;

        if (dragging) {
            // needs to have a valid target
            context.valid = valid && draggedTo &&
                    // no drop on self or parent
                    (dragging !== insertBefore || originalPosition.parent !== draggedTo);

            context.finalize = (valid = context.valid) => {
                // revert if invalid (and context still exists, might have been aborted from outside)
                if (!valid && this.context) {
                    me.revertPosition();
                }

                dragging.classList.remove(me.dropPlaceholderCls);
                dragProxy.remove();

                me.reset();
            };

            // allow async finalization by setting async to true on context in drop handler,
            // requires implementer to call context.finalize later to finish the drop
            context.async = false;

            me.trigger('drop', { context, event });

            if (!context.async) {
                // finalize immediately
                context.finalize();
            }
            else {
                context.awaitingFinalization = true;
            }
        }
    }

    /**
     * Aborts a drag operation.
     * @private
     * @param {Boolean} [invalid]
     * @param {Object} [event]
     * @param {Boolean} [silent]
     */
    abortContainerDrag(invalid = false, event = null, silent = false) {
        const me = this,
            context = me.context;

        if (context.dragging) {
            context.dragging.classList.remove(me.dropPlaceholderCls);
            context.dragProxy.remove();

            me.context = {};
        }

        if (!silent) {
            me.trigger(invalid ? 'drop' : 'abort', { context, event });
        }
    }

    //endregion

    //region Helpers

    /**
     * Starts a drag operation by creating a proxy and storing which element is being dragged.
     * @private
     */
    // startDrag() {
    //     const context = this.context,
    //           div      = context.element.cloneNode(true);
    //
    //     // init drag proxy
    //     div.classList.add('b-drag-proxy');
    //     document.body.appendChild(div);
    //     context.dragProxy = div;
    //
    //     // style dragged element
    //     context.dragging = context.element;
    //     context.dragging.classList.add('myClass');
    // }

    /**
     * Updates the drag proxy position.
     * @private
     * @param event
     */
    updateContainerProxy(event) {
        const me = this,
            context = me.context,
            proxy = context.dragProxy;

        let newX = event.pageX - context.offsetX,
            newY = event.pageY - context.offsetY;

        if (typeof me.minX === 'number') {
            newX = Math.max(me.minX, newX);
        }

        if (typeof me.maxX === 'number') {
            newX = Math.min(me.maxX - proxy.offsetWidth, newX);
        }

        if (typeof me.minY === 'number') {
            newY = Math.max(me.minY, newY);
        }

        if (typeof me.maxY === 'number') {
            newY = Math.min(me.maxY  - proxy.offsetHeight, newY);
        }

        if (me.lockX) {
            DomHelper.setTranslateY(proxy, newY);
        }
        else if (me.lockY) {
            DomHelper.setTranslateX(proxy, newX);
        }
        else {
            DomHelper.setTranslateXY(proxy, newX, newY);
        }

        let targetElement;

        if (event.type === 'touchmove') {
            let touch     = event.changedTouches[0];
            targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
        }
        else {
            targetElement = event.target;
        }

        context.targetElement = targetElement;
    }

    /**
     * Positions element being dragged in relation to targetElement.
     * @private
     * @param targetElement
     * @param event
     */
    moveNextTo(targetElement, event) {
        const context = this.context,
            dragElement = context.dragging,
            parent   = targetElement.parentElement;

        if (targetElement !== dragElement) {
            // dragged over a container and not over self, calculate where to insert

            const centerX = targetElement.getBoundingClientRect().left + targetElement.offsetWidth / 2;

            if (event.pageX < centerX) {
                // dragged left of target center, insert before
                parent.insertBefore(dragElement, targetElement);
                context.insertBefore = targetElement;
            }
            else {
                // dragged right of target center, insert after
                if (targetElement.nextElementSibling) {
                    // check that not dragged to the immediate left of self. in such case, position should not change
                    if (targetElement.nextElementSibling !== dragElement) {
                        context.insertBefore = targetElement.nextElementSibling;
                        parent.insertBefore(dragElement, targetElement.nextElementSibling);
                    }
                    else if (!context.insertBefore && dragElement.parentElement.lastElementChild !== dragElement) {
                        // dragged left initially, should stay in place (checked in finishContainerDrag)
                        // TODO: or flag as invalid drag? since no change...
                        context.insertBefore = targetElement.nextElementSibling;
                    }
                }
                else {
                    parent.appendChild(dragElement);
                    context.insertBefore = null;
                }
            }

            context.draggedTo = parent;
        }
    }

    /**
     * Moves element being dragged back to its original position.
     * @private
     */
    revertPosition() {
        const context = this.context,
            original = context.originalPosition;

        // revert to correct location
        if (original.next) {
            const isNoop = original.next && original.next.previousSibling === context.dragging || (!original.next && context.dragging === original.parent.lastChild);

            if (!isNoop) {
                original.parent.insertBefore(context.dragging, original.next);
            }
        }
        else {
            original.parent.appendChild(context.dragging);
        }

        // no target container
        context.draggedTo = null;
    }

    //endregion
};

/**
 * @module Core/helper/mixin/DragHelperTranslate
 */

const noScroll = { pageXOffset : 0, pageYOffset : 0 };

/**
 * Mixin for DragHelper that handles repositioning (translating) an element within its container
 *
 * @mixin
 */
var DragHelperTranslate = Target => class DragHelperTranslate extends Delayable(Target || Base) {
    //region Init

    /**
     * Initialize translation drag mode.
     * @private
     */
    initTranslateDrag() {
        const me = this;
        if (!me.isElementDraggable && me.targetSelector) {
            me.isElementDraggable = element => DomHelper.up(element, me.targetSelector);
        }
    }

    //endregion

    //region Grab, update, finish

    /**
     * Grab an element which can be moved using translation.
     * @private
     * @param event
     * @returns {Boolean}
     */
    grabTranslateDrag(event) {
        const me      = this,
            element = me.getTarget(event);

        if (element) {
            me.context = {
                valid  : true,
                action : me.mode, // translateX or translateXY...
                element,

                startPageX   : event.pageX,
                startPageY   : event.pageY,
                startClientX : event.clientX,
                startClientY : event.clientY
            };

            return true;
        }

        return false;
    }

    getTarget(event) {
        return DomHelper.up(event.target, this.targetSelector);
    }

    /**
     * Start translating, called on first mouse move after dragging
     * @private
     * @param event
     */
    startTranslateDrag(event) {
        const me      = this,
            context = me.context,
            { relatedElements } = context;

        let element = context.dragProxy || context.element;

        if (element && !context.started) {
            const grabbed       = element,
                grabbedParent = element.parentElement,
                // When cloning an element to be dragged, we place it in BODY by default
                dragWithin    = me.dragWithin = me.dragWithin || (me.cloneTarget && document.body),
                outerElement = me.outerElement;

            if (me.cloneTarget) {
                const offsetX      = DomHelper.getOffsetX(element, dragWithin),
                    offsetY      = DomHelper.getOffsetY(element, dragWithin),
                    offsetWidth  = element.offsetWidth,
                    offsetheight = element.offsetHeight;

                element = this.createProxy(element);

                // Match the grabbed element's size and position.
                DomHelper.setTranslateXY(element, offsetX, offsetY);
                element.style.width = `${offsetWidth}px`;
                element.style.height = `${offsetheight}px`;

                element.classList.add(me.dragProxyCls);
                dragWithin.appendChild(element);

                grabbed.classList.add('b-drag-original');

                if (me.hideOriginalElement) {
                    grabbed.classList.add('b-hidden');
                }
            }

            Object.assign(me.context, {
                // The element which we're moving, could be a cloned version of grabbed, or the grabbed element itself
                element,

                // The original element upon which the mousedown event triggered a drag operation
                grabbed,

                // The parent of the original element where the pointerdown was detected - to be able to restore after an invalid drop
                grabbedParent,

                // The next sibling of the original element where the pointerdown was detected - to be able to restore after an invalid drop
                grabbedNextSibling : element.nextElementSibling,

                // elements position within parent element
                elementStartX : DomHelper.getTranslateX(element),
                elementStartY : DomHelper.getTranslateY(element),
                elementX      : DomHelper.getOffsetX(element, dragWithin || outerElement),
                elementY      : DomHelper.getOffsetY(element, dragWithin || outerElement),

                scrollX : 0,
                scrollY : 0,

                scrollManagerElementContainsDragProxy : !me.cloneTarget || dragWithin === outerElement
            });

            element.classList.add(me.draggingCls);

            if (dragWithin) {
                context.parentElement = element.parentElement;

                if (dragWithin !== element.parentElement) {
                    dragWithin.appendChild(element);
                }
                me.updateTranslateProxy(event);
            }

            if (relatedElements) {
                relatedElements.forEach(r => {
                    r.classList.add(me.draggingCls);
                });
            }
        }
    }

    /**
     * Limit translation to outer bounds and specified constraints
     * @private
     * @param element
     * @param x
     * @param y
     * @returns {{constrainedX: *, constrainedY: *}}
     */
    applyConstraints(element, x, y) {
        const me         = this,
            dragWithin = me.dragWithin,
            { pageXOffset, pageYOffset } = dragWithin === document.body ? window : noScroll;

        // limit to outer elements edges
        if (dragWithin && me.constrain) {
            if (x < 0) x = 0;
            if (x + element.offsetWidth > dragWithin.scrollWidth) x = dragWithin.scrollWidth - element.offsetWidth;

            if (y < 0) y = 0;
            if (y + element.offsetHeight > dragWithin.scrollHeight) y = dragWithin.scrollHeight - element.offsetHeight;
        }

        // limit horizontally
        if (typeof me.minX === 'number') {
            x = Math.max(me.minX + pageXOffset, x);
        }
        if (typeof me.maxX === 'number') {
            x = Math.min(me.maxX + pageXOffset, x);
        }

        // limit vertically
        if (typeof me.minY === 'number') {
            y = Math.max(me.minY + pageYOffset, y);
        }
        if (typeof me.maxY === 'number') {
            y = Math.min(me.maxY + pageYOffset, y);
        }

        return { constrainedX : x, constrainedY : y };
    }

    /**
     * Update elements translation on mouse move.
     * @private
     * @param event
     */
    updateTranslateProxy(event, scrollManagerConfig) {
        const
            me       = this,
            { mode, lockX, lockY } = me,
            context  = me.context,
            element  = context.dragProxy || context.element,
            { relatedElements, relatedElDragFromPos } = context;

        // If we are cloning the dragged element outside of the element(s) monitored by the ScrollManager, then no need to take the scrollManager scroll values into account
        // since it is only relevant when dragProxy is inside the Grid (where scroll manager operates).
        if (context.scrollManagerElementContainsDragProxy && scrollManagerConfig) {
            context.scrollX = scrollManagerConfig.scrollRelativeLeft;
            context.scrollY = scrollManagerConfig.scrollRelativeTop;
        }

        context.pageX = event.pageX;
        context.pageY = event.pageY;
        context.clientX = event.clientX;
        context.clientY = event.clientY;

        const
            newX                           = context.elementStartX + event.pageX - context.startPageX + context.scrollX,
            newY                           = context.elementStartY + event.pageY - context.startPageY + context.scrollY,
            { constrainedX, constrainedY } = me.applyConstraints(element, newX, newY);

        if (mode === 'translateXY' && !(lockX || lockY)) {
            DomHelper.setTranslateXY(element, constrainedX, constrainedY);
        }
        else if (mode === 'translateX' || lockY) {
            DomHelper.setTranslateX(element, constrainedX);
        }
        else if (mode === 'translateY' || lockX) {
            DomHelper.setTranslateY(element, constrainedY);
        }

        if (relatedElements) {
            const
                deltaX = (!lockX && mode !== 'translateY') ? constrainedX - context.elementStartX : 0,
                deltaY = (!lockY && mode !== 'translateX') ? constrainedY - context.elementStartY : 0;

            relatedElements.forEach((r, i) => {
                const [x, y] = relatedElDragFromPos[i];

                DomHelper.setTranslateXY(r, x + deltaX, y + deltaY);
            });
        }

        context.newX = constrainedX;
        context.newY = constrainedY;
    }

    /**
     * Finalize drag, fire drop.
     * @private
     * @param event
     * @fires drop
     */
    finishTranslateDrag(event) {
        const me       = this,
            context  = me.context,
            xChanged = context.newX !== context.elementStartX,
            yChanged = context.newY !== context.elementStartY,
            element  = context.dragProxy || context.element,
            { relatedElements } = context;

        function cleanUp() {
            element.classList.remove(me.invalidCls);
            element.classList.remove(me.draggingCls);

            if (relatedElements) {
                relatedElements.forEach(r => {
                    r.classList.remove(me.invalidCls);
                    r.classList.remove(me.draggingCls);
                });
            }
            // If we're currently aborting, the b-hidden CSS class will be removed after animation is complete
            if (!element.classList.contains('b-aborting')) {
                if (me.hideOriginalElement) {
                    context.grabbed.classList.remove('b-hidden');
                }
                context.grabbed.classList.remove('b-drag-original');
            }
        }

        if (!me.ignoreSamePositionDrop || (me.mode !== 'translateY' && xChanged) || (me.mode !== 'translateX' && yChanged)) {

            if (context.valid === false) {
                me.abortTranslateDrag(true, event);
            }
            else {
                const targetRect = Rectangle.from(me.dragWithin || me.outerElement);

                if ((!me.minX && (event.pageX < targetRect.left)) ||
                    (!me.maxX && (event.pageX > targetRect.right)) ||
                    (!me.minY && (event.pageY < targetRect.top)) ||
                    (!me.maxY && (event.pageY > targetRect.bottom))) {
                    // revert location when dropped outside allowed element
                    context.valid = false;
                    me.abortTranslateDrag(true, event);
                }
                else {
                    context.finalize = (valid = context.valid) => {
                        if (context.asyncCleanup) {
                            cleanUp();
                        }

                        // abort if invalid (and context still exists, might have been aborted from outside)
                        if (!valid && me.context) {
                            // abort if flagged as invalid, without triggering abort or drop again
                            me.abortTranslateDrag(true, null, true);
                        }
                        else if (me.cloneTarget || context.dragProxy) {
                            element.remove();
                        }

                        me.reset();
                    };

                    // allow async finalization by setting async to true on context in drop handler,
                    // requires implementer to call context.finalize later to finish the drop
                    context.async = false;

                    me.trigger('drop', { context, event });

                    if (!context.async) {
                        // finalize immediately
                        context.finalize();
                    }
                    else {
                        context.awaitingFinalization = true;
                    }
                }
            }

            if (!context.asyncCleanup) {
                cleanUp();
            }
        }
        else {
            // no change, abort but not as invalid
            me.abortTranslateDrag(false, event);
        }
    }

    /**
     * Abort translation
     * @private
     * @param invalid
     * @fires abort
     */
    abortTranslateDrag(invalid = false, event = null, silent = false) {
        const me      = this,
            context = me.context,
            { relatedElements, relatedElStartPos, grabbed } = context,
            element = context.dragProxy || context.element,
            resetEl = me.cloneTarget && me.hideOriginalElement ? grabbed : element;

        let { elementStartX, elementStartY } = context;

        if (element && context.started) {
            // Put the dragged element back where it was
            if (!me.cloneTarget && me.dragWithin && me.dragWithin !== context.grabbedParent) {
                context.grabbedParent.insertBefore(element, context.grabbedNextSibling);
            }

            grabbed.classList.remove('b-hidden');

            // Align the now visible grabbed element with the clone, so that it looks like it's
            // sliding back into place when the clone is removed
            if (me.cloneTarget) {
                if (me.hideOriginalElement) {
                    [elementStartX, elementStartY] = DomHelper.getTranslateXY(grabbed);
                    DomHelper.alignTo(grabbed, element);

                    // The getBoundingClientRect is important. The aligning above must be processed
                    // by a forced synchronous layout *before* the b-aborting class is added below.
                    resetEl.getBoundingClientRect();
                }

                element.remove();
            }

            // animated restore of position.
            resetEl.classList.add('b-aborting');

            // Move the elements back to their original positions.
            if (me.mode === 'translateXY' && !(me.lockX || me.lockY)) {
                DomHelper.setTranslateXY(resetEl, elementStartX, elementStartY);
                relatedElements && relatedElements.forEach((element, i) => {
                    element.classList.add('b-aborting');
                    DomHelper.setTranslateXY(element, relatedElStartPos[i][0], relatedElStartPos[i][1]);
                });
            }
            if (me.mode === 'translateX' || me.lockY) {
                DomHelper.setTranslateX(resetEl, elementStartX);
                relatedElements && relatedElements.forEach((element, i) => {
                    element.classList.add('b-aborting');
                    DomHelper.setTranslateX(element, relatedElStartPos[i][0]);
                });
            }
            if (me.mode === 'translateY' || me.lockX) {
                DomHelper.setTranslateY(resetEl, elementStartY);
                relatedElements && relatedElements.forEach((element, i) => {
                    element.classList.add('b-aborting');
                    DomHelper.setTranslateY(element, relatedElStartPos[i][1]);
                });
            }

            me.setTimeout(() => {
                resetEl.classList.remove('b-aborting');

                grabbed.classList.remove('b-dragging');
                grabbed.classList.remove('b-drag-original');

                if (!me.cloneTarget) {
                    relatedElements && relatedElements.forEach((element, i) => {
                        element.classList.remove('b-aborting');
                    });
                    element.classList.remove('b-aborting');
                    element.classList.remove(me.draggingCls);
                    element.classList.remove(me.invalidCls);
                }
            }, me.transitionDuration, undefined, true);

            if (!silent) {
                me.trigger(invalid ? 'drop' : 'abort', { context, event });
            }
        }

        me.reset();
    }

    //endregion
};

//TODO: add touch support
//TODO: add pointer events support

/**
 * @module Core/helper/DragHelper
 */

const documentListeners = {
    down       : 'onMouseDown',
    move       : 'onMouseMove',
    up         : 'onMouseUp',
    docclick   : 'onDocumentClick',
    touchstart : 'onTouchStart',
    touchmove  : 'onTouchMove',
    touchend   : 'onTouchEnd',
    keydown    : 'onKeyDown'
};

/**
 * Helps with drag and drop. Supports two modes of dragging:
 * * `container` - moving/rearranging elements within and between specified containers
 * * `translateXY` - repositioning an element withing its container
 *
 * Usage examples:
 * ```
 * // dragging element between containers
 * let dragHelper = new DragHelper({
 *   mode       : 'container',
 *   containers : [ container1, container2 ]
 * });
 *
 * // dragging element within container
 * let dragHelper = new DragHelper({
 *   mode    : 'translateXY',
 *   targetSelector: 'div.moveable'
 * });
 * ```
 * In the various Drag event handlers, you will have access to the raw DOM event and some useful `context` of the drag operation:
 *
 * ```
 *  myDrag.on({
 *      drag : ({event , context}) {
 *            // The element which we're moving, could be a cloned version of grabbed, or the grabbed element itself
 *           const element = context.element;
 *
 *           // The original mousedown element upon which triggered the drag operation
 *           const grabbed = context.grabbed;
 *
 *           // The target under the current mouse / pointer / touch position
 *           const target = context.target;
 *       }
 *  });
 * ```
 *
 * Simple drag drop with a drop target specified:
 * ```
 * export default class MyDrag extends DragHelper {
        static get defaultConfig() {
            return {
                // Don't drag the actual cell element, clone it
                cloneTarget        : true,
                mode               : 'translateXY',
                // Only allow drops on DOM elements with 'yourDropTarget' CSS class specified
                dropTargetSelector : '.yourDropTarget',

                // Only allow dragging elements with the 'draggable' CSS class
                targetSelector : '.draggable'
            };
        }

        construct(config) {
            const me = this;

            super.construct(config);

            me.on({
                dragstart : me.onDragStart
            });
        }

        onDragStart({ event, context }) {
            const target = context.target;

            // Here you identify what you are dragging (an image of a user, grid row in an order table etc) and map it to something in your
            // data model. You can store your data on the context object which is available to you in all drag-related events
            context.userId = target.dataset.userId;
        }

        onEquipmentDrop({ context, event }) {
            const me = this;

            if (context.valid) {
                const userId   = context.userId,
                      droppedOnTarget = context.target;

                console.log(`You dropped user ${userStore.getById(userId).name} on ${droppedOnTarget}`, droppedOnTarget);

                // Dropped on a scheduled event, display toast
                WidgetHelper.toast(`You dropped user ${userStore.getById(userId).name} on ${droppedOnTarget}`);

                // tell the drag helper the operation is finished
                me.context.finalize();
            }
        }
    };
 * ```
 * @mixes Core/helper/mixin/DragHelperContainer
 * @mixes Core/helper/mixin/DragHelperTranslate
 * @mixes Core/mixin/Events
 * @extends Core/Base
 */
class DragHelper extends base(Base).mixes(Events, DragHelperContainer, DragHelperTranslate) {
    //region Config

    static get defaultConfig() {
        return {
            /**
             * Drag proxy CSS class
             * @config {String}
             * @default
             * @private
             */
            dragProxyCls : 'b-drag-proxy',

            /**
             * CSS class added when drag is invalid
             * @config {String}
             * @default
             */
            invalidCls : 'b-drag-invalid',

            /**
             * CSS class added to the source element in Container drag
             * @config {String}
             * @default
             * @private
             */
            draggingCls : 'b-dragging',

            /**
             * CSS class added to the source element in Container drag
             * @config {String}
             * @default
             * @private
             */
            dropPlaceholderCls : 'b-drop-placeholder',

            /**
             * The amount of pixels to move mouse before it counts as a drag operation
             * @config {Number}
             * @default
             */
            dragThreshold : 5,

            /**
             * The outer element where the drag helper will operate (attach events to it and use as outer limit when looking for ancestors)
             * @config {HTMLElement}
             * @default
             */
            outerElement : document.body,

            /**
             * Outer element that limits where element can be dragged
             * @config {HTMLElement}
             * @default
             */
            dragWithin : null,

            /**
             * Constrain translate drag to dragWithin elements bounds (set to false to allow it to "overlap" edges)
             * @config {Boolean}
             * @default
             */
            constrain : true,

            /**
             * Smallest allowed x when dragging horizontally.
             * @config {Number}
             * @default
             */
            minX : null,

            /**
             * Largest allowed x when dragging horizontally.
             * @config {Number}
             * @default
             */
            maxX : null,

            /**
             * Smallest allowed y when dragging horizontally.
             * @config {Number}
             * @default
             */
            minY : null,

            /**
             * Largest allowed y when dragging horizontally.
             * @config {Number}
             * @default
             */
            maxY : null,

            /**
             * Enabled dragging, specify mode:
             * <table>
             * <tr><td>container<td>Allows reordering elements within one and/or between multiple containers
             * <tr><td>translateXY<td>Allows dragging within a parent container
             * </table>
             * @config {String}
             * @default
             */
            mode : null,

            /**
             * A function that determines if dragging an element is allowed. Gets called with the element as argument,
             * return true to allow dragging or false to prevent.
             * @config {Function}
             * @default
             */
            isElementDraggable : null,

            /**
             * A CSS selector used to determine if dragging an element is allowed.
             * @config {String}
             * @default
             */
            targetSelector : null,

            /**
             * A CSS selector used to determine if a drop is allowed at the current position.
             * @config {String}
             * @default
             */
            dropTargetSelector : null,

            /**
             * Set to true to clone the dragged target, and not move the actual target DOM node.
             * @config {Boolean}
             * @default
             */
            cloneTarget : false,

            /**
             * Set to true to hide the original element while dragging (applicable when `cloneTarget` is true).
             * @config {Boolean}
             * @default
             */
            hideOriginalElement : false,

            /**
             * Containers whose elements can be rearranged (and moved between the containers). Used when
             * mode is set to "container".
             * @config {HTMLElement[]}
             * @default
             */
            containers : null,

            /**
             * A CSS selector used to exclude elements when using container mode
             * @config {String}
             * @default
             */
            ignoreSelector : null,

            startEvent : null,

            /**
             * Configure as `true` to disallow dragging in the `X` axis. The dragged element will only move vertically.
             * @config {Boolean}
             * @default
             */
            lockX : false,

            /**
             * Configure as `true` to disallow dragging in the `Y` axis. The dragged element will only move horizontally.
             * @config {Boolean}
             * @default
             */
            lockY : false,

            touchStartDelay    : 300,
            // For the abort animation
            transitionDuration : 300,

            clickSwallowDuration : 50,

            ignoreSamePositionDrop : true,

            testConfig : {
                transitionDuration : 10,

                // In Edge synthetic click events are fired asynchronously and can take considerable
                // amount of time. Setting larger click swallow timeout to make sure Edge has time to fire click event.
                // Caught by test EventDrag4.t in Edge
                clickSwallowDuration : BrowserHelper.isEdge ? 300 : 50
            }
        };
    }

    //endregion

    //region Events

    /**
     * Fired before dragging starts, return false to prevent the drag operation.
     * @preventable
     * @event beforeDragStart
     * @param {DragHelper} source
     * @param {Object} context
     * @param {MouseEvent|TouchEvent} event
     */

    /**
     * Fired when dragging starts.
     * @event dragStart
     * @param {DragHelper} source
     * @param {Object} context
     * @param {MouseEvent|TouchEvent} event
     */

    /**
     * Fired while dragging, you can signal that the drop is valid or invalid by setting `context.valid = false;`
     * @event drag
     * @param {DragHelper} source
     * @param {Object} context
     * @param {Boolean} context.valid Set this to true or false to indicate whether the drop position is valid.
     * @param {MouseEvent} event
     */

    //endregion

    //region Init

    /**
     * Initializes a new DragHelper.
     * @param {Object} config Configuration object, accepts options specified under Configs above
     * @example
     * new DragHelper({
     *   containers: [div1, div2],
     *   isElementDraggable: element => element.className.contains('handle'),
     *   outerElement: topParent,
     *   listeners: {
     *     drop: onDrop,
     *     thisObj: this
     *   }
     * });
     * @function constructor
     */
    construct(config) {
        const me = this;

        super.construct(config);

        me.initListeners();

        if (me.mode === 'container') {
            me.initContainerDrag();
        }
        else if (me.mode.startsWith('translate')) {
            if (me.lockY) {
                me.mode = 'translateX';
            }
            else if (me.lockX) {
                me.mode = 'translateY';
            }
            me.initTranslateDrag();
        }
    }

    doDestroy() {
        // Abort dragging
        this.abort(true);
        super.doDestroy();
    }

    /**
     * Initialize listener
     * @private
     */
    initListeners() {
        const dragStartListeners = {
            element   : this.outerElement,
            mousedown : documentListeners.down,
            thisObj   : this
        };

        if (BrowserHelper.isTouchDevice) {
            dragStartListeners.touchstart = documentListeners.touchstart;
        }

        // These will be autoDetached upon destroy
        EventHelper.on(dragStartListeners);
    }

    //endregion

    //region Events

    /**
     * Fires after drop. For valid drops, it exposes `context.async` which you can set to true to signal that additional
     * processing is needed before finalizing the drop (such as showing some dialog). When that operation is done, call
     * `context.finalize(true/false)` with a boolean that determines the outcome of the drop.
     * @event drop
     * @param {DragHelper} dragHelper
     * @param {Object} context
     */

    onPointerDown(event) {
        let me      = this,
            handled = false,
            isTouch = 'touches' in event;

        // If a drag is ongoing already, finalize it and don't proceed with new drag (happens if user does mouseup
        // outside browser window). Also handles the edge case of trying to start a new drag while previous is awaiting
        // finalization, in which case it just bails out.
        if (me.context) {
            if (!me.context.awaitingFinalization) {
                me.onMouseUp(event);
                me.reset();
            }
            return;
        }

        me.startEvent = event;

        if (me.isElementDraggable && !me.isElementDraggable(event.target, event)) return;

        if (me.mode) {
            if (!handled && me.mode === 'container') handled = me.grabContainerDrag(event);
            if (!handled && me.mode.startsWith('translate')) handled = me.grabTranslateDrag(event);
        }

        if (handled) {
            const dragListeners = {
                element : document,
                thisObj : me,
                keydown : documentListeners.keydown
            };

            if (isTouch) {
                dragListeners.touchmove = {
                    handler : documentListeners.touchmove,
                    passive : false // We need to be able to preventDefault on the touchmove
                };
                // Touch desktops don't fire touchend event when touch has ended, instead pointerup is fired
                // iOS do fire touchend
                dragListeners.touchend = dragListeners.pointerup = documentListeners.touchend;
            }
            else {
                dragListeners.mousemove = documentListeners.move;
                dragListeners.mouseup = documentListeners.up;
            }

            // A listener detacher is returned;
            me.removeListeners = EventHelper.on(dragListeners);

            if (me.dragWithin && me.dragWithin !== me.outerElement) {
                const box = me.dragWithin.getBoundingClientRect();

                me.minY = box.top;
                me.maxY = box.bottom;

                me.minX = box.left;
                me.maxX = box.right;
            }
        }
    }

    /**
     * @param event
     * @private
     */
    onTouchStart(event) {
        const me = this;
        // only allowing one finger for now...
        if (event.touches.length === 1) {
            me.touchStartTimer = me.setTimeout(() => {
                me.touchStartTimer = null;
            }, me.touchStartDelay);

            me.onPointerDown(event);
        }
    }

    /**
     * Grab draggable element on mouse down.
     * @private
     * @param event
     */
    onMouseDown(event) {
        // only dragging with left mouse button
        if (event.button === 0) {
            this.onPointerDown(event);
        }
    }

    internalMove(event) {
        const
            me      = this,
            context = me.context,
            distance = EventHelper.getDistanceBetween(me.startEvent, event),
            abortTouchDrag = me.touchStartTimer && distance > me.dragThreshold;

        if (abortTouchDrag) {
            me.abort(true);
            return;
        }

        if (!me.touchStartTimer && context && context.element &&
            // Only target Elements, not text nodes
            event.target && event.target.nodeType === Node.ELEMENT_NODE &&
            (context.started || distance >= me.dragThreshold)) {
            if (!context.started) {
                // triggers beforeDragStart, dragStart. returning false from beforeDragStart aborts drag
                if (me.callPreventable('dragStart', { context, event }, () => {
                    const direction = me.lockX ? 'vertical' : (me.lockY ? 'horizontal' : 'both');

                    if (context.action.startsWith('translate')) {
                        me.startTranslateDrag(event);
                    }
                    else if (context.action === 'container') {
                        me.startContainerDrag(event);
                    }

                    context.started = true;

                    // Now that the drag drop is confirmed to be starting, activate the configured scrollManager if present
                    if (me.scrollManager) {
                        me.scrollManager.startMonitoring({
                            direction : direction,
                            element   : me.dragWithin || me.outerElement,
                            callback  : config => {
                                if (me.context.element && me.lastMouseMoveEvent) {
                                    // Indicate that this is a 'fake' mousemove event as a result of the scrolling
                                    me.lastMouseMoveEvent.isScroll = true;

                                    me.update(me.lastMouseMoveEvent, config);
                                }
                            },
                            thisObj : me
                        });
                    }

                    // Global informatoinal class for when DragHelper is dragging
                    document.body.classList.add('b-draghelper-active');
                }) === false) {
                    return me.abort();
                }
            }

            // to prevent view drag (scroll) on ipad
            if (event.type === 'touchmove') {
                event.preventDefault();
                event.stopImmediatePropagation();
            }

            me.update(event);
        }
    }

    onTouchMove(event) {
        this.internalMove(event);
    }

    /**
     * Move drag element with mouse.
     * @param event
     * @fires beforeDragStart
     * @fires dragStart
     * @private
     */
    onMouseMove(event) {
        this.internalMove(event);
    }

    /**
     * Updates drag, called when an element is grabbed and mouse moves
     * @private
     * @fires drag
     */
    update(event, scrollManagerConfig) {
        const me              = this,
            context         = me.context,
            draggingElement = context.dragProxy || context.element; // two different modes used

        let target = event.target,
            scrollingPageElement = (document.scrollingElement || document.body);

        // "pointer-events:none" touchmove has no effect for the touchmove event target, meaning we cannot know
        // what's under the cursor as easily in touch devices
        if (event.type === 'touchmove') {
            const touch = event.changedTouches[0];

            target = DomHelper.elementFromPoint(touch.clientX + scrollingPageElement.scrollLeft, touch.clientY + scrollingPageElement.scrollTop);
        }

        context.target = target;

        if (me.dropTargetSelector) {
            context.valid = Boolean(target.closest(me.dropTargetSelector));
        }
        else {
            // assume valid drop location
            context.valid = true;
        }

        // Move the drag proxy or dragged element before triggering the drag event
        if (context.action) {
            if (context.action === 'container') {
                me.updateContainerProxy(event, scrollManagerConfig);
            }
            if (context.action.startsWith('translate')) {
                me.updateTranslateProxy(event, scrollManagerConfig);
            }
        }

        // Allow external code to validate the context before updating a container drag
        me.trigger('drag', { context, event });

        // Move the placeholder element into its new place.
        // This will see the new state of context if mutated by a drag listener.
        if (context.action === 'container') {
            me.updateContainerDrag(event, scrollManagerConfig);
        }

        // change to toggle with force when not supporting IE11 any longer
        draggingElement.classList[context.valid ? 'remove' : 'add'](me.invalidCls);

        if (event) me.lastMouseMoveEvent = event;
    }

    /**
     * Abort dragging
     * @fires abort
     */
    abort(silent = false) {
        const me      = this,
            context = me.context;

        me.scrollManager && me.scrollManager.stopMonitoring(me.dragWithin || me.outerElement);

        if (context) {
            // Force a synchronous layout so that transitions from this point will work.
            context.element.getBoundingClientRect();

            // Aborted drag not considered valid
            context.valid = false;

            if (context.action === 'container') {
                me.abortContainerDrag(undefined, undefined, silent);
            }
            else {
                me.abortTranslateDrag(undefined, undefined, silent);
            }
        }

        me.reset();
    }

    // Empty class implementation. If listeners *are* added, the detacher is added
    // as an instance property. So this is always callable.
    removeListeners() {
    }

    // Called when a drag operation is completed, or aborted
    // Removes DOM listeners and resets context
    reset(silent) {
        document.body.classList.remove('b-draghelper-active');
        this.removeListeners();
        /**
         * Fired when a drag operation is completed or aborted
         * @event reset
         * @private
         * @param {DragHelper} dragHelper
         */
        if (!silent) {
            this.trigger('reset');
        }
        this.context = this.lastMouseMoveEvent = null;
    }

    onTouchEnd(event) {
        this.onMouseUp(event);
    }

    /**
     * This is a capture listener, only added during drag, which prevents a click gesture
     * propagating from the terminating mouseup gesture
     * @param {MouseEvent} event
     * @private
     */
    onDocumentClick(event) {
        event.stopPropagation();
    }

    /**
     * Drop on mouse up (if dropped on valid target).
     * @param event
     * @private
     */
    onMouseUp(event) {
        const me      = this,
            context = me.context;

        me.removeListeners();

        if (context) {
            me.scrollManager && me.scrollManager.stopMonitoring(me.dragWithin || me.outerElement);

            if (context.action === 'container') {
                me.finishContainerDrag(event);
            }
            else if (context.started && context.action.startsWith('translate')) {
                me.finishTranslateDrag(event);
            }

            if (context.started) {
                // Prevent the impending document click from the mouseup event from propagating
                // into a click on our element.
                EventHelper.on({
                    element : document,
                    thisObj : me,
                    click   : documentListeners.docclick,
                    capture : true,
                    expires : me.clickSwallowDuration, // In case a click did not ensue, remove the listener
                    once    : true
                });
            }
            else {
                me.reset(true);
            }
        }
    }

    /**
     * Cancel on ESC key
     * @param event
     * @private
     */
    onKeyDown(event) {
        if (event.key === 'Escape') this.abort();
    }

    /**
     * Creates the proxy element to be dragged, when using {@link #config-cloneTarget}. Clones the original element by default
     */
    createProxy(element) {
        const clone = element.cloneNode(true);
        clone.removeAttribute('id');

        return clone;
    }
    //endregion
}
DragHelper._$name = 'DragHelper';

//TODO: add pointer events support

const documentListeners$1 = {
    down       : 'onMouseDown',
    move       : 'onMouseMove',
    up         : 'onMouseUp',
    docclick   : 'onDocumentClick',
    touchstart : 'onTouchStart',
    touchmove  : 'onTouchMove',
    touchend   : 'onTouchEnd',
    keydown    : 'onKeyDown'
};

/**
 * @module Core/helper/ResizeHelper
 */

/**
 * Handles resizing of elements using handles. Handles can be actual elements or virtual handles specified as a border
 * area on elements left and right edges.
 *
 * ```
 * // enable resizing all elements with class 'resizable'
 * let resizer = new ResizeHelper({
 *   targetSelector: '.resizable'
 * });
 * ```
 *
 * @mixes Core/mixin/Events
 * @internal
 */
class ResizeHelper extends Events(Base) {
    //region Config

    static get defaultConfig() {
        return {
            /**
             * CSS class added when resizing
             * @config {String}
             * @default
             */
            resizingCls : 'b-resizing',

            /**
             * The amount of pixels to move mouse before it counts as a drag operation
             * @config {Number}
             * @default
             */
            dragThreshold : 5,

            /**
             * Resizing handle size
             * @config {Number}
             * @default
             */
            handleSize : 10,

            /**
             * Automatically shrink virtual handles when available space < handleSize. The virtual handles will
             * decrease towards width/height 1, reserving space between opposite handles to for example leave room for
             * dragging. To configure reserved space, see {@link #config-reservedSpace}.
             * @config {Boolean}
             * @default false
             */
            dynamicHandleSize : null,

            //
            /**
             * Room in px to leave unoccupied by handles when shrinking them dynamically (see
             * {@link #config-dynamicHandleSize}).
             * @config {Number}
             * @default
             */
            reservedSpace : 10,

            /**
             * Resizing handle size on touch devices
             * @config {Number}
             * @default
             */
            touchHandleSize : 30,

            /**
             * Minimum width when resizing
             * @config {Number}
             * @default
             */
            minWidth : 1,

            /**
             * Max width when resizing.
             * @config {Number}
             * @default
             */
            maxWidth : 0,

            /**
             * Minimum height when resizing
             * @config {Number}
             * @default
             */
            minHeight : 1,

            /**
             * Max height when resizing
             * @config {Number}
             * @default
             */
            maxHeight : 0,

            // outerElement, attach events to it and use as outer limit when looking for ancestors
            outerElement : document.body,

            /**
             * Optional scroller used to read scroll position. If unspecified, the outer element will be used.
             * @config {Core.helper.util.Scroller}
             */
            scroller : null,

            /**
             * Assign a function to determine if a hovered element can be resized or not
             * @config {Function}
             * @default
             */
            allowResize : null,

            /**
             * Outer element that limits where element can be dragged
             * @config {HTMLElement}
             * @default
             */
            dragWithin : null,

            /**
             * A function that determines if dragging an element is allowed. Gets called with the element as argument,
             * return true to allow dragging or false to prevent.
             * @config {Function}
             * @default
             */
            isElementResizable : null,

            /**
             * A CSS selector used to determine if resizing an element is allowed.
             * @config {String}
             * @default
             */
            targetSelector : null,

            /**
             * Use left handle when resizing. Only applies when `direction` is 'horizontal'
             * @config {Boolean}
             * @default
             */

            leftHandle : true,

            /**
             * Use right handle when resizing. Only applies when `direction` is 'horizontal'
             * @config {Boolean}
             * @default
             */
            rightHandle : true,

            /**
             * Use top handle when resizing. Only applies when `direction` is 'vertical'
             * @config {Boolean}
             * @default
             */

            topHandle : true,

            /**
             * Use bottom handle when resizing. Only applies when `direction` is 'vertical'
             * @config {Boolean}
             * @default
             */
            bottomHandle : true,

            /**
             * A CSS selector used to determine where handles should be "displayed" when resizing. Defaults to
             * targetSelector if unspecified
             * @config {String}
             * @default
             */
            handleSelector : null,

            /**
             * A CSS selector used to determine which inner element contains handles.
             * @config {String}
             * @default
             */
            handleContainerSelector : null,

            startEvent : null,

            /*
             * Optional config object, used by EventResize feature: it appends proxy and has to start resizing immediately
             * @config {Object}
             * @private
             */
            grab : null,

            /**
             * CSS class added when the resize state is invalid
             * @config {String}
             * @default
             */
            invalidCls : 'b-resize-invalid',

            // A number that controls whether or not the element is wide enough for it to make sense to show resize handles
            // e.g. handle width is 10px, so doesn't make sense to show them unless handles on both sides fit
            handleVisibilityThreshold : null,

            // Private config that disables translation when resizing left edge. Useful for example in cases when element
            // being resized is part of a flex layout
            skipTranslate : false,

            /**
             * Direction to resize in, either 'horizontal' or 'vertical'
             * @config {String}
             * @default
             */
            direction : 'horizontal'
        };
    }

    //endregion

    //region Events

    /**
     * Fired while dragging
     * @event resizing
     * @param {Core.helper.ResizeHelper} source
     * @param {Object} context Resize context
     * @param {MouseEvent} event Browser event
     */

    /**
     * Fired when dragging starts.
     * @event resizeStart
     * @param {Core.helper.ResizeHelper} source
     * @param {Object} context Resize context
     * @param {MouseEvent|TouchEvent} event Browser event
     */

    /**
     * Fires after resize, and allows for asynchronous finalization by setting 'async' to `true` on the context object.
     * @event resize
     * @param {Core.helper.ResizeHelper} source
     * @param {Object} context Context about the resize operation. Set 'async' to `true` to indicate asynchronous validation of the resize flow (for showing a confirmation dialog etc)
     */

    /**
     * Fires when a resize is canceled (width is unchanged)
     * @event cancel
     * @param {Core.helper.ResizeHelper} source
     * @param {Object} context Resize context
     * @param {MouseEvent|TouchEvent} event Browser event
     */
    //endregion

    //region Init

    construct(config) {
        const me = this;

        super.construct(config);

        // Larger grabbable zones on touch devices
        if (!me.handleSelector && BrowserHelper.isTouchDevice) {
            me.handleSize = me.touchHandleSize;
        }

        me.handleVisibilityThreshold = me.handleVisibilityThreshold || 2 * me.handleSize;

        me.initListeners();

        me.initResize();
    }

    doDestroy() {
        this.abort(true);
        super.doDestroy();
    }

    /**
     * Initializes resizing
     * @private
     */
    initResize() {
        const me = this;

        if (!me.isElementResizable && me.targetSelector) {
            me.isElementResizable = element => DomHelper.up(element, me.targetSelector);
        }

        if (me.grab) {
            const { edge, element, event } = me.grab;

            me.startEvent = event;

            // emulates mousedown & grabResize
            me.context = {
                element,
                edge,
                valid         : true,
                async         : false,
                elementStartX : DomHelper.getTranslateX(element) || element.offsetLeft, // extract x from translate
                elementStartY : DomHelper.getTranslateY(element) || element.offsetTop, // extract x from translate
                newX          : DomHelper.getTranslateX(element) || element.offsetLeft, // No change yet on start, but info must be present
                newY          : DomHelper.getTranslateY(element) || element.offsetTop, // No change yet on start, but info must be present
                elementWidth  : element.offsetWidth,
                elementHeight : element.offsetHeight,
                startX        : event.clientX + me.scrollLeft,
                startY        : event.clientY + me.scrollTop,
                started       : true,
                finalize      : () => me.reset && me.reset()
            };
            element.classList.add(me.resizingCls);

            me.internalStartResize(me.isTouch);
        }
    }

    /**
     * Initialize listeners
     * @private
     */
    initListeners() {
        const
            me = this,
            dragStartListeners = {
                element   : me.outerElement,
                mousedown : documentListeners$1.down,
                thisObj   : me
            };

        if (BrowserHelper.isTouchDevice) {
            dragStartListeners.touchstart = documentListeners$1.touchstart;
        }
        else if (!me.handleSelector) {
            dragStartListeners.mousemove = {
                handler : documentListeners$1.move,

                // Filter events for checkResizeHandles so we only get called if the mouse
                // is over one of our targets.
                delegate : me.targetSelector
            };

            // We need to clean up when we exit one of our targets
            dragStartListeners.mouseleave = {
                handler  : 'onMouseLeaveTarget',
                delegate : me.targetSelector,
                capture  : true
            };
        }

        // These will be autoDetached upon destroy
        me.removeListeners = EventHelper.on(dragStartListeners);
    }

    removeListeners() {}

    //endregion

    //region Scroll helpers

    get scrollLeft() {
        if (this.scroller) {
            return this.scroller.x;
        }

        return this.outerElement.scrollLeft;
    }

    get scrollTop() {
        if (this.scroller) {
            return this.scroller.y;
        }

        return this.outerElement.scrollTop;
    }

    //endregion

    //region Events

    internalStartResize(isTouch) {
        const me          = this,
            dragListeners = {
                element : document,
                keydown : documentListeners$1.keydown,
                thisObj : me
            };

        if (isTouch) {
            dragListeners.touchmove = documentListeners$1.touchmove;
            // Touch desktops don't fire touchend event when touch has ended, instead pointerup is fired
            // iOS do fire touchend
            dragListeners.touchend = dragListeners.pointerup = documentListeners$1.touchend;
        }
        else {
            dragListeners.mousemove = documentListeners$1.move;
            dragListeners.mouseup = documentListeners$1.up;
        }

        // A listener detacher is returned;
        me.removeDragListeners = EventHelper.on(dragListeners);

        me.scrollManager && me.scrollManager.startMonitoring({
            direction : me.direction, // TODO Update this then when we add support for vertical resizing too
            element   : me.dragWithin || me.outerElement,
            callback  : config => me.context && me.context.element && me.lastMouseMoveEvent && me.update(me.lastMouseMoveEvent, config),
            thisObj   : me
        });
    }

    // Empty class implementation. If listeners *are* added, the detacher is added
    // as an instance property. So this is always callable.
    removeDragListeners() {}

    reset() {
        this.removeDragListeners();
        this.context = null;
    }

    onPointerDown(isTouch, event) {
        const me = this;

        me.startEvent = event;

        if (!me.isElementResizable || me.isElementResizable(event.target, event)) {
            if (me.grabResizeHandle(isTouch, event)) {
                // Stop event if resize handle was grabbed (resize started)
                event.stopImmediatePropagation();
                me.internalStartResize(isTouch);
            }
        }
    }

    onTouchStart(event) {
        // only allowing one finger for now...
        if (event.touches.length > 1) {
            return;
        }

        this.onPointerDown(true, event);
    }

    /**
     * Grab draggable element on mouse down.
     * @private
     * @param event
     */
    onMouseDown(event) {
        // only dragging with left mouse button
        if (event.button !== 0) {
            return;
        }

        this.onPointerDown(false, event);
    }

    internalMove(isTouch, event) {
        const
            me      = this,
            context = me.context;

        if (context && context.element && (context.started || EventHelper.getDistanceBetween(me.startEvent, event) >= me.dragThreshold)) {
            if (!context.started) {
                me.trigger('resizeStart', { context, event });

                context.started = true;
            }

            me.update(event);
        }
        // If a mousemove, and we are using zones, and not handles, we have to
        // programatically check whether we are over a handle, and add/remove
        // classes to change the mouse cursor to resize.
        // If we are using handles, their CSS will set the mouse cursor.
        else if (!isTouch && !me.handleSelector) {
            me.checkResizeHandles(event);
        }
    }

    onTouchMove(event) {
        this.internalMove(true, event);
    }

    /**
     * Move grabbed element with mouse.
     * @param event
     * @fires resizestart
     * @private
     */
    onMouseMove(event) {
        this.internalMove(false, event);
    }

    internalEnd(isTouch, event) {
        const
            me      = this,
            context = me.context;

        me.removeDragListeners();

        if (context) {
            me.scrollManager && me.scrollManager.stopMonitoring(me.dragWithin || me.outerElement);

            me.finishResize(event);

            // Resize could have not been finalized
            if (me.context && !BrowserHelper.isFirefox && !BrowserHelper.isSafari) {
                // Prevent the impending document click from the mouseup event from propagating
                // into a click on our element.
                EventHelper.on({
                    element : document,
                    thisObj : me,
                    click   : documentListeners$1.docclick,
                    capture : true,
                    once    : true
                });
            }
        }
    }

    onTouchEnd(event) {
        this.internalEnd(true, event);
    }

    /**
     * Drop on mouse up (if dropped on valid target).
     * @param event
     * @private
     */
    onMouseUp(event) {
        this.internalEnd(false, event);
    }

    /**
     * This is a capture listener, only added during drag, which prevents a click gesture
     * propagating from the terminating mouseup geature
     * @param {MouseEvent} event
     * @private
     */
    onDocumentClick(event) {
        event.stopPropagation();
    }

    /**
     * Cancel on ESC key
     * @param event
     * @private
     */
    onKeyDown(event) {
        if (event.key === 'Escape') {
            this.abort();
        }
    }

    //endregion

    //region Grab, update, finish

    /**
     * Updates resize, called when an element is grabbed and mouse moves
     * @private
     * @fires resizing
     */
    update(event) {
        const
            me              = this,
            context         = me.context,
            parentRectangle = Rectangle.from(me.outerElement.parentElement);

        // Calculate the current pointer X. Do not allow overflowing either edge
        context.currentX = Math.max(Math.min(event.clientX, parentRectangle.right - 1), parentRectangle.x) + me.scrollLeft;
        context.currentY = Math.max(Math.min(event.clientY, parentRectangle.bottom - 1), parentRectangle.y) + me.scrollTop;

        me.updateResize(event);

        me.trigger('resizing', { context, event });

        context.element.classList[context.valid === false ? 'add' : 'remove'](me.invalidCls);
        // When IE11 support is dropped
        // context.grabbed.classList.toggle(me.invalidCls, context.valid === false);

        if (event) {
            me.lastMouseMoveEvent = event;
        }
    }

    /**
     * Abort dragging
     */
    abort(silent = false) {
        const me = this;

        me.scrollManager && me.scrollManager.stopMonitoring(me.dragWithin || me.outerElement);

        if (me.context) {
            me.abortResize(null, silent);
        }
    }

    /**
     * Starts resizing, updates ResizeHelper#context with relevant info.
     * @private
     * @param {Boolean} isTouch
     * @param {MouseEvent} event
     * @returns {Boolean} True if handled, false if not
     */
    grabResizeHandle(isTouch, event) {
        const me = this;

        if (me.allowResize && !me.allowResize(event.target, event)) {
            return false;
        }

        const
            handleSelector = me.handleSelector,
            coordsFrom = event.type === 'touchstart' ? event.changedTouches[0] : event,
            clientX = coordsFrom.clientX,
            clientY = coordsFrom.clientY,
            // go up from "handle" to resizable element
            element = me.targetSelector ? DomHelper.up(event.target, me.targetSelector) : event.target;

        if (element) {
            let edge;

            // Calculate which edge to resize
            // If there's a handle selector, see if it's anchored on the left or the right
            if (handleSelector) {
                if (event.target.matches(handleSelector)) {
                    if (me.direction === 'horizontal') {
                        if (event.pageX < DomHelper.getPageX(element) + element.offsetWidth / 2) {
                            edge = 'left';
                        }
                        else {
                            edge = 'right';
                        }
                    }
                    else {
                        if (event.pageY < DomHelper.getPageY(element) + element.offsetHeight / 2) {
                            edge = 'top';
                        }
                        else {
                            edge = 'bottom';
                        }
                    }
                }
                else {
                    return false;
                }
            }
            // If we're not using handles, but just active zones
            // then test whether the event position is in an active resize zone.
            else {
                if (me.direction === 'horizontal') {
                    if (me.overLeftHandle(event, element)) {
                        edge = 'left';
                    }
                    else if (me.overRightHandle(event, element)) {
                        edge = 'right';
                    }
                }
                else {
                    if (me.overTopHandle(event, element)) {
                        edge = 'top';
                    }
                    else if (me.overBottomHandle(event, element)) {
                        edge = 'bottom';
                    }
                }

                if (!edge) {
                    me.context = null;
                    // not over an edge, abort
                    return false;
                }
            }

            // If resizing is initiated by a touch, we must preventDefault on the touchstart
            // so that scrolling is not invoked when dragging. This is in lieu of a functioning
            // touch-action style on iOS Safari. When that's fixed, this will not be needed.
            if (event.type === 'touchstart') {
                event.preventDefault();
            }

            if (me.trigger('beforeResizeStart', { element, event }) !== false) {
                // store initial size
                me.context = {
                    element,
                    edge,
                    valid         : true,
                    async         : false,
                    direction     : me.direction,
                    isTouch       : isTouch,
                    elementStartX : DomHelper.getTranslateX(element) || element.offsetLeft, // extract x from translate
                    elementStartY : DomHelper.getTranslateY(element) || element.offsetTop, // extract y from translate
                    newX          : DomHelper.getTranslateX(element) || element.offsetLeft, // No change yet on start, but info must be present
                    newY          : DomHelper.getTranslateY(element) || element.offsetTop, // No change yet on start, but info must be present
                    elementWidth  : element.offsetWidth,
                    elementHeight : element.offsetHeight,
                    startX        : clientX + me.scrollLeft,
                    startY        : clientY + me.scrollTop,
                    finalize      : () => me.reset && me.reset()
                };

                element.classList.add(me.resizingCls);

                return true;
            }
        }

        return false;
    }

    /**
     * Check if mouse is over a resize handle (virtual). If so, highlight.
     * @private
     * @param event
     */
    checkResizeHandles(event) {
        const
            me     = this,
            target = me.targetSelector ? DomHelper.up(event.target, me.targetSelector) : event.target;

        // mouse over a target element and allowed to resize?
        if (target && (!me.allowResize || me.allowResize(event.target, event))) {
            me.currentElement = me.handleContainerSelector ? DomHelper.up(event.target, me.handleContainerSelector) : event.target;

            if (me.currentElement) {
                let over = false;

                if (me.direction === 'horizontal') {
                    over = me.overLeftHandle(event, target) || me.overRightHandle(event, target);
                }
                else {
                    over = me.overTopHandle(event, target) || me.overBottomHandle(event, target);
                }

                if (over) {
                    me.highlightHandle(); // over handle
                }
                else {
                    me.unHighlightHandle(); // not over handle
                }
            }
        }
        else if (me.currentElement) {
            me.unHighlightHandle(); // outside element
        }
    }

    onMouseLeaveTarget(event) {
        const me = this;

        me.currentElement = me.handleContainerSelector ? DomHelper.up(event.target, me.handleContainerSelector) : event.target;

        if (me.currentElement) {
            me.unHighlightHandle();
        }
    }

    /**
     * Updates size of target (on mouse move).
     * @private
     * @param event
     */
    updateResize(event) {
        const
            me      = this,
            context = me.context;

        // flip which edge is being dragged depending on whether we're to the right or left of the mousedown
        if (me.allowEdgeSwitch) {
            if (me.direction === 'horizontal') {
                context.edge = context.currentX > context.startX ? 'right' : 'left';
            }
            else {
                context.edge = context.currentY > context.startY ? 'bottom' : 'top';
            }
        }

        let // limit to outerElement if set
            deltaX   = context.currentX - context.startX,
            deltaY   = context.currentY - context.startY,
            minWidth = DomHelper.getExtremalSizePX(context.element, 'minWidth') || me.minWidth,
            maxWidth = DomHelper.getExtremalSizePX(context.element, 'maxWidth') || me.maxWidth,
            minHeight = DomHelper.getExtremalSizePX(context.element, 'minHeight') || me.minHeight,
            maxHeight = DomHelper.getExtremalSizePX(context.element, 'maxHeight') || me.maxHeight,
            // dragging right edge right increases width, dragging left edge right decreases width
            sign     = context.edge === 'right' || context.edge === 'bottom' ? 1 : -1,
            // new width, not allowed to go below minWidth
            newWidth = context.elementWidth + deltaX * sign,
            width    = Math.max(minWidth, newWidth),
            newHeight = context.elementHeight + deltaY * sign,
            height    = Math.max(minHeight, newHeight);

        if (maxWidth > 0) {
            width = Math.min(width, maxWidth);
        }

        if (maxHeight > 0) {
            height = Math.min(height, maxHeight);
        }

        // remove flex when resizing
        if (context.element.style.flex) {
            context.element.style.flex = '';
        }

        if (me.direction === 'horizontal') {
            context.element.style.width = Math.abs(width) + 'px';
            context.newWidth = width;

            // when dragging left edge, also update position (so that right edge remains in place)
            if (context.edge === 'left' || width < 0) {
                context.newX = Math.max(Math.min(context.elementStartX + context.elementWidth - me.minWidth, context.elementStartX + deltaX), 0);
                if (!me.skipTranslate) {
                    DomHelper.setTranslateX(context.element, context.newX);
                }
            }
            // When dragging the right edge and we're allowed to flip the drag from left to right
            // through the start point (eg drag event creation) the element must be at its initial X position
            else if (context.edge === 'right' && me.allowEdgeSwitch && !me.skipTranslate) {
                DomHelper.setTranslateX(context.element, context.elementStartX);
            }
        }
        else {
            context.element.style.height = Math.abs(height) + 'px';
            context.newHeight = height;

            // when dragging top edge, also update position (so that bottom edge remains in place)
            if (context.edge === 'top' || height < 0) {
                context.newY = Math.max(Math.min(context.elementStartY + context.elementHeight - me.minHeight, context.elementStartY + deltaY), 0);
                if (!me.skipTranslate) {
                    DomHelper.setTranslateY(context.element, context.newY);
                }
            }
            // When dragging the bottom edge and we're allowed to flip the drag from top to bottom
            // through the start point (eg drag event creation) the element must be at its initial Y position
            else if (context.edge === 'bottom' && me.allowEdgeSwitch && !me.skipTranslate) {
                DomHelper.setTranslateY(context.element, context.elementStartY);
            }
        }
    }

    /**
     * Finalizes resize, fires drop.
     * @private
     * @param event
     * @fires resize
     * @fires cancel
     */
    finishResize(event) {
        const
            me          = this,
            context     = me.context,
            eventObject = { context, event };

        context.element.classList.remove(me.resizingCls);

        let changed = false;

        if (me.direction === 'horizontal') {
            changed = context.newWidth && context.newWidth !== context.elementWidth;
        }
        else {
            changed = context.newHeight && context.newHeight !== context.elementHeight;
        }

        me.trigger(changed ? 'resize' : 'cancel', eventObject);

        if (!context.async) {
            context.finalize();
        }
    }

    /**
     * Abort resizing
     * @private
     * @fires cancel
     */
    abortResize(event = null, silent = false) {
        const
            me      = this,
            context = me.context;

        context.element.classList.remove(me.resizingCls);
        if (me.direction === 'horizontal') {
            DomHelper.setTranslateX(context.element, context.elementStartX);
            context.element.style.width = context.elementWidth + 'px';
        }
        else {
            DomHelper.setTranslateY(context.element, context.elementStartY);
            context.element.style.height = context.elementHeight + 'px';
        }

        !silent && me.trigger('cancel', { context, event });

        if (!me.isDestroyed) {
            me.reset();
        }
    }

    //endregion

    //region Handles

    // /**
    //  * Constrain resize to outerElements bounds
    //  * @private
    //  * @param x
    //  * @returns {*}
    //  */
    // constrainResize(x) {
    //     const me = this;
    //
    //     if (me.outerElement) {
    //         const box = me.outerElement.getBoundingClientRect();
    //         if (x < box.left) x = box.left;
    //         if (x > box.right) x = box.right;
    //     }
    //
    //     return x;
    // }

    /**
     * Highlights handles (applies css that changes cursor).
     * @private
     */
    highlightHandle() {
        const
            me     = this,
            target = me.targetSelector ? DomHelper.up(me.currentElement, me.targetSelector) : me.currentElement;

        // over a handle, add cls to change cursor
        me.currentElement.classList.add('b-resize-handle');
        target.classList.add('b-over-resize-handle');
    }

    /**
     * Unhighlight handles (removes css).
     * @private
     */
    unHighlightHandle() {
        const
            me = this,
            target = me.targetSelector ? DomHelper.up(me.currentElement, me.targetSelector) : me.currentElement;

        target && target.classList.remove('b-over-resize-handle');
        me.currentElement.classList.remove('b-resize-handle');
        me.currentElement = null;
    }

    overAnyHandle(event, target) {
        return this.overStartHandle(event, target) || this.overEndHandle(event, target);
    }

    overStartHandle(event, target) {
        return this.direction === 'horizontal' ? this.overLeftHandle(event, target) : this.overTopHandle(event, target);
    }

    overEndHandle(event, target) {
        return this.direction === 'horizontal' ? this.overRightHandle(event, target) : this.overBottomHandle(event, target);
    }

    getDynamicHandleSize(opposite, offsetWidth) {
        const
            handleCount = opposite ? 2 : 1,
            { handleSize } = this;

        // Shrink handle size when configured to do so, preserving reserved space between handles
        if (this.dynamicHandleSize && handleSize * handleCount > offsetWidth - this.reservedSpace) {
            return Math.max((offsetWidth - this.reservedSpace) / handleCount, 1);
        }

        return handleSize;
    }

    /**
     * Check if over left handle (virtual).
     * @private
     * @param {MouseEvent} event MouseEvent
     * @param {HTMLElement} target The current target element
     * @returns {Boolean} Returns true if mouse is over left handle, otherwise false
     */
    overLeftHandle(event, target) {
        const
            me              = this,
            { offsetWidth } = target;

        if (me.leftHandle && (offsetWidth >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
            const leftHandle = Rectangle.from(target);

            leftHandle.width = me.getDynamicHandleSize(me.rightHandle, offsetWidth);

            return leftHandle.contains(EventHelper.getPagePoint(event));
        }
        return false;
    }

    /**
     * Check if over right handle (virtual).
     * @private
     * @param {MouseEvent} event MouseEvent
     * @param {HTMLElement} target The current target element
     * @returns {Boolean} Returns true if mouse is over left handle, otherwise false
     */
    overRightHandle(event, target) {
        const
            me              = this,
            { offsetWidth } = target;

        if (me.rightHandle && (offsetWidth >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
            const rightHandle = Rectangle.from(target);

            rightHandle.x = rightHandle.right - me.getDynamicHandleSize(me.leftHandle, offsetWidth);

            return rightHandle.contains(EventHelper.getPagePoint(event));
        }
        return false;
    }

    /**
     * Check if over top handle (virtual).
     * @private
     * @param {MouseEvent} event MouseEvent
     * @param {HTMLElement} target The current target element
     * @returns {Boolean} Returns true if mouse is over top handle, otherwise false
     */
    overTopHandle(event, target) {
        const
            me               = this,
            { offsetHeight } = target;

        if (me.topHandle && (offsetHeight >= me.handleVisibilityThreshold  || me.dynamicHandleSize)) {
            const topHandle = Rectangle.from(target);

            topHandle.height = me.getDynamicHandleSize(me.bottomHandle, offsetHeight);

            return topHandle.contains(EventHelper.getPagePoint(event));
        }
        return false;
    }

    /**
     * Check if over bottom handle (virtual).
     * @private
     * @param {MouseEvent} event MouseEvent
     * @param {HTMLElement} target The current target element
     * @returns {Boolean} Returns true if mouse is over bottom handle, otherwise false
     */
    overBottomHandle(event, target) {
        const
            me               = this,
            { offsetHeight } = target;

        if (me.bottomHandle && (offsetHeight >= me.handleVisibilityThreshold  || me.dynamicHandleSize)) {
            const bottomHandle = Rectangle.from(target);

            bottomHandle.y = bottomHandle.bottom - me.getDynamicHandleSize(me.bottomHandle, offsetHeight);

            return bottomHandle.contains(EventHelper.getPagePoint(event));
        }
        return false;
    }

    //endregion
}
ResizeHelper._$name = 'ResizeHelper';

/**
 * @module Core/helper/util/RandomGenerator
 */

/**
 * Generates pseudo random numbers from predefined sequence of 100 numbers
 */
class RandomGenerator {

    constructor() {
        this.random100 = [46, 2, 36, 46, 54, 59, 18, 20, 71, 55, 88, 98, 13, 61, 61, 40, 2, 15, 3, 32, 51, 45, 64, 25, 81, 85, 54, 13, 57, 49, 64, 22, 81, 94, 0, 62, 17, 7, 11, 2, 33, 99, 85, 26, 83, 83, 96, 26, 20, 89, 91, 38, 26, 13, 11, 79, 32, 30, 5, 51, 70, 7, 5, 56, 58, 77, 37, 89, 40, 80, 78, 59, 26, 36, 8, 51, 60, 23, 86, 5, 11, 96, 64, 94, 87, 64, 4, 78, 17, 85, 35, 0, 90, 86, 23, 55, 53, 9, 35, 59, 29, 2, 64, 42, 8, 49, 43, 73, 6, 53, 38, 9, 39, 31, 32, 40, 49, 13, 78, 68, 20, 99, 24, 78, 35, 91, 73, 46, 67, 76, 89, 69, 30, 69, 25, 3, 4, 55, 1, 65, 66, 76, 83, 19, 67, 1, 95, 24, 54, 45, 56, 40, 67, 92, 72, 4, 69, 8, 47, 50, 27, 2, 38, 9, 14, 83, 12, 14, 62, 95, 22, 47, 35, 18, 38, 14, 86, 64, 68, 61, 52, 69, 39, 93, 20, 73, 32, 52, 74, 6, 56, 68, 99, 29, 24, 92, 40, 67, 6, 72, 31, 41, 91, 53, 80, 55, 33, 97, 97, 99, 18, 20, 5, 27, 82, 84, 61, 78, 27, 67, 7, 42, 75, 95, 91, 25, 63, 21, 70, 36, 46, 0, 1, 45, 84, 6, 86, 15, 10, 62, 96, 94, 10, 23, 93, 83, 94, 47, 5, 29, 29, 52, 51, 37, 77, 96, 43, 72, 43, 14, 54, 14, 72, 52, 4, 39, 15, 26, 68, 28, 25, 76, 60, 50, 22, 40, 72, 74, 68, 58, 8, 48, 40, 62, 52, 24, 9, 26, 47, 44, 49, 96, 7, 77, 90, 45, 76, 47, 5, 86, 1, 36, 18, 42, 19, 90, 34, 23, 70, 32, 69, 79, 0, 99, 57, 80, 72, 21, 19, 72, 85, 68, 4, 40, 86, 62, 0, 63, 4, 11, 69, 31, 78, 31, 21, 78, 29, 84, 13, 53, 57, 10, 26, 50, 24, 30, 90, 42, 51, 96, 93, 21, 99, 23, 81, 0, 89, 43, 86, 63, 93, 19, 54, 71, 92, 36, 4, 95, 37, 99, 60, 29, 23, 50, 68, 95, 57, 95, 77, 53, 99, 78, 75, 12, 92, 47, 23, 14, 0, 41, 98, 11, 34, 64, 26, 90, 50, 23, 38, 31, 74, 76, 16, 76, 66, 23, 22, 72, 48, 50, 20, 36, 37, 58, 5, 43, 49, 64, 81, 30, 8, 21, 98, 75, 60, 17, 50, 42, 27, 38, 90, 74, 45, 68, 67, 27, 31, 15, 58, 76, 41, 99, 23, 98, 53, 98, 56, 19, 79, 2, 4, 38, 96, 24, 65, 51, 43, 42, 41, 60, 46, 7, 90, 65, 3, 27, 63, 99, 51, 44, 86, 1, 54, 40, 15, 74, 3, 81, 51, 63, 87, 79, 84, 72, 22, 38, 96, 95, 33, 41, 21, 99, 21, 69, 7, 49, 40, 52, 41, 6, 91, 19, 76, 40, 54, 17, 33, 11, 11, 0, 1, 32, 94, 33, 13, 18, 45, 7, 85, 61, 42, 54, 45, 72, 78, 96, 17, 9, 80, 87, 41, 96, 66, 0, 8, 59, 18, 21, 2, 28, 64, 75, 97, 32, 80, 86, 97, 97, 55, 2, 73, 75, 11, 89, 67, 58, 70, 76, 12, 46, 64, 17, 22, 97, 25, 35, 93, 57, 82, 46, 57, 61, 31, 74, 27, 4, 32, 85, 53, 86, 53, 53, 42, 5, 28, 50, 65, 63, 70, 61, 73, 37, 13, 80, 7, 34, 22, 3, 26, 6, 62, 78, 12, 56, 87, 41, 58, 64, 31, 27, 45, 35, 18, 66, 62, 43, 89, 69, 94, 93, 33, 74, 2, 43, 85, 37, 82, 41, 74, 9, 15, 44, 33, 42, 65, 19, 1, 49, 78, 12, 29, 9, 78, 7, 55, 12, 45, 40, 33, 16, 86, 14, 52, 16, 73, 76, 0, 98, 75, 91, 78, 46, 99, 95, 90, 69, 78, 45, 62, 55, 37, 88, 49, 77, 27, 83, 38, 73, 39, 1, 75, 40, 65, 83, 54, 95, 7, 73, 4, 30, 26, 36, 89, 21, 5, 95, 11, 14, 87, 45, 36, 21, 77, 55, 5, 66, 51, 98, 48, 62, 74, 58, 23, 82, 30, 28, 19, 53, 89, 76, 98, 8, 34, 70, 28, 54, 16, 52, 35, 93, 54, 54, 72, 49, 18, 93, 72, 90, 71, 73, 15, 60, 38, 80, 76, 53, 70, 39, 69, 25, 5, 31, 61, 46, 6, 54, 34, 31, 52, 33, 36, 79, 76, 44, 29, 28, 38, 1, 66, 2, 90, 91, 1, 76, 78, 31, 55, 37, 71, 2, 3, 38, 85, 0, 95, 42, 2, 39, 57, 87, 61, 77, 98, 2, 24, 80, 48, 27, 47, 71, 15, 7, 49, 60, 86, 3, 2, 29, 38, 54, 36, 59, 83, 27, 47, 9, 36, 42, 8, 73, 85, 9, 16, 73, 60, 39, 12, 43, 25, 23, 29, 28, 47, 40, 77, 20, 89, 22, 30, 41, 59, 96, 19, 56, 20, 76, 73, 39, 46, 72, 40, 47, 37, 52, 29, 79, 37, 39, 50, 41, 87, 66, 17, 75, 31, 45, 26, 88, 70, 11, 90, 40, 74, 9, 32, 65, 72, 61, 6, 93, 54, 15, 84, 22, 99, 47, 10, 96, 4, 84, 19, 85, 73, 45, 25, 16, 8, 94, 99, 39, 28, 26, 68, 87, 48, 1, 65, 86, 46, 86, 7, 60, 82, 45, 75, 38, 56, 41, 35, 30, 86, 91, 97, 85, 45, 5, 14, 69, 85, 96, 37, 18, 26, 16, 38, 16, 1, 44, 94, 85, 58, 60, 20, 5, 47, 52, 41, 50, 71, 43, 42, 67, 64, 38, 65, 83, 99, 78, 96, 33, 20, 98, 24, 6, 2, 25, 16, 16, 44, 63, 24, 68, 56, 49, 91, 15, 59, 99, 27, 43, 34, 28, 36, 45, 1, 10, 19, 54, 26, 75, 17, 88, 96, 63, 24, 71, 93, 72, 97, 66, 87, 18, 86];
        this.randomCache = {};
        this.rndIndex    = 0;
    }

    /**
     * Returns next pseudo random integer number from sequence between 0 and max parameter value (99 is maximum value)
     * @param max max value
     * @returns {number}
     */
    nextRandom(max) {
        let randomCache = this.randomCache,
            randomNumbers;

        if (randomCache[max]) {
            randomNumbers = randomCache[max];
        }
        else {
            randomNumbers    = this.random100.filter(num => num < max);
            randomCache[max] = randomNumbers;
        }

        return randomNumbers[this.rndIndex++ % randomNumbers.length];
    }

    /**
     * Resets sequence to initial number
     */
    reset() {
        this.rndIndex = 0;
    }

    /**
     * Returns pseudo random array element
     * @param array input array
     * @returns {*}
     */
    fromArray(array) {
        return array[this.nextRandom(array.length)];
    }
}
RandomGenerator._$name = 'RandomGenerator';

class DataGenerator {
    //region Random

    static reset() {
        this.rnd.reset();
        this.rndTime.reset();
        this.rndRating.reset();
    }

    //endregion

    //region Generate data

    static * generate(count, randomHeight = false, initialId = 1) {
        const
            me         = this,
            rnd        = me.rnd,
            rndTime    = me.rndTime,
            rndRating  = me.rndRating,
            firstNames = me.firstNames,
            surNames   = me.surNames,
            teams      = me.teams,
            foods      = me.foods,
            colors     = me.colors,
            cities     = me.cities;

        for (let i = 0; i < count; i++) {
            const firstName = rnd.fromArray(firstNames),
                surName   = rnd.fromArray(surNames),
                name      = `${firstName} ${String.fromCharCode(65 + (i % 25))} ${surName}`,
                startDay  = rnd.nextRandom(60) + 1,
                start     = new Date(2019, 0, startDay),
                finish    = new Date(2019, 0, startDay + rnd.nextRandom(30) + 2), //DateHelper.add(start, rnd.nextRandom(30) + 2, 'days'),
                row       = {
                    id        : i + initialId,
                    title     : 'Row ' + i,
                    name      : name,
                    firstName : firstName,
                    surName   : surName,
                    city      : rnd.fromArray(cities),
                    team      : rnd.fromArray(cities) + ' ' + rnd.fromArray(teams),
                    age       : 10 + rnd.nextRandom(80),
                    food      : rnd.fromArray(foods),
                    color     : rnd.fromArray(colors),
                    score     : rnd.nextRandom(100) * 10,
                    rank      : rnd.nextRandom(100) + 1,
                    start     : start,
                    finish    : finish,
                    time      : DateHelper.getTime(rndTime.nextRandom(24), rndTime.nextRandom(12) * 5),
                    percent   : rnd.nextRandom(100),
                    done      : rnd.nextRandom(100) < 50,
                    rating    : rndRating.nextRandom(5),
                    relatedTo : Math.min(count - 1, i + initialId + rnd.nextRandom(10))
                };

            if (randomHeight) {
                row.rowHeight = rnd.nextRandom(randomHeight === true ? 20 : randomHeight) * 5 + 20;
            }

            yield row;
        }
    }

    // Param reset defaults to true to ensure we get the same dataset on consecutive calls. Without it, code editor
    // reloading modules yields different data each time
    static generateData(count, randomHeight = false, initialId = 1, reset = true) {
        if (reset) this.reset();

        const rows      = [],
            number    = DataGenerator.overrideRowCount ? DataGenerator.overrideRowCount : count,
            generator = this.generate(number, randomHeight, initialId);

        for (let i = 0; i < number; i++) {
            rows.push(generator.next().value);
        }
        return rows;
    }

    //endregion
}

Object.assign(DataGenerator, {
    rnd       : new RandomGenerator(),
    rndTime   : new RandomGenerator(),
    rndRating : new RandomGenerator(),
    cities    : [
        'Stockholm', 'Barcelona', 'Paris', 'Dubai', 'New York', 'San Francisco', 'Washington', 'Moscow'
    ],
    firstNames : [
        'Mike', 'Linda', 'Don', 'Karen', 'Doug', 'Jenny', 'Daniel', 'Melissa', 'John', 'Jane', 'Theo', 'Lisa',
        'Adam', 'Mary', 'Barbara', 'James', 'David'
    ],
    surNames : [
        'McGregor', 'Ewans', 'Scott', 'Smith', 'Johnson', 'Adams', 'Williams', 'Brown', 'Jones', 'Miller',
        'Davis', 'More', 'Wilson', 'Taylor', 'Anderson', 'Thomas', 'Jackson'
    ],
    teams : [
        'Lions', 'Eagles', 'Tigers', 'Horses', 'Dogs', 'Cats', 'Panthers', 'Rats', 'Ducks', 'Cougars', 'Hens', 'Roosters'
    ],
    foods : [
        'Pancake', 'Burger', 'Fish n chips', 'Carbonara', 'Taco', 'Salad', 'Bolognese', 'Mac n cheese', 'Waffles'
    ],
    colors : [
        'Blue', 'Green', 'Red', 'Yellow', 'Pink', 'Purple', 'Orange', 'Teal', 'Black'
    ]
});
DataGenerator._$name = 'DataGenerator';

const knownProps = [
    'action',
    'target',
    'to',
    'deltaX',
    'deltaY',
    'x',
    'y',
    'text'
];

class DemoBot extends Events(Delayable()) {
    static get defaultConfig() {
        return {
            repeat          : true,
            outerElement    : document.body,
            callOnFunctions : true
        };
    }

    // expects an outer element (grid.element/scheduler.element) and an array of steps similar to chain steps in siesta
    construct(config) {
        super.construct(config);

        const me = this;

        if (me.widget) {
            me.outerElement = me.widget.element;
            me.widget.playingDemo = true;
        }

        EventHelper.playingDemo = true;

        Object.assign(me, {
            prevTarget  : null,
            currentStep : 0,
            mouse       : DomHelper.createElement({
                parent    : me.outerElement,
                tag       : 'div',
                className : 'simulated-mouse'
            }),
            timeoutId        : null,
            innerIntervalId  : null,
            mouseOutElements : []
        });

        me.intervalId = me.setInterval(me.nextStep.bind(me), 1000);

        me.outerElement.classList.add('b-playing-demo');

        me.outerElement.addEventListener('click', event => {
            if (event.isTrusted) {
                me.abort();
            }
        });
    }

    doDestroy() {
        this.abort();
    }

    // stops the bot
    abort(atEnd = false) {
        const me = this;

        me.mouse.style.top = '-100px';
        me.clearInterval(me.intervalId);
        me.timeoutId && me.clearTimeout(me.timeoutId);
        me.innerIntervalId && me.clearInterval(me.innerIntervalId);

        me.outerElement.classList.remove('b-playing-demo');
        if (me.widget) {
            me.widget.playingDemo = false;
        }

        EventHelper.playingDemo = false;

        me.trigger(atEnd ? 'done' : 'abort');
    }

    // triggers a synthetic event
    triggerEvent(element, type, data) {
        if (!element) return null;

        let event;

        if (type.startsWith('mouse')) {
            const box = this.mouse.getBoundingClientRect();

            event = new MouseEvent(type, Object.assign({
                view       : window,
                bubbles    : true,
                cancelable : true,
                clientX    : box.left,
                clientY    : box.top
            }, data || {}));
        }
        else {
            event = document.createEvent('Event');
            event.initEvent(type, true, false);
        }

        element.dispatchEvent(event);

        return event;
    }

    // moves mouse to target in 10 steps, with animated transition between steps
    handleMouseMove(step, target) {
        const me    = this,
            mouse = me.mouse;

        mouse.classList.add('quick');
        if (me.mouseDown) mouse.classList.add('drag');

        let mouseBox    = Rectangle.from(mouse, me.outerElement),
            x           = mouseBox.x,
            y           = mouseBox.y,
            deltaX      = 0,
            deltaY      = 0;

        if (step.to) {
            if (typeof step.to === 'string') {
                const toElement = me.outerElement.querySelector(step.to);
                if (toElement) {
                    const rect = Rectangle.from(toElement, me.outerElement),
                        toX  = (rect.x + rect.width / 2),
                        toY  = (rect.y + rect.height / 2);
                    deltaX = (toX - x) / 10;
                    deltaY = (toY - y) / 10;
                }
            }
            else if (step.to.x) {
                deltaX = (step.to.x - x) / 10;
            }
            else {
                deltaX = step.to[0] / 10;
                deltaY = step.to[1] / 10;
            }
        }
        else if (step.deltaX) {
            deltaX = step.deltaX / 10;
        }
        else if (step.x) {
            deltaX = (step.x - x) / 10;
        }

        if (step.deltaY) {
            deltaY = step.deltaY / 10;
        }

        let i = 0;

        me.innerIntervalId = me.setInterval(() => {
            // Only move mouse if in view and not scrolling
            if (me.shouldPause) {
                return;
            }

            if (i++ === 9) {
                clearInterval(me.innerIntervalId);
                if (step.then) {
                    step.then();
                }
            }

            const mouseX = x + deltaX * i,
                mouseY = y + deltaY * i;

            // Move mouse there also
            mouse.style.left = mouseX + 'px';
            mouse.style.top = mouseY + 'px';

            const
                mouseBounds = mouse.getBoundingClientRect(),
                clientX     = mouseBounds.left,
                clientY     = mouseBounds.top,
                eventTarget = document.elementFromPoint(clientX, clientY);

            if (eventTarget !== me.prevTarget) {
                if (me.prevTarget) {
                    me.mouseOutElements.push(me.prevTarget);
                    if (!DomHelper.isDescendant(me.mouseOutElements[0], eventTarget)) {
                        me.mouseOutElements.forEach(element => me.triggerEvent(element, 'mouseout'));
                        me.mouseOutElements.length = 0;
                    }
                }
                me.prevTarget = eventTarget;
                me.triggerEvent(eventTarget, 'mouseover');
            }

            me.triggerEvent(eventTarget, step.action, {
                clientX,
                clientY
            });
        }, 50);
    }

    // target can be a string selector, a function or blank to use last target or outerElement if first time
    getTarget(step) {
        const me     = this,
            target = step.target;

        if (!target) {
            return me.prevTarget || me.outerElement;
        }

        if (typeof target === 'function') {
            return target(step);
        }

        return document.querySelector(target);
    }

    // action can be a function, a string or extracted from a property by scanning for unknown names
    normalizeStep(step) {
        if (step.action) {
            if (typeof step.action === 'function') {
                return step.action(step);
            }
            return step;
        }

        if (typeof step === 'function') {
            step();
            return step;
        }

        // try to find action among properties
        for (let prop in step) {
            if (step.hasOwnProperty(prop) && !knownProps.includes(prop)) {
                step.action = prop.toLowerCase();
                step.to = step[prop];
            }
        }

        if (!step.target && (typeof step.to === 'string' || typeof step.to === 'function')) step.target = step.to;

        return step;
    }

    get isScrolling() {
        const me       = this,
            box      = me.outerElement.getBoundingClientRect(),
            scrolled = me.lastTop && box.top !== me.lastTop;

        me.lastTop = box.top;

        return scrolled;
    }

    get isInView() {
        const box = this.outerElement.getBoundingClientRect();
        return (box.top < window.innerHeight && box.bottom > 0);
    }

    get shouldPause() {
        return !this.isInView || this.isScrolling || document.hidden || !document.hasFocus();
    }

    // process the next step
    nextStep() {
        const me = this;

        // Only perform step if in view and not scrolling
        if (me.shouldPause) {
            return;
        }

        if (me.currentStep === me.steps.length) {
            if (me.repeat) {
                me.currentStep = 0;
            }
            else {
                return me.abort(true);
            }
        }

        // First step, signal to let demo initialize stuff
        if (me.currentStep === 0) {
            me.trigger('initialize');
        }

        const mouse  = me.mouse,
            step   = me.normalizeStep(me.steps[me.currentStep++]),
            target = me.getTarget(step),
            action = step.action;

        if (target && action) {
            mouse.className = 'simulated-mouse';

            if (action === 'mousemove') {
                me.handleMouseMove(step, target);
            }
            else {
                // First move mouse into position
                if (target !== me.prevTarget) {
                    const rect = Rectangle.from(target, me.outerElement);
                    mouse.style.left = (rect.x + rect.width / 2) + 'px';
                    mouse.style.top = (rect.y + rect.height / 2) + 'px';
                }

                if (action === 'mousedown') {
                    me.mouseDown = true;
                }

                if (action === 'mouseup') {
                    me.mouseDown = false;
                }

                // Then trigger action
                me.timeoutId = me.setTimeout(() => {
                    me.prevTarget = target;

                    // Animate click etc.
                    mouse.classList.add(action);

                    if (action === 'type') {
                        const field = IdHelper.fromElement(target),
                            parts = step.text.split('|');

                        field.value = parts[parts.length === 1 || field.value != parts[0] ? 0 : 1];
                    }
                    else {
                        me.triggerEvent(target, action);
                    }

                }, action === 'type' ? 100 : 550);
            }
        }
    }
}
DemoBot._$name = 'DemoBot';

/**
 * @module Core/helper/util/Fullscreen
 */

/**
 * Encapsulates the functionality related to switching cross-browser to full screen view and back.
 */
class Fullscreen {
    static init() {
        const fnNames  = ['fullscreenEnabled', 'requestFullscreen', 'exitFullscreen', 'fullscreenElement'],
            // turns fnNames into function calls to prefixed functions, fullscreenEnabled -> document.mozFullscreenEnabled
            prefixFn = prefix => fnNames.map(fn => {
                let result = prefix + StringHelper.capitalizeFirstLetter(fn);

                // fullscreenEnabled in Firefox is called fullScreenEnabled
                if (prefix === 'moz') {
                    result = result.replace('screen', 'Screen');

                    // #6555 - Crash when clicking full screen button twice
                    // firefox doesn't support exitFullScreen method
                    if ('mozCancelFullScreen' in document && fn === 'exitFullscreen') {
                        result = 'mozCancelFullScreen';
                    }
                }

                return result;
            });

        this.functions = (
            ('fullscreenEnabled' in document && fnNames) ||
            ('webkitFullscreenEnabled' in document && prefixFn('webkit')) ||
            ('mozFullScreenEnabled' in document && prefixFn('moz')) ||
            ('msFullscreenEnabled' in document && prefixFn('ms')) ||
            []
        );

        const eventNames   = [
                'fullscreenchange',
                'fullscreenerror'
            ],
            msEventNames = [
                'MSFullscreenChange',
                'MSFullscreenError'
            ],
            prefixEvt    = prefix => eventNames.map(eventName => prefix + StringHelper.capitalizeFirstLetter(eventName));

        this.events = (
            ('fullscreenEnabled' in document && eventNames) ||
            ('webkitFullscreenEnabled' in document && prefixEvt('webkit')) ||
            ('mozFullscreenEnabled' in document && prefixEvt('moz')) ||
            ('msFullscreenEnabled' in document && msEventNames) ||
            []
        );
    }

    /**
     * True if the fullscreen mode is supported and enabled, false otherwise
     * @property {Boolean}
     */
    static get enabled() {
        return document[this.functions[0]];
    }

    /**
     * Request entering the fullscreen mode.
     * @param {HTMLElement} element Element to be displayed fullscreen
     */
    static request(element) {
        return element[this.functions[1]]();
    }

    /**
     * Exit the previously entered fullscreen mode.
     */
    static exit() {
        return document[this.functions[2]]();
    }

    /**
     * True if fullscreen mode is currently active, false otherwise
     * @return {Boolean}
     */
    static get isFullscreen() {
        return !!document[this.functions[3]];
    }

    /**
     * Installs the passed listener to fullscreenchange event
     * @param {Function} fn The listener to install
     */
    static onFullscreenChange(fn) {
        document.addEventListener(this.events[0], fn);
    }

    /**
     * Uninstalls the passed listener from fullscreenchange event
     * @param {Function} fn
     */
    static unFullscreenChange(fn) {
        document.removeEventListener(this.events[0], fn);
    }
}

Fullscreen.init();
Fullscreen._$name = 'Fullscreen';

/**
 * @module Core/mixin/Override
 */

const excludedPropNames = {
    constructor : 1,
    prototype   : 1,
    name        : 1,
    length      : 1,
    arguments   : 1,
    caller      : 1,
    callee      : 1,
    __proto__   : 1
};

/**
 * Simplifies overriding class methods by allowing methods from another class to be used as overrides.
 * Overrides are defined as own classes. They must at a minimum contain a static getter named targetClass, which
 * should return the class to override. Apply the override by calling {@link #function-apply-static apply()}.
 *
 * @example
 * class TemplateColumnOverride {
 *   static get target() {
 *     return {
 *             class: TemplateColumn,
 *             product: 'grid',
 *             minVersion: '1.0',
 *             maxVersion: '1.5'
 *     }
 *   }
 *
 *   renderer(renderData) {
 *       // call overridden function (optional)
 *       const value = this._overridden.renderer.call(this, renderData);
 *
 *       return 'HELLO' + value;
 *   }
 * }
 * Override.apply(TemplateColumnOverride);
 */
class Override {
    /**
     * Apply override. We strongly suggest that you at least specify a maxVersion for your overrides.
     * ```
     * class OriginalOverride {
     *     static get target() {
     *         return {
     *             class: Original,
     *             product: 'grid',
     *             minVersion: '1.0',
     *             maxVersion: '1.5'
     *         }
     *     }
     * }
     * ```
     * @param override An override class definition
     */
    static apply(override) {
        if (!override.target) throw new Error('Override must specify what it overrides, using static getter target');
        if (!override.target.class) throw new Error('Override must specify which class it overrides, using target.class');

        if (!this.shouldApplyOverride(override)) return false;

        const staticKeys   = Object.getOwnPropertyNames(override),
            instanceKeys = Object.getOwnPropertyNames(override.prototype);

        staticKeys.splice(staticKeys.indexOf('target'), 1);

        this.internalOverrideAll(override.target.class, staticKeys, override);
        this.internalOverrideAll(override.target.class.prototype, instanceKeys, override.prototype);

        return true;
    }

    static internalOverrideAll(targetClass, properties, overrideDefinition) {
        Reflect.ownKeys(overrideDefinition).forEach(key => {
            if (properties.includes(key) && !excludedPropNames[key]) {
                const desc = Object.getOwnPropertyDescriptor(overrideDefinition, key);
                let currentTargetClass = targetClass;

                let targetProperty = null;

                // Walk up the prototype chain to find fn, needed for mixin overrides applied to class that has them
                // mixed in
                while (!targetProperty && currentTargetClass) {
                    targetProperty = Object.getOwnPropertyDescriptor(currentTargetClass, key);
                    if (!targetProperty) {
                        currentTargetClass = Object.getPrototypeOf(currentTargetClass);
                    }
                }

                if (targetProperty) {
                    this.internalOverride(currentTargetClass, key, desc, targetProperty);
                }
            }
        });
    }

    static internalOverride(target, key, desc, targetDesc) {
        const overrides = target._overridden = target._overridden || {};

        overrides[key] = target[key];

        if (targetDesc.get) {
            Object.defineProperty(target, key, {
                enumerable   : false,
                configurable : true,
                get          : desc.get
            });
        }
        else {
            target[key] = desc.value;
        }
    }

    /**
     * Checks versions if an override should be applied. Specify version in your overrides target config
     * @param override
     * @returns {Boolean}
     * @example
     * class OriginalOverride {
     *     static get target() {
     *         return {
     *             class: Original,
     *             product: 'grid',
     *             minVersion: '1.0',
     *             maxVersion: '1.5'
     *         }
     *     }
     * }
     * @private
     */
    static shouldApplyOverride(override) {
        const config = override.target;
        // not using versioning, allow override
        if (!config.maxVersion && !config.minVersion) return true;

        // must specify product to be able to lookup versions
        if (!config.product) throw new Error('Override must specify product when using versioning');

        // override is for older version, disallow
        if (config.maxVersion && VersionHelper[config.product].isNewerThan(config.maxVersion)) {
            
            return false;
        }

        // override is for newer version, disallow
        if (config.minVersion && VersionHelper[config.product].isOlderThan(config.minVersion)) {
            
            return false;
        }

        // override is for current version, allow
        return true;
    }
}
Override._$name = 'Override';

// The code is based on https://epsil.github.io/gll/ article.

/**
 * @module Core/util/Parser
 */

// Tools. Maybe move it to memoization module.
let nextObjectIdentity = 0;
const objectIdentityMap = new WeakMap();

const argsToCacheKey = (...args) => args.map((arg) => {
    let result;

    if (arg && typeof arg == 'object' || typeof arg == 'function') {
        result = objectIdentityMap.get(arg);
        if (result === undefined) {
            result = ++nextObjectIdentity;
            objectIdentityMap.set(arg, result);
        }
    }
    else {
        result = String(arg);
    }

    return result;
}).join('-');

/**
 * Generic memoization function. Wraps `fn` into higher order function which caches `fn` result
 * using stringified arguments as the cache key.
 *
 * @param {Function} fn function to memoize
 */
const memo = (fn) => {
    const mlist = new Map();

    return (...args) => {
        const mkey = argsToCacheKey(args);
        let result = mlist.get(mkey);

        if (result === undefined) {
            result = fn(...args);
            mlist.set(mkey, result);
        }

        return result;
    };
};

/**
 * Specific memoization function caches `fn` calls. `fn` should recieve 2 arguments, the first one
 * is a string, and the second one is a callback which should be called by `fn` with some result.
 * The function returned wraps `fn` and it's callback such that `fn` would be called only once
 * with a particular first argument, other time callback will be called instantly with the result cached.
 *
 * @param {Function} fn function to memoize
 */
const memoCps = (fn) => {
    const table = new Map(),
        entryContinuations = (entry) => entry[0],
        entryResults = (entry) => entry[1],
        pushContinuation = (entry, cont) => entryContinuations(entry).push(cont),
        pushResult = (entry, result) => entryResults(entry).push(result),
        isResultSubsumed = (entry, result) => entryResults(entry).some(r => ObjectHelper.isEqual(r, result)),
        makeEntry = () => [[], []],
        isEmptyEntry = (entry) => !entryResults(entry).length && !entryContinuations(entry).length,
        tableRef = (str) => {
            let entry = table.get(str);

            if (entry === undefined) {
                entry = makeEntry();
                table.set(str, entry);
            }

            return entry;
        };

    return (str, cont) => {
        const entry = tableRef(str);

        if (isEmptyEntry(entry)) {
            pushContinuation(entry, cont);
            fn(str, (result) => {
                if (!isResultSubsumed(entry, result)) {
                    pushResult(entry, result);
                    entryContinuations(entry).forEach(cont => cont(result));
                }
            });
        }
        else {
            pushContinuation(entry, cont);
            entryResults(entry).forEach(result => cont(result));
        }
    };
};
// End of tools

const SUCCESS = Symbol('success');
const FAILURE = Symbol('failure');

/**
 * Successfull parsing result. Represented as array with 3 items:
 * - SUCCESS symbol which can be checked with {@link #function-isSuccess} function.
 * - Parsed payload
 * - Rest string left to parse
 *
 * @typedef {Array} SuccessResult
 */

/**
 * Creates successull parsing result with parsed `val` and unparsed `rest`
 *
 * @param {String} val Parsed value
 * @param {String} rest Unparsed rest
 * @return {SuccessResult}
 */
const success = (val, rest) => [SUCCESS, val, rest];

/**
 * Failure parsing result. Represented as array with 2 items:
 * - FAILURE symbol which can be checked with {@link #function-isSuccess} function
 * - Rest string left to parse
 *
 * @typedef {Array} FailureResult
 */

/**
 * Creates failed parsing result with unparsed `rest`
 *
 * @param {String} rest Unparsed rest
 * @return {FailureResult}
 */
const failure = (rest) => [FAILURE, rest];

/**
 * Checks if the given parsing `result` is successfull
 *
 * @param {SuccessfullResult|FailureResult} result
 */
const isSuccess = (result) => result.length && result[0] === SUCCESS;

/**
 * Resolves parser when needed. Parser should be resolved if it's defined as a function
 * with no arguments which returns the actual parser function with more then one argument.
 *
 * @param {Function} p Parser factory
 * @return {Function} Combinable parser function
 */
const resolveParser = (p) => typeof p === 'function' && !p.length ? p() : p;

/**
 * Returns combinable parser which always return successfull parsing result with `val`
 * as parsed result and string parsed as `rest`.
 *
 * @param {*} val Succefull parsing result parsed payload
 * @return {Function} Combinable parser function
 *
 * @example
 * const sp = succeed('Ok');
 * sp('My string', (r) => console.dir(r)) // Will output successfull parsing result with `Ok` payload and `My string` rest.
 */
const succeed =
    memo(
        (val) =>
            memoCps(
                (str, cont) =>
                    cont(success(val, str))
            )
    );

/**
 * Returns combinable parser which succeeds if string parsed starts with `match`. The parsing
 * result will contain `match` as parsed result and rest of the string characters,
 * the ones after `match` as the unparsed rest.
 *
 * @param {String} match String to match
 * @return {Function} Combinable parser function
 *
 * @example
 * const mp = string('My');
 * mp('My string', (r) => console.dir(r)); // Will output successfull parsing result with `My` payload and `string` rest.
 */
const string =
    memo(
        (match) =>
            memoCps(
                (str, cont) => {
                    const len = Math.min(match.length, str.length),
                        head = str.substr(0, len),
                        tail = str.substr(len);

                    cont(head === match ? success(head, tail) : failure(tail));
                }
            )
    );

/**
 * Binds parser or parser factory with a `fn` function which should recieve one string argument
 * and return a combinable parser function.
 *
 * @param {Function} p Combinable parser function or combinable parser factory which can be
 *                     resolved using with {@link #function-resolveParser}.
 * @param {Function} fn A function recieving one string argument and returning combinable parser function.
 *
 * @internal
 */
const bind = (p, fn) =>
    (str, cont) =>
        resolveParser(p)(str, (result) => {
            if (isSuccess(result)) {
                const [, val, rest] = result;
                fn(val)(rest, cont);
            }
            else {
                cont(result);
            }
        });

/**
 * Combines several combined parser functions or combinable parser factories in sequence such that second starts after first succeeds
 * third after second etc, if first fails then second will not be called and so on.
 *
 * @param {...Function} parsers Combinable parser function or combinable parser factory which can be
 *                      resolved using with {@link #function-resolveParser}.
 * @returns {Function} Combinable parser function
 *
 * @example
 * const ab = seq(string('a'), string('b'));
 * ab('abc', (r) => console.dir(r)); // Will output successfull parsing result with `ab` as parsed payload and `c` as the rest.
 */
const seq =
    memo(
        (...parsers) => {
            const seq2 = memo(
                (a, b) =>
                    memoCps(
                        bind(
                            a,
                            (x) => bind(
                                b,
                                (y) => succeed([].concat(x, y))
                            )
                        )
                    )
            );

            return parsers.reduce(seq2, succeed([]));
        }
    );

/**
 * Combines several combined parser functions or combinable parser factories in alteration such that successfull parsing result will be passed into
 * a callback if one of those parsers succeeds.
 *
 * @param {...Function} parsers Combinable parser function or combinable parser factory which can be
 *                      resolved using with {@link #function-resolveParser}.
 * @returns {Function} Combinable parser function
 *
 * @example
 * const aorb = alt(string('a'), string('b'));
 * aorb('abc', (r) => console.dir(r)); // Will output successfull parsing result with `a` as parsed payload and `bc` as the rest.
 * aorb('bbc', (r) => console.dir(r)); // Will output successfull parsing result with `b` as parsed payload and `bc` as the rest.
 */
const alt =
    memo(
        (...parsers) =>
            memoCps(
                (str, cont) =>
                    parsers.forEach(p => resolveParser(p)(str, cont))
            )
    );

/**
 * Creates combinable parser which succeeds if string to parse starts from a substring which succeeds for the regular expression
 * `pattern` the parser is created with.
 *
 * @param {String} pattern Regular expression pattern
 * @return {Function} Combinable parser function
 *
 * @example
 * const rp = regexp('a+');
 * rp('aaabb', (r) => console.dir(r)); // Will output successfull parsing result with `aaa` as parsed payload and `bb` as the rest.
 */
const regexp =
    memo(
        (pattern) =>
            (str, cont) => {
                const rexp = new RegExp(`^${pattern}`),
                    match = rexp.exec(str);

                if (match) {
                    const head = match[0],
                        tail = str.substr(head.length);

                    cont(success(head, tail));
                }
                else {
                    cont(failure(str));
                }
            }
    );

/**
 * Creates reducing combinable parser function which should be used to create semantic actions
 * on parsed results.
 *
 * @param {Function} p Combinable parser function or combinable parser factory which can be
 *                     resolved using with {@link #function-resolveParser}.
 * @param {Function} fn Semantic action function should be the same arity as the successfull result arity
 *                      of `p` parser.
 * @return {Function} Combinable parser function
 *
 * @example
 * const nump = red(
 *     regexp('\d'),
 *     Number
 * );
 *
 * const plusp = string('+');
 *
 * const sump = red(
 *     seq(nump, plusp, nump),
 *     (a, _, b) => a + b
 * );
 *
 * sump('7+8', (r) => console.dir(r)); // Will return successfull parsing result with `15` as parsing payload and `` as rest.
 */
const red =
    memo(
        (p, fn) =>
            bind(
                p,
                (...val) =>
                    succeed(fn(...[].concat.apply([], val)))
            )
    );

/**
 * Runs combinable parsing function returning totaly parsed results only, i.e. such results which have
 * parsed the `str` string completely.
 *
 * @param {Function} body Combinable parser function
 * @param {String} str String to parse
 * @return {SuccessfullResult[]} All totaly parsed results possible for the given parsing function.
 */
const runParser = (body, str) => {
    let results = [];

    body(str, (result) => {
        if (isSuccess(result)) {
            const [, , left] = result;
            if (left === '') {
                results.push(result);
            }
        }
    });

    return results;
};

/**
 * Helper function for combinable parser definition supplements combinable parser function
 * returning a higher order function which when called with 2 arguments (string to parse and
 * a callback function) behaves exactly like parser function, but when called with 1 argument
 * it wraps call to parser function with {@link function-runParser} thus returning array of
 * totaly parsed results.
 *
 * @param {Function} body Combinable parser function
 */
const defineParser = (body) =>
    (str, cont) => cont ? resolveParser(body)(str, cont) : runParser(resolveParser(body), str);

/**
 * Combines exports in an object such that it was possible to export parser utilities
 * in UMD/module bundles.
 *
 * @example
 * import Parser from 'Core/util/Parser.js';
 * const {string, alt, seq, success, red, defineParser} = Parser;
 */
var Parser = {
    memo,
    memoCps,
    success,
    failure,
    isSuccess,
    resolveParser,
    succeed,
    string,
    bind,
    seq,
    alt,
    regexp,
    red,
    runParser,
    defineParser
};

/**
 * Boolean combo, a combo box with two options corresponding to true or false.
 *
 * This field can be used as an {@link Grid.column.Column#config-editor editor} for the {@link Grid.column.Column Column}.
 *
 * @classType booleancombo
 * @extends Core/widget/Combo
 */
class BooleanCombo extends Localizable(Combo) {
    static get $name() {
        return 'BooleanCombo';
    }

    static get type() {
        return 'booleancombo';
    }

    //region Config
    static get defaultConfig() {
        return {
            /**
             * Positive option value
             *
             * @config {*}
             */
            positiveValue : true,
            /**
             * Positive option display value
             *
             * @config {String}
             */
            positiveText  : null,
            /**
             * Negative option value
             *
             * @config {*}
             */
            negativeValue : false,
            /**
             * False option display value
             *
             * @config {String}
             */
            negativeText  : null,
            /**
             * Default value
             *
             * @config {*}
             */
            value         : false
        };
    }
    //endregion

    get store() {
        if (!this._store) {
            this.store = new Store({
                data : [{
                    id   : this.positiveValue,
                    text : this.positiveText || this.L('Yes')
                }, {
                    id   : this.negativeValue,
                    text : this.negativeText || this.L('No')
                }]
            });
        }

        return this._store;
    }

    set store(store) {
        super.store = store;
    }
}

BooleanCombo._$name = 'BooleanCombo'; BryntumWidgetAdapterRegister.register(BooleanCombo.type, BooleanCombo);

/**
 * @module Core/widget/DisplayField
 */

/**
 * DisplayField widget used to show a read only value
 *
 * @extends Core/widget/Field
 *
 * @example
 * let displayField = new DisplayField({
 *   label: 'name',
 *   value : 'John Doe'
 * });
 *
 * @classType DisplayField
 * @externalexample widget/DisplayField.js
 */
class DisplayField extends TextField {
    static get $name() {
        return 'DisplayField';
    }

    static get defaultConfig() {
        return {
            readOnly : true,
            editable : false,
            cls      : 'b-display-field'
        };
    }

    get focusElement() {
        // we're not focusable.
    }

    set readOnly(value) {
        // empty, to not allow changing readOnly status
    }

    get readOnly() {
        return true;
    }
}

DisplayField._$name = 'DisplayField'; BryntumWidgetAdapterRegister.register('display', DisplayField);
BryntumWidgetAdapterRegister.register('displayfield', DisplayField);

/**
 * @module Core/widget/DurationField
 */

/**
 * A specialized field allowing a user to also specify duration unit when editing the duration value.
 *
 * This field can be used as an {@link Grid.column.Column#config-editor editor} for the {@link Grid.column.Column Column}.
 * It is used as the default editor for the `DurationColumn`.
 *
 * @extends Core/widget/TextField
 *
 * @classType durationfield
 */
class DurationField extends TextField {
    static get $name() {
        return 'DurationField';
    }

    static get defaultConfig() {
        return {
            /**
             * The `value` config may be set in Object form specifying two properties,
             * `magnitude`, a Number, and `unit`, a String.
             *
             * If a String is passed, it is parsed in accordance with current locale rules.
             * The string is taken to be the numeric magnitude, followed by whitespace, then an abbreviation, or name of the unit.
             * @config {Object|String}
             */
            value : null,

            /**
             * Step size for spin button clicks.
             * @config {Number}
             * @default
             */
            step : 1,

            /**
             * The duration unit to use with the current magnitude value.
             * @config {String}
             */
            unit : null,

            defaultUnit : 'day',

            /**
             * The duration magnitude to use with the current unit value.
             * @config {Number}
             */
            magnitude : null,

            /**
             * When set to `true` the field will use short names of unit durations
             * (as returned by {@link Core.helper.DateHelper#function-getShortNameOfUnit-static}) when creating the
             * input field's display value.
             * @config {Boolean}
             */
            useAbbreviation : false,

            /**
             * Set to `true` to allow negative duration
             * @config {Boolean}
             */
            allowNegative : false,

            /**
             * The number of decimal places to allow. Defaults to no constraint.
             * @config {Number}
             * @default
             */
            decimalPrecision : null,

            triggers : {
                spin : {
                    type : 'spintrigger'
                }
            }
        };
    }

    get inputValue() {
        // Do not use the _value property. If called during configuration, this
        // will import the configured value from the config object.
        return this.value == null ? '' : this.value.toString(this.useAbbreviation);
    }

    /**
     * Get/Set duration unit to use with the current magnitude value.
     * Valid values are:
     * - "millisecond" - Milliseconds
     * - "second" - Seconds
     * - "minute" - Minutes
     * - "hour" - Hours
     * - "day" - Days
     * - "week" - Weeks
     * - "month" - Months
     * - "quarter" - Quarters
     * - "year"- Years
     *
     * @property {String}
     */
    set unit(unit) {
        this._unit = unit;
        super.value = this.calcValue();
    }

    get unit() {
        return this._unit;
    }

    /**
     * Get/Set numeric magnitude `value` to use with the current unit value.
     * @property {Number}
     */
    set magnitude(magnitude) {
        this._magnitude = this.roundMagnitude(magnitude);
        super.value = this.calcValue();
    }

    get magnitude() {
        return this._magnitude;
    }

    roundMagnitude(value) {
        return value && this.decimalPrecision != null ? ObjectHelper.round(value, this.decimalPrecision) : value;
    }

    get allowDecimals() {
        return this.decimalPrecision !== 0;
    }

    get isValid() {
        const
            me      = this,
            isEmpty = me.value == null || (me.value && me.value.magnitude == null);

        return (isEmpty && !me.required) || !isEmpty && (me.allowNegative || me.value.magnitude >= 0);
    }

    internalOnChange(event) {
        const
            me     = this,
            value  = me.value,
            oldVal = me._lastValue;

        if (me.hasChanged(oldVal, value)) {
            me._lastValue = value;
            me.trigger('change', { value, event, userAction : true, valid : me.isValid });
        }
    }

    onFocusOut(e) {
        this.syncInputFieldValue(true);

        return super.onFocusOut(e);
    }

    /**
     * The `value` property may be set in Object form specifying two properties,
     * `magnitude`, a Number, and `unit`, a String.
     *
     * If a Number is passed, the field's current unit is used and just the magnitude is changed.
     *
     * If a String is passed, it is parsed in accordance with current locale rules.
     * The string is taken to be the numeric magnitude, followed by whitespace, then an abbreviation, or name of the unit.
     *
     * Upon read, the value is always returned in object form containing `magnitude` and `unit`.
     * @property {String|Number|Object|Duration}
     */
    set value(value) {
        const
            me = this;
        let newMagnitude, newUnit;

        if (typeof value === 'number') {
            // A number means preserving existing unit value
            newMagnitude = me.roundMagnitude(value);
            newUnit = me._unit;
        }
        else if (typeof value === 'string') {
            // Parse as a string
            const
                parsedDuration = DateHelper.parseDuration(value, me.allowDecimals, me._unit || DurationField.defaultConfig.defaultUnit);
            if (parsedDuration) {
                newUnit = parsedDuration.unit;
                newMagnitude = me.roundMagnitude(parsedDuration.magnitude);
            }
        }
        else {
            // Using value object with unit and magnitude
            if (value && 'unit' in value && 'magnitude' in value) {
                newUnit = value.unit;
                newMagnitude = me.roundMagnitude(value.magnitude);
            }
            else {
                newUnit = null;
                newMagnitude = null;
            }
        }

        if (me._magnitude !== newMagnitude || me._unit !== newUnit) {
            me._magnitude = newMagnitude;
            me._unit = newUnit;
            super.value = me.calcValue();
        }
    }

    get value() {
        return super.value;
    }

    calcValue() {
        const
            me = this;

        if ((!me._unit || !me._magnitude) && me.clearable) {
            return null;
        }
        else {
            return new Duration(me._magnitude, me._unit || DurationField.defaultConfig.defaultUnit);
        }
    }

    hasChanged(oldValue, newValue) {
        return newValue && !oldValue ||
            !newValue && oldValue ||
            newValue && oldValue && !oldValue.isEqual(newValue);
    }

    /**
     * The `milliseconds` property is a read only property which returns the
     * number of milliseconds in this field's value
     * @property {Number}
     */
    get milliseconds() {
        return this.value ? this.value.milliseconds : 0;
    }

    onInternalKeyDown(keyEvent) {
        if (keyEvent.key === 'ArrowUp') {
            this.doSpinUp();
        }
        else if (keyEvent.key === 'ArrowDown') {
            this.doSpinDown();
        }
    }

    doSpinUp() {
        const
            me = this;
        me._isUserAction = true;
        me.magnitude = (me.magnitude || 0) + me.step;
        me._isUserAction = false;
    }

    doSpinDown() {
        const
            me = this;
        if (me.allowNegative || (me.magnitude || 0) > 0) {
            me._isUserAction = true;
            me.magnitude = (me.magnitude || 0) - me.step;
            me._isUserAction = false;
        }
    }
}

DurationField._$name = 'DurationField'; BryntumWidgetAdapterRegister.register('durationfield', DurationField);
BryntumWidgetAdapterRegister.register('duration', DurationField);

/**
 * @module Core/widget/FileField
 */

/**
 * Filefield widget. Wraps native &lt;input type="file"&gt;.
 *
 * There is a nicer styled wrapper for this field, see {@link Core/widget/FilePicker}
 *
 * @extends Core/widget/Field
 * @example
 *
 * let fileField = new FileField({
 *   multiple : true,
 *   accept   : "image/*"
 * });
 *
 * @classType filefield
 * @externalexample widget/FileField.js
 */
class FileField extends Field {
    static get $name() {
        return 'FileField';
    }

    internalOnChange(event) {
        // Event order is not consistent across browsers:
        //
        //  Chrome/Firefox:             IE11:                       Edge:
        //      internalOnInput             internalOnChange            internalOnChange
        //      internalOnChange            internalOnInput
        //
        // The problem this creates is that the onChange logic expects value != lastValue which is ensured by the
        // onInput handler. In the IE11/Edge sequence, the first change event is ignored, but with a file input that
        // is the only one you get and so the component's change event does not fire. The user has to make a second
        // file selection to get the event to fire.
        //
        // Fortunately, the event sequence for a file input is simple, so we can just force that order here:
        super.internalOnInput(event);
        super.internalOnChange(event);
    }

    internalOnInput() {
        // ignore -- see internalOnChange above
    }

    static get defaultConfig() {
        return {
            /**
             * Set to true to allow picking multiple files
             * @config {Boolean}
             * @default
             */
            multiple : false,

            /**
             * Comma-separated list of file extensions or MIME type to to accept. E.g.
             * ".jpg,.png,.doc" or "image/*". Null by default, allowing all files.
             * @config {String}
             */
            accept : null
        };
    }

    inputTemplate() {
        const me = this;

        // Historical note: this had a comment about not setting "reference" and how removing it helped IE11:
        //
        //  > [8/13/2019]
        //  > Not using reference="input" here intentionally.
        //  > In IE11/Edge when you pick file first time, field.value reports empty string while field.files.length is
        //  > non zero. Trying to fix this and embed file field to common field behavior is very tricky because cannot
        //  > be covered with siesta tests (it looks like).
        //
        // It is true that you cannot test a file input using synthetic events (as in Siesta), but the root of the IE11
        // value issue comes down to event order. See comments in internalOnChange above. At one time that might have
        // worked by inserting a timing change, however, the "reference" was added back on 11/22/2019 to resolve issues
        // related to incorrect attachment of the input element.
        return TemplateHelper.tpl`
            <input
             type="file"
             reference="input"
             id="${me.id}_input"
             class="${me.inputCls || ''}"
             ${me.multiple ? 'multiple' : ''}
             ${me.accept ? 'accept="' + me.accept + '"' : ''}
            />
        `;
    }

    /**
     * Returns list of selected files
     * @returns {FileList}
     * @readonly
     */
    get files() {
        return this.input.files;
    }

    /**
     * Opens browser file picker
     * @internal
     */
    pickFile() {
        this.input.click();
    }

    /**
     * Clears field value
     */
    clear() {
        this.input.value = null;
    }

    triggerChange(event) {
        this.trigger('change', {
            event,
            value      : this.input.value,
            oldValue   : this._lastValue,
            userAction : true,
            valid      : true
        });
    }
}

FileField._$name = 'FileField'; BryntumWidgetAdapterRegister.register('filefield', FileField);

/**
 * @module Core/widget/FilePicker
 */

/**
 * File input field wrapped into {@link Core/widget/Button button}. Clicking button opens browser file picker window.
 * When files are chosen, badge appears showing amount of files. Hovering the button shows tip with file names.
 *
 * By default only single file allowed.
 *
 * @extends Core/widget/Container
 * @example
 *
 * let fileField = new FilePicker({
 *   fileFieldConfig : {
 *      multiple : true,
 *      accept   : "image/*"
 *   },
 *   buttonConfig : {
 *       text : 'Pick file...'
 *   }
 * });
 *
 * @classType filepicker
 * @externalexample widget/FilePicker.js
 */
class FilePicker extends Container {
    static get $name() {
        return 'FilePicker';
    }

    static get defaultConfig() {
        return {

            /**
             * The name of the property to set when a single value is to be applied to this FilePicker. Such as when used
             * in a grid WidgetColumn, this is the property to which the column's `field` is applied.
             * @config {String}
             * @default
             * @category Misc
             */
            defaultBindProperty : 'value',

            /**
             * Fires after user closes file picker dialog.
             * @event change
             * @param {FileList} files List of picked files
             */

            /**
             * Fires when field is cleared with {@link #function-clear} method
             * @event clear
             */

            /**
             * Wrapper button config object. See {@link Core/widget/Button} for list of available configs.
             * @config {Object}
             */
            buttonConfig : null,

            /**
             * Underlying field config object. See {@link Core/widget/FileField} for list of available configs.
             * @config {Object}
             */
            fileFieldConfig : null
        };
    }

    construct(config = {}) {
        const me = this;

        config.items = [
            Object.assign({
                type : 'button',
                ref  : 'fileButton',
                text : 'File'
            }, config.buttonConfig),
            Object.assign({
                type  : 'filefield',
                ref   : 'fileField',
                style : 'display: none'
            }, config.fileFieldConfig)
        ].concat(config.items || []);

        super.construct(config);

        me.button.on({
            click   : me.onButtonClick,
            thisObj : me
        });

        me.fileField.on({
            change  : me.onFileFieldChange,
            thisObj : me
        });

        me._thisIsAUsedExpression(me.fileTip);
    }

    get button() {
        return this.widgetMap.fileButton;
    }

    get fileField() {
        return this.widgetMap.fileField;
    }

    /**
     * List of selected files
     * @returns {FileList}
     * @readonly
     */
    get files() {
        return this.fileField.files;
    }

    get fileTip() {
        const me = this;

        return me._fileTip || (me._fileTip = new Tooltip({
            cls          : 'b-file-tip',
            forElement   : me.button.element,
            showOnHover  : true,
            align        : 'b-t',
            scrollAction : 'realign',
            listeners    : {
                beforeshow() {
                    const
                        tip   = this,
                        files = me.files;

                    if (files && files.length) {
                        tip.html = `${Array.from(files).map(file => file.name).join('<br>')}`;
                        return true;
                    }

                    // Veto show
                    return false;
                }
            }
        }));
    }

    /**
     * Clears field
     */
    clear() {
        const me = this;

        me.fileField.clear();
        me.button.badge = '';

        me.trigger('clear');
    }

    onButtonClick({ event }) {
        const me = this;

        // forward click to the file input to open browser file picker
        // me.fileField.input.click();
        me.fileField.pickFile();

        event.preventDefault();
    }

    onFileFieldChange() {
        const me = this;

        me.button.badge = me.files.length || '';

        me.trigger('change', { files : me.files });
    }
}

FilePicker._$name = 'FilePicker'; BryntumWidgetAdapterRegister.register('filepicker', FilePicker);

/**
 * @module Core/widget/FlagField
 */

/**
 * DEPRECATED! Flag field is a checkbox which is driven by its boolean value and vice-versa.
 * When value is `true` then checkbox is checked, when it's `false` then checkbox
 * is unchecked.
 *
 * This field can be used as an {@link Grid.column.Column#config-editor editor} for the {@link Grid.column.Column Column}.
 * @deprecated
 */
class FlagField extends Checkbox {
    static get $name() {
        return 'FlagField';
    }

    static get type() {
        return 'flagfield';
    }

    static get defaultConfig() {
        return {
            value : ''
        };
    }

    get value() {
        return this.checked;
    }

    set value(v) {
        v = Boolean(v);
        super.value = v;

        if (!this.inputting) {
            this.checked = v;
        }
    }
}

FlagField._$name = 'FlagField'; BryntumWidgetAdapterRegister.register(FlagField.type, FlagField);

// No module tag here. That stops the singleton from being included by the docs.

/**
 * A singleton modal dialog box which can be used to ask the user to confirm or reject actions.
 *
 * Usage:
 * ```javascript
 *  MessageDialog.confirm({
 *      title: 'Dialog Title',
 *      message : 'Are you sure?'
 *  }).then(result => {
 *      if (result === MessageDialog.yesButton) {
 *          // The YES button was clicked, so go ahead!
 *      }
 *  });```
 *
 * @extends Core/widget/Popup
 * @singleton
 */
class MessageDialog extends Popup {
    static get $name() {
        return 'MessageDialog';
    }

    static get defaultConfig() {
        return {
            id : 'bryntum-msgdialog',

            centered : true,

            modal : true,

            hidden : true,

            autoShow : false,

            closeAction : 'hide',

            title : '\xa0',

            items : [{
                type : 'widget',
                id   : 'bryntum-msgdialog-message',
                cls  : 'b-msgdialog-message',
                ref  : 'message'
            }, {
                type : 'textfield',
                id   : 'bryntum-msgdialog-input',
                cls  : 'b-msgdialog-input',
                ref  : 'input'
            }],

            bbar : {
                id    : 'bryntum-msgdialog-bbar',
                items : [{
                    ref     : 'yesButton',
                    id      : 'bryntum-msgdialog-yesbutton',
                    cls     : 'b-msgdialog-yesbutton',
                    text    : 'Yes',
                    onClick : 'up.onYesClick'
                }, {
                    ref     : 'noButton',
                    id      : 'bryntum-msgdialog-nobutton',
                    cls     : 'b-msgdialog-nobutton',
                    text    : 'No',
                    onClick : 'up.onNoClick'
                }, {
                    ref     : 'cancelButton',
                    id      : 'bryntum-msgdialog-cancelbutton',
                    cls     : 'b-msgdialog-cancelbutton',
                    text    : 'Cancel',
                    onClick : 'up.onCancelClick'
                }]
            }
        };
    }

    /**
     * Shows a confirm dialog with "Yes" and "No" buttons. The returned promise resolves passing `true`
     * if the "yes" button is pressed, and `false` if the "No" button is pressed. Typing `ESC` rejects.
     * @param {Object} options An options object for what to show.
     * @param {String} [options.title] The title to show in the dialog header.
     * @param {String} [options.message] The message to show in the dialog body.
     * @async
     */
    async confirm({
        message,
        title = '\xa0'
    }) {
        const me = this;

        me.title = title;
        me.element.classList.remove(me.showClass);

        if (message) {
            me.showClass = 'b-show-message-yes-no';
            me.widgetMap.message.html = message;
        }
        else {
            me.showClass = 'b-show-yes-no';
        }
        me.element.classList.add(me.showClass);

        me.show();
        return me.promise = new Promise((resolve) => {
            me.resolve = resolve;
        });
    }

    doResolve(value) {
        const
            me          = this,
            { resolve } = me;

        if (resolve) {
            me.resolve = me.reject = me.promise = null;
            resolve(value);
            me.hide();
        }
    }

    onInternalKeyDown(event) {
        // Cancel on escape key
        if (event.key === 'Escape') {
            event.stopImmediatePropagation();
            if (this.widgetMap.cancelButton.isVisible) {
                this.onCancelClick();
            }
            else {
                this.onNoClick();
            }
        }
        super.onInternalKeyDown(event);
    }

    onYesClick() {
        this.doResolve(md.yesButton);
    }

    onNoClick() {
        this.doResolve(md.noButton);
    }

    onCancelClick() {
        this.doResolve(md.cancelButton);
    }
}

const md = new MessageDialog();

md.noButton = 0;
md.yesButton = 1;
md.cancelButton = 3;

/**
 * @module Core/widget/PagingToolbar
 */

/**
 * A special Toolbar class, which, when attached to an {@link Core.data.AjaxStore AjaxStore},
 * which has been configured to be {@link Core.data.AjaxStore#property-isPaged paged}, controls
 * the loading of that store to page through the data set.
 *
 * ```javascript
 * new Panel({
 *      layout : 'fit',
 *      items  : [
 *          myGrid
 *      ],
 *      bbar : {
 *          type  : 'pagingtoolbar',
 *          store : myGrid.store
 *      }
 * });
 * ```
 *
 * @extends Core/widget/Toolbar
 * @classType toolbar
 */
class PagingToolbar extends Toolbar {
    static get $name() {
        return 'PagingToolbar';
    }

    static get defaultConfig() {
        return {
            /**
             * The {@link Core.data.AjaxStore AjaxStore} that this PagingToolbar is to control.
             * @config {Core.data.AjaxStore}
             */
            store : null,

            localeClass : this,

            namedItems : {

                firstPageButton : {
                    onClick : 'up.onFirstPageClick',
                    icon    : 'b-fa-angle-double-left'
                },
                previousPageButton : {
                    onClick : 'up.onPreviousPageClick',
                    icon    : 'b-fa-angle-left'
                },
                pageNumber : {
                    type     : 'numberfield',
                    label    : 'L{page}',
                    min      : 1,
                    max      : 1,
                    triggers : null,
                    onChange : 'up.onPageNumberChange'
                },
                pageCount : {
                    type : 'widget',
                    cls  : 'b-pagecount b-toolbar-text'
                },
                nextPageButton : {
                    onClick : 'up.onNextPageClick',
                    icon    : 'b-fa-angle-right'
                },
                lastPageButton : {
                    onClick : 'up.onLastPageClick',
                    icon    : 'b-fa-angle-double-right'
                },
                reloadButton : {
                    onClick : 'up.onReloadClick',
                    icon    : 'b-fa-redo'
                },
                dataSummary : {
                    type : 'widget',
                    cls  : 'b-toolbar-text'
                }
            },

            items : {
                firstPageButton    : true,
                previousPageButton : true,
                pageNumber         : true,
                pageCount          : true,
                nextPageButton     : true,
                lastPageButton     : true,
                sep                : '|',
                reloadButton       : true,
                spacer             : '->',
                dataSummary        : true
            }
        };
    }

    set store(store) {
        const
            me = this,
            listener = {
                beforerequest : 'onStoreBeforeRequest',
                afterrequest  : 'onStoreChange',
                change        : 'onStoreChange',
                thisObj       : me
            };

        if (me.store) {
            me.store.un(listener);
        }

        me._store = store;
        if (store) {
            store.on(listener);
            if (store.isLoading) {
                me.onStoreBeforeRequest();
            }
        }
    }

    get store() {
        return this._store;
    }

    onStoreBeforeRequest() {
        this.eachWidget(w => w.disable());
    }

    updateLocalization() {
        const
            me = this,
            { reloadButton,  firstPageButton, previousPageButton, nextPageButton, lastPageButton } = me.widgetMap;

        firstPageButton.tooltip = me.L('firstPage');
        previousPageButton.tooltip = me.L('prevPage');
        nextPageButton.tooltip = me.L('nextPage');
        lastPageButton.tooltip = me.L('lastPage');
        reloadButton.tooltip = me.L('reload');

        me.updateSummary();

        super.updateLocalization();
    }

    updateSummary() {
        const
            me                         = this,
            { pageCount, dataSummary } = me.widgetMap;

        let count, lastPage, start, end, allCount;

        count = lastPage = start = end = allCount = 0;

        if (me.store) {
            const
                { store } = me,
                { pageSize, currentPage } = store;

            count = store.count;
            lastPage = store.lastPage;
            allCount = store.allCount;

            start = Math.max(0, (currentPage - 1) * pageSize + 1);
            end = Math.min(allCount, start + pageSize - 1);
        }

        pageCount.html = me.L('pageCountTemplate')({ lastPage });
        dataSummary.html = count ? me.L('summaryTemplate')({ start, end, allCount }) : me.L('noRecords');
    }

    onStoreChange() {
        const
            me = this,
            { widgetMap, store } = me,
            { count, lastPage, currentPage } = store,
            { pageNumber, pageCount, firstPageButton, previousPageButton, nextPageButton, lastPageButton, dataSummary } = widgetMap;

        me.eachWidget(w => w.enable());

        pageNumber.value = currentPage;
        pageNumber.max = lastPage;

        dataSummary.disabled = pageNumber.disabled = pageCount.disabled = !count;
        firstPageButton.disabled = previousPageButton.disabled = currentPage <= 1 || !count;
        nextPageButton.disabled  = lastPageButton.disabled = currentPage >= lastPage || !count;

        me.updateSummary();
    }

    onPageNumberChange({ value }) {
        if (this.store.currentPage !== value) {
            this.store.loadPage(value);
        }
    }

    onFirstPageClick() {
        this.store.loadPage(1);
    }

    onPreviousPageClick() {
        this.store.previousPage();
    }

    onNextPageClick() {
        this.store.nextPage();
    }

    onLastPageClick() {
        this.store.loadPage(this.store.lastPage);
    }

    onReloadClick() {
        this.store.loadPage(this.store.currentPage);
    }
}

PagingToolbar._$name = 'PagingToolbar'; BryntumWidgetAdapterRegister.register('pagingtoolbar', PagingToolbar);

/**
 * @module Core/widget/Splitter
 */

const hasFlex = el => parseInt(DomHelper.getStyleValue(el, 'flex-basis'), 10) || parseInt(DomHelper.getStyleValue(el, 'flex-grow'), 10);

/**
 * A simple splitter widget that resizes the elements next to it or above/below it depending on orientation.
 *
 * @extends Core/widget/Widget
 * @classType splitter
 * @externalexample widget/Splitter.js
 */
class Splitter extends Widget {
    //region Config

    static get defaultConfig() {
        return {
            /**
             * The splitters orientation, configurable with 'auto', 'horizontal' or 'vertical'.
             *
             * 'auto' tries to determine the orientation by either checking the `flex-direction` of the parent element
             * or by comparing the positions of the closest sibling elements to the splitter. If they are above and
             * below 'horizontal' is used, if not it uses 'vertical'.
             *
             * ```
             * new Splitter({
             *    orientation : 'horizontal'
             * });
             * ```
             *
             * To receive the actully used orienatation when configured with 'auto', see
             * {@link #property-currentOrientation}.
             *
             * @config {String}
             * @default
             */
            orientation : 'auto'
        };
    }

    //endregion

    //region Init & destroy

    doDestroy() {
        this.mouseDetacher && this.mouseDetacher();
        super.doDestroy();
    }

    //endregion

    //region Template & element

    template() {
        return TemplateHelper.tpl`
            <div class="b-splitter"></div>
        `;
    }

    get element() {
        return super.element;
    }

    set element(element) {
        super.element = element;

        EventHelper.on({
            element   : this.element,
            mousedown : 'onMouseDown',
            thisObj   : this
        });
    }

    //endregion

    //region Orientation

    /**
     * Get actually used orientation, which is either the configured value for `orientation` or if configured with
     * 'auto' the currently used orientation.
     * @property {String}
     * @readonly
     */
    get currentOrientation() {
        return this._currentOrientation;
    }

    /**
     * Splitter orientation, see {@link #config-orientation}. When set to 'auto' then actually used orientation can be
     * retrieved using {@link #property-currentOrientation}.
     * @property {String}
     * @readonly
     */
    get orientation() {
        return this._orientation;
    }

    set orientation(orientation) {
        this._orientation = orientation;

        if (orientation === 'auto') {
            this._currentOrientation = null;
        }
        else {
            this._currentOrientation = orientation;
        }

        this.updateOrientation();
    }

    // Determines current orientation if configured with 'auto'. Adds orientation cls
    updateOrientation() {
        const
            me          = this,
            { element } = this;

        if (me._prevOrientation) {
            element.classList.remove(me._prevOrientation);
        }

        // Orientation auto and already rendered, determine orientation to use
        if (!me._currentOrientation && me.rendered && element.offsetParent) {
            const flexDirection = DomHelper.getStyleValue(element.parentElement, 'flex-direction');

            // If used in a flex layout, determine orientation from flex-direction
            if (flexDirection) {
                me._currentOrientation = flexDirection.startsWith('column') ? 'horizontal' : 'vertical';
            }
            // If used in some other layout, try to determine form sibling elements position
            else {
                const
                    previous = element.previousElementSibling,
                    next     = element.nextElementSibling;

                if (!previous || !next) {
                    // To early in rendering, next sibling not rendered yet
                    return;
                }

                const
                    prevRect   = previous.getBoundingClientRect(),
                    nextRect   = next.getBoundingClientRect(),
                    topMost    = prevRect.top < nextRect.top ? prevRect : nextRect,
                    bottomMost = topMost === nextRect ? prevRect : nextRect;

                me._currentOrientation = topMost.top !== bottomMost.top ? 'horizontal' : 'vertical';
            }
        }

        if (me._currentOrientation) {
            element.classList.add(`b-${me._currentOrientation}`);
        }

        me._prevOrientation = me._currentOrientation;
    }

    //endregion

    //region Events

    onMouseDown(event) {
        const
            me          = this,
            { element } = me,
            prev        = element.previousElementSibling,
            next        = element.nextElementSibling,
            prevHasFlex = hasFlex(prev),
            nextHasFlex = hasFlex(next),
            flexed      = [];

        // Remember flexed children, to enable maintaining their proportions on resize
        for (const child of element.parentElement.children) {
            if (hasFlex(child) && child !== element) {
                flexed.push({
                    element : child,
                    width   : child.offsetWidth,
                    height  : child.offsetHeight
                });
            }
        }

        me.context = {
            startX     : event.pageX,
            startY     : event.pageY,
            prevWidth  : prev.offsetWidth,
            prevHeight : prev.offsetHeight,
            nextWidth  : next.offsetWidth,
            nextHeight : next.offsetHeight,
            prevHasFlex,
            nextHasFlex,
            flexed,
            prev,
            next
        };

        me.mouseDetacher = EventHelper.on({
            element   : document,
            mousemove : 'onMouseMove',
            mouseup   : 'onMouseUp',
            thisObj   : me
        });
    }

    onMouseMove(event) {
        const
            me = this,
            { context } = me,
            deltaX = event.pageX - context.startX,
            deltaY = event.pageY - context.startY;

        event.preventDefault();

        Object.assign(context, {
            deltaX,
            deltaY
        });

        if (!context.started) {
            context.started = true;

            me.trigger('start', { context, event });

            // Convert heights/widths to flex for flexed elements to maintain proportions
            // 100px high -> flex-grow 100
            context.flexed.forEach(flexed => {
                if (me.currentOrientation === 'vertical') {
                    flexed.element.style.flexGrow = flexed.width;
                }
                else {
                    flexed.element.style.flexGrow = flexed.height;
                }
                //Remove flex-basis, since it interferes with resizing
                flexed.element.style.flexBasis = '0';
            });
        }

        // Adjust flex-grow or width/height for splitters closest siblings
        if (me.currentOrientation === 'vertical') {
            const
                newPrevWidth = context.prevWidth + deltaX,
                newNextWidth = context.nextWidth - deltaX;

            if (context.prevHasFlex) {
                context.prev.style.flexGrow = newPrevWidth;
            }
            else {
                context.prev.style.width = `${newPrevWidth}px`;
            }

            if (context.nextHasFlex) {
                context.next.style.flexGrow = newNextWidth;
            }
            else {
                context.next.style.width = `${newNextWidth}px`;
            }
        }
        else {
            const
                newPrevHeight = context.prevHeight + deltaY,
                newNextHeight = context.nextHeight - deltaY;

            if (context.prevHasFlex) {
                context.prev.style.flexGrow = newPrevHeight;
            }
            else {
                context.prev.style.height = `${newPrevHeight}px`;
            }

            if (context.nextHasFlex) {
                context.next.style.flexGrow = newNextHeight;
            }
            else {
                context.next.style.height = `${newNextHeight}px`;
            }
        }

        me.trigger('move', { context, event });
    }

    onMouseUp(event) {
        const me = this;

        me.mouseDetacher && me.mouseDetacher();
        me.mouseDetacher = null;

        if (me.context.started) {
            me.trigger('end', { context : me.context, event });
        }

        me.context = null;
    }

    //endregion

    render() {
        super.render(...arguments);

        const me = this;

        if (!me._currentOrientation) {
            // Determine current orientation
            me.updateOrientation();
            if (!me._currentOrientation) {
                // Determine current orientation from closest siblings, needs to happen on new frame since the splitter
                // is rendered before its next sibling
                me.requestAnimationFrame(() => me.updateOrientation());
            }
        }
    }
}

Splitter._$name = 'Splitter'; BryntumWidgetAdapterRegister.register('splitter', Splitter);

/**
 * @module Grid/column/Column
 */

/**
 * Base class for other column types, used if no type is specified on a column.
 *
 * Default editor is a {@link Core.widget.TextField TextField}.
 *
 * ```javascript
 * const grid = new Grid({
 *   columns : [
 *      { field : 'name', text : 'Name' }, // Will use Column
 *      { type : 'number', field : 'age', text : 'Age' } // Will use NumberColumn
 *   ]
 * });
 * ```
 *
 * @extends Core/data/Model
 * @classType column
 * @mixes Core/mixin/Events
 * @mixes Core/localization/Localizable
 */
class Column extends Events(Localizable(Model)) {
    //region Config

    static get fields() {
        return [
            //region Common

            /**
             * Get/set header text
             * @member {String} text
             */

            /**
             * Text to display in the header
             * @config {String} text
             * @category Common
             */
            'text',

            /**
             * The {@link Core.data.Model Model} field name to read data from
             * @config {String} field
             * @category Common
             */
            'field',

            /**
             * Renderer function, used to format and style the content displayed in the cell. Return the cell text you want to display.
             * Can also affect other aspects of the cell, such as styling.
             * @param {Object} renderData Object containing renderer parameters
             * @param {HTMLElement} [renderData.cellElement] Cell element, for adding CSS classes, styling etc. Can be
             * null in case of export
             * @param {*} renderData.value Value to be displayed in the cell
             * @param {Core.data.Model} renderData.record Record for the row
             * @param {Grid.column.Column} renderData.column This column
             * @param {Grid.view.Grid} renderData.grid This grid
             * @param {Grid.row.Row} [renderData.row] Row object. Can be null in case of export
             * @param {Object} [renderData.size] Set `size.height` to specify the desired row height for the current row.
             * Largest specified height will be used, including the configured {@link Grid/view/Grid#config-rowHeight}.
             * Can be null in case of export
             * @param {Boolean} [renderData.isExport] True if record is being exported to allow special handling during export
             * @config {Function} renderer
             * @category Common
             */
            'renderer',

            /**
             * Column width. If value is Number then width is in pixels
             * @config {Number|String} width
             * @category Common
             */
            'width',

            /**
             * Gets or sets the column flex weight
             * @member {String} flex
             */

            /**
             * Column width as a flex weight. All columns with flex specified divide the available space (after
             * subtracting fixed widths) between them according to the flex value. Columns that have flex 2 will be
             * twice as wide as those with flex 1 (and so on)
             * @config {Number} flex
             * @category Common
             */
            'flex',

            //endregion

            //region Interaction

            /**
             * Specify if this column should be editable, and define which editor to use for editing cells in the
             * column (if {@link Grid/feature/CellEdit CellEdit} feature is enabled). Editor refers to {@link #config-field}
             * for a data source.
             *
             * All subclasses of {@link Core.widget.Field Field} can be used as editors. The most popular are:
             * - {@link Core.widget.TextField TextField};
             * - {@link Core.widget.NumberField NumberField};
             * - {@link Core.widget.DateField DateField};
             * - {@link Core.widget.TimeField TimeField};
             * - {@link Core.widget.Combo Combo};
             *
             * If record has method set + capitalized field, method will be called, e.g. if record has method named
             * `setFoobar` and this config is `foobar`, then instead of `record.foobar = value`,
             * `record.setFoobar(value)` will be called.
             *
             * @config {String|Object|Boolean} editor
             * @category Interaction
             */
            { name : 'editor', defaultValue : {} },

            /**
             * A function which is called when a cell edit is requested to finish.
             *
             * This may be an `async` function which performs complex validation. The edit will not
             * complete until it returns `false` to mean the edit cannot be finished, or `true` to go
             * ahead and complete.
             *
             * @param {Object} context An object describing the state of the edit at completion request time.
             * @param {Core.widget.Field} context.inputField The field configured as the column's `editor`.
             * @param {Core.data.Model} context.record The record being edited.
             * @param {*} context.oldValue The old value of the cell.
             * @param {*} context.value The new value of the cell.
             * @param {Grid.view.Grid} context.grid The host grid.
             * @param {Object} context.editorContext The {@link Grid.feature.CellEdit CellEdit} context object.
             * @param {Grid.column.Column} context.editorContext.column The column being edited.
             * @param {Core.data.Model} context.editorContext.record The record being edited.
             * @param {HTMLElement} context.editorContext.cell The cell element hosting the editor.
             * @param {Core.widget.Editor} context.editorContext.editor The floating Editor widget which is hosting the input field.
             * @config {Function} finalizeCellEdit
             * @category Interaction
             */
            'finalizeCellEdit',

            /**
             * Setting this option means that pressing the `ESCAPE` key after editing the field will
             * revert the field to the value it had when the edit began. If the value is _not_ changed
             * from when the edit started, the input field's {@link Core.widget.Field#config-clearable}
             * behaviour will be activated. Finally, the edit will be canceled.
             * @config {Boolean} revertOnEscape
             * @default true
             * @category Interaction
             */
            { name : 'revertOnEscape', defaultValue : true },

            /**
             * How to handle a request to complete a cell edit in this column if the field is invalid.
             * There are three choices:
             *  - `block` The default. The edit is not exited, the field remains focused.
             *  - `allow` Allow the edit to be completed.
             *  - `revert` The field value is reverted and the edit is completed.
             * @config {String} invalidAction
             * @default 'block'
             * @category Interaction
             */
            { name : 'invalidAction', defaultValue : 'block' },

            /**
             * Allow sorting of data in the column. You can pass true/false to enable/disable sorting, or provide a
             * custom sorting function, or a config object for a {@link Core.util.CollectionSorter}
             *
             * ```javascript
             * const grid = new Grid({
             *     columns : [
             *          {
             *              // Disable sorting for this column
             *              sortable : false
             *          },
             *          {
             *              // Custom sorting for this column
             *              sortable : function(user1, user2) {
             *                  return user1.name < user2.name ? -1 : 1;
             *              }
             *          },
             *          {
             *              // A config object for a Core.util.CollectionSorter
             *              sortable : {
             *                  property         : 'someField',
             *                  direction        : 'DESC',
             *                  useLocaleCompare : 'sv-SE'
             *              }
             *          }
             *     ]
             * });
             * ```
             *
             * @config {Boolean|Function|Object} sortable
             * @default true
             * @category Interaction
             */
            { name : 'sortable', defaultValue : true },

            /**
             * Allow searching in the column (respected by QuickFind and Search features)
             * @config {Boolean} searchable
             * @default true
             * @category Interaction
             */
            { name : 'searchable', defaultValue : true },

            /**
             * Allow filtering data in the column (if Filter or FilterBar feature is enabled). Also allows passing a
             * custom filtering function that will be called for each record with a single argument of format
             * { value, record, [operator] }. Returning `true` from the function includes the record in the filtered set.
             *
             * ```
             * const grid = new Grid({
             *     columns : [
             *          {
             *              field : 'name',
             *              // Disable filtering for this column
             *              filterable : false
             *          },
             *          {
             *              field : 'age',
             *              // Custom filtering for this column
             *              filterable: ({ value, record }) => Math.abs(record.age - value) < 10
             *          },
             *          {
             *              field : 'city',
             *              // Filtering for a value out of a list of values
             *              filterable: {
             *                  filterField : {
             *                      type  : 'combo',
             *                      value : '',
             *                      items : [
             *                          'Paris',
             *                          'Dubai',
             *                          'Moscow',
             *                          'London',
             *                          'New York'
             *                      ]
             *                  }
             *              }
             *          }
             *     ]
             * });
             * ```
             *
             * @config {Boolean|Function} filterable
             * @default true
             * @category Interaction
             */
            { name : 'filterable', defaultValue : true },

            /**
             * Allow column visibility to be toggled through UI
             * @config {Boolean} hideable
             * @default true
             * @category Interaction
             */
            { name : 'hideable', defaultValue : true },

            /**
             * Set to false to prevent this column header from being dragged
             * @config {Boolean} draggable
             * @category Interaction
             */
            { name : 'draggable', defaultValue : true },

            /**
             * Set to false to prevent grouping by this column
             * @config {Boolean} groupable
             * @category Interaction
             */
            { name : 'groupable', defaultValue : true },

            /**
             * Set to `false` to prevent the column from being drag-resized when the ColumnResize plugin is enabled.
             * @config {Boolean} resizable
             * @default true
             * @category Interaction
             */
            { name : 'resizable', defaultValue : true },

            //endregion

            //region Rendering

            /**
             * Renderer function for group headers (when using Group feature).
             * @param {Object} renderData
             * @param {HTMLElement} renderData.cellElement Cell element, for adding CSS classes, styling etc.
             * @param {*} renderData.groupRowFor Current group value
             * @param {Core.data.Model} renderData.record Record for the row
             * @param {Core.data.Model[]} renderData.groupRecords Records in the group
             * @param {Grid.column.Column} renderData.column Current rendering column
             * @param {Grid.column.Column} renderData.groupColumn Column that the grid is grouped by
             * @param {Number} renderData.count Number of records in the group
             * @param {Grid.view.Grid} renderData.grid This grid
             * @config {Function} groupRenderer
             * @returns {String} The header grouping text
             * @category Rendering
             */
            'groupRenderer',

            /**
             * Renderer function for the column header.
             * @param {Object} renderData
             * @param {Grid.column.Column} renderData.column This column
             * @param {HTMLElement} renderData.headerElement The header element
             * @config {Function} headerRenderer
             * @category Rendering
             */
            'headerRenderer',

            /**
             * Renderer function for cell tooltips header (used with CellTooltip feature). Specify false to prevent
             * tooltip for that column.
             * @param {HTMLElement} cellElement Cell element
             * @param {Core.data.Model} record Record for cell row
             * @param {Grid.column.Column} column Cell column
             * @param {CellTooltip} cellTooltip Feature instance, used to set tooltip content async
             * @param {MouseEvent} event The event that triggered the tooltip
             * @config {Function} tooltipRenderer
             * @category Rendering
             */
            'tooltipRenderer',

            /**
             * CSS class added to each cell in this column
             * @config {String} cellCls
             * @category Rendering
             */
            'cellCls',

            /**
             * CSS class added to the header of this column
             * @config {String} cls
             * @category Rendering
             */
            'cls',

            /**
             * Get/set header icon class
             * @member {String} icon
             */

            /**
             * Icon to display in header. Specifying an icon will render a `<i>` element with the icon as value for the
             * class attribute
             * @config {String} icon
             * @category Rendering
             */
            'icon',

            //endregion

            //region Layout

            /**
             * Text align (left, center, right)
             * @config {String} align
             * @category Layout
             */
            'align',

            /**
             * Column minimal width. If value is Number then minimal width is in pixels
             * @config {Number|String} minWidth
             * @default 60
             * @category Layout
             */
            { name : 'minWidth', defaultValue : 60 },

            /**
             * Get/set columns hidden state. Specify `true` to hide the column, `false` to show it.
             * @member {Boolean} hidden
             */

            /**
             * Hide the column from start
             * @config {Boolean} hidden
             * @category Layout
             */
            { name : 'hidden', defaultValue : false },

            /**
             * Convenient way of putting a column in the "locked" region. Same effect as specifying region: 'locked'.
             * If you have defined your own regions (using {@link Grid.view.Grid#config-subGridConfigs}) you should use
             * {@link #config-region} instead of this one.
             * @config {Boolean} locked
             * @default false
             * @category Layout
             */
            { name : 'locked' },

            /**
             * Region (part of the grid, it can be configured with multiple) where to display the column. Defaults to
             * {@link Grid.view.Grid#config-defaultRegion}.
             * @config {String} region
             * @category Layout
             */
            { name : 'region' },

            //endregion

            // region Menu

            /**
             * Show column picker for the column
             * @config {Boolean} showColumnPicker
             * @default true
             * @category Menu
             */
            { name : 'showColumnPicker', defaultValue : true },

            /**
             * false to prevent showing a context menu on the column header element
             * @config {Boolean} enableHeaderContextMenu
             * @default true
             * @category Menu
             */
            { name : 'enableHeaderContextMenu', defaultValue : true },

            /**
             * false to prevent showing a context menu on the cell elements in this column
             * @config {Boolean} enableCellContextMenu
             * @default true
             * @category Menu
             */
            { name : 'enableCellContextMenu', defaultValue : true },

            /**
             * Extra items to show in the header context menu for this column
             * @config {Object[]} headerMenuItems
             * @category Menu
             */
            'headerMenuItems',

            /**
             * Extra items to show in the cell context menu for this column
             * @config {Object[]} cellMenuItems
             * @category Menu
             */
            'cellMenuItems',

            //endregion

            //region Summary

            /**
             * Summary type (when using Summary feature). Valid types are:
             * <dl class="wide">
             * <dt>sum <dd>Sum of all values in the column
             * <dt>add <dd>Alias for sum
             * <dt>count <dd>Number of rows
             * <dt>countNotEmpty <dd>Number of rows containing a value
             * <dt>average <dd>Average of all values in the column
             * <dt>function <dd>A custom function, used with store.reduce. Should take arguments (sum, record)
             * </dl>
             * @config {String} sum
             * @category Summary
             */
            'sum',

            /**
             * Summary configs, use if you need multiple summaries per column. Replaces {@link #config-sum} and
             * {@link #config-summaryRenderer} configs. Accepts an array of objects with the following fields:
             * * sum - Matching {@link #config-sum}
             * * renderer - Matching {@link #config-summaryRenderer}
             * * seed - Initial value when using a function as `sum`
             * @config {Object[]} summaries
             * @category Summary
             */
            'summaries',

            /**
             * Renderer function for summary (when using Summary feature). The renderer is called with the calculated
             * summary as only argument.
             * @config {Function} summaryRenderer
             * @category Summary
             */
            'summaryRenderer',

            //region Misc

            /**
             * Column settings at different responsive levels, see responsive demo under examples/
             * @config {Object} responsiveLevels
             * @category Misc
             */
            'responsiveLevels',

            /**
             * Tags, may be used by ColumnPicker feature for grouping columns by tag in the menu
             * @config {String[]} tags
             * @category Misc
             */
            'tags',

            /**
             * Column config to apply to normal config if viewed on a touch device
             * @config {Object} touchConfig
             * @category Misc
             */
            'touchConfig',

            /**
             * When using the tree feature, exactly one column should specify { tree: true }
             * @config {Boolean} tree
             * @category Misc
             */
            'tree',

            /**
             * Determines which type of filtering to use for the column. Usually determined by the column type used,
             * but may be overridden by setting this field.
             * @config {String} filterType
             * @category Misc
             */
            'filterType',

            /**
             * By default, any rendered column text content is HTML-encoded. Set this flag to `false` disable this and allow rendering html elements
             * @config {Boolean} htmlEncode
             * @default true
             * @category Misc
             */
            { name : 'htmlEncode', defaultValue : true },

            /**
             * Set to `true`to automatically call DomHelper.sync for html returned from a renderer. Should in most cases
             * be more performant than replacing entire innerHTML of cell and also allows CSS transitions to work. Has
             * no effect unless `htmlEncode` is enabled. Returned html must contain a single root element (that can have
             * multiple children). See PercentColumn for example usage.
             * @config {Boolean} autoSyncHtml
             * @default false
             * @category Misc
             */
            { name : 'autoSyncHtml', defaultValue : false },

            'type',

            /**
             * Set to `true` to have the {@link Grid.feature.CellEdit CellEdit} feature update the record being
             * edited live upon field edit instead of when editing is finished by using `TAB` or `ENTER`
             */
            { name : 'instantUpdate', defaultValue : false },

            { name : 'repaintOnResize', defaultValue : false },

            /**
            * An optional query selector to select a sub element within the cell being
            * edited to align a cell editor's `X` position and `width` to.
            * @config {String} editTargetSelector
            */
            'editTargetSelector',

            /**
             * Used by the Export feature. Set to `false` to omit a column from an exported dataset
             * @config {Boolean} exportable
             * @default true
             */
            { name : 'exportable', defaultValue : true },

            /**
             * Column type which will be used by {@link Grid.util.TableExporter}. See list of available types in TableExporter
             * doc. Returns undefined by default, which means column type should be read from the record field.
             * @config {String} exportedType
             */
            { name : 'exportedType' }
            //endregion
        ];
    }

    // prevent undefined fields from being exposed, to simplify spotting errors
    static get autoExposeFields() {
        return false;
    }

    //endregion

    //region Init

    construct(data, store) {
        const me = this;

        me.masterStore = store;

        // Store might be an array
        if (store) {
            me._grid = Array.isArray(store) ? store[0].grid : store.grid;
        }

        me.localizableProperties = data.localizableProperties || ['text'];

        if (data.localeClass) {
            me.localeClass = data.localeClass;
        }

        super.construct(data, store, null, false);

        me.processConfiguredListeners(data.listeners);

        // Default value for region is assigned by the ColumnStore in createRecord(), same for `locked`

        // Allow field : null if the column does not rely on a record field.
        // For example the CheckColumn when used by GridSelection.
        if (!('field' in me.data)) {
            me.field = '_' + (me.type || '') + (++Column.emptyCount);
            me.noFieldSpecified = true;
        }

        // If our field is a dot separated path, we must use ObjectHelper.getPath to extract our value
        me.hasComplexMapping = me.field && me.field.includes('.');

        if (!me.width && !me.flex && !me.children) {
            // Set the width silently because we're in construction.
            me.set({
                width : Column.defaultWidth,
                flex  : null
            }, null, true);
        }
    }

    remove() {
        const
            { subGrid, grid } = this,
            focusedCell       = subGrid && grid && grid.focusedCell;

        // Prevent errors when removing the column that the owning grid has registered as focused.
        if (focusedCell && focusedCell.columnId === this.id) {

            // Focus is in the grid, navigate before column is removed
            if (document.activeElement === grid) {
                grid.navigateRight();
            }
            // Focus not in the grid, bump the focused cell pointer to the ext visible column.
            else {
                focusedCell.columnId = subGrid.columns.getAdjacentVisibleLeafColumn(this.id, true, true).id;
            }
        }
        super.remove();
    }

    /**
     * Extracts the value from the record specified by this Column's {@link #config-field} specification.
     *
     * This will work if the field is a dot-separated path to access fields in associated records, eg
     *
     * ```javascript
     *  field : 'resource.calendar.name'
     * ```
     *
     * **Note:** This is the raw field value, not the value returned by the {@link #config-renderer}.
     * @param {Core.data.Model} record The record from which to extract the field value.
     * @returns {*} The value of the referenced field if any.
     */
    getRawValue(record) {
        const me = this;

        if (me.hasComplexMapping) {
            return ObjectHelper.getPath(record, me.field);
        }
        return record[me.field] || record.get(me.field);
    }

    // Create an ownership hierarchy which links columns up to their SubGrid if no owner injected.
    get owner() {
        return this._owner || this.subGrid;
    }

    set owner(owner) {
        this._owner = owner;
    }

    get nextVisibleSibling() {
        // During move from one region to another, nextSibling might not be wired up to the new next sibling in region.
        // (Because the order in master store did not change)
        const region = this.region;

        let next = this.nextSibling;
        while (next && (next.hidden || next.region !== region)) {
            next = next.nextSibling;
        }
        return next;
    }

    get isLastInSubGrid() {
        return !this.nextVisibleSibling && (!this.parent || this.parent.isLastInSubGrid);
    }

    /**
     * The header element for this Column. *Only available after the grid has been rendered*.
     *
     * **Note that column headers are rerendered upon mutation of Column values, so this
     * value is volatile and should not be cached, but should be read whenever needed.**
     * @property {HTMLElement}
     * @readonly
     */
    get element() {
        return this.grid.getHeaderElement(this);
    }

    /**
     * The text wrapping element for this Column. *Only available after the grid has been rendered*.
     *
     * This is the full-width element which *contains* the text-bearing element and any icons.
     *
     * **Note that column headers are rerendered upon mutation of Column values, so this
     * value is volatile and should not be cached, but should be read whenever needed.**
     * @property {HTMLElement}
     * @readonly
     */
    get textWrapper() {
        return DomHelper.getChild(this.element, '.b-grid-header-text');
    }

    /**
     * The text containing element for this Column. *Only available after the grid has been rendered*.
     *
     * **Note that column headers are rerendered upon mutation of Column values, so this
     * value is volatile and should not be cached, but should be read whenever needed.**
     * @property {HTMLElement}
     * @readonly
     */
    get textElement() {
        return DomHelper.down(this.element, '.b-grid-header-text-content');
    }

    /**
     * The child element into which content should be placed. This means where any
     * contained widgets such as filter input fields should be rendered. *Only available after the grid has been rendered*.
     *
     * **Note that column headers are rerendered upon mutation of Column values, so this
     * value is volatile and should not be cached, but should be read whenever needed.**
     * @property {HTMLElement}
     * @readonly
     */
    get contentElement() {
        return DomHelper.down(this.element, '.b-grid-header-children');
    }

    /**
     * The Field to use as editor for this column
     * @private
     * @readonly
     */
    get editor() {
        let editor = this.data.editor;

        if (editor && !(editor instanceof Widget)) {
            // Give frameworks a shot at injecting their own editor, wrapped as a widget
            const result = this.grid.processCellEditor({ editor, field : this.field });

            if (result) {
                // Use framework editor
                editor = this.data.editor = result.editor;
            }
            else {
                if (typeof editor === 'string') {
                    editor = {
                        type : editor
                    };
                }

                editor = this.data.editor = WidgetHelper.createWidget(Object.assign(this.defaultEditor, editor, {
                    owner : this.grid
                }));
            }
        }

        return editor;
    }

    set editor(editor) {
        this.data.editor = editor;
    }

    /**
     * A config object specifying the editor to use to edit this column.
     * @private
     * @readonly
     */
    get defaultEditor() {
        return {
            type : 'textfield',
            name : this.field
        };
    }

    /**
     * Default settings for the column, applied in constructor. None by default, override in subclass.
     * @member {Object} defaults
     * @returns {Object}
     * @readonly
     */
    //get defaults() {
    //    return {};
    //}
    //endregion

    //region Properties

    static get type() {
        return 'column';
    }

    static get text() {
        return this.defaultValues.text;
    }

    get grid() {
        return this._grid || this.parent && this.parent.grid;
    }

    get locked() {
        return this.data.region === 'locked';
    }

    set locked(locked) {
        this.region = locked ? 'locked' : 'normal';
    }

    // parent headers cannot be sorted by
    get sortable() {
        return this.isLeaf && this.data.sortable;
    }

    set sortable(sortable) {
        this.set('sortable', sortable);
    }

    // parent headers cannot be grouped by
    get groupable() {
        return this.isLeaf && this.data.groupable;
    }

    set groupable(groupable) {
        this.set('groupable', groupable);
    }

    //endregion

    //region Show/hide

    /**
     * Hides this column.
     */
    hide(silent = false) {
        const
            me     = this,
            parent = me.parent;

        // Reject non-change
        if (!me.hidden) {
            me.hidden = true;

            if (parent && !parent.isRoot) {
                // check if all sub columns are hidden, if so hide parent
                const anyVisible = parent.children.some(child => child.hidden !== true);
                if (!anyVisible && !parent.hidden) {
                    silent = true; // hiding parent will trigger event
                    parent.hide();
                }
            }

            if (me.children) {
                me.children.forEach(child => child.hide(true));
            }

            if (!silent) {
                me.stores.forEach(store => store.trigger('hideColumn'));
            }
        }
    }

    /**
     * Shows this column.
     */
    show(silent = false) {
        const me     = this,
            parent = me.parent;

        // Reject non-change
        if (me.hidden) {
            me.hidden = false;

            if (parent && parent.hidden) {
                parent.show();
            }

            if (me.children) {
                me.children.forEach(child => child.show(true));
            }

            // event is triggered on chained stores
            if (!silent) {
                me.stores.forEach(store => store.trigger('showColumn'));
            }
        }
    }

    /**
     * Toggles the column visibility.
     * @param {Boolean} force Set to true (visible) or false (hidden) to force a certain state
     */
    toggle(force = null) {
        if ((this.hidden && force === undefined) || force === true) return this.show();
        if ((!this.hidden && force === undefined) || force === false) return this.hide();
    }

    //endregion

    //region Index & id

    /**
     * Generates an id for the column when none is set. Generated ids are 'col1', 'col2' and so on. If a field is
     * specified (as it should be in most cases) the field name is used instead: 'name1', 'age2' ...
     * @private
     * @returns {String}
     */
    generateId() {
        if (!Column.generatedIdIndex) Column.generatedIdIndex = 0;

        return (this.field ? this.field.replace(/\./g, '-') : 'col') + (++Column.generatedIdIndex);
    }

    /**
     * Index among all flattened columns
     * @property {Number}
     * @readOnly
     * @internal
     */
    get allIndex() {
        return this.masterStore.indexOf(this);
    }

    //endregion

    //region Width

    /**
     * Get/set columns width in px. If column uses flex, width will be undefined.
     * Setting a width on a flex column cancels out flex.
     *
     * **NOTE:** Grid might be configured to always stretch the last column, in which case the columns actual width
     * might deviate from the configured width.
     *
     * ```javascript
     * let grid = new Grid({
     *     appendTo : 'container',
     *     height   : 200,
     *     width    : 400,
     *     columns  : [{
     *         text  : 'First column',
     *         width : 100
     *     }, {
     *         text  : 'Last column',
     *         width : 100 // last column in the grid is always stretched to fill the free space
     *     }]
     * });
     *
     * grid.columns.last.element.offsetWidth; // 300 -> this points to the real element width
     * ```
     * @property {Number|String}
     */
    get width() {
        return this.data.width;
    }

    set width(width) {
        const data = { width };
        if (width && ('flex' in this.data)) {
            data.flex = null; // remove flex when setting width to enable resizing flex columns
        }
        this.set(data);
    }

    // Private, only used in tests where standalone Headers are created with no grid
    // from which to lookup the associate SubGrid.
    set subGrid(subGrid) {
        this._subGrid = subGrid;
    }

    /**
     * Get the SubGrid to which this column belongs
     * @property {Grid.view.SubGrid}
     * @readonly
     */
    get subGrid() {
        return  this._subGrid || (this.grid ? this.grid.getSubGridFromColumn(this) : undefined);
    }

    /**
     * Get the element for the SubGrid to which this column belongs
     * @property {HTMLElement}
     * @readonly
     * @private
     */
    get subGridElement() {
        return this.subGrid.element;
    }

    // Returns size in pixels for measured value
    measureSize(value) {
        return DomHelper.measureSize(value, this.subGrid ? this.subGrid.element : undefined);
    }

    // This method is used to calculate minimum row width for edge and safari
    // It calculates minimum width of the row taking column hierarchy into account
    calculateMinWidth() {
        const
            me       = this,
            width    = me.measureSize(me.width),
            minWidth = me.measureSize(me.minWidth);

        let minChildWidth = 0;

        if (me.children) {
            minChildWidth = me.children.reduce((result, column) => {
                return result + column.calculateMinWidth();
            }, 0);
        }

        return Math.max(width, minWidth, minChildWidth);
    }

    /**
     * Resizes the column to match the widest string in it. By default it also measures the column header, this
     * behaviour can be configured by setting {@link Grid.view.Grid#config-resizeToFitIncludesHeader}.
     *
     * Called internally when you double click the edge between
     * column headers, but can also be called programmatically. For performance reasons it is limited to checking 1000
     * rows surrounding the current viewport.
     */
    resizeToFitContent() {
        const me         = this,
            {
                grid,
                renderer,
                defaultRenderer,
                element
            } = me,
            rowManager  = grid.rowManager,
            store       = grid.store,
            count       = store.count,
            useRenderer = renderer || defaultRenderer;

        if (count <= 0) return;

        const cellElement       = grid.element.querySelector(`.b-grid-cell[data-column-id=${me.id}]`),
            originalStyle     = cellElement.cssText,    // Renderer might overwrite
            originalClassName = cellElement.className;  // Renderer might overwrite

        let maxWidth = 0,
            start, end, i, record, value;

        // Measure header unless configured not to
        if (grid.resizeToFitIncludesHeader) {
            const style = window.getComputedStyle(element);
            // Header always in view, use its element
            maxWidth = DomHelper.measureText(
                element.innerText,
                element,
                false,
                element.parentElement
            ) + parseInt(style.paddingLeft); // Seems to miss the padding, have not found why

            // Remove measuring element, it messes some styling rules up if left in DOM
            element.parentElement.offScreenDiv.parentElement.remove();
        }

        // If it's a very large dataset, measure the maxWidth of the field in the 1000 rows
        // surrounding the rendered block.
        if (count > 1000) {
            start = Math.max(Math.min(rowManager.topIndex + rowManager.rowCount / 2 - 500, count - 1000), 0);
            end = start + 1000;
        }
        else {
            start = 0;
            end = count;
        }

        for (i = start; i < end; i++) {
            record = store.getAt(i);
            value = me.getRawValue(record);

            if (useRenderer) {
                value = useRenderer.call(me, {
                    cellElement,
                    rowElement        : cellElement.parentNode,
                    value,
                    record,
                    column            : me,
                    size              : { height : record.rowHeight || 0 },
                    grid,
                    row               : {},
                    updatingSingleRow : false
                });

                // Cell renderer is allowed to direction manipulate the cell element, if so it wont return a value
                value = value == null ? cellElement.innerHTML : String(value);
            }

            if (value) {
                // Measure withing the SubGrid, allows more css rules to apply. Not measuring inside rows sine that might get to costly performance wise
                maxWidth = Math.max(
                    maxWidth,
                    DomHelper.measureText(
                        value,
                        cellElement,
                        !(me.htmlEncode && !me.disableHtmlEncode),
                        me.subGrid.element
                    )
                );
            }
        }

        // Restore top cell which may be mutated by the repeated call of the renderer.
        cellElement.className = originalClassName;
        cellElement.cssText = originalStyle;

        return me.width = maxWidth;
    }

    //endregion

    //region State

    /**
     * Get column state, used by State mixin
     * @private
     */
    getState() {
        // TODO: exclude those with value = default?
        const me    = this,
            state = {
                [me.flex ? 'flex' : 'width'] : me.flex ? me.flex : me.width,
                id                           : me.id,
                hidden                       : me.hidden,
                index                        : me.allIndex,
                region                       : me.region,
                filterable                   : me.filterable,
                text                         : me.text,
                locked                       : me.locked
            };

        if (me.children) state.children = me.children.map(child => child.getState());

        return state;
    }

    /**
     * Apply state to column, used by State mixin
     * @private
     */
    applyState(state) {
        const me = this;

        me.beginBatch();

        if ('locked' in state) {
            me.locked = state.locked;
        }

        if ('minWidth' in state) {
            me.minWidth = state.minWidth;
        }

        if ('width' in state) {
            me.width = state.width;
        }

        if ('flex' in state) {
            me.flex = state.flex;
        }

        if ('width' in state && me.flex) {
            me.flex = undefined;
        }
        else if ('flex' in state && me.width) {
            me.width = undefined;
        }

        if ('text' in state) {
            me.text = state.text;
        }

        if ('region' in state) {
            me.region = state.region;
        }

        if ('renderer' in state) {
            me.renderer = state.renderer;
        }

        if ('filterable' in state) {
            me.filterable = state.filterable;
        }

        me.endBatch();

        if ('hidden' in state) {
            me.toggle(state.hidden !== true);
        }
    }

    //endregion

    //region Other

    /**
     * Clear cell contents. Base implementation which just sets innerHTML to blank string.
     * Should be overridden in subclasses to clean up for examples widgets.
     * @param {HTMLElement} cellElement
     * @internal
     */
    clearCell(cellElement) {
        cellElement.innerHTML = '';
    }

    /**
     * Override in subclasses to allow/prevent editing of certain rows.
     * @param {Core.data.Model} record
     * @internal
     */
    canEdit(record) {
        return true;
    }

    //endregion
}
// Registered in ColumnStore as we can't have this in Column due to circular dependencies
// ColumnStore.registerColumnType(Column);

Column.emptyCount = 0;
Column.defaultWidth = 100;
Column.exposeProperties();
Column._$name = 'Column';

/**
 * @module Grid/data/ColumnStore
 */

/**
 * A store specialized in handling columns. Used by the Grid to hold its columns and used as a chained store by each SubGrid
 * to hold theirs. Should not be instanced directly, instead access it through `grid.columns` or `subGrid.columns`
 *
 * ```
 * // resize first column
 * grid.columns.first.width = 200;
 *
 * // remove city column
 * grid.columns.get('city').remove();
 *
 * // add new column
 * grid.columns.add({text : 'New column'});
 *
 * // add new column to specific region (SubGrid)
 * grid.columns.add({text : 'New column', region : 'locked'});
 *
 * // add new column to 'locked' region (SubGrid)
 * grid.columns.add({text : 'New column', locked : true});
 * ```
 *
 * @extends Core/data/Store
 */
class ColumnStore extends Localizable(Store) {
    static get defaultConfig() {
        return {
            modelClass : Column,
            tree       : true,

            /**
             * Automatically adds a field definition to the store used by the Grid when adding a new Column displaying a
             * non-existing field.
             *
             * To enable this behaviour:
             *
             * ```javascript
             * const grid = new Grid({
             *     columns : {
             *         autoAddField : true,
             *         data         : [
             *             // Column definitions here
             *         ]
             *     }
             * }
             *
             * @config {Boolean}
             * @default
             */
            autoAddField : false
        };
    }

    construct(config) {
        const me = this;

        // Consequences of ColumnStore construction can cause reading of grid.columns
        // so set the property early.
        if (config.grid) {
            config.grid._columnStore = me;
            me.id = `${config.grid.id}-columns`;

            // Visible columns must be invalidated on expand/collapse
            config.grid.on({
                subGridCollapse : 'clearSubGridCaches',
                subGridExpand   : 'clearSubGridCaches',
                thisObj         : me
            });
        }
        super.construct(config);

        // So that we can invalidate cached collections which take computing so that we compute them
        // only when necessary. For example when asking for the visible leaf columns, we do not want
        // to compute that each time.
        me.on({
            change  : me.clearCaches,
            thisObj : me,
            prio    : 1
        });
    }

    get modelClass() {
        return this._modelClass;
    }

    set modelClass(ClassDef) {
        this._modelClass = ClassDef;
    }

    doDestroy() {
        const allColumns = [];

        this.traverse(column => allColumns.push(column));

        super.doDestroy();

        // Store's destroy unjoins all records. Destroy all columns *after* that.
        allColumns.forEach(column => column.destroy());
    }

    // Overridden because the flat collection only contains top level columns,
    // not leaves - group columns are *not* expanded.
    getById(id) {
        return super.getById(id) || this.idRegister[id];
    }

    forEach(fn, thisObj = this) {
        // Override to omit root
        this.traverseWhile((n, i) => fn.call(thisObj, n, i), true);
    }

    get totalFixedWidth() {
        let result = 0;
        for (let col of this) {
            if (!col.hidden) {
                if (col.flex) {
                    result += col.measureSize(Column.defaultWidth);
                }
                else {
                    result += Math.max(col.measureSize(col.width), col.measureSize(col.minWidth));
                }
            }
        }
        return result;
    }

    /**
     * Returns the top level columns. If using grouped columns, this is the top level columns. If no grouped
     * columns are being used, this is the leaf columns.
     * @property {Grid.column.Column[]}
     * @readonly
     */
    get topColumns() {
        return this.isChained ? this.masterStore.rootNode.children.filter(this.chainedFilterFn) : this.rootNode.children;
    }

    /**
     * Returns the visible leaf headers which drive the rows' cell content.
     * @property {Grid.column.Column[]}
     * @readonly
     */
    get visibleColumns() {
        const me = this;

        if (!me._visibleColumns) {
            me._visibleColumns = me.leaves.filter(column => !column.hidden && (!column.subGrid || !column.subGrid.collapsed));
        }

        return me._visibleColumns;
    }

    clearSubGridCaches(subGrid) {
        subGrid.columns.clearCaches();
        this.clearCaches();
    }

    clearCaches() {
        this._visibleColumns = null;
    }

    onMasterDataChanged(event) {
        super.onMasterDataChanged(event);

        // If master store has changes we also need to clear cached columns, in case a column was hidden
        this.clearCaches();
    }

    getAdjacentVisibleLeafColumn(columnOrId, next = true, wrap = false) {
        let columns = this.visibleColumns,
            column = (columnOrId instanceof Column) ? columnOrId : this.getById(columnOrId),
            idx = columns.indexOf(column) + (next ? 1 : -1);

        // If we walked off either end, wrap if directed to do so,
        // otherwise, return null;
        if (!columns[idx]) {
            if (wrap) {
                idx = next ? 0 : columns.length - 1;
            }
            else {
                return null;
            }
        }

        return columns[idx];
    }

    /**
     * Bottom columns are the ones displayed in the bottom row of a grouped header, or all columns if not using a grouped
     * header. They are the columns that actually display any data.
     * @returns {Grid.column.Column[]}
     * @readonly
     */
    get bottomColumns() {
        return this.leaves;
    }

    /**
     * Get column by field. To be sure that you are getting exactly the intended column, use {@link Core.data.Store#function-getById Store#getById()} with the
     * columns id instead.
     * @param {String} field Field name
     * @returns {Grid.column.Column}
     */
    get(field) {
        return this.findRecord('field', field, true);
    }

    /**
     * Used internally to create a new record in the store. Creates a column of the correct type by looking up the
     * specified type among registered columns.
     * @private
     */
    createRecord(data) {
        const
            { grid = {} } = this, // Some ColumnStore tests lacks Grid
            { store } = grid;

        let columnClass = this.modelClass;

        if (data.type) {
            columnClass = ColumnStore.getColumnClass(data.type);
            if (!columnClass) {
                throw new Error(this.L('columnTypeNotFound', data));
            }
        }

        if (data.locked) {
            data.region = 'locked';
            delete data.locked;
        }

        const column = new columnClass(data, this);

        // Doing this after construction, in case the columnClass has a default value for region (Schedulers
        // TimeAxisColumn has)
        if (!column.data.region) {
            column.data.region = grid.defaultRegion || 'normal';
        }

        // Add missing fields to Grids stores model
        if (this.autoAddField && !column.noFieldSpecified && store && !store.modelClass.getFieldDefinition(column.field)) {
            let fieldDefinition = column.field;

            // Some columns define the type to use for new fields (date, number etc)
            if (column.constructor.fieldType) {
                fieldDefinition = {
                    name : column.field,
                    type : column.constructor.fieldType
                };
            }

            store.modelClass.addField(fieldDefinition);
        }

        return column;
    }

    /**
     * indexOf extended to also accept a columns field, for backward compatibility.
     * ```
     * grid.columns.indexOf('name');
     * ```
     * @param recordOrId
     * @returns {Number}
     */
    indexOf(recordOrId) {
        // TODO: build the need for field away
        let index = super.indexOf(recordOrId);
        if (index > -1) return index;
        // no record found by id, find by field since old code relies on that instead of id
        // TODO: replace such cases with columns id
        return this.records.findIndex(r => r.field === recordOrId);
    }

    //region Column types

    /**
     * Call from custom column to register it with ColumnStore. Required to be able to specify type in column config.
     * @param {Class} columnClass The {@link Grid.column.Column} subclass to register.
     * @param {Boolean} simpleRenderer Pass `true` if its default renderer does *not* use other fields from the passed
     * record than its configured {@link Grid.column.Column#config-field}. This enables more granular cell updating
     * upon record mutation.
     * @example
     * // create and register custom column
     * class CustomColumn {
     *  static get type() {
     *      return 'custom';
     *  }
     * }
     * ColumnStore.registerColumnType(CustomColumn, true);
     * // now possible to specify in column config
     * let grid = new Grid({
     *   columns: [
     *     { type: 'custom', field: 'id' }
     *   ]
     * });
     */
    static registerColumnType(columnClass, simpleRenderer = false) {
        if (!ColumnStore.columnTypes) ColumnStore.columnTypes = {};
        columnClass.simpleRenderer = simpleRenderer;
        ColumnStore.columnTypes[columnClass.type] = columnClass;
    }

    /**
     * Returns registered column class for specified type.
     * @param type Type name
     * @returns {Grid.column.Column}
     * @internal
     */
    static getColumnClass(type) {
        return ColumnStore.columnTypes && ColumnStore.columnTypes[type];
    }

    //endregion
}

/**
 * Custom {@link Grid.data.ColumnStore} event which triggers when a column is resized, i.e. its width has been changed
 *
 * @param {Function} handler
 * @param {Object} [thisObj]
 */
const columnResizeEvent = (handler, thisObj) => ({
    'update' : ({ store, record, changes }) => {
        let result = true;

        if ('width' in changes || 'minWidth' in changes || 'flex' in changes) {
            result = handler.call(thisObj, { store, record, changes });
        }

        return result;
    }
});
// Can't have this in Column due to circular dependencies
ColumnStore.registerColumnType(Column, true);
ColumnStore._$name = 'ColumnStore';

/**
 * @module Grid/column/AggregateColumn
 */

/**
 * A column, which, when used as part of a Tree, aggregates the values of this column's descendants using
 * a configured function which defaults to `sum`.
 *
 * Default editor depends on the data field type. If it is a number, default editor is a {@link Core.widget.NumberField NumberField}.
 * Otherwise Default editor is a {@link Core.widget.TextField TextField}.
 *
 * ```
 * const grid = new TreeGrid({
 *   // Custom aggregation handler.
 *   // For test purposes, this just does "sum"
 *   myAggregator(...values) {
 *       let result = 0;
 *
 *       for (let i = 0, { length } = args; i < length; i++) {
 *           result += parseInt(args[i], 10);
 *       }
 *       return result;
 *   },
 *   columns : [
 *      { field : 'name', text : 'Name' },
 *
 *      // Will sum the ages of leaf nodes. This is the default.
 *      { type : 'aggregate', field : 'age', text : 'Age', renderer : ({ value }) => `<b>${value}<b>` },
 *
 *      // Will use AggregateColumn's built-in avg of scores of leaf nodes
 *      { type : 'aggregate', field : 'score', text : 'Score', function : 'avg' },
 *
 *      // Will use the grid's myAggregator function
 *      { type : 'aggregate', field : 'revenue', text : 'Revenue', function : 'up.myAggregator' },
 *   ]
 * });
 * ```
 *
 * @extends Grid/column/Column
 * @classType aggregate
 */
class AggregateColumn extends Column {
    //region Config
    static get type() {
        return 'aggregate';
    }

    static get fields() {
        return [
            'function'
        ];
    }

    static get defaults() {
        return {
            /**
             * Math Function name, or function name prepended by `"up."` that is resolveable in an
             * ancestor component (such as the owning Grid, or a hight Container), or a function to
             * use to aggregate child record values for this column, or a function.
             *
             * This Column is provided with a `sum` and `avg` function. The default function is `sum`
             * which is used for the aggregation.
             * @config {Function|String}
             * @category Common
             */
            function : 'sum'
        };
    }

    construct(data, columnStore) {
        this.configuredAlign = 'align' in data;
        this.configuredEditor = 'editor' in data;

        super.construct(...arguments);

        const { grid } = columnStore;

        if (grid) {
            this.owner = grid;
            grid.on({
                paint   : 'onGridPaint',
                thisObj : this,
                prio    : 1000
            });
        }
    }

    onGridPaint({ source : grid }) {
        this.store = grid.store;
    }

    set store(store) {
        const
            me             = this,
            storeListeners = {
                update  : 'onRecordUpdate',
                thisObj : me,
                prio    : 1000
            },
            oldStore = me._store;

        if (store !== oldStore) {
            if (oldStore) {
                oldStore.un(storeListeners);
            }

            me._store = store;

            const
                { modelClass } = store,
                field = modelClass.fieldMap[me.field];

            // It's *likely*, but not certain that this will be used for a numeric field.
            // Use numeric defaults unless configured otherwise if so.
            if (field && field.type === 'number') {
                if (!me.configuredAlign) {
                    me.align = 'end';
                }
                if (!me.configuredEditor) {
                    me.editor = 'number';
                }
            }

            store.on(storeListeners);
        }
    }

    canEdit(record) {
        return record.isLeaf;
    }

    get store() {
        return this._store;
    }

    sum(...args) {
        let result = 0;

        for (let i = 0, { length } = args; i < length; i++) {
            result += parseInt(args[i], 10);
        }
        return result;
    }

    avg(...args) {
        let result = 0;
        const { length } = args;

        for (let i = 0; i < length; i++) {
            result += parseInt(args[i], 10);
        }
        return result / length;
    }

    onRecordUpdate({ record, changes }) {
        const
            me = this,
            { rowManager } = me.grid;

        if (me.field in changes) {
            if (record.isLeaf) {
                record.bubble(rec => {
                    const row = rowManager.getRowFor(rec);

                    if (row) {
                        const cell = row.getCell(me.field);

                        if (cell) {
                            row.renderCell(cell, rec);
                        }
                    }
                }, true);
            }
        }
    }

    getRawValue(record) {
        let value = 0;

        if (record.children) {
            const
                me       = this,
                fn       = me.function,
                isMathFn = typeof fn === 'string' && typeof Math[fn] === 'function',
                {
                    handler,
                    thisObj
                } = isMathFn ? {
                    handler : Math[fn],
                    thisObj : Math
                } : me.resolveCallback(fn);

            for (let i = 0, { length } = record.children; i < length; i++) {
                value = handler.call(thisObj, value, me.getRawValue(record.children[i]));
            }
            record.setData(me.field, value);
        }
        else {
            value = record[this.field];
        }
        return value;
    }
}

ColumnStore.registerColumnType(AggregateColumn, true);
AggregateColumn.exposeProperties();
AggregateColumn._$name = 'AggregateColumn';

//TODO: Currently widgets reuse elements already in cell, but performance would improve if entire widget was reused

/**
 * @module Grid/column/WidgetColumn
 */

/**
 * A column that displays widgets in the cells.
 *
 * There is no `editor` provided. It is the configured widget's responsibility to provide editing if needed.
 *
 * @extends Grid/column/Column
 *
 * @example
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *         { type: 'widget', text: 'Increase age', widget: { type: 'button', icon: 'add' }, data: 'age' }
 *     ]
 * });
 *
 * @classType widget
 * @externalexample column/WidgetColumn.js
 */
class WidgetColumn extends Column {

    //region Config

    static get type() {
        return 'widget';
    }

    static get fields() {
        return [
            /**
             * An array of widget config objects
             * @config {Object[]} widgets
             * @category Common
             */
            'widgets'
        ];
    }

    static get defaults() {
        return {
            filterable : false,
            sortable   : false,
            editor     : false,
            searchable : false
        };
    }

    //endregion

    //region Init / Destroy

    construct(config, store) {
        this.widgetMap = {};
        this.internalCellCls = 'b-widget-cell';

        super.construct(...arguments);
    }

    doDestroy() {
        // Destroy all the widgets we created.
        for (const widget of Object.values(this.widgetMap)) {
            widget.destroy && widget.destroy();
        }
        super.doDestroy();
    }

    //endregion

    //region Render

    /**
     * Renderer that displays a widget in the cell.
     * @param {Object} event Render event
     * @private
     */
    renderer(event) {
        const
            me = this,
            { cellElement, column, value, record, isExport } = event,
            widgets = column.widgets;

        // This renderer might be called from subclasses by accident
        // This condition saves us from investigating bug reports
        if (!isExport && widgets) {
            // If there is no widgets yet and we're going to add them,
            // need to make sure there is no content left in the cell after its previous usage
            // by grid features such as grouping feature or so.
            if (!cellElement.widgets) {
                // Reset cell content
                me.clearCell(cellElement);
            }
            cellElement.widgets = widgets.map((widgetCfg, i) => {
                let widget, widgetNextSibling;

                // If cell element already has widgets, check if we need to destroy/remove one
                if (cellElement.widgets) {
                    // Current widget
                    widget = cellElement.widgets[i];

                    // Store next element sibling to insert widget to correct position later
                    widgetNextSibling = widget.element.nextElementSibling;

                    // If we are not syncing content for present widget, remove it from cell and render again later
                    if (widgetCfg.recreate && widget) {
                        // destroy widget and remove reference to it
                        delete me.widgetMap[widget.id];
                        widget.destroy();
                        cellElement.widgets[i] = null;
                    }
                }

                // Ensure widget is created if first time through
                if (!widget) {
                    me.onBeforeWidgetCreate(widgetCfg, event);
                    widget = WidgetHelper.append(widgetCfg, widgetNextSibling ? { insertBefore : widgetNextSibling } : cellElement)[0];
                    me.widgetMap[widget.id] = widget;
                    me.onAfterWidgetCreate(widget, event);
                }

                widget.cellInfo = {
                    cellElement,
                    value,
                    record,
                    column
                };

                if (me.grid) {
                    widget.readOnly = me.grid.readOnly;
                }

                if (me.onBeforeWidgetSetValue(widget, event) !== false) {
                    if (!widgetCfg.noValueOnRender) {
                        if (widgetCfg.valueProperty) {
                            widget[widgetCfg.valueProperty] = value;
                        }
                        else if (widget.defaultBindProperty) {
                            widget[widget.defaultBindProperty] = value;
                        }
                        else {
                            widget.text = widget.value = value;
                        }
                    }
                }

                me.onAfterWidgetSetValue(widget, event);

                return widget;
            });
        }

        if (isExport) {
            return null;
        }
    }

    //endregion

    //region Other

    /**
     * Called before widget is created on rendering
     * @param {Object} widgetCfg Widget config
     * @param {Object} event Render event
     * @private
     */
    onBeforeWidgetCreate(widgetCfg, event) {}

    /**
     * Called after widget is created on rendering
     * @param {Core.widget.Widget} widget Created widget
     * @param {Object} event Render event
     * @private
     */
    onAfterWidgetCreate(widget, event) {}

    /**
     * Called before widget gets value on rendering. Pass `false` to skip value setting while rendering
     * @param {Core.widget.Widget} widget Created widget
     * @param {Object} event Render event
     * @private
     */
    onBeforeWidgetSetValue(widget, renderEvent) {}

    /**
     * Called after widget gets value on rendering.
     * @param {Core.widget.Widget} widget Created widget
     * @param {Object} event Render event
     * @private
     */
    onAfterWidgetSetValue(widget, renderEvent) {}

    // Overrides base implementation to cleanup widgets, for example when a cell is reused as part of group header
    clearCell(cellElement) {
        if (cellElement.widgets) {
            cellElement.widgets.forEach(widget => {
                // Destroy widget and remove reference to it
                delete this.widgetMap[widget.id];
                widget.destroy();
            });
            cellElement.widgets = null;
        }

        // Even if there is no widgets need to make sure there is no content left, for example after a cell has been reused as part of group header
        super.clearCell(cellElement);
    }

    // Null implementation because there is no way of ascertaining whether the widgets get their width from
    // the column, or the column shrinkwraps the Widget.
    // Remember that the widget could have a width from a CSS rule which we cannot read.
    // It might have width: 100%, or a flex which would mean it is sized by us, but we cannot read that -
    // getComputedStyle would return the numeric width.
    resizeToFitContent() {
    }
    //endregion
}

ColumnStore.registerColumnType(WidgetColumn);
WidgetColumn.exposeProperties();
WidgetColumn._$name = 'WidgetColumn';

//TODO: Reuse checkbox instead of creating a new one

/**
 * @module Grid/column/CheckColumn
 */

/**
 * A column that displays a checkbox in the cell. The value of the backing field is toggled by the checkbox.
 *
 * This column uses a {@link Core.widget.Checkbox checkbox} as its editor, and it is not intended to be changed.
 *
 * @extends Grid/column/WidgetColumn
 *
 * @example
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *         { type: 'check', field: 'allow' }
 *     ]
 * });
 *
 * @classType check
 * @externalexample column/CheckColumn.js
 */
class CheckColumn extends WidgetColumn {
    //region Config

    static get type() {
        return 'check';
    }

    static get fields() {
        return ['checkCls', 'showCheckAll'];
    }

    static get defaults() {
        return {
            align : 'center',

            /**
             * CSS class name to add to checkbox
             * @config {String}
             * @category Rendering
             */
            checkCls : null,

            /**
             * True to show a checkbox in the column header to be able to select/deselect all rows
             * @config {Boolean}
             */
            showCheckAll : false,

            widgets : [{
                type          : 'checkbox',
                valueProperty : 'checked'
            }]
        };
    }

    constructor(config, store) {
        super(...arguments);

        this.internalCellCls = 'b-check-cell';

        if (this.grid) {
            this.grid.on('destroy', () => this.headerCheckbox && this.headerCheckbox.destroy());
        }
    }

    headerRenderer({ headerElement, column }) {
        const me = this;

        headerElement.classList.add('b-check-header');

        if (column.showCheckAll) {
            headerElement.classList.add('b-check-header-with-checkbox');

            if (column.headerCheckbox) {
                column.headerCheckbox.destroy();
            }

            column.headerCheckbox = new Checkbox({
                appendTo  : headerElement,
                owner     : me.grid,
                listeners : {
                    change  : ({ checked }) => {
                        /**
                         * Fired when the header checkbox is clicked to toggle its checked status.
                         * @event toggleAll
                         * @param {Grid.column.Column} source This Column
                         * @param {Boolean} checked The checked status of the header checkbox.
                         */
                        column.trigger('toggleAll', { checked });
                    }
                }
            });
        }
        else {
            return column.text;
        }
    }

    //endregion

    renderer({ value, isExport }) {
        if (isExport) {
            return value == null ? '' : value;
        }
        else {
            super.renderer(...arguments);
        }
    }

    //region Widget rendering

    onBeforeWidgetCreate(widgetCfg, event) {
        widgetCfg.cls = this.checkCls;
    }

    onAfterWidgetCreate(widget, event) {
        event.cellElement.widget = widget;

        widget.on({
            beforeChange : 'onBeforeCheckboxChange',
            change       : 'onCheckboxChange',
            thisObj      : this
        });
    }

    onBeforeWidgetSetValue(widget) {
        widget.record     = widget.cellInfo.record;
        this.isInitialSet = true;
    }

    onAfterWidgetSetValue(widget) {
        this.isInitialSet = false;
    }

    //endregion

    //region Events

    onBeforeCheckboxChange({ source, checked }) {
        if (!this.isInitialSet) {
            /**
             * Fired when a cell is clicked to toggle its checked status. Returning `false` will prevent status change.
             * @event beforeToggle
             * @param {Grid.column.Column} source This Column
             * @param {Core.data.Model} record The record for the row containing the cell.
             * @param {Boolean} checked The new checked status of the cell.
             */
            return this.trigger('beforeToggle', { record : source.cellInfo.record, checked });
        }
    }

    onCheckboxChange({ source, checked }) {
        if (!this.isInitialSet) {
            const
                record = source.cellInfo.record,
                field  = this.field;

            if (field) {
                const setterName = `set${StringHelper.capitalizeFirstLetter(field)}`;
                if (record[setterName]) {
                    record[setterName](checked);
                }
                else {
                    record.set(field, checked);
                }
            }

            /**
             * Fired when a cell is clicked to toggle its checked status.
             * @event toggle
             * @param {Grid.column.Column} source This Column
             * @param {Core.data.Model} record The record for the row containing the cell.
             * @param {Boolean} checked The new checked status of the cell.
             */
            this.trigger('toggle', { record, checked });
        }
    }

    //endregion
}

ColumnStore.registerColumnType(CheckColumn, true);
CheckColumn._$name = 'CheckColumn';

/**
 * @module Grid/column/DateColumn
 */

/**
 * A column that displays a date in the specified format (see {@link Core.helper.DateHelper#function-format-static} for
 * formatting options).
 *
 * Default editor is a {@link Core.widget.DateField DateField}.
 *
 * If no `format` is specified, {@link Core.helper.DateHelper#property-defaultFormat-static DateHelper.defaultFormat} is
 * used. Please note that by default the `L` format is used.
 *
 * @extends Grid/column/Column
 *
 * @example
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *          { type: 'date', text: 'Start date', format: 'YYYY-MM-DD', data: 'start' }
 *     ]
 * });
 *
 * @classType date
 * @externalexample column/DateColumn.js
 */
class DateColumn extends Column {

    //region Config

    static get type() {
        return 'date';
    }

    // Type to use when auto adding field
    static get fieldType() {
        return 'date';
    }

    static get fields() {
        return ['format', 'pickerFormat', 'step'];
    }

    static get defaults() {
        return {
            /**
             * Date format
             * @config {String}
             * @category Common
             */
            format : 'L',

            /**
             * Time increment duration value. See {@link Core.widget.DateField#config-step} for more information
             * @config {String|Number|Object}
             * @category Common
             */
            step : 1,

            minWidth : 85,

            filterType : 'date'
        };
    }

    //endregion

    //region Init

    constructor(config, store) {
        super(...arguments);

        this.internalCellCls = 'b-date-cell';
    }

    //endregion

    //region Display

    /**
     * Renderer that displays the date with the specified format. Also adds cls 'date-cell' to the cell.
     * @private
     */
    defaultRenderer({ value }) {
        return value ? this.formatValue(value) : '';
    }

    /**
     * Group renderer that displays the date with the specified format.
     * @private
     */
    groupRenderer({ cellElement, groupRowFor }) {
        cellElement.innerHTML = this.formatValue(groupRowFor);
    }

    //endregion

    //region Formatter

    /**
     * Used by both renderer and groupRenderer to do the actual formatting of the date
     * @private
     * @param value
     * @returns {String}
     */
    formatValue(value) {
        // Ideally we should be served a date, but if not make it easier for the user by parsing
        if (typeof value === 'string') {
            value = DateHelper.parse(value, this.format || undefined); // null does not use default format
        }
        return DateHelper.format(value, this.format || undefined);
    }

    //endregion

    //region Getters/setters

    /**
     * Get/Set format for date displayed in cell and editor (see {@link Core.helper.DateHelper#function-format-static} for formatting options)
     * @property {String}
     */
    set format(value) {
        const me = this,
            editor = me.editor;
        me.set('format', value);
        if (editor) {
            editor.format = me.format;
        }
    }

    get format() {
        return this.get('format');
    }

    get defaultEditor() {
        const me = this;

        return {
            name                 : me.field,
            type                 : 'date',
            calendarContainerCls : 'b-grid-cell-editor-related',
            format               : me.format,
            step                 : me.step
        };
    }

    //endregion

}

ColumnStore.registerColumnType(DateColumn, true);
DateColumn.exposeProperties();
DateColumn._$name = 'DateColumn';

/**
 * @module Grid/column/PercentColumn
 */

/**
 * A column that display a basic progress bar.
 *
 * Default editor is a {@link Core.widget.NumberField NumberField}.
 *
 * @extends Grid/column/Column
 *
 * @example
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *         { type: 'percent', text: 'Progress', data: 'progress' }
 *     ]
 * });
 *
 * @classType percent
 * @externalexample column/PercentColumn.js
 */
class PercentColumn extends Column {
    static get type() {
        return 'percent';
    }

    // Type to use when auto adding field
    static get fieldType() {
        return 'number';
    }

    static get fields() {
        return ['lowThreshold'];
    }

    static get defaults() {
        return {
            /**
             * PercentColumn uses a {@link Core.widget.NumberField} configured with an allowed interval 0 - 100 as
             * its default editor.
             * @config {Object|String}
             * @default Core.widget.NumberField
             * @category Misc
             */
            editor : {
                type : 'number',
                min  : 0,
                max  : 100
            },

            /**
             * When below this percentage the bar will have `b-low` CSS class added. By default it turns the bar red.
             * @config {Number}
             * @category Rendering
             */
            lowThreshold : 20,

            filterType      : 'number',
            htmlEncode      : false,
            searchable      : false,
            summaryRenderer : sum => `${sum}%`
        };
    }

    constructor(config, store) {
        super(...arguments);

        this.internalCellCls = 'b-percent-bar-cell';
    }

    /**
     * Renderer that displays a progress bar in the cell.
     * @private
     */
    renderer({ value }) {
        value = value || 0;

        return {
            className : 'b-percent-bar-outer',
            children  : [
                {
                    tag       : 'div',
                    className : {
                        'b-percent-bar' : 1,
                        'b-zero'        : value === 0,
                        'b-low'         : value < this.lowThreshold
                    },
                    style : {
                        width : value + '%'
                    },
                    html : value + '%'
                }
            ]
        };
    }

    // Overrides base implementation to cleanup the checkbox, for example when a cell is reused as part of group header
    clearCell(cellElement) {
        if (cellElement.percentBarElement) {
            cellElement.percentBarElement = null;
        }
        super.clearCell(cellElement);
    }

    // Null implementation because the column width drives the width of its content.
    // So the concept of sizing to content is invalid here.
    resizeToFitContent() {}
}

PercentColumn.sum = 'average';

ColumnStore.registerColumnType(PercentColumn, true);
PercentColumn._$name = 'PercentColumn';

/**
 * @module Grid/column/NumberColumn
 */

/**
 * A column for showing/editing numbers.
 *
 * Default editor is a {@link Core.widget.NumberField NumberField}.
 *
 * @extends Grid/column/Column
 * @example
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *         { type: 'number', min: 0, max : 100, field: 'score' }
 *     ]
 * });
 *
 * @classType number
 * @externalexample column/NumberColumn.js
 */
class NumberColumn extends Column {
    //region Config

    static get type() {
        return 'number';
    }

    // Type to use when auto adding field
    static get fieldType() {
        return 'number';
    }

    static get fields() {
        return [
            /**
             * The minimum value for the field used during editing.
             * @config {Number} min
             * @category Common
             */
            'min',

            /**
             * The maximum value for the field used during editing.
             * @config {Number} max
             * @category Common
             */
            'max',

            /**
             * Step size for the field used during editing. Specify a fractional step size to allow entering decimal
             * numbers.
             * @config {Number} step
             * @category Common
             */
            'step',

            /**
             * Unit to append to displayed value.
             * @config {String} unit
             * @category Common
             */
            'unit'
        ];
    }

    static get defaults() {
        return {
            filterType : 'number'
        };
    }

    constructor(config, store) {
        super(...arguments);

        this.internalCellCls = 'b-number-cell';
    }

    //endregion

    //region Init

    get defaultEditor() {
        return {
            name : this.field,
            type : 'numberfield',
            max  : this.max,
            min  : this.min,
            step : this.step
        };
    }

    /**
     * Renderer that displays value + optional unit in the cell
     * @private
     */
    defaultRenderer({ value = 0 }) {
        if (this.unit) {
            return `${value}${this.unit}`;
        }

        return value;
    }
}

ColumnStore.registerColumnType(NumberColumn, true);
NumberColumn.exposeProperties();
NumberColumn._$name = 'NumberColumn';

// TODO: resuse icon elements

/**
 * @module Grid/column/RatingColumn
 */

/**
 * A column that displays a star rating. Click a start to set a value, shift+click to unset a single start from the end.
 * Clicking the first and only star toggles it.
 *
 * This column uses a custom widget as its editor, and it is not intended to be changed.
 *
 * @extends Grid/column/NumberColumn
 *
 * @example
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *         { type: 'rating', max : 10, field: 'rating' }
 *     ]
 * });
 *
 * @classType percent
 * @externalexample column/RatingColumn.js
 */
class RatingColumn extends NumberColumn {
    static get type() {
        return 'rating';
    }

    // Type to use when auto adding field
    static get fieldType() {
        return 'number';
    }

    static get fields() {
        return ['emptyIcon', 'filledIcon', 'editable'];
    }

    static get defaults() {
        return {
            min : 0,
            max : 5,

            /**
             * The empty rating icon to show
             * @config {String}
             * @category Rendering
             */
            emptyIcon : 'b-icon b-icon-star',

            /**
             * The filled rating icon to show
             * @config {String}
             * @category Rendering
             */
            filledIcon : 'b-icon b-icon-star',

            /**
             * Allow user to click an icon to change the value
             * @config {Boolean}
             * @category Interaction
             */
            editable : true,

            filterType   : 'number',
            searchable   : false,
            width        : '11.2em',
            htmlEncode   : false,
            autoSyncHtml : true,
            minWidth     : '11.2em',
            editor       : false
        };
    }

    constructor(config, store) {
        super(...arguments);

        this.internalCellCls = 'b-rating-cell';
    }

    /**
     * Renderer that displays a number of stars in the cell. Also adds CSS class 'b-rating-cell' to the cell.
     * @private
     */
    renderer({ value }) {
        let html = `<div class="b-rating-cell-inner ${!this.editable ? 'b-not-editable' : ''}">`;

        for (let i = 0; i < this.max; i++) {
            let filled = i < value;
            html += `<i class="b-rating-icon ${filled ? 'b-filled ' + this.filledIcon : 'b-empty ' + this.emptyIcon}"></i>`;
        }

        html += '</div>';

        return html;
    }

    onCellClick({ grid, column, record, cellSelector, target, event }) {
        if (target.classList.contains('b-rating-icon') && !grid.readOnly && column.editable) {
            let starIndex = [].indexOf.call(target.parentNode.childNodes, target);

            if (target.classList.contains('b-filled') && (event.metaKey || event.shiftKey)) {
                starIndex = starIndex - 1;
            }

            // Clicking first star when it is only one removes it
            if (record.get(column.field) === 1 && starIndex === 0) {
                starIndex = -1;
            }

            record.set(column.field, starIndex + 1);
        }
    }
}

ColumnStore.registerColumnType(RatingColumn, true);
RatingColumn.exposeProperties();
RatingColumn._$name = 'RatingColumn';

/**
 * @module Grid/column/RowNumberColumn
 */

/**
 * A column that displays the row number in each cell.
 *
 * There is no `editor`, since value is read-only.
 *
 * @extends Grid/column/Column
 *
 * @example
 * let grid = new Grid({
    appendTo : targetElement,
    width    : 300,
    columns  : [
        { type : 'rownumber' }
    ]
});
 *
 * @classType rownumber
 * @externalexample column/RowNumberColumn.js
 */
class RowNumberColumn extends Column {
    static get defaults() {
        return {
            groupable  : false,
            sortable   : false,
            filterable : false,
            searchable : false,
            resizable  : false,
            minWidth   : 50,
            width      : 50,
            align      : 'right',
            text       : '#',
            editor     : false
        };
    }

    construct(config, store) {
        const me = this;

        super.construct(...arguments);

        // Update our width when the store mutates (tests test Columns in isolation with no grid, so we must handle that!)
        if (me.grid) {
            me.grid.store.on({
                change  : me.resizeToFitContent,
                thisObj : me
            });
            if (me.grid.store.count) {
                me.grid.on({
                    render  : me.resizeToFitContent,
                    thisObj : me,
                    once    : true
                });
            }
        }
        me.internalCellCls = 'b-row-number-cell';
    }

    static get type() {
        return 'rownumber';
    }

    /**
     * Renderer that displays the row number in the cell.
     * @private
     */
    renderer({ record, grid }) {
        return record.meta.specialRow ? '' : grid.store.indexOf(record, true) + 1;
    }

    /**
     * Resizes the column to match the widest string in it. Called when you double click the edge between column
     * headers
     */
    resizeToFitContent() {
        const grid  = this.grid,
            store = grid.store,
            count = store.count;

        if (count && !this.hidden) {
            const cellElement = grid.element.querySelector(`.b-grid-cell[data-column-id=${this.id}]`);

            // cellElement might not exist, e.g. when trial is expired
            if (cellElement) {
                const cellStyle = window.getComputedStyle(cellElement),
                    cellPadding = parseInt(cellStyle['padding-left']),
                    maxWidth    = DomHelper.measureText(count, cellElement);

                this.width = maxWidth + 2 * cellPadding;
            }
        }
    }

    set flex(f) {
        
    }
}

ColumnStore.registerColumnType(RowNumberColumn, true);
RowNumberColumn._$name = 'RowNumberColumn';

/**
 * @module Grid/column/TemplateColumn
 */

/**
 * A column that uses a template for cell content. Any function can be used as template, and the function is passed { value, record, field } properties.
 * It should return a string which will be rendered in the cell.
 *
 * Default editor is a {@link Core.widget.TextField TextField}.
 *
 * @extends Grid/column/Column
 *
 * @example
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *         { type: 'template', field: 'age', template: value => `${value} years old` }
 *     ]
 * });
 *
 * @classType template
 * @externalexample column/TemplateColumn.js
 */
class TemplateColumn extends Column {
    static get fields() {
        return [
            /**
             * Template function used to generate a value displayed in the cell. Called with arguments { value, record, field }
             * @config {Function} template
             * @category Common
             */
            'template'
        ];
    }

    static get defaults() {
        return {
            htmlEncode : false
        };
    }

    constructor(config, store) {
        super(...arguments);

        const me = this;

        if (!me.template) throw new Error(me.L('noTemplate'));
        if (typeof me.template !== 'function') throw new Error(me.L('noFunction'));
    }

    static get type() {
        return 'template';
    }

    /**
     * Renderer that uses a template for cell content.
     * @private
     */
    renderer(renderData) {
        // If it's a special row, such as a group row, we can't use the user's template
        if (!renderData.record.meta.specialRow) {
            return this.template({
                value  : renderData.value,
                record : renderData.record,
                field  : renderData.column.field
            });
        }
    }
}

ColumnStore.registerColumnType(TemplateColumn, true);
TemplateColumn.exposeProperties();
TemplateColumn._$name = 'TemplateColumn';

/**
 * @module Grid/column/TimeColumn
 */

/**
 * A column that displays a time in the specified format (see {@link Core.helper.DateHelper#function-format-static} for formatting options).
 *
 * Default editor is a {@link Core.widget.TimeField TimeField}.
 *
 * @extends Grid/column/Column
 *
 * @example
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *          { type: 'time', text: 'Start time', format: 'HH:mm:ss', data: 'start' }
 *     ]
 * });
 *
 * @classType time
 * @externalexample column/TimeColumn.js
 */
class TimeColumn extends Column {

    //region Config

    static get type() {
        return 'time';
    }

    // Type to use when auto adding field
    static get fieldType() {
        return 'date';
    }

    static get fields() {
        return ['format'];
    }

    static get defaults() {
        return {
            /**
             * Time format
             * @config {String}
             * @category Common
             */
            format : 'LT',

            minWidth : 140,

            filterType : 'time'
        };
    }

    //endregion

    //region Init

    constructor(config, store) {
        super(...arguments);

        this.internalCellCls = 'b-time-cell';
    }

    //endregion

    //region Display

    /**
     * Renderer that displays the time with the specified format. Also adds cls 'b-time-cell' to the cell.
     * @private
     */
    defaultRenderer({ value }) {
        return value ? this.formatValue(value) : '';
    }

    /**
     * Group renderer that displays the time with the specified format.
     * @private
     */
    groupRenderer({ cellElement, groupRowFor }) {
        cellElement.innerHTML = this.formatValue(groupRowFor);
    }

    //endregion

    //region Formatter

    /**
     * Used by both renderer and groupRenderer to do the actual formatting of the time
     * @private
     * @param value
     * @returns {String}
     */
    formatValue(value) {
        const me = this;
        // Ideally we should be served a time, but if not make it easier for the user by parsing
        if (typeof value === 'string') {
            value = DateHelper.parse(value, me.format);
        }
        return DateHelper.format(value, me.format);
    }

    //endregion

    //region Getters/Setters
    /**
     * Get/Set format for time displayed in cell and editor (see {@link Core.helper.DateHelper#function-format-static} for formatting options)
     * @property {String}
     */
    set format(value) {
        const me = this,
            editor = me.editor;
        me.set('format', value);
        if (editor) {
            editor.format = me.format;
        }
    }

    get format() {
        return  this.get('format');
    }

    get defaultEditor() {
        return {
            name   : this.field,
            type   : 'time',
            format : this.format
        };
    }

    //endregion
}

ColumnStore.registerColumnType(TimeColumn, true);
TimeColumn.exposeProperties();
TimeColumn._$name = 'TimeColumn';

/**
 * @module Grid/column/TreeColumn
 */

let currentParentHasIcon = false;

/**
 * A column that displays a tree structure when using the {@link Grid.feature.Tree tree} feature.
 *
 * Default editor is a {@link Core.widget.TextField TextField}.
 *
 * When the TreeColumn renders its cells, it will look for two special fields {@link Grid.data.GridRowModel#field-href}
 * and {@link Grid.data.GridRowModel#field-target}. Specifying `href` will produce a link for the TreeNode,
 * and `target` will have the same meaning as in an A tag:
 *
 * ```javascript
 * {
 *    id        : 1,
 *    name      : 'Some external link'
 *    href      : '//www.website.com",
 *    target    : '_blank"
 * }
 * ```
 *
 * @example
 * new TreeGrid({
 *     appendTo : document.body,
 *
 *     columns : [
 *          { type: 'tree', field: 'name' }
 *     ]
 * });
 *
 * @classType tree
 * @extends Grid/column/Column
 * @externalexample column/TreeColumn.js
 */
class TreeColumn extends Column {
    static get defaults() {
        return {
            tree     : true,
            hideable : false,
            minWidth : 150
        };
    }

    static get fields() {
        return [
            /**
             * The icon to use for the collapse icon in collapsed state
             * @config {String} expandIconCls
             */
            { name : 'expandIconCls', defaultValue : 'b-icon b-icon-tree-expand' },

            /**
             * The icon to use for the collapse icon in expanded state
             * @config {String} collapseIconCls
             */
            { name : 'collapseIconCls', defaultValue : 'b-icon b-icon-tree-collapse' },

            /**
             * The icon to use for the collapse icon in expanded state
             * @config {String} collapsedFolderIconCls
             */
            //{ name : 'collapsedFolderIconCls', defaultValue : 'b-icon b-icon-tree-folder' },
            { name : 'collapsedFolderIconCls' },

            /**
             * The icon to use for the collapse icon in expanded state
             * @config {String} expandedFolderIconCls
             */
            //{ name : 'expandedFolderIconCls', defaultValue : 'b-icon b-icon-tree-folder-open' },
            { name : 'expandedFolderIconCls' },

            /**
             * The icon to use for the leaf nodes in the tree
             * @config {String} leafIconCls
             */
            { name : 'leafIconCls', defaultValue : 'b-icon b-icon-tree-leaf' },

            { name : 'editTargetSelector', defaultValue : '.b-tree-cell-value' }
        ];
    }

    static get type() {
        return 'tree';
    }

    constructor(config, store) {
        super(...arguments);

        const me = this;

        me.internalCellCls = 'b-tree-cell';

        // We handle htmlEncoding in this class rather than relying on the generic Row DOM manipulation
        // since this class requires quite a lot of DOM infrastructure around the actual rendered content
        me.shouldHtmlEncode = me.htmlEncode;
        me.tempDiv = document.createElement('div');
        me.setData('htmlEncode', false);

        // add tree renderer (which calls original renderer internally)
        if (me.renderer) {
            me.originalRenderer = me.renderer;
        }
        me.renderer = me.treeRenderer.bind(me);
    }

    /**
     * A column renderer that is automatically added to the column with { tree: true }. It adds padding and node icons
     * to the cell to make the grid appear to be a tree. The original renderer is called in the process.
     * @private
     */
    treeRenderer(renderData) {
        const
            me                                     = this,
            { cellElement, row, record, isExport } = renderData,
            gridMeta                               = record.instanceMeta(renderData.grid.store),
            tag                                    = record.href ? 'a' : 'div';

        let value = renderData.value,
            html  = '',
            cls   = '',
            iconCls, result;

        if (me.originalRenderer) {
            const rendererHtml = me.originalRenderer(renderData);
            value = rendererHtml === false ? cellElement.innerHTML : rendererHtml;
        }

        if (!isExport) {
            if (!record.isLeaf) {
                row.addCls && row.addCls('b-tree-parent-row');
                cellElement.classList.add('b-tree-parent-cell');

                // Spinner while loading children, added to row in Tree#toggleCollapse but needs to be readded if row is
                // rerendered during load
                if (gridMeta.isLoadingChildren) {
                    row.addCls('b-loading-children');
                }

                // TODO remove IE 11 is no longer supported (doesnt support this)
                //cellElement.classList.toggle('b-tree-collapsed', record.meta.collapsed === true);

                html += `<div class="b-tree-expander ${gridMeta.collapsed ? (me.expandIconCls + ' b-tree-collapsed') : (me.collapseIconCls + ' b-tree-expanded')}"></div>`;

                // Allow user to customize tree icon or opt out entirely
                currentParentHasIcon = iconCls = renderData.iconCls || record.iconCls || (gridMeta.collapsed ? me.collapsedFolderIconCls : me.expandedFolderIconCls);
                if (iconCls) {
                    html += `<div class="b-tree-icon ${iconCls}"></div>`;
                }
            }
            else {
                // TODO: Cleanup for reusing dom nodes should be done elsewhere, also cleanup selection
                cellElement.classList.add('b-tree-leaf-cell');

                // Allow user to customize tree icon or opt out entirely
                iconCls = renderData.iconCls || record.iconCls || me.leafIconCls;
                if (iconCls) {
                    cls += iconCls;
                }
            }

            value = value != null ? value : '';

            if (me.shouldHtmlEncode) {
                me.tempDiv.innerText = value;
                value = me.tempDiv.innerHTML;
            }

            html += `<div class="b-tree-cell-value">${value}</div>`;

            // TODO: make size configurable
            const padding = (record.childLevel * 1.7 + (record.isLeaf ? currentParentHasIcon ? 1.8 : iconCls ? 0.4 : 0.3 : 0));

            result = `<${tag} ${record.href ? `href="${record.href}"` : ''} ${tag === 'a' && record.target ? `target="${record.target}"` : ''} class="b-tree-cell-inner ${cls}" style="padding-left:${padding}em">${html}</${tag}>`;
        }
        else {
            result = value != null ? value : '';
        }

        return result;
    }
}

ColumnStore.registerColumnType(TreeColumn, true);
TreeColumn.exposeProperties();
TreeColumn._$name = 'TreeColumn';

/**
 * @module Grid/data/GridRowModel
 */

/**
 * Model extended with some fields related to grid rendering. Used as default model type in the grids store if nothing
 * else is specified.
 *
 * Using this model is optional. If you use a custom model instead and need the functionality of any of the fields
 * below, you just have to remember to add fields with the same name to your model.
 *
 * @extends Core/data/Model
 */
class GridRowModel extends Model {
    static get fields() {
        return [
            /**
             * Icon for row (used automatically in tree, feel free to use it in renderer in other cases)
             * @field {String} iconCls
             */
            'iconCls',

            /**
             * Start expanded or not (only valid for tree data)
             * @field {Boolean} expanded
             */
            'expanded',

            /**
             * CSS class (or several classes divided by space) to append to row elements
             * @field {String} cls
             */
            'cls',

            /**
             * Row height, set it to use another height then the default for a row
             * @field {Number} rowHeight
             */
            'rowHeight',

            /**
             * A link to use for this record when rendered into a {@link Grid.column.TreeColumn}.
             * @field {String} href
             */
            'href',

            /**
             * The target to use if this tree node provides a value for the {@link #field-href} field.
             * @field {String} target
             */
            'target'
        ];
    }
}

GridRowModel.exposeProperties();
GridRowModel._$name = 'GridRowModel';

/**
 * @module Grid/feature/GridFeatureManager
 */

const
    consumerToFeatureMap        = new Map(),
    consumerToDefaultFeatureMap = new Map(),
    DEFAULT_FOR_TYPE            = 'Grid',
    remapToBase                 = {
        'Grid'      : 'GridBase',
        'Scheduler' : 'SchedulerBase',
        'Gantt'     : 'GanttBase'
    },
    classNameFix = /\$\d+$/;

/**
 * Static class intended to register and query grid features
 *
 * @class
 */
class GridFeatureManager {
    /**
     * Register a feature class with the Grid. Enables it to be created and configured using config Grid#features.
     * @param {Core.mixin.InstancePlugin} featureClass Feature to register
     * @param {Boolean} [onByDefault] Specify true to have the feature enabled per default
     * @param {String|String[]} [forType] Specify a type to let the class applying the feature to determine if it should use it
     */
    static registerFeature(featureClass, onByDefault = false, forType = null, as = null) {
        // Our built in features should all define $name to survive minification/obfuscation, but user defined features might not
        as = StringHelper.lowercaseFirstLetter(as || (featureClass.hasOwnProperty('$name') && featureClass.$name) || featureClass.name);

        // Remove webpack's disambiguation suffix.
        // For example ExcelExporter in Scheduler will be called ExcelExporter$1
        // It must be found as ExcelExporter in the Scheduler's feature Map, so correct the name.
        as = as.replace(classNameFix, '');

        if (!Array.isArray(forType)) {
            forType = [forType || DEFAULT_FOR_TYPE];
        }

        forType.forEach(forType => {
            const
                type                       = remapToBase[forType] || forType,
                consumerFeaturesMap        = consumerToFeatureMap.get(type) || new Map(),
                consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type) || new Map();

            consumerFeaturesMap.set(as, featureClass);
            consumerDefaultFeaturesMap.set(featureClass, onByDefault);

            consumerToFeatureMap.set(type, consumerFeaturesMap);
            consumerToDefaultFeatureMap.set(type, consumerDefaultFeaturesMap);
        });
    }

    /**
     * Get all the features registered for the given type name in an object where keys are feature names and values are feature constructors.
     *
     * @param {String} [forType]
     * @return {Object}
     */
    static getTypeNameFeatures(forType = DEFAULT_FOR_TYPE) {
        const
            type                = remapToBase[forType] || forType,
            consumerFeaturesMap = consumerToFeatureMap.get(type),
            features            = {};

        if (consumerFeaturesMap) {
            consumerFeaturesMap.forEach((featureClass, as) => features[as] = featureClass);
        }

        return features;
    }

    /**
     * Get all the default features registered for the given type name in an object where keys are feature names and values are feature constructors.
     *
     * @param {String} [forType]
     * @return {Object}
     */
    static getTypeNameDefaultFeatures(forType = DEFAULT_FOR_TYPE) {
        const
            type                       = remapToBase[forType] || forType,
            consumerFeaturesMap        = consumerToFeatureMap.get(type),
            consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type);

        let features = {};

        if (consumerFeaturesMap && consumerDefaultFeaturesMap) {
            consumerFeaturesMap.forEach((featureClass, as) => {
                if (consumerDefaultFeaturesMap.get(featureClass)) {
                    features[as] = featureClass;
                }
            });
        }

        return features;
    }

    /**
     * Gets all the features registered for the given instance type name chain. First builds the type name chain then quaries for features
     * for each type name and combines them into one object, see {@link #function-getTypeNameFeatures-static}() for returned object description.
     * If feature is registered for both parent and child type name then feature for child overrides feature for parent.
     *
     * @param {Object} instance
     * @return {Object}
     */
    static getInstanceFeatures(instance) {
        return instance.classNameHierarchy().reduce(
            (features, typeName) => Object.assign(features, this.getTypeNameFeatures(typeName)),
            {}
        );
    }

    /**
     * Gets all the *defualt* features registered for the given instance type name chain. First builds the type name chain then quaries for features
     * for each type name and combines them into one object, see {@link #function-getTypeNameFeatures-static}() for returned object description.
     * If feature is registered for both parent and child type name then feature for child overrides feature for parent.
     *
     * @param {Object} instance
     * @return {Object}
     */
    static getInstanceDefaultFeatures(instance) {
        return instance.classNameHierarchy().reduce(
            (features, typeName) => Object.entries(
                this.getTypeNameFeatures(typeName)
            ).reduce(
                (features, [as, featureClass]) => {
                    if (this.isDefaultFeatureForTypeName(featureClass, typeName)) {
                        features[as] = featureClass;
                    }
                    else {
                        delete features[as];
                    }
                    return features;
                },
                features
            ),
            {}
        );
    }

    /**
     * Checks if the given feature class is default for the type name
     *
     * @param {Core.mixin.InstancePlugin} featureClass Feature to check
     * @param {String} [forType]
     * @return {Boolean}
     */
    static isDefaultFeatureForTypeName(featureClass, forType = DEFAULT_FOR_TYPE) {
        const
            type                       = remapToBase[forType] || forType,
            consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type);
        return consumerDefaultFeaturesMap && consumerDefaultFeaturesMap.get(featureClass) || false;
    }

    /**
     * Checks if the given feature class is default for the given instance type name chain. If the feature is not default for the
     * parent type name but it is for the child type name, then the child setting overrides the parent one.
     *
     * @param {Core.mixin.InstancePlugin} featureClass Feature to check
     * @param {String} [forType]
     * @return {Boolean}
     */
    static isDefaultFeatureForInstance(featureClass, instance) {
        //const typeChain = ObjectHelper.getTypeNameChain(instance);
        const typeChain = instance.classNameHierarchy().reverse();

        let result = null;

        for (let i = 0, len = typeChain.length; i < len && result === null; ++i) {

            const consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(typeChain[i]);

            if (consumerDefaultFeaturesMap && consumerDefaultFeaturesMap.has(featureClass)) {
                result = consumerDefaultFeaturesMap.get(featureClass);
            }
        }

        return result || false;
    }

    /**
     * Resets feature registration date, used in tests to reset state after test
     *
     * @internal
     */
    static reset() {
        consumerToFeatureMap.clear();
        consumerToDefaultFeatureMap.clear();
    }
}
GridFeatureManager._$name = 'GridFeatureManager';

//TODO: Maybe some more way to stop editing in touch mode (in case grid fills entire page...)

const
    validNonEditingKeys = {
        Enter : 1,
        F2    : 1
    },
    validEditingKeys = {
        ArrowUp    : 1,
        ArrowDown  : 1,
        ArrowLeft  : 1,
        ArrowRight : 1
    };

/**
 * @module Grid/feature/CellEdit
 */

/**
 * Adding this feature to the grid enables cell editing. All subclasses of {@link Core.widget.Field Field} can be used
 * as editors for the {@link Grid.column.Column Column}. The most popular are:
 * - {@link Core.widget.TextField TextField};
 * - {@link Core.widget.NumberField NumberField};
 * - {@link Core.widget.DateField DateField};
 * - {@link Core.widget.TimeField TimeField};
 * - {@link Core.widget.Combo Combo};
 *
 * Usage instructions:
 * ### Start editing
 * * Double click on a cell
 * * Press [ENTER] or [F2] with a cell selected
 *
 * ### While editing
 * * [ENTER] Finish editing and start editing the same cell in next row
 * * [SHIFT] + [ENTER] Same as above put with previous row
 * * [F2] Finish editing
 * * [CMD/CTRL] + [ENTER] Finish editing
 * * [ESC] By default, first reverts the value back to its original value, next press cancels editing
 * * [TAB] Finish editing and start editing the next cell
 * * [SHIFT] + [TAB] Finish editing and start editing the previous cell
 *
 * Columns specify editor in their configuration. Editor can also by set by using a column type. Columns
 * may also contain these three configurations which affect how their cells are edited:
 * * {@link Grid.column.Column#config-invalidAction}
 * * {@link Grid.column.Column#config-revertOnEscape}
 * * {@link Grid.column.Column#config-finalizeCellEdit}
 *
 * ### Preventing editing of certain cells
 * You can prevent editing on a column by setting `editor` to false:
 *
 * ```javascript
 * new Grid({
 *    columns : [
 *       {
 *          type   : 'number',
 *          text   : 'Age',
 *          field  : 'age',
 *          editor : false
 *       }
 *    ]
 * ```
 * To prevent editing in a specific cell, listen to the {@link #event-beforeCellEditStart} and return false:
 *
 * ```javascript
 * grid.on('beforeCellEditStart', ({ editorContext }) => {
 *     return editorContext.column.field !== 'id';
 * });
 * ```
 *
 * To use an alternative input field to edit a cell, listen to the {@link #event-beforeCellEditStart} and
 * set the `editor` property of the context to the input field you want to use:
 *
 * ```javascript
 * grid.on('beforeCellEditStart', ({ editorContext }) => {
 *     return editorContext.editor = myDateField;
 * });
 * ```
 *
 * This feature is *enabled* by default.
 *
 * @example
 * { data: 'name', text: 'Name', editor: 'text' }
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @demo Grid/celledit
 * @classtype cellEdit
 * @externalexample feature/CellEdit.js
 */
class CellEdit extends Delayable(InstancePlugin) {
    //region Config

    static get $name() {
        return 'CellEdit';
    }

    // Default configuration
    static get defaultConfig() {
        return {
            /**
             * Set to true to select the field text when editing starts
             * @config {Boolean}
             * @default
             */
            autoSelect : true,

            /**
             * What action should be taken when focus moves leaves the cell editor, for example when clicking outside.
             * May be `'complete'` or `'cancel`'.
             * @config {String}
             * @default
             */
            blurAction : 'complete',

            /**
             * Set to true to have TAB on the last cell in the data set create a new record
             * and begin editing it at its first editable cell.
             *
             * If this is configured as an object, it is used as the default data value set for each new record.
             * @config {Boolean|Object}
             * @default
             */
            addNewAtEnd : null,

            /**
             * Set to true to start editing when user starts typing text on a focused cell (as in Excel)
             * @config {Boolean}
             * @default
             */
            autoEdit : false,

            /**
             * Class to use as an editor. Default value: {@link Core.widget.Editor}
             * @config {Core.widget.Widget}
             * @internal
             */
            editorClass : Editor
        };
    }

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            assign : ['startEditing'],
            before : ['onElementKeyDown', 'onElementMouseDown'],
            chain  : ['onElementClick']
        };
    }

    //endregion

    //region Init

    construct(grid, config) {
        const me = this;

        me.grid = grid;

        super.construct(grid, config);

        me.storeListenerDetacher = grid.store.on({
            update  : 'onStoreUpdate',
            thisObj : me
        });
        me.listenerDetacher = grid.on({
            cellclick        : 'onCellClick',
            celldblclick     : 'onCellDblClick',
            beforerenderrows : 'onGridBeforeRenderRows',
            thisObj          : me
        });
    }

    /**
     * Displays a YES/NO confirmation dialog box owned by the current Editor. This is intended to be
     * used by {@link Grid.column.Column#config-finalizeCellEdit} implementations. The returned promise resolves passing `true`
     * if the "yes" button is pressed, and `false` if the "No" button is pressed. Typing `ESC` rejects.
     * @param {Object} options An options object for what to show.
     * @param {String} [options.title] The title to show in the dialog header.
     * @param {String} [options.message] The message to show in the dialog body.
     * @async
     */
    async confirm(options) {
        let result = true;

        if (this.editorContext) {
            // The input field must not lose containment of focus during this confirmation
            // so temporarily make the MessageDialog a descendant widget.
            md.owner = this.editorContext.editor.inputField;
            result = await md.confirm(options);
            md.owner = null;
        }

        return result === md.yesButton;
    }

    doDestroy() {
        const me = this;

        me.cancelEditing(true);
        me.listenerDetacher();
        me.storeListenerDetacher();

        // To kill timeouts
        me.grid.columns.allRecords.forEach(column => {
            if (column._cellEditor) {
                column._cellEditor.destroy();
            }
        });

        super.doDestroy();
    }

    doDisable(disable) {
        if (disable) {
            this.cancelEditing(true);
        }

        super.doDisable(disable);
    }

    set disabled(disabled) {
        super.disabled = disabled;
    }

    get disabled() {
        const { grid } = this;

        return Boolean(super.disabled || grid.disabled || grid.readOnly);
    }

    //endregion

    //region Editing

    /**
     * Is any cell currently being edited?
     * @returns {Boolean}
     */
    get isEditing() {
        return Boolean(this.editorContext);
    }

    /**
     * Returns the record currently being edited, or `null`
     * @returns {Core.data.Model}
     */
    get activeRecord() {
        return this.editorContext && this.editorContext.record || null;
    }


    /**
     * Internal function to create or get existing editor for specified cell.
     * @private
     * @param cellContext Cell to get or create editor for
     * @returns {Core.widget.Editor} An Editor container which displays the input field.
     * @category Internal
     */
    getEditorForCell({ column, selector, editor }) {
        const
            me = this,
            grid = me.grid;

        // Reuse the Editor by caching it on the column.
        let cellEditor = column._cellEditor;

        editor.autoSelect = me.autoSelect;
        if (cellEditor) {
            // Already got the positioned Editor container which carries the input field.
            // just check if the actual field has been changed in a beforeCellEditStart handler.
            // If so, switch it out.
            if (cellEditor.inputField !== editor) {
                cellEditor.remove(cellEditor.items[0]);
                cellEditor.add(editor);
            }
        }
        else {
            cellEditor = column._cellEditor = new me.editorClass({
                cls           : 'b-cell-editor',
                inputField    : editor,
                blurAction    : 'none',
                invalidAction : column.invalidAction,
                completeKey   : false,
                cancelKey     : false,
                owner         : grid,
                listeners     : me.getEditorListeners()
            });
        }

        // Keep the record synced with the value
        if (column.instantUpdate && !editor.cellEditValueSetter) {
            ObjectHelper.wrapProperty(editor, 'value', null, v => {
                const { editorContext } = me;
                // Only tickle the record if the value has changed.
                if (editorContext && !ObjectHelper.isEqual(editorContext.record[editorContext.column.field], v)) {
                    editorContext.record[editorContext.column.field] = v;
                }
            });
            editor.cellEditValueSetter = true;
        }

        Object.assign(cellEditor.element.dataset, {
            rowId    : selector.id,
            columnId : selector.columnId,
            field    : column.field
        });

        // First ESC press reverts
        cellEditor.inputField.revertOnEscape = column.revertOnEscape;

        return me.editor = cellEditor;
    }

    // Turned into function to allow overriding in Gantt, and make more configurable in general
    getEditorListeners() {
        return {
            focusout       : 'onEditorFocusOut',
            focusin        : 'onEditorFocusIn',
            start          : 'onEditorStart',
            beforecomplete : 'onEditorBeforeComplete',
            complete       : 'onEditorComplete',
            cancel         : 'onEditorCancel',
            thisObj        : this
        };
    }

    onEditorStart({ source : editor }) {
        const me = this,
            editorContext = me.editorContext = editor.cellEditorContext;

        if (editorContext) {
            const { grid } = me,
                { cell, editor, column } = editorContext;

            // Match editorTarget size and position
            if (column.editTargetSelector) {
                const editorTarget = cell.querySelector(column.editTargetSelector);

                if (editorTarget) {
                    editor.width -= editorTarget.offsetLeft;
                    DomHelper.addTranslateX(editor.element, editorTarget.offsetLeft);
                }
            }

            cell.classList.add('b-editing');

            me.grid.on({
                cellclick      : 'onCellClickWhileEditing',
                viewportResize : 'onViewportResizeWhileEditing'
            }, me);

            // Handle tapping outside of the grid element. Use GlobalEvents
            // because it uses a capture:true listener before any other handlers
            // might stop propagation.
            // Cannot use delegate here. A tapped cell will match :not(#body-container)
            me.removeEditingListeners = GlobalEvents.addListener({
                globaltap : 'onTapOut',
                thisObj   : me
            });

            /**
             * Fires on the owning Grid when editing starts
             * @event startCellEdit
             * @param {Grid.view.Grid} grid **Deprecated** Use `source` instead
             * @param {Grid.view.Grid} source Owner grid
             * @param {Object} editorContext Editing context
             * @param {Core.widget.Editor} editorContext.editor The Editor being used.
             * Will contain an `inputField` property which is the field being used to perform the editing.
             * @param {Grid.column.Column} editorContext.column Target column
             * @param {Core.data.Model} editorContext.record Target record
             * @param {HTMLElement} editorContext.cell Target cell
             * @param {*} editorContext.value Cell value
             */
            grid.trigger('startCellEdit', { grid, editorContext });
        }
    }

    onEditorBeforeComplete(context) {
        const { grid } = this,
            editor = context.source,
            editorContext = editor.cellEditorContext;

        context.grid = grid;
        context.editorContext = editorContext;

        /**
         * Fires on the owning Grid before the cell editing is finished, return false to signal that the value is invalid and editing should not be finalized.
         * @event beforeFinishCellEdit
         * @param {Grid.view.Grid} grid Target grid
         * @param {Object} editorContext Editing context
         * @param {Core.widget.Editor} editorContext.editor The Editor being used.
         * Will contain an `inputField` property which is the field being used to perform the editing.
         * @param {Grid.column.Column} editorContext.column Target column
         * @param {Core.data.Model} editorContext.record Target record
         * @param {HTMLElement} editorContext.cell Target cell
         * @param {*} editorContext.value Cell value
         */
        return grid.trigger('beforeFinishCellEdit', context);
    }

    onEditorComplete({ source : editor }) {
        const { grid } = this,
            editorContext = editor.cellEditorContext;

        // Ensure the docs below are accurate!
        editorContext.value = editor.inputField.value;

        /**
         * Fires on the owning Grid when cell editing is finished
         * @event finishCellEdit
         * @param {Grid.view.Grid} grid Target grid
         * @param {Object} editorContext Editing context
         * @param {Core.widget.Editor} editorContext.editor The Editor being used.
         * Will contain an `inputField` property which is the field being used to perform the editing.
         * @param {Grid.column.Column} editorContext.column Target column
         * @param {Core.data.Model} editorContext.record Target record
         * @param {HTMLElement} editorContext.cell Target cell
         * @param {*} editorContext.value Cell value
         */
        grid.trigger('finishCellEdit', { grid, editorContext });
        this.cleanupAfterEdit(editorContext);
    }

    onEditorCancel() {
        const { editorContext, muteEvents, grid } = this;

        if (editorContext) {
            this.cleanupAfterEdit(editorContext);
        }
        if (!muteEvents) {
            /**
             * Fires on the owning Grid when editing is cancelled
             * @event cancelCellEdit
             * @param {Grid.view.Grid} grid **Deprecated** Use `source` instead
             * @param {Grid.view.Grid} source Owner grid
             */
            grid.trigger('cancelCellEdit', { grid });
        }
    }

    cleanupAfterEdit(editorContext) {
        const me = this,
            { editor } = editorContext;

        editorContext.cell.classList.remove('b-editing');
        editor.cellEditorContext = me.editorContext = null;
        me.grid.un({
            cellclick      : 'onCellClickWhileEditing',
            viewportResize : 'onViewportResizeWhileEditing'
        }, me);
        me.removeEditingListeners();
        // MS Edge workaround.
        // At this moment active element is grid.element, but removing editor element still triggers focusout event
        // which is processed by the GlobalEvents, which decides that focus goes to body element. That, in turn, triggers
        // clearFocus on grid navigation, removing focused cell from cache etc, eventually focus actually goes to body.
        // Suspending listener to seamlessly remove element keeping focus where it belongs.
        // NOTE: not reproducible in IFrame, so our tests cannot catch this
        GlobalEvents.suspendFocusEvents();
        editor.element.remove();
        GlobalEvents.resumeFocusEvents();
    }

    /**
     * Find the next succeeding or preceding cell which is editable (column.editor != false)
     * @param {Object} cellInfo
     * @param {Boolean} isForward
     * @returns {Object}
     * @private
     * @category Internal
     */
    getAdjacentEditableCell(cellInfo, isForward) {
        let addNewAtEnd = this.addNewAtEnd,
            grid = this.grid,
            store = grid.store,
            rowManager = grid.rowManager,
            rowId    = cellInfo.id,
            columnId = cellInfo.columnId,
            columns  = grid.columns,
            column   = columns.getAdjacentLeaf(columnId, isForward);

        while (rowId) {
            const record = store.getById(rowId);

            if (column) {
                columnId = column.id;

                if (!column.hidden && column.editor && column.canEdit(record)) {
                    return { id : rowId, columnId : column.id };
                }

                column = columns.getAdjacentLeaf(columnId, isForward);
            }
            else {
                let editRec = store.getAdjacent(cellInfo.id, isForward, false, true);

                if (!editRec && isForward && addNewAtEnd) {
                    editRec = store.add(typeof addNewAtEnd === 'object' ? ObjectHelper.clone(addNewAtEnd) : {})[0];

                    // If the new record was not added due to it being off the end of the rendered block
                    // ensure we force it to be there before we attempt to edit it.
                    if (!rowManager.getRowFor(editRec)) {
                        rowManager.displayRecordAtBottom();
                    }
                }

                rowId = editRec && editRec.id;

                if (editRec) {
                    column = isForward ? columns.first : columns.leaves[columns.leaves.length - 1];
                }
            }
        }

        return null;
    }

    /**
     * Creates an editing context object for the passed cell context (target cell must be in the DOM).
     *
     * If the referenced cell is editable, an object returned will
     * be returned containing the following properties:
     *
     *     - column
     *     - record
     *     - cell
     *     - value
     *     - selector
     *
     * If the references cell is _not_ editable, `false` will be returned.
     * @param {Object} cellContext an object which encapsulates a cell.
     * @param {String} cellContext.id The record id of the row to edit
     * @param {String} cellContext.columnId The column id of the column to edit
     * @private
     */
    getEditingContext(cellContext) {
        cellContext = this.grid.normalizeCellContext(cellContext);

        const me = this,
            { grid } = me,
            column = grid.columns.getById(cellContext.columnId),
            record = grid.store.getById(cellContext.id),
            cell = grid.getCell(cellContext);

        // Cell must be in the DOM to edit.
        // Cannot edit hidden columns and columns without an editor.
        // Cannot edit special rows (groups etc).
        if (cell && column && !column.hidden && column.editor && record && !record.meta.specialRow && column.canEdit(record)) {
            const value = record && record[column.field];

            return {
                column,
                record,
                cell,
                value    : value === undefined ? null : value,
                selector : cellContext,
                editor   : column.editor
            };
        }
        else {
            return false;
        }
    }

    /**
     * Start editing specified cell. If no cellContext is given it starts with the first cell in the first row.
     * This function is exposed on Grid and can thus be called as `grid.startEditing(...)`
     * @param {Object} cellContext Cell specified in format { id: 'x', columnId/column/field: 'xxx' }. See {@link Grid.view.Grid#function-getCell} for details.
     * @fires startCellEdit
     * @returns {Boolean} editingStarted
     * @category Editing
     */
    startEditing(cellContext = {}) {
        const me = this;

        // If already editing, or grid is readonly, no can do.
        if (!(me.editorContext || me.disabled)) {
            const
                { grid }          = me,
                normalizedContext = grid.normalizeCellContext(cellContext);

            // First scroll record into view and register it as last focusedCell
            grid.focusCell(cellContext);

            const editorContext = me.getEditingContext(normalizedContext);

            /**
             * Fires on the owning Grid before editing starts, return `false` to prevent editing
             * @event beforeCellEditStart
             * @preventable
             * @param {Grid.view.Grid} source Owner grid
             * @param {Object} editorContext Editing context
             * @param {Grid.column.Column} editorContext.column Target column
             * @param {Core.data.Model} editorContext.record Target record
             * @param {HTMLElement} editorContext.cell Target cell
             * @param {Core.widget.Field} editorContext.editor The input field that the column is configured
             * with (see {@link Grid.column.Column#config-field}). This property mey be replaced
             * to be a different {@link Core.widget.Field field} in the handler, to take effect
             * just for the impending edit.
             * @param {Function} [editorContext.finalize] An async function may be injected into this property
             * which performs asynchronous finalization tasks such as complex validation of confirmation. The
             * value `true` or `false` must be returned.
             * @param {Object} [editorContext.finalize.context] An object describing the editing context upon requested completion of the edit.
             * @param {*} editorContext.value Cell value
             */
            if (!editorContext || grid.trigger('beforeCellEditStart', { grid, editorContext }) === false) {
                return false;
            }

            // Cannot edit hidden columns and columns without an editor
            // Cannot edit special rows (groups etc).
            if (editorContext) {
                // Focus grid element to preserve focus inside once editing is started
                // https://app.assembla.com/spaces/bryntum/tickets/8155-grid-cell-not-properly-focused-in-advanced-demo
                DomHelper.focusWithoutScrolling(grid.element);

                const
                    editor                   = editorContext.editor = me.getEditorForCell(editorContext),
                    { cell, record, column } = editorContext;

                // Prevent highlight when setting the value in the editor
                editor.inputField.highlightExternalChange = false;

                editor.cellEditorContext = editorContext;
                editor.render(me.grid.getSubGridFromColumn(column).element);

                // Attempt to start edit.
                // We will set up our context in onEditorStart *if* the start was successful.
                editor.startEdit({
                    target : cell,
                    record,
                    field  : editor.inputField.name || editorContext.column.field
                });

                return true;
            }
        }

        return false;
    }

    /**
     * Cancel editing, destroys the editor
     * @param {Boolean} silent Pass true to prevent method from firing event
     * @fires cancelCellEdit
     * @category Editing
     */
    cancelEditing(silent = false) {
        const
            me                              = this,
            { editorContext, editor, grid } = me;

        if (editorContext) {
            // If cancel was not called from onEditorFocusOut, then refocus the grid.
            if (editor.containsFocus) {
                // Kill editorContext before we destroy the editor so that we know we are not editing
                // in ensuing focusout event handling
                me.editorContext = null;

                // Control focus reversion if we own focus
                if (editor.inputField.owns(DomHelper.activeElement)) {
                    DomHelper.focusWithoutScrolling(grid.element);
                }
                me.editorContext = editorContext;
            }

            me.muteEvents = silent;
            editor.cancelEdit();
            me.muteEvents = false;
        }
    }

    /**
     * Finish editing, update the underlying record and destroy the editor
     * @fires finishCellEdit
     * @category Editing
     * @returns `false` if the edit could not be finished due to the value being invalid or the
     * Editor's `complete` event was vetoed.
     * @async
     */
    async finishEditing() {
        const { editorContext } = this;

        let result = false;

        if (editorContext) {
            const { column } = editorContext;

            // If completeEdit finds that the editor context has a finalize method in it,
            // it will *await* the completion of that method before completing the edit
            // so we must await completeEdit.
            // We can override that finalize method by passing the column's own finalizeCellEdit.
            result = await editorContext.editor.completeEdit(column.bindCallback(column.finalizeCellEdit));
        }
        return result;
    }

    //endregion

    //region Events

    /**
     * Event handler added when editing is active called when user clicks a cell in the grid during editing.
     * It finishes editing and moves editor to the selected cell instead.
     * @private
     * @category Internal event handling
     */
    onCellClickWhileEditing({ event, cellSelector }) {
        const me = this;

        // Ignore clicks in the editor.
        if (!me.editorContext.editor.owns(event.target)) {
            if (me.getEditingContext(cellSelector)) {
                // Attempt to finish the current edit.
                // Will return false if the field is invalid.
                if (me.finishEditing()) {
                    me.startEditing(cellSelector);
                }
                // Previous edit was invalid, return to it.
                else {
                    me.grid.focusCell(me.editorContext.selector);
                    me.editor.inputField.focus();
                }
            }
            else {
                me.finishEditing();
            }
        }
    }

    onViewportResizeWhileEditing() {
        const {
            editor,
            column
        } = this.editorContext;

        editor.width = column.element.offsetWidth;
    }

    /**
     * Starts editing if user taps selected cell again on touch device. Chained function called when user clicks a cell.
     * @private
     * @category Internal event handling
     */
    onCellClick({ source : grid, record, cellSelector, cellElement, target, event }) {
        const
            selected = grid.focusedCell || {},
            column   = grid.columns.getById(cellSelector.columnId);

        // Columns may provide their own handling of cell editing
        if (column.onCellClick) {
            column.onCellClick({ grid, column, record, cellSelector, cellElement, target, event });
        }
        else if (target.matches('.b-tree-expander')) {
            this.cancelEditing();
            return false;
        }
        else if (DomHelper.isTouchEvent &&
            cellSelector.id == selected.id &&
            cellSelector.columnId == selected.columnId) {
            this.startEditing(cellSelector);
        }
    }

    /**
     * Chained function called when user dbl clicks a cell. Starts editing.
     * @private
     * @category Internal event handling
     */
    onCellDblClick({ cellSelector }) {
        const me = this;

        if (me.editorContext && !me.finishEditing()) {
            return;
        }
        me.startEditing(cellSelector);
    }

    /**
     * Update the input field if underlying data changes during edit.
     * @private
     * @category Internal event handling
     */
    onStoreUpdate({ changes, record }) {
        const { editorContext } = this;

        if (editorContext && editorContext.editor.isVisible) {
            if (record === editorContext.record && editorContext.editor.dataField in changes) {
                editorContext.editor.refreshEdit();
            }
        }
    }

    /**
     * Invalidate editor when grid renders rows.
     * @private
     * @category Internal event handling
     */
    onGridBeforeRenderRows() {
        // grid rows are being rerendered, meaning the underlying data might be changed.
        // the editor probably won't be over the same record, so cancel
        if (this.editorContext && this.editorContext.editor.isVisible) {
            this.cancelEditing();
        }
    }

    /**
     * Chained function called on key down. [enter] or [f2] starts editing. [enter] also finishes editing and starts
     * editing next row, [f2] also finishes editing without moving to the next row. [esc] cancels editing. [tab]
     * edits next column, [shift] + [tab] edits previous.
     * @param event
     * @private
     * @category Internal event handling
     */
    async onElementKeyDown(event) {
        const me = this;

        // flagging event with handled = true used to signal that other features should probably not care about it
        if (event.handled) return;

        if (!me.editorContext) {
            const key = event.key,
                editingStartedWithCharacterKey = me.autoEdit && (key.length === 1 || key === 'Backspace');

            // enter or f2 to edit, or any character key if autoEdit is enabled
            if ((editingStartedWithCharacterKey || validNonEditingKeys[key]) && me.grid.focusedCell) {
                event.preventDefault();

                if (!me.startEditing(me.grid.focusedCell)) {
                    return;
                }

                const inputField = me.editor.inputField,
                    input = inputField.input;

                // if editing started with a keypress and the editor has an input field, set its value
                if (editingStartedWithCharacterKey && input) {
                    // Simulate a keydown in an input field by setting input value
                    // plus running our internal processing of that event
                    input.value = key === 'Backspace' ? '' : key;
                    inputField.internalOnInput(event);

                    // IE11 + Edge put caret at 0 when focusing
                    inputField.moveCaretToEnd();
                }
            }
        }
        else {
            // enter
            if (event.key === 'Enter') {
                event.preventDefault();
                event.stopPropagation();
                if (await me.finishEditing()) {
                    // Finalizing might have been blocked by an invalid value
                    if (!me.isEditing) {
                        // Enter in combination with special keys finishes editing
                        // On touch Enter always finishes editing. Feels more natural since no tab-key etc.
                        if (event.ctrlKey || event.metaKey || event.altKey || me.grid.touch) {
                            return;
                        }
                        // Edit previous
                        else if (event.shiftKey) {
                            if (me.grid.navigateUp()) {
                                me.startEditing(me.grid.focusedCell);
                            }
                        }
                        // Edit next
                        else if (me.grid.navigateDown()) {
                            me.startEditing(me.grid.focusedCell);
                        }
                    }
                }
            }

            // f2
            if (event.key === 'F2') {
                event.preventDefault();
                me.finishEditing();
            }

            // esc
            if (event.key === 'Escape') {
                event.stopPropagation();
                event.preventDefault();
                me.cancelEditing();
            }

            // tab
            if (event.key === 'Tab') {
                event.preventDefault();

                let focusedCell = me.grid.focusedCell;

                if (focusedCell) {
                    let cellInfo = me.getAdjacentEditableCell(focusedCell, !event.shiftKey);

                    if (cellInfo) {
                        if (await me.finishEditing()) {
                            me.grid.focusCell(cellInfo, {
                                animate : 100
                            });

                            me.startEditing(cellInfo);
                        }
                    }
                }
            }

            // prevent arrow keys from moving editor
            if (validEditingKeys[event.key]) {
                event.handled = true;
            }
        }
    }

    onElementMouseDown(event) {
        // If it's a contextmenu mousedown during cell edit, prevent default
        // because the contextmenu handler will move focus directly to the context menu.
        // If we allow it to go through the grid, the edit will not terminate because
        // that usually means begin editing somewhere else in the grid.
        // TODO: This won't be necessary when cells are the focusable DOM unit.
        if (event.button === 2 && this.editorContext) {
            event.preventDefault();
        }
    }

    /**
     * Cancel editing on widget focusout
     * @private
     */
    onEditorFocusOut(event) {
        const me = this,
            { grid } = me;

        // If the editor is not losing focus as a result of its tidying up process
        // And focus is moving to outside of the grid, or back to the initiating cell
        // (which indicates a click on empty space below rows), then explicitly terminate.
        if (me.editorContext && !me.editor.isFinishing && me.editor.inputField.owns(event.target) && (event.toWidget !== grid || grid.isLocationEqual(me.grid.focusedCell, me.editorContext.selector))) {
            if (me.blurAction === 'cancel') {
                me.cancelEditing();
            }
            else {
                me.finishEditing();
            }
        }
    }

    onEditorFocusIn(event) {
        const widget = event.toWidget;

        if (widget === this.editor.inputField) {
            if (this.autoSelect && widget.selectAll && !widget.readOnly && !widget.disabled) {
                widget.selectAll();
            }
        }
    }

    /**
     * Cancel edit on touch outside of grid for mobile Safari (focusout not triggering unless you touch something focusable)
     * @private
     */
    onTapOut({ event }) {
        const me = this;

        if (!me.grid.bodyContainer.contains(event.target)) {
            if (!me.editor.owns(event.target)) {
                if (me.blurAction === 'cancel') {
                    me.cancelEditing();
                }
                else {
                    me.finishEditing();
                }
            }
        }
    }

    /**
     * Finish editing if clicking below rows (only applies when grid is higher than rows).
     * @private
     * @category Internal event handling
     */
    onElementClick(event) {
        const me = this;
        if (event.target.classList.contains('b-grid-body-container') && me.editorContext) {
            me.finishEditing();
        }
    }

    //endregion
}

CellEdit._$name = 'CellEdit'; GridFeatureManager.registerFeature(CellEdit, true);

/**
 * @module Grid/feature/CellTooltip
 */

/**
 * Displays a tooltip when hovering cells. Contents can be customized by specifying a global `tooltipRenderer` function
 * for the feature and/or on a per column basis.
 *
 * Configuration properties passed into this feature are used to configure the {@link Core.widget.Tooltip} instance
 * used.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * ## Showing async content
 * Showing remotely loaded content is super easy using the {@link #config-tooltipRenderer}:
 *
 * ```javascript
 * // Async tooltip with some custom settings
 * let grid = new Grid({
 *   features: {
 *     cellTooltip: {
 *       // Time that mouse needs to be over cell before tooltip is shown
 *       hoverDelay : 4000,
 *       // Time after mouse out to hide the tooltip, 0 = instantly
 *       hideDelay  : 0,
 *       // Async tooltip renderer, return a Promise which yields the text content
 *       tooltipRenderer({ record, tip }) => AjaxHelper.get(`tooltip.php?id=${record.id}`).then(response => response.text())
 *     }
 *   }
 * });
 * ```
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @example
 * // Enable CellTooltip and configure it to show the cell's full value
 * let grid = new Grid({
 *   features: {
 *     cellTooltip: ({value}) => value
 *   }
 * });
 *
 * // Column with its own tooltip renderer
 * {
 *   text            : 'Name',
 *   field           : 'name',
 *   tooltipRenderer : ({ record }) => `My name is\xa0<b>${record.name}</b>`
 * }
 *
 * @demo Grid/celltooltip
 * @classtype cellTooltip
 * @externalexample feature/CellTooltip.js
 */
class CellTooltip extends InstancePlugin {
    //region Config

    static get $name() {
        return 'CellTooltip';
    }

    static get defaultConfig() {
        return {
            /**
             * Function called to generate the HTML content for the cell tooltip. The function should return a string (your HTML), or a Promise yielding a string (for remotely loaded content)
             * @config {Function}
             * @param {Object} context
             * @param {HTMLElement} context.cellElement The cell element
             * @param {Core.data.Model} context.record The row record
             * @param {Grid.column.Column} context.column The column
             * @param {Core.widget.Tooltip} context.tip The Tooltip instance
             * @param {Grid.feature.CellTooltip} context.cellTooltip The feature
             * @param {Event} context.event The raw DOM event
             * @return {String|Promise}
             */
            tooltipRenderer : null
        };
    }

    //endregion

    // region Init

    construct(grid, config) {
        const me = this;

        super.construct(grid, me.processConfig(config));
    }

    initTip() {
        const me = this;

        me.tip = new Tooltip(Object.assign({
            forElement  : me.client.element,
            forSelector : '.b-grid-cell',
            hoverDelay  : 1000,
            trackMouse  : false,
            cls         : 'b-celltooltip-tip',
            getHtml     : me.getTooltipContent.bind(me),
            listeners   : {
                pointerOver : 'onPointerOver',
                thisObj     : me
            }
        }, me.initialConfig));

        me.relayEvents(me.tip, ['beforeshow', 'show']);
    }

    onPointerOver({ target }) {
        const column = this.client.getColumnFromElement(target);

        // Veto onPointerOver if column's tooltipRenderer is false
        return column.tooltipRenderer !== false;
    }

    // CellTooltip feature handles special config cases, where user can supply a function to use as tooltipRenderer
    // instead of a normal config object
    processConfig(config) {
        if (typeof config === 'function') {
            return {
                tooltipRenderer : config
            };
        }

        return config;
    }

    // override setConfig to process config before applying it (used mainly from ReactGrid)
    setConfig(config) {
        super.setConfig(this.processConfig(config));
    }

    doDestroy() {
        this.tip && this.tip.destroy();
        super.doDestroy();
    }

    doDisable(disable) {
        if (!disable) {
            this.initTip();
        }
        else if (this.tip) {
            this.tip.destroy();
            this.tip = null;
        }

        super.doDisable(disable);
    }

    //endregion

    //region Content

    /**
     * Called from Tooltip to populate it with html.
     * @private
     */
    getTooltipContent({ tip, activeTarget : cellElement, event }) {
        const
            me     = this,
            record = me.client.getRecordFromElement(cellElement),
            column = me.client.getColumnFromElement(cellElement);

        let result;

        // If we have not changed context, we should not change content, unless we have a custom target selector
        // (element within the cell)
        if (!me.forSelector && record === me.lastRecord && column === me.lastColumn) {
            return me.tip._html;
        }

        // first, use columns tooltipRenderer if any
        if (column.tooltipRenderer) {
            result = column.tooltipRenderer({ cellElement, record, column, event, tip, cellTooltip : me });

            if (result === false) {
                VersionHelper.deprecate('Grid', '5.0.0', 'Returning false to indicate loading is deprecated. Please see https://bryntum.com/docs/grid/#guides/upgrades/3.0.1.md for more information');
            }
        }
        // secondly, try features renderer (but specifying column.tooltipRenderer as false prevents tooltip in that column)
        else if (me.tooltipRenderer && column.tooltipRenderer !== false) {
            result = me.tooltipRenderer({ cellElement, record, column, event, tip, cellTooltip : me });

            if (result === false) {
                VersionHelper.deprecate('Grid', '5.0.0', 'Returning false to indicate loading is deprecated. Please see https://bryntum.com/docs/grid/#guides/upgrades/3.0.1.md for more information');
            }
        }

        if (result != null) {
            me.lastRecord = record;
            me.lastColumn = column;
        }
        return result;
    }

    //endregion
}

CellTooltip._$name = 'CellTooltip'; GridFeatureManager.registerFeature(CellTooltip);

/**
 * @module Grid/feature/ColumnDragToolbar
 */

/**
 * Displays a toolbar while dragging column headers. Drop on a button in the toolbar to activate a certain function,
 * for example to group by that column. This feature simplifies certain operations on touch devices.
 *
 * This feature is <strong>disabled</strong> by default, but turned on automatically on touch devices.
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @classtype columnDragToolbar
 * @externalexample feature/ColumnDragToolbar.js
 * @demo Grid/columndragtoolbar
 */
class ColumnDragToolbar extends Delayable(InstancePlugin) {
    //region Config

    static get $name() {
        return 'ColumnDragToolbar';
    }

    // Plugin configuration. This plugin chains some of the functions in Grid
    static get pluginConfig() {
        return {
            after : ['render']
        };
    }

    //endregion

    //region Init

    construct(grid, config) {
        if (grid.features.columnReorder) {
            grid.features.columnReorder.on('beforedestroy', this.onColumnReorderBeforeDestroy, this);
        }

        this.grid = grid;

        super.construct(grid, config);
    }

    doDestroy() {
        const me = this;

        if (me.grid.features.columnReorder && !me.grid.features.columnReorder.isDestroyed) {
            me.detachFromColumnReorder();
        }

        me.element && me.element.remove();
        me.element = null;
        super.doDestroy();
    }

    doDisable(disable) {
        if (this.initialized) {
            if (disable) {
                this.detachFromColumnReorder();
            }
            else {
                this.init();
            }
        }
        super.doDisable(disable);
    }

    init() {
        const
            me   = this,
            grid = me.grid;

        if (!grid.features.columnReorder) {
            return;
        }

        me.reorderDetacher = grid.features.columnReorder.on({
            gridheaderdragstart({ context }) {
                const column = grid.columns.getById(context.element.dataset.columnId);
                me.showToolbar(column);
            },

            gridheaderdrag : ({ context }) => me.onDrag(context),

            gridheaderabort : () => {
                me.hideToolbar();
            },

            gridheaderdrop : ({ context }) => {
                if (context.valid) {
                    me.hideToolbar();
                }
                else {
                    me.onDrop(context);
                }
            },

            thisObj : me
        });

        me.initialized = true;
    }

    onColumnReorderBeforeDestroy() {
        this.detachFromColumnReorder();
    }

    detachFromColumnReorder() {
        const me = this;

        me.grid.features.columnReorder.un('beforedestroy', me.onColumnReorderBeforeDestroy, me);

        me.reorderDetacher && me.reorderDetacher();
        me.reorderDetacher = null;
    }

    /**
     * Initializes this feature on grid render.
     * @private
     */
    render() {
        if (!this.initialized) {
            this.init();
        }
    }

    //endregion

    //region Toolbar

    showToolbar(column) {
        const me      = this,
            buttons = me.grid.getColumnDragToolbarItems(column, []),
            groups  = [];

        me.clearTimeout(me.buttonHideTimer);
        me.clearTimeout(me.toolbarHideTimer);

        buttons.forEach(button => {
            let group = groups.find(group => group.text === button.group);
            if (!group) {
                group = { text : button.group, buttons : [] };
                groups.push(group);
            }

            group.buttons.push(button);
        });

        me.element = DomHelper.append(me.grid.element, me.template(groups));

        me.groups  = groups;
        me.buttons = buttons;
        me.column  = column;
    }

    hideToolbar() {
        const me = this;

        return new Promise(resolve => {
            if (me.element && !me.toolbarHideTimer) {
                me.element.classList.add('b-remove');

                // TODO: use AnimationHelper when available
                me.toolbarHideTimer = me.setTimeout(() => {
                    me.toolbarHideTimer = null;
                    me.element && me.element.remove();
                    me.element = null;
                    resolve();
                }, 200);
            }
        });
    }

    //endregion

    //region Events

    onDrag(info) {
        const me = this;

        if (info.dragProxy.getBoundingClientRect().top - me.grid.element.getBoundingClientRect().top > 100) {
            me.element.classList.add('b-closer');
        }
        else {
            me.element.classList.remove('b-closer');
        }

        if (me.hoveringButton) {
            me.hoveringButton.classList.remove('b-hover');
            me.hoveringButton = null;
        }

        if (info.targetElement && info.targetElement.closest('.b-columndragtoolbar')) {
            me.element.classList.add('b-hover');

            let button = info.targetElement.closest('.b-columndragtoolbar  .b-target-button:not([data-disabled=true])');
            if (button) {
                button.classList.add('b-hover');
                me.hoveringButton = button;
            }
        }
        else {
            me.element.classList.remove('b-hover');
        }
    }

    onDrop(info) {
        const me = this;

        if (info.targetElement && info.targetElement.matches('.b-columndragtoolbar .b-target-button:not([data-disabled=true])')) {
            const buttonEl = info.targetElement,
                button   = me.buttons.find(button => button.name === buttonEl.dataset.name);

            if (button) {
                buttonEl.classList.add('b-activate');

                me.buttonHideTimer = me.setTimeout(() => {
                    me.hideToolbar();
                    button.onDrop({ column : me.column });
                }, 100);
            }
        }
        else {
            me.hideToolbar();
        }
    }

    //endregion

    template(groups) {
        return TemplateHelper.tpl`
            <div class="b-columndragtoolbar">     
            <div class="b-title"></div>          
            ${groups.map(group => TemplateHelper.tpl`
                <div class="b-group">
                    <div class="b-buttons">
                    ${group.buttons.map(btn => TemplateHelper.tpl`
                        <div class="b-target-button" data-name="${btn.name}" data-disabled="${btn.disabled}">
                            <i class="${btn.icon}"></i>
                            ${btn.text}
                        </div>
                    `)}
                    </div>
                    <div class="b-title">${group.text}</div>
                </div>
            `)}
            </div>`;
    }
}

ColumnDragToolbar.featureClass = 'b-hascolumndragtoolbar';

// used by default on touch devices, can be enabled otherwise
ColumnDragToolbar._$name = 'ColumnDragToolbar'; GridFeatureManager.registerFeature(ColumnDragToolbar, BrowserHelper.isTouchDevice);

/**
 * @module Grid/feature/ColumnPicker
 */

/**
 * Displays a column picker (to show/hide columns) in the header context menu. Columns can be displayed in sub menus
 * by region or tag. Grouped headers are displayed as menu hierarchies.
 *
 * This feature is <strong>enabled</strong> by default.
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @demo Grid/columns
 * @classtype columnPicker
 * @externalexample feature/ColumnPicker.js
 */
class ColumnPicker extends InstancePlugin {
    //region Config

    static get $name() {
        return 'ColumnPicker';
    }

    static get defaultConfig() {
        return {
            /**
             * Groups columns in the picker by region (each region gets its own sub menu)
             * @config {Boolean}
             * @default
             */
            groupByRegion : false,

            /**
             * Groups columns in the picker by tag, each column may be shown under multiple tags. See
             * {@link Grid.column.Column#config-tags}
             * @config {Boolean}
             * @default
             */
            groupByTag : false
        };
    }

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            chain : ['getHeaderMenuItems', 'getColumnDragToolbarItems']
        };
    }

    //endregion

    //region Init

    construct(grid, config) {
        this.grid = grid;
        super.construct(grid, config);
    }

    //endregion

    //region Context menu

    /**
     * Get menu items, either a straight list of columns or sub menus per subgrid
     * @private
     * @param columnStore Column store to traverse
     * @returns {Object[]} Menu item configs
     */
    getColumnPickerItems(columnStore) {
        const me = this;

        if (me.groupByRegion) {
            // submenus for grids regions
            return me.grid.regions.map(region => {
                const columns = me.grid.getSubGrid(region).columns.topColumns;

                return {
                    text     : StringHelper.capitalizeFirstLetter(region),
                    menu     : me.buildColumnMenu(columns),
                    disabled : columns.length === 0,
                    region   : region
                };
            });
        }
        else if (me.groupByTag) {
            // submenus for column tags
            const tags = {};
            columnStore.topColumns.forEach(column => {
                column.tags && column.hideable && column.tags.forEach(tag => {
                    if (!tags[tag]) {
                        tags[tag] = 1;
                    }
                });
            });

            // TODO: as checkitems, but how to handle toggling? hide a column only when all tags for it are unchecked?
            return Object.keys(tags).sort().map(tag => ({
                text            : StringHelper.capitalizeFirstLetter(tag),
                menu            : me.buildColumnMenu(me.getColumnsForTag(tag)),
                tag             : tag,
                onBeforeSubMenu : ({ item, itemEl }) => {
                    me.refreshTagMenu(item, itemEl);
                }
            }));
        }
        else {
            // all columns in same menu
            return me.buildColumnMenu(columnStore.topColumns);
        }
    }

    /**
     * Get all columns that has the specified tag
     * TODO: if tags are useful from somewhere else, move to ColumnStore
     * @private
     * @param tag
     * @returns {Grid.column.Column[]}
     */
    getColumnsForTag(tag) {
        // TODO: if tags are usefull from somewhere else, move to ColumnStore
        return this.grid.columns.records.filter(column =>
            column.tags && column.tags.includes(tag) && column.hideable !== false
        );
    }

    /**
     * Refreshes checked status for a tag menu. Needed since columns can appear under multiple tags.
     * @private
     */
    refreshTagMenu(item, itemEl) {
        const columns = this.getColumnsForTag(item.tag);
        columns.forEach(column => {
            const subItem = item.items.find(subItem => subItem.column === column);
            if (subItem) subItem.checked = column.hidden !== true;
        });
    }

    /**
     * Traverses columns to build menu items for the column picker.
     * @private
     */
    buildColumnMenu(columns) {
        let currentRegion = columns.length > 0 && columns[0].region,
            { grid }      = this;

        return columns.reduce((items, column) => {
            const visibleInRegion = this.grid.columns.visibleColumns.filter(col => col.region === column.region);

            if (column.hideable !== false) {
                const itemConfig = {
                    grid,
                    text     : column.text,
                    column   : column,
                    name     : column.id,
                    checked  : column.hidden !== true,
                    disabled : column.hidden !== true && visibleInRegion.length === 1,
                    cls      : column.region !== currentRegion ? 'b-separator' : ''
                };

                currentRegion = column.region;

                if (column.children) {
                    itemConfig.menu = this.buildColumnMenu(column.children);
                }

                items.push(itemConfig);
            }
            return items;
        }, []);
    }

    /**
     * Supply items for headers context menu.
     * @private
     * @param column Header for this column
     * @param items Array of items to add to
     * @returns {Object[]} Modified items
     */
    getHeaderMenuItems(column, items) {
        const me = this,
            { grid, disabled } = me,
            { columns } = grid;

        if (column.showColumnPicker !== false && columns.some(col => col.hideable)) {
            // column picker
            items.push({
                text     : me.L('columnsMenu'),
                name     : 'columnPicker',
                icon     : 'b-fw-icon b-icon-columns',
                cls      : 'b-separator',
                weight   : 100,
                menu     : me.getColumnPickerItems(columns),
                onToggle : me.onColumnToggle,
                disabled
            });
        }

        // menu item for hiding this column
        if (column.hideable !== false) {
            const visibleInRegion = columns.visibleColumns.filter(col => col.region === column.region);

            items.push({
                text     : me.L('hideColumn'),
                icon     : 'b-fw-icon b-icon-hide-column',
                weight   : 101,
                name     : 'hideColumn',
                disabled : visibleInRegion.length === 1 || disabled,
                onItem   : () => column.hide()
            });
        }
    }

    /**
     * Handler for column hide/show menu checkitems.
     * @private
     * @param {Object} The {@link Core.widget.MenuItem#event-toggle} event.
     */
    onColumnToggle({ menu, item, checked }) {
        if (!!item.column.hidden !== !checked) {
            item.column[checked ? 'show' : 'hide']();

            const
                { grid, column } = item,
                { columns } = grid,
                // Sibling items, needed to disable other item if it is the last one in region
                siblingItems = menu.items,
                // Columns left visible in same region as this items column
                visibleInRegion = columns.visibleColumns.filter(col => col.region === item.column.region),
                // Needed to access "hide-column" item outside of column picker
                { currentMenu } = grid.features.contextMenu,
                // TODO: When we have actual MenuItems there should be a way to store the item and not have to look it up
                hideItem = currentMenu.items.find(item => item.name === 'hideColumn');

            // Do not allow user to hide the last column in any region
            if (visibleInRegion.length === 1) {
                const lastVisibleItem = siblingItems.find(i => i.name === visibleInRegion[0].id);
                if (lastVisibleItem) {
                    lastVisibleItem.disabled = true;
                }

                // Also disable "Hide column" item if only one column left in this region
                if (hideItem && column.region === item.column.region) {
                    hideItem.disabled = true;
                }
            }
            // Multiple columns visible, enable "hide-column" and all items for that region
            else {
                visibleInRegion.forEach(col => {
                    const siblingItem = siblingItems.find(sibling => sibling.column === col);
                    if (siblingItem) {
                        siblingItem.disabled = false;
                    }
                });

                if (hideItem && column.region === item.column.region) {
                    hideItem.disabled = false;
                }
            }

            if (item.menu) {
                // Reflect status in submenu.
                // Cannot use short form () => foo because eachWidget aborts on return of false
                item.menu.eachWidget(subItem => {
                    subItem.checked = checked;
                });
            }

            const parentItem = menu.owner;
            if (parentItem && parentItem.column === column.parent) {
                const anyChecked = siblingItems.some(subItem => subItem.checked === true);
                parentItem.checked = anyChecked;
            }
        }
    }

    /**
     * Supply items to ColumnDragToolbar
     * @private
     */
    getColumnDragToolbarItems(column, items) {
        const visibleInRegion = this.grid.columns.visibleColumns.filter(col => col.region === column.region);

        if (column.hideable !== false && visibleInRegion.length > 1) {
            items.push({
                text   : this.L('hideColumnShort'),
                group  : this.L('Column'),
                icon   : 'b-fw-icon b-icon-hide-column',
                weight : 101,
                name   : 'hideColumn',
                onDrop : ({ column }) => column.hide()
            });
        }
        return items;
    }

    //endregion
}

ColumnPicker._$name = 'ColumnPicker'; GridFeatureManager.registerFeature(ColumnPicker, true);

/**
 * @module Grid/feature/ColumnReorder
 */

/**
 * Allows user to reorder columns by dragging headers. To get notified about column reorder listen to `change` event
 * on {@link Grid.data.ColumnStore columns} store.
 *
 * This feature is <strong>enabled</strong> by default.
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @demo Grid/columns
 * @classtype columnReorder
 * @externalexample feature/ColumnReorder.js
 */
class ColumnReorder extends Delayable(InstancePlugin) {
    //region Init

    static get $name() {
        return 'ColumnReorder';
    }

    construct(grid, config) {
        this.ignoreSelectors = [
            '.b-grid-header-resize-handle',
            '.b-field'
        ];

        this.grid = grid;

        super.construct(grid, config);
    }

    doDestroy() {
        this.dragHelper && this.dragHelper.destroy();

        super.doDestroy();
    }

    /**
     * Initialize drag & drop (called from render)
     * @private
     */
    init() {
        const
            me         = this,
            { grid }   = me,
            gridEl     = grid.element,
            containers = DomHelper.children(gridEl, '.b-grid-headers');

        containers.push(...DomHelper.children(gridEl, '.b-grid-header-children'));

        if (me.dragHelper) {
            // update the dragHelper with the new set of containers it should operate upon
            me.dragHelper.containers = containers;
        }
        else {
            me.dragHelper = new DragHelper({
                name           : 'columnReorder',
                mode           : 'container',
                dragThreshold  : 10,
                targetSelector : '.b-grid-header',
                outerElement   : gridEl.querySelector('header.b-grid-header-container'),
                containers,
                isElementDraggable(element) {
                    const abort = Boolean(DomHelper.up(element, me.ignoreSelectors.join(',')));

                    if (abort || me.disabled) {
                        return false;
                    }

                    const
                        columnEl = DomHelper.up(element, this.targetSelector),
                        column   = columnEl && grid.columns.getById(columnEl.dataset.columnId),
                        isLast   = column && column.childLevel === 0 && grid.subGrids[column.region].columns.count === 1;

                    // TODO: If we want to prevent dragging last column out of group we can use the code below...
                    /*isLast = column.level !== 0
                            // In grouped header, do not allow dragging last remaining child
                            ? column.parent.children.length === 1
                            // Not in a grouped header, do not allow dragging last remaining column
                            : grid.subGrids[column.region].columns.count === 1;*/

                    return Boolean(column) && column.draggable !== false && !isLast;
                },
                ignoreSelector : '.b-filter-icon,.b-grid-header-resize-handle',
                listeners      : {
                    dragstart : me.onDragStart,
                    drag      : me.onDrag,
                    drop      : me.onDrop,
                    thisObj   : me
                }
            });

            me.relayEvents(me.dragHelper, ['dragStart', 'drag', 'drop', 'abort'], 'gridHeader');
        }
    }

    //endregion

    //region Plugin config

    // Plugin configuration. This plugin chains some of the functions in Grid
    static get pluginConfig() {
        return {
            after : ['render', 'renderContents']
        };
    }

    //endregion

    //region Events (drop)

    onDrag({ context, event }) {
        const
            me           = this,
            targetHeader = IdHelper.fromElement(event.target, 'header');

        // If SubGrid is configured with a sealed column set, do not allow moving into it
        if (targetHeader && targetHeader.subGrid.sealedColumns) {
            context.valid = false;
            return;
        }

        // Require that we drag inside grid header while dragging if we don't have a drag toolbar
        if (!me.grid.features.columnDragToolbar) {
            context.valid = Boolean(event.target.closest('.b-grid-headers'));
        }
    }

    onDragStart() {
        const me = this;

        if (!me.grid.features.columnDragToolbar) {
            const headerContainerBox = me.grid.element.querySelector('.b-grid-header-container').getBoundingClientRect();

            me.dragHelper.minY = headerContainerBox.top;
            me.dragHelper.maxY = headerContainerBox.bottom;
        }

        this.grid.headerContainer.classList.add('b-dragging-header');
    }

    /**
     * Handle drop
     * @private
     */
    onDrop({ context }) {
        if (!context.valid) {
            return this.onInvalidDrop({ context });
        }

        const
            me           = this,
            grid         = me.grid,
            element      = context.dragging,
            onHeader     = DomHelper.up(context.target, '.b-grid-header'),
            onColumn     = grid.columns.get(onHeader.dataset.column),
            toRegion     = context.draggedTo.dataset.region || onColumn.region,
            sibling      = context.insertBefore,
            column       = grid.columns.getById(element.dataset.columnId),
            insertBefore = sibling ? grid.columns.getById(sibling.dataset.columnId) : grid.subGrids[toRegion].columns.last.nextSibling,
            newParent    = insertBefore ? insertBefore.parent : grid.columns.rootNode;

        grid.headerContainer.classList.remove('b-dragging-header');

        // Dropped into its current position in the same SubGrid - abort
        if (toRegion === column.region && (onColumn === column.previousSibling || insertBefore === column.nextSibling)) {
            me.dragHelper.abort();
            return;
        }

        // Check if we should remove last child
        const emptyParent = column.parent && column.parent.children.length === 1 && column.parent;

        if (emptyParent) {
            emptyParent.parent.removeChild(emptyParent);
        }

        // Clean up element used during drag drop as it will not be removed by Grid when it refreshes its header elements
        element.remove();

        column.region = toRegion;

        // Insert the column into its new place
        newParent.insertChild(column, insertBefore);
    }

    /**
     * Handle invalid drop
     * @private
     */
    onInvalidDrop() {
        this.grid.headerContainer.classList.remove('b-dragging-header');
    }

    //endregion

    //region Render

    /**
     * Updates DragHelper with updated headers when grid contents is rerendered
     * @private
     */
    renderContents() {
        // columns shown, hidden or reordered
        this.init();
    }

    /**
     * Initializes this feature on grid render.
     * @private
     */
    render() {
        // always reinit on render
        this.init();
    }

    //endregion
}

ColumnReorder.featureClass = 'b-column-reorder';

ColumnReorder._$name = 'ColumnReorder'; GridFeatureManager.registerFeature(ColumnReorder, true);

/**
 * @module Grid/feature/ColumnResize
 */

/**
 * Enables user to resize columns by dragging a handle on the righthand side of the header. To get notified about column
 * resize listen to `change` event on {@link Grid.data.ColumnStore columns} store.
 *
 * This feature is <strong>enabled</strong> by default.
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @demo Grid/columns
 * @classtype columnResize
 * @externalexample feature/ColumnResize.js
 */
class ColumnResize extends InstancePlugin {

    static get $name() {
        return 'ColumnResize';
    }

    static get defaultConfig() {
        return {
            /**
             * Resize all cells below a resizing header during dragging.
             * `'auto'` means `true` on non-mobile platforms.
             * @config {String|Boolean}
             * @default
             */
            liveResize : 'auto'
        };
    }

    //region Init

    construct(grid, config) {
        const me = this;

        me.grid = grid;

        super.construct(grid, config);

        me.resizer = new ResizeHelper({
            name           : 'columnResize',
            targetSelector : '.b-grid-header',
            handleSelector : '.b-grid-header-resize-handle',
            outerElement   : grid.element,
            listeners      : {
                beforeresizestart : me.onBeforeResizeStart,
                resizestart       : me.onResizeStart,
                resizing          : me.onResizing,
                resize            : me.onResize,
                thisObj           : me
            }
        });
    }

    //endregion

    // This plugin needs no functions chaining into the client grid
    static get pluginConfig() {
        return [];
    }

    set liveResize(liveResize) {
        if (liveResize === 'auto') {
            liveResize = !BrowserHelper.isMobileSafari;
        }
        this._liveResize = liveResize;
    }

    get liveResize() {
        return this._liveResize;
    }

    doDestroy() {
        this.resizer && this.resizer.destroy();
        super.doDestroy();
    }

    //region Events

    onBeforeResizeStart() {
        return !this.disabled;
    }

    onResizeStart({ context }) {
        const
            { grid, resizer } = this,
            column = context.column = grid.columns.getById(context.element.dataset.columnId);

        resizer.minWidth = column.minWidth;

        // remove minWidth value as it's used as a rendering workaround for IE flexbox bugs
        context.element.style.minWidth = '';

        grid.element.classList.add('b-column-resizing');
    }

    /**
     * Handle drag event - resize the column live unless it's a touch gesture
     * @private
     */
    onResizing({ context }) {
        if (context.valid && this.liveResize) {
            this.grid.dragResizing = true;
            context.column.width = context.newWidth;
        }
    }

    /**
     * Handle drop event (only used for touch)
     * @private
     */
    onResize({ context }) {
        const
            { grid } = this,
            { column } = context;

        grid.element.classList.remove('b-column-resizing');

        if (context.valid) {
            if (this.liveResize) {
                grid.dragResizing = false;
                grid.afterColumnsResized();
            }
            else {
                column.width = context.newWidth;
            }

            // In case of IE 11 we should calculate flex basis to fix header width
            // covered by ColumnResize.t
            if (BrowserHelper.isIE11 && column.parent && column.parent.flex) {
                const parent = column.parent,
                    headerEl = grid.getHeaderElement(parent.id);

                headerEl.style.flexBasis = parent.children.reduce((result, column) => {
                    return result + grid.getHeaderElement(column.id).offsetWidth;
                }, 0) + 'px';
            }
        }
    }

    //endregion
}

ColumnResize._$name = 'ColumnResize'; GridFeatureManager.registerFeature(ColumnResize, true);

//TODO: Context menu should hide when clicking elsewhere

/**
 * @module Grid/feature/ContextMenu
 */

/**
 * Right click to display context menu for headers and cells. Items for the menu are requested by calling
 * {@link Grid.view.Grid#function-getHeaderMenuItems Grid.getHeaderMenuItems()} or
 * {@link Grid.view.Grid#function-getCellMenuItems Grid.getCellMenuItems()} (see {@link Grid.feature.Sort Sort} feature).
 * It is also possible to add items via the features config and via column configs. See examples below.
 *
 * Add extra items to both header and cell for all columns:
 *
 * ```javascript
 * // Extra items for all columns
 * const grid = new Grid({
 *   features: {
 *     contextMenu: {
 *       headerItems: [
 *         { text: 'My header item', icon: 'fa fa-car', weight: 200, onItem : () => ... }
 *       ],
 *
 *       cellItems: [
 *         { text: 'My cell item', icon: 'fa fa-bus', weight: 200, onItem : () => ... }
 *       ]
 *     }
 *   }
 * });
 * ```
 *
 * Add extra items to both header and cell for a single column:
 *
 * ```javascript
 * // Extra items for single column
 * const grid = new Grid({
 *   columns: [
 *     { field: 'name', text: 'Name', headerMenuItems: [
 *       { text: 'My unique header item', icon: 'fa fa-flask', onItem : () => ... }
 *     ]},
 *     { field: 'city', text: 'City', cellMenuItems: [
 *       { text: 'My unique cell item', icon: 'fa fa-beer', onItem : () => ... }
 *     ]},
 *   ]
 * });
 * ```
 *
 * It is also possible to manipulate the default items and add new ones in a processing function (same pattern applies
 * for header menu):
 *
 * ```javascript
 * const grid = new Grid({
 *   features: {
 *     contextMenu: {
 *       processCellItems({items, record}) {
 *           if (record.cost > 5000) {
 *              items.push({ text : 'Split cost' });
 *           }
 *       }
 *     }
 *   }
 * });
 * ```
 *
 * This feature is <strong>enabled</strong> by default.
 *
 * @extends Core/mixin/InstancePlugin
 * @demo Grid/filtering
 * @classtype contextMenu
 * @externalexample feature/ContextMenu.js
 */
class ContextMenu extends InstancePlugin {
    //region Config

    static get $name() {
        return 'ContextMenu';
    }

    static get defaultConfig() {
        return {
            /**
             * Extra items to add to the header context menu. See {@link Core.widget.MenuItem} for more info.
             *
             * ```javascript
             * features : {
             *     contextMenu : {
             *         headerItems : [
             *             { text : 'Header item', onItem : () => ... }
             *         ]
             *     }
             * }
             * ```
             *
             * @config {Object[]}
             */
            headerItems : [],

            /**
             * A function called before displaying the header menu that allows manipulations of its items. Called with a
             * single parameter with format { column, items }. Returning `false` from this function prevents
             * the menu from being shown.
             *
             * ```javascript
             * features : {
             *     contextMenu : {
             *         processHeaderItems({record, items}) {
             *             // Add or remove items here as needed
             *             if (column.field === 'age') {
             *                 items.push({ text: 'Hide youngsters', icon : 'b-fa b-fa-fw b-fa-baby' })
             *             }
             *         }
             *     }
             * }
             * ```
             *
             * @config {Function}
             */
            processHeaderItems : null,

            /**
             * Extra items to add to the cell context menu. See {@link Core.widget.MenuItem} for more info.
             *
             * ```javascript
             * features : {
             *     contextMenu : {
             *         cellItems : [
             *             { text : 'Cell item', onItem : () => ... }
             *         ]
             *     }
             * }
             * ```
             *
             * @config {Object[]}
             */
            cellItems : [],

            /**
             * A function called before displaying the cell menu that allows manipulations of its items. Called with a
             * single parameter with format { record, items }. Returning `false` from this function prevents
             * the menu from being shown.
             *
             * ```javascript
             * features : {
             *     contextMenu : {
             *         processCellItems({record, items}) {
             *             // Add or remove items here as needed
             *             if (record.age > 50) {
             *                 items.push({ text: 'Add extra vacation', icon : 'b-fa b-fa-fw b-fa-umbrella-beach' })
             *             }
             *         }
             *     }
             * }
             * ```
             *
             * @config {Function}
             */
            processCellItems : null,

            /**
             * Event which is used to show context menu.
             * Available options are: 'contextmenu', 'click', 'dblclick'.
             * Default value is used from {@link Grid/view/Grid#config-contextMenuTriggerEvent}
             * @config {String}
             */
            triggerEvent : null,
    
            // Private config to disable context menu for cells, raised when
            // taskContextMenu is enabled
            disableCellContextMenu : null
        };
    }

    //endregion

    //region Events

    /**
     * Fired from grid before the context menu is shown for a header. Allows manipulation of the items
     * to show in the same way as in `processHeaderItems`. Returning false from a listener prevents the
     * menu from being shown.
     * @event headerContextMenuBeforeShow
     * @preventable
     * @param {Grid.view.Grid} source
     * @param {Object} items Menu item configs
     * @param {Grid.column.Column} column Column
     */

    /**
     * Fired from grid after showing the context menu for a header
     * @event headerContextMenuShow
     * @preventable
     * @param {Grid.view.Grid} source
     * @param {Core.widget.Menu} menu The menu
     * @param {Grid.column.Column} column Column
     */

    /**
     * Fired from grid before the context menu is shown for a cell. Allows manipulation of the items
     * to show in the same way as in `processCellItems`. Returning false from a listener prevents the
     * menu from being shown.
     * @event cellContextMenuBeforeShow
     * @preventable
     * @param {Grid.view.Grid} source
     * @param {Object} items Menu item configs
     * @param {Grid.column.Column} column Column
     * @param {Core.data.Model} record Record
     */

    /**
     * Fired from grid after showing the context menu for a cell
     * @event cellContextMenuShow
     * @preventable
     * @param {Grid.view.Grid} source
     * @param {Core.widget.Menu} menu The menu
     * @param {Grid.column.Column} column Column
     * @param {Core.data.Model} record Record
     */

    /**
     * Fired when an item is selected in the context menu.
     * @event contextMenuItem
     * @param {Grid.view.Grid} grid The grid
     * @param {Object} item Selected menu item
     * @param {Grid.column.Column} column Column
     * @param {HTMLElement} itemEl Menu item element
     */

    /**
     * Fired when an check item is toggled in the context menu.
     * @event contextMenuToggleItem
     * @param {Grid.view.Grid} grid The grid
     * @param {Object} item Selected menu item
     * @param {Grid.column.Column} column Column
     * @param {Boolean} checked Checked or not
     * @param {HTMLElement} itemEl Menu item element
     */

    //endregion

    //region Init

    construct(grid, config) {
        this.grid = grid;

        super.construct(grid, config);
    }

    doDestroy() {
        if (this.currentMenu) {
            this.currentMenu.destroy();
        }

        super.doDestroy();
    }

    //endregion

    //region Plugin config

    // Plugin configuration. This plugin chains some of the functions in Grid.
    // The contextmenu event is emulated from a taphold gesture on touch platforms.
    static get pluginConfig() {
        return {
            assign : ['showContextMenu'],
            chain  : [
                'onElementContextMenu',
                'onElementClick',
                'onElementDblClick',
                'onElementKeyDown'
            ]
        };
    }

    //endregion

    //region Events

    onElementContextMenu(event) {
        this.triggerEvent === 'contextmenu' && this.showContextMenu(event);
    }

    onElementClick(event) {
        this.triggerEvent === 'click' && this.showContextMenu(event);
    }

    onElementDblClick(event) {
        this.triggerEvent === 'dblclick' && this.showContextMenu(event);
    }

    onElementKeyDown(event) {
        if (!event.handled && event.target.matches('.b-grid-header.b-depth-0')) {
            switch (event.key) {
                case ' ':
                case 'ArrowDown':
                    this.showContextMenu(event);
                    break;
            }
        }
    }

    /**
     * Show context menu.
     * @param event
     * @fires contextmenuitem
     * @fires contextmenutoggleitem
     * @private
     */
    showContextMenu(event) {
        if (!this.disabled) {
            const
                header   = DomHelper.up(event.target, '.b-grid-header'),
                cellData = this.grid.getEventData(event);

            if (header) {
                this.handleHeaderContextMenu(header, event);
            }
            else if (cellData && !this.disableCellContextMenu) {
                this.handleCellContextMenu(cellData, event);
            }
        }
    }

    handleHeaderContextMenu(header, event) {
        if (header.dataset.column) {
            const
                me        = this,
                grid      = me.grid,
                column    = grid.columns.getById(header.dataset.columnId),
                setColumn = item => {
                    if (!item.column) {
                        item.column = column;
                    }

                    let menu = item.menu;
                    if (menu) {
                        if (!Array.isArray(menu)) {
                            menu = menu.items || menu.widgets;
                        }
                        menu.forEach(setColumn);
                    }
                };

            if (column.enableHeaderContextMenu !== false) {
                // User's items for all headers and for specific column correspondingly. Check Context Menu demo for details.
                const
                    items                  = [...me.headerItems, ...(column.headerMenuItems || [])],
                    { processHeaderItems } = me,
                    eventParams            = { items, column, event, element : header };

                // getHeaderMenuItems() is chained by mixins, thus each feature can supply items
                grid.getHeaderMenuItems(column, items);

                if ((!processHeaderItems || processHeaderItems(eventParams) !== false) && items.length > 0) {
                    event.preventDefault();

                    items.sort((a, b) => ((a.weight || 150) - (b.weight || 150)));

                    // Propagate the operating column down to all MenuItem levels
                    // Will not override if they are preconfigured with a column.
                    items.forEach(setColumn);

                    // Trigger event that allows preventing menu or manipulating its items
                    if (grid.trigger('headerContextMenuBeforeShow', eventParams) !== false) {
                        // Align to header element when using arrow down key
                        me.currentMenu = WidgetHelper.showContextMenu(event.type === 'keydown' ? header : [event.clientX + 1, event.clientY + 1], {
                            owner       : me.client,
                            constrainTo : document,
                            cls         : 'b-context-menu',
                            items       : items,

                            // We can only realign if we are aligning to an element.
                            scrollAction : 'hide',
                            onItem({ source, item, element }) {
                                grid.trigger('contextMenuItem', { source : grid, item, column, element });
                            },

                            onToggle({ source, item, checked, element }) {
                                grid.trigger('contextMenuToggleItem', {
                                    source : grid,
                                    item,
                                    column,
                                    checked,
                                    element
                                });
                            },

                            onDestroy() {
                                // If menu is destroyed by WidgetHelper, make sure we don't keep a reference to it anymore
                                me.currentMenu = null;
                            },

                            listeners : {
                                show({ source : menu }) {
                                    eventParams.menu = menu;
                                    grid.trigger('headerContextMenuShow', eventParams);
                                }
                            }
                        });
                    }
                }
            }
        }
    }

    handleCellContextMenu(cellData, event) {
        const
            me = this,
            grid = me.grid,
            cell = cellData.cellElement,
            column   = grid.columns.getById(cellData.columnId);

        if (column.enableCellContextMenu !== false) {

            // Process the gesture as navigation so that the use may select/multiselect
            // the items to include in their context menu operation.
            // Also select if not already selected.
            grid.focusCell(cellData.cellSelector, {
                doSelect : !grid.isSelected(cellData.id),
                event
            });

            const
                record = cellData.record,
                items  = [...(me.cellItems || []), ...(column.cellMenuItems || [])],
                { processCellItems } = me,
                eventParams            = { items, column, event, record, element : cell };

            // getCellMenuItems() is chained by mixins, thus each feature can supply items
            grid.getCellMenuItems(column, record, items);

            if ((!processCellItems || processCellItems(eventParams) !== false) && items.length > 0) {

                items.forEach(item => {
                    item.column = column;
                    item.record = record;
                });

                event.preventDefault();

                items.sort((a, b) => ((a.weight || 150) - (b.weight || 150)));

                // Trigger event that allows preventing menu or manipulating its items
                if (grid.trigger('cellContextMenuBeforeShow', eventParams) !== false) {
                    me.currentMenu = WidgetHelper.showContextMenu([event.clientX + 1, event.clientY + 1], {
                        owner : me.client,
                        items : items,

                        // Load up the item event with the contextual info
                        onBeforeItem : itemEvent => {
                            Object.assign(itemEvent, eventParams);
                        },

                        onItem({ item }) {
                            grid.trigger('contextMenuItem', { source : grid, item, column, record, cell });
                        },

                        onClose({ reason }) {
                            // return focus to grid when context menu is closed, if not cause by clicking outside of grid
                            if (reason !== 'outside') {
                                grid.element.focus();
                            }
                        },

                        onDestroy() {
                            // If menu is destroyed by WidgetHelper, make sure we don't keep a reference to it anymore
                            me.currentMenu = null;
                        },

                        listeners : {
                            show({ source : menu }) {
                                eventParams.menu = menu;
                                grid.trigger('cellContextMenuShow', eventParams);
                            }
                        }
                    });
                }
            }
        }
    }

    /**
     * Hides the context menu
     * @protected
     * @internal
     */
    hideContextMenu(animate) {
        this.currentMenu && this.currentMenu.hide(animate);
    }

    //endregion

    //region Getters/Setters

    get triggerEvent() {
        return this._triggerEvent || this.client.contextMenuTriggerEvent;
    }

    set triggerEvent(value) {
        this._triggerEvent = value;
    }

    //endregion

}

ContextMenu.featureClass = '';

ContextMenu._$name = 'ContextMenu'; GridFeatureManager.registerFeature(ContextMenu, true);

//TODO: Format value in header filter tooltip (see date)

/**
 * @module Grid/feature/Filter
 */

/**
 * Feature that allows filtering of the grid by settings filters on columns. The actual filtering is done by the store.
 * For info on programmatically handling filters, see {@link Core.data.mixin.StoreFilter StoreFilter}.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @example
 * // Filtering turned on but no default filter
 * let grid = new Grid({
 *   features : {
 *     filter : true
 *   }
 * });
 *
 * // Using default filter
 * let grid = new Grid({
 *   features : {
 *     filter : { property : 'city', value : 'Gavle' }
 *   }
 * });
 *
 * // Custom filtering function for a column
 * let grid = new Grid({
 *    features : {
 *        filter : true
 *    },
 *
 *    columns: [
 *        {
 *          field      : 'age',
 *          text       : 'Age',
 *          type       : 'number',
 *          // Custom filtering function that checks "greater than" no matter which field user filled in :)
 *          filterable : ({ record, value, operator }) => record.age > value
 *        }
 *    ]
 * });
 *
 * @demo Grid/filtering
 * @classtype filter
 * @externalexample feature/Filter.js
 */
class Filter extends InstancePlugin {
    //region Init

    static get $name() {
        return 'Filter';
    }

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            chain : ['renderHeader', 'getCellMenuItems', 'getHeaderMenuItems', 'onElementClick']
        };
    }

    construct(grid, config) {
        const me = this;

        me.grid = grid;
        me.store = grid.store;
        me.closeFilterEditor = me.closeFilterEditor.bind(me);

        super.construct(grid, config);

        me.store.on({ filter : me.onStoreFilter }, me);

        if (config && typeof config === 'object') {
            me.store.filter(config, null, me.client.isConfiguring);
        }
    }

    //endregion

    //region Plugin config

    doDestroy() {
        const me = this;

        me.filterTip && me.filterTip.destroy();
        me.filterEditorPopup && me.filterEditorPopup.destroy();

        me.store.un({ sort : me.onStoreFilter }, me);

        super.doDestroy();
    }

    //endregion

    //region Refresh headers

    /**
     * Update headers to match stores filters. Called on store load and grid header render.
     * @param reRenderRows Also refresh rows?
     * @private
     */
    refreshHeaders(reRenderRows) {
        const
            me      = this,
            grid    = me.grid,
            element = grid.headerContainer;

        if (element) {
            // remove .latest from all filters, will be applied to actual latest
            DomHelper.children(element, '.b-filter-icon.b-latest').forEach(iconElement => iconElement.classList.remove('b-latest'));

            if (!me.filterTip) {
                me.filterTip = new Tooltip({
                    forElement  : element,
                    forSelector : '.b-filter-icon',
                    getHtml({ activeTarget }) {
                        return activeTarget.dataset.filterText;
                    }
                });
            }

            for (const column of grid.columns) {
                if (column.filterable !== false) {
                    const
                        filter   = me.store.filters.getBy('property', column.field),
                        headerEl = column.element;

                    if (headerEl) {
                        const textEl = column.textWrapper;

                        let filterIconEl = textEl && textEl.querySelector('.b-filter-icon'),
                            filterText;

                        if (filter) {
                            filterText = me.L('filter') + ': ' + (typeof filter === 'string'
                                ? filter
                                : `${filter.operator} ${filter.displayValue || filter.value || ''}`);
                            //TODO: filter.value needs to be formatted using column format or something
                        }
                        else {
                            filterText = me.L('applyFilter');
                        }

                        if (!filterIconEl) {
                            // putting icon in header text to have more options for positioning it
                            filterIconEl = DomHelper.createElement({
                                parent    : textEl,
                                tag       : 'div',
                                className : 'b-filter-icon',
                                dataset   : {
                                    filterText : filterText
                                }
                            });
                            headerEl.classList.add('b-filterable');
                        }
                        else {
                            filterIconEl.dataset.filterText = filterText;
                        }

                        // latest applied filter distinguished with class to enable highlighting etc.
                        if (column.field === me.store.latestFilterField) filterIconEl.classList.add('b-latest');

                        headerEl.classList[filter ? 'add' : 'remove']('b-filter');
                        // When IE11 support is dropped
                        // headerEl.classList.toggle('b-filter', !!filter);
                    }

                    column.meta.isFiltered = !!filter;
                }
            }

            if (reRenderRows) {
                grid.refreshRows();
            }
        }
    }

    //endregion

    //region Filter

    applyFilter(config) {
        const
            { store } = this,
            column    = this.grid.columns.get(config.property);

        if (typeof column.filterable === 'function') {
            store.filter({
                filterBy     : record => column.filterable(Object.assign({}, config, { record })),
                // To be able to retrieve the value next time filtering popup is shown, not actually used by the filter
                value        : config.value,
                property     : config.property,
                operator     : config.operator,
                displayValue : config.displayValue
            });
        }
        else {
            store.filter(config);
        }
    }

    // TODO: break out as own views, registering with Filter the same way columns register with ColumnManager

    getPopupDateItems(fieldType, filter, initialValue, field, store, changeCallback, closeCallback) {
        const
            me      = this,
            onClose = changeCallback,
            onClear = closeCallback;

        function onChange({ source, value }) {
            if (value == null) {
                closeCallback();
            }
            else {
                me.applyFilter({ property : field, operator : source.operator, value, displayValue : source._value });
                changeCallback();
            }
        }

        return [{
            type        : 'date',
            ref         : 'on',
            placeholder : me.L('on'),
            clearable   : true,
            label       : '<i class="b-fw-icon b-icon-filter-equal"></i>',
            value       : filter && filter.operator === '=' ? filter.value : initialValue,
            operator    : '=',
            onChange,
            onClose,
            onClear
        }, {
            type        : 'date',
            ref         : 'before',
            placeholder : me.L('before'),
            clearable   : true,
            label       : '<i class="b-fw-icon b-icon-filter-before"></i>',
            value       : filter && filter.operator === '<' ? filter.value : null,
            operator    : '<',
            onChange,
            onClose,
            onClear
        }, {
            type        : 'date',
            ref         : 'after',
            cls         : 'b-last-row',
            placeholder : me.L('after'),
            clearable   : true,
            label       : '<i class="b-fw-icon b-icon-filter-after"></i>',
            value       : filter && filter.operator === '>' ? filter.value : null,
            operator    : '>',
            onChange,
            onClose,
            onClear
        }];
    }

    getPopupNumberItems(fieldType, filter, initialValue, field, store, changeCallback, closeCallback) {
        const
            me      = this,
            onEsc   = changeCallback,
            onClear = closeCallback;

        function onChange({ source, value }) {
            if (value == null) {
                closeCallback();
            }
            else {
                me.applyFilter({ property : field, operator : source.operator, value });
                changeCallback();
            }
        }

        return [{
            type        : 'number',
            placeholder : me.L('equals'),
            clearable   : true,
            label       : '<i class="b-fw-icon b-icon-filter-equal"></i>',
            value       : filter && filter.operator === '=' ? filter.value : initialValue,
            operator    : '=',
            onChange,
            onEsc,
            onClear
        }, {
            type        : 'number',
            placeholder : me.L('lessThan'),
            clearable   : true,
            label       : '<i class="b-fw-icon b-icon-filter-less"></i>',
            value       : filter && filter.operator === '<' ? filter.value : null,
            operator    : '<',
            onChange,
            onEsc,
            onClear
        }, {
            type        : 'number',
            cls         : 'b-last-row',
            placeholder : me.L('moreThan'),
            clearable   : true,
            label       : '<i class="b-fw-icon b-icon-filter-more"></i>',
            value       : filter && filter.operator === '>' ? filter.value : null,
            operator    : '>',
            onChange,
            onEsc,
            onClear
        }];
    }

    getPopupStringItems(fieldType, filter, initialValue, field, store, changeCallback, closeCallback) {
        const me = this;

        return [{
            type        : fieldType,
            cls         : 'b-last-row',
            placeholder : me.L('filter'),
            clearable   : true,
            label       : '<i class="b-fw-icon b-icon-filter-equal"></i>',
            value       : filter ? filter.value || filter : initialValue,
            onChange    : ({ value }) => {
                if (value === '') {
                    closeCallback();
                }
                else {
                    me.applyFilter({ property : field, value });
                    changeCallback();
                }
            },
            onClose : changeCallback,
            onClear : closeCallback
        }];
    }

    /**
     * Get fields to display in filter popup.
     * @param fieldType Type of field, number, date etc.
     * @param filter Current filter filter
     * @param initialValue
     * @param field Column
     * @param store Grid store
     * @param changeCallback Callback for when filter has changed
     * @param closeCallback Callback for when editor should be closed
     * @returns {*}
     * @private
     */
    getPopupItems(fieldType, filter, initialValue, field, store, changeCallback, closeCallback) {
        switch (fieldType) {
            case 'date':
                return this.getPopupDateItems(...arguments);
            case 'number':
                return this.getPopupNumberItems(...arguments);
            default:
                return this.getPopupStringItems(...arguments);
        }
    }

    /**
     * Shows a popup where a filter can be edited.
     * @param {Grid.column.Column} column Column to show filter editor for
     * @param {*} value Value to init field with
     */
    showFilterEditor(column, value) {
        const
            me        = this,
            { store } = me,
            col       = typeof column === 'string' ? me.grid.columns.getById(column) : column,
            headerEl  = col.element,
            field     = store.modelClass.fieldMap[col.field],
            filter    = store.filters.getBy('property', col.field),
            type      = field && field.type || col.filterType || col.type || 'string',
            fieldType = {
                'string' : 'text',
                'number' : 'number',
                'date'   : 'date'
            }[type] || 'text';

        if (col.filterable === false) {
            return;
        }

        // Destroy previous filter popup
        me.closeFilterEditor();

        me.filterEditorPopup = WidgetHelper.openPopup(headerEl, {
            owner        : this.grid,
            width        : '16em',
            cls          : 'b-filter-popup',
            scrollAction : 'realign',
            items        : me.getPopupItems(
                fieldType,
                filter,
                value,
                col.field,
                me.store,
                me.closeFilterEditor,
                () => {
                    me.store.removeFieldFilter(col.field);
                    me.closeFilterEditor();
                }
            )
        });
    }

    /**
     * Close the filter editor.
     */
    closeFilterEditor() {
        const me = this;

        // Must defer the destroy because it may be closed by an event like a "change" event where
        // there may be plenty of code left to execute which must not execute on destroyed objects.
        me.filterEditorPopup && me.filterEditorPopup.setTimeout(me.filterEditorPopup.destroy);
        me.filterEditorPopup = null;
    }

    //endregion

    //region Context menu

    //TODO: break out together with getPopupXXItems() (see comment above)

    getMenuDateItems(column, record) {
        const
            me     = this,
            value  = record[column.field],
            filter = operator => {
                me.applyFilter({
                    property     : column.field,
                    operator,
                    value,
                    displayValue : column.formatValue ? column.formatValue(value) : value
                });
            };

        return [{
            text     : me.L('on'),
            icon     : 'b-fw-icon b-icon-filter-equal',
            cls      : 'b-separator',
            name     : 'filterDateEquals',
            disabled : me.disabled,
            onItem   : () => filter('=')
        }, {
            text     : me.L('before'),
            icon     : 'b-fw-icon b-icon-filter-before',
            name     : 'filterDateBefore',
            disabled : me.disabled,
            onItem   : () => filter('<')
        }, {
            text     : me.L('after'),
            icon     : 'b-fw-icon b-icon-filter-after',
            name     : 'filterDateAfter',
            disabled : me.disabled,
            onItem   : () => filter('>')
        }];
    }

    getMenuNumberItems(column, record) {
        const
            me     = this,
            filter = operator => {
                me.applyFilter({
                    property : column.field,
                    operator : operator,
                    value    : record[column.field]
                });
            };

        return [{
            text     : me.L('equals'),
            icon     : 'b-fw-icon b-icon-filter-equal',
            cls      : 'b-separator',
            name     : 'filterNumberEquals',
            disabled : me.disabled,
            onItem   : () => filter('=')
        }, {
            text     : me.L('lessThan'),
            icon     : 'b-fw-icon b-icon-filter-less',
            name     : 'filterNumberLess',
            disabled : me.disabled,
            onItem   : () => filter('<')
        }, {
            text     : me.L('moreThan'),
            icon     : 'b-fw-icon b-icon-filter-more',
            name     : 'filterNumberMore',
            disabled : me.disabled,
            onItem   : () => filter('>')
        }];
    }

    getMenuStringItems(column, record) {
        return [{
            text     : this.L('equals'),
            icon     : 'b-fw-icon b-icon-filter-equal',
            cls      : 'b-separator',
            name     : 'filterStringEquals',
            disabled : this.disabled,
            onItem   : () => {
                this.applyFilter({ property : column.field, value : record[column.field] });
            }
        }];
    }

    /**
     * Add menu items for filtering, depending on filter type etc.
     * @param column
     * @param record
     * @param items
     * @returns {Object[]}
     * @private
     */
    getCellMenuItems(column, record, items) {
        const
            me    = this,
            field = record.getFieldDefinition(column.field);

        if (column.filterable !== false) {
            const filterItems = [];

            if (column.meta.isFiltered) {
                filterItems.push({
                    text     : me.L('removeFilter'),
                    icon     : 'b-fw-icon b-icon-clear',
                    cls      : 'b-separator',
                    name     : 'filterRemove',
                    disabled : me.disabled,
                    onItem() {
                        me.store.removeFieldFilter(column.field);
                    }
                });
            }

            switch (column.filterType || column.type || (field && field.type)) {
                case 'date':
                    filterItems.push(...me.getMenuDateItems(...arguments));
                    break;
                case 'number':
                    filterItems.push(...me.getMenuNumberItems(...arguments));
                    break;
                default:
                    filterItems.push(...me.getMenuStringItems(...arguments));
                    break;
            }

            // remove separator from second item if filtered
            if (column.meta.isFiltered && filterItems.length > 1) {
                filterItems[1].cls = '';
            }

            items.push(...filterItems);
        }
    }

    /**
     * Add menu item for removing filter if column is filtered.
     * @private
     * @param column Column
     * @param items Menu items
     * @returns {Object[]}
     */
    getHeaderMenuItems(column, items) {
        const me = this;

        if (column.meta.isFiltered) {
            items.push({
                text     : me.L('editFilter'),
                name     : 'editFilter',
                icon     : 'b-fw-icon b-icon-filter',
                cls      : 'b-separator',
                disabled : me.disabled,
                onItem() {
                    me.showFilterEditor(column);
                }
            });
            items.push({
                text     : me.L('removeFilter'),
                name     : 'removeFilter',
                icon     : 'b-fw-icon b-icon-remove',
                disabled : me.disabled,
                onItem() {
                    me.store.removeFieldFilter(column.field);
                }
            });
        }
        else if (column.filterable !== false) {
            items.push({
                text     : me.L('filter'),
                name     : 'filter',
                icon     : 'b-fw-icon b-icon-filter',
                cls      : 'b-separator',
                disabled : me.disabled,
                onItem() {
                    me.showFilterEditor(column);
                }
            });
        }
    }

    //endregion

    //region Events

    /**
     * Store filtered; refresh headers.
     * @private
     */
    onStoreFilter() {
        // Pass false to not refresh rows.
        // Store's refresh event will refresh the rows.
        this.refreshHeaders(false);
    }

    /**
     * Called after headers are rendered, make headers match stores initial sorters
     * @private
     */
    renderHeader() {
        this.refreshHeaders(false);
    }

    /**
     * Called when user clicks on the grid. Only care about clicks on the filter icon.
     * @param {MouseEvent} event
     * @private
     */
    onElementClick(event) {
        const target = event.target;

        if (this.filterEditorPopup) this.closeFilterEditor();

        // Checks if click is on node expander icon, then toggles expand/collapse
        if (target.classList.contains('b-filter-icon')) {
            const headerEl = DomHelper.up(target, '.b-grid-header');

            this.showFilterEditor(headerEl.dataset.columnId);
            return false;
        }
    }

    //endregion
}

Filter._$name = 'Filter'; GridFeatureManager.registerFeature(Filter);

/**
 * @module Grid/feature/FilterBar
 */

/**
 * Feature that allows filtering of the grid by entering filters on column headers.
 * The actual filtering is done by the store.
 * For info on programmatically handling filters, see {@link Core.data.mixin.StoreFilter StoreFilter}.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * The individual filterability of columns is defined by a `filterable`
 * property on the column which defaults to `true`. If `false`, that column
 * is not filterable.
 *
 * The property value may also be a custom filter function.
 *
 * The property value may also be an object which may contain the following two properties:
 *  - **filterFn** : `Function` A custom filtering function
 *  - **filterField** : `Object` A config object for the filter value input field.
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @example
 * // filtering turned on but no default filter
 * let grid = new Grid({
 *   features: {
 *     filterBar : true
 *   }
 * });
 *
 * @example
 * // using default filter
 * let grid = new Grid({
 *   features : {
 *     filterBar : { filter: { property : 'city', value : 'Gavle' } }
 *   }
 * });
 *
 * @example
 * // Custom filtering function for a column
 * let grid = new Grid({
 *   features : {
 *     filter : true
 *   },
 *
 *   columns: [
 *      {
 *        field      : 'age',
 *        text       : 'Age',
 *        type       : 'number',
 *        // Custom filtering function that checks "greater than"
 *        filterable : ({ record, value }) => record.age > value
 *      },
 *      {
 *        field : 'name',
 *        // Filterable may specify a filterFn and a config for the filtering input field
 *        filterable : {
 *          filterFn : ({ record, value }) => record.name.toLowerCase().indexof(value.toLowerCase()) !== -1,
 *          filterField : {
 *            emptyText : 'Filter name'
 *          }
 *        }
 *      },
 *      {
 *        field : 'city',
 *        text : 'Visited',
 *        flex : 1,
 *        // Filterable with multiselect combo to pick several items to filter
 *        filterable : {
 *          filterField : {
 *            type        : 'combo',
 *            multiSelect : true,
 *            items       : ['Barcelona', 'Moscow', 'Stockholm']
 *          },
 *          filterFn    : ({ record, value }) => !value.length || value.includes(record.city)
 *        }
 *      }
 *   ]
 * });
 *
 * @demo Grid/filterbar
 * @classtype filterBar
 * @externalexample feature/FilterBar.js
 */
class FilterBar extends InstancePlugin {
    //region Default config
    static get $name() {
        return 'FilterBar';
    }

    static get defaultConfig() {
        return {
            /**
             * The delay in milliseconds to wait after the last keystroke before applying filters.
             * Set to 0 to not trigger filtering from keystrokes, requires pressing ENTER instead
             * @config {Number}
             * @default
             */
            keyStrokeFilterDelay : 300,

            // Destroying data level filters when we hiding UI is supposed to be optional someday. So far this flag is private
            clearStoreFiltersOnHide : true
        };
    }

    //endregion

    //region Init

    construct(grid, config) {
        const me = this;

        Object.assign(me, {
            filterFieldCls           : 'b-filter-bar-field',
            filterFieldInputCls      : 'b-filter-bar-field-input',
            filterableColumnCls      : 'b-filter-bar-enabled',
            filterFieldInputSelector : '.b-filter-bar-field-input',
            filterableColumnSelector : '.b-filter-bar-enabled',
            filterParseRegExp        : /^\s*([<>=*])?(.*)$/,
            storeTrackingSupended    : 0,
            store                    : grid.store,
            grid                     : grid
        });

        me.onColumnFilterFieldChange = me.onColumnFilterFieldChange.bind(me);

        super.construct(grid, Array.isArray(config) ? {
            filter : config
        } : config);

        me.store.on({
            filter  : me.onStoreFilter,
            thisObj : me
        });

        if (me.filter) {
            me.store.filter(me.filter);
        }

        me.gridDetacher = grid.on('beforeelementclick', me.onBeforeElementClick, me);
    }

    doDestroy() {
        const me = this;

        me.destroyFilterBar();
        me.gridDetacher && me.gridDetacher();

        super.doDestroy();
    }

    doDisable(disable) {
        const { columns } = this.grid;

        // hide the fields, each silently - no updating of the store's filtered state until the end
        columns && columns.forEach(column => {
            const widget = this.getColumnFilterField(column);
            if (widget) {
                widget.disabled = disable;
            }
        });

        super.doDisable(disable);
    }

    static get pluginConfig() {
        return {
            before : ['onElementKeyDown'],
            chain  : ['renderHeader', 'getHeaderMenuItems']
        };
    }

    //endregion

    //region FilterBar

    destroyFilterBar() {
        this.grid.columns && this.grid.columns.forEach(this.destroyColumnFilterField, this);
    }

    /**
     * Hides the filtering fields.
     */
    hideFilterBar() {
        const
            me      = this,
            columns = me.grid.columns;

        // we don't want to hear back store "filter" event while we're resetting store filters
        me.clearStoreFiltersOnHide && me.suspendStoreTracking();

        // hide the fields, each silently - no updating of the store's filtered state until the end
        columns && columns.forEach(col => me.hideColumnFilterField(col, true));

        // Now update the filtered state
        me.grid.store.filter();

        me.clearStoreFiltersOnHide && me.resumeStoreTracking();

        me.hidden = true;
    }

    /**
     * Shows the filtering fields.
     */
    showFilterBar() {
        this.renderFilterBar();

        this.hidden = false;
    }

    /**
     * Toggles the filtering fields visibility.
     */
    toggleFilterBar() {
        const me = this;

        if (me.hidden) {
            me.showFilterBar();
        }
        else {
            me.hideFilterBar();
        }
    }

    /**
     * Renders the filtering fields for filterable columns.
     * @private
     */
    renderFilterBar() {
        this.grid.columns.visibleColumns.forEach(column => this.renderColumnFilterField(column));
        this.rendered = true;
    }

    //endregion

    //region FilterBar fields

    /**
     * Renders text field filter in the provided column header.
     * @param {Grid.column.Column} column Column to render text field filter for.
     * @private
     */
    renderColumnFilterField(column) {
        const
            me         = this,
            grid       = me.grid,
            filterable = me.getColumnFilterable(column);

        // we render fields for filterable columns only
        if (filterable && !column.hidden) {
            const headerEl = column.element;

            let widget = me.getColumnFilterField(column);

            // if we don't haven't created a field yet
            // we build it from scratch
            if (!widget) {
                const
                    filter = grid.store.filters.getBy('property', column.field),
                    type   = `${column.filterType || 'text'}field`;

                widget = WidgetHelper.append(Object.assign({
                    type,
                    owner                : me.grid,
                    clearable            : true,
                    column               : column,
                    name                 : column.field,
                    value                : filter && me.buildFilterString(filter),
                    cls                  : me.filterFieldCls,
                    inputCls             : me.filterFieldInputCls,
                    keyStrokeChangeDelay : me.keyStrokeFilterDelay,
                    onChange             : me.onColumnFilterFieldChange,
                    onClear              : me.onColumnFilterFieldChange,
                    disabled             : me.disabled
                }, filterable.filterField), headerEl)[0];

                me.setColumnFilterField(column, widget);
            }
            // if we have one..
            else {
                // re-apply widget filter
                me.onColumnFilterFieldChange({ source : widget, value : widget.value });
                // re-append the widget to its parent node (in case the column header was redrawn (happens when resizing columns))
                widget.render(headerEl);
                // show widget in case it was hidden
                widget.show();
            }

            headerEl.classList.add(me.filterableColumnCls);
        }
    }

    /**
     * Fills in column filter fields with values from the grid store filters.
     * @private
     */
    updateColumnFilterFields() {
        const
            me   = this,
            grid = me.grid;

        let field, filter;

        for (const column of grid.columns) {
            field = me.getColumnFilterField(column);
            if (field) {
                filter = grid.store.filters.getBy('property', column.field);
                field.value = filter && me.buildFilterString(filter) || '';
            }
        }
    }

    getColumnFilterable(column) {
        if (!column.isRoot && column.filterable !== false && column.field) {
            if (typeof column.filterable === 'function') {
                column.filterable = {
                    filterFn : column.filterable
                };
            }
            return column.filterable;
        }
    }

    destroyColumnFilterField(column) {
        const me     = this,
            widget = me.getColumnFilterField(column);

        if (widget) {
            me.hideColumnFilterField(column);
            // destroy filter UI field
            widget.destroy();
            // remember there is no field bound anymore
            me.setColumnFilterField(column, undefined);
        }
    }

    hideColumnFilterField(column, silent) {
        const me       = this,
            store    = me.grid.store,
            columnEl = column.element,
            widget   = me.getColumnFilterField(column);

        if (widget) {
            // hide field
            widget.hide();

            if (me.clearStoreFiltersOnHide && column.field) {
                store.removeFieldFilter(column.field, silent);
            }

            columnEl.classList.remove(me.filterableColumnCls);
        }
    }

    getColumnFilterField(column) {
        return this._columnFilters && this._columnFilters[column.data.id];
    }

    setColumnFilterField(column, widget) {
        this._columnFilters = this._columnFilters || {};

        this._columnFilters[column.data.id] = widget;
    }

    //endregion

    //region Filters

    parseFilterValue(value) {
        const match = String(value).match(this.filterParseRegExp);

        return {
            operator : match[1] || '*',
            value    : match[2]
        };
    }

    buildFilterString(filter) {
        let result;

        if (filter && !filter.initialConfig.filterBy) {
            result = (filter.operator === '*' ? '' : filter.operator) + filter.value;
        }

        return result;
    }

    //endregion

    // region Events

    /**
     * Fires when store gets filtered. Refreshes field values in column headers.
     * @private
     */
    onStoreFilter() {
        if (!this.storeTrackingSupended && this.rendered) {
            this.updateColumnFilterFields();
        }
    }

    suspendStoreTracking() {
        this.storeTrackingSupended++;
    }

    resumeStoreTracking() {
        this.storeTrackingSupended--;
    }

    /**
     * Called after headers are rendered, make headers match stores initial sorters
     * @private
     */
    renderHeader() {
        this.renderFilterBar();
    }

    onElementKeyDown(event) {
        const me = this;

        // flagging event with handled = true used to signal that other features should probably not care about it
        if (event.handled) return;

        // if we are pressing left/right arrow keys while being in a filter editor
        // we set event.handled flag (otherwise other features prevent the event)
        if (event.target.matches(me.filterFieldInputSelector)) {
            switch (event.key) {
                case 'ArrowLeft':
                case 'ArrowRight':
                    event.handled = true;
            }
        }
    }

    onBeforeElementClick({ event }) {
        const me = this;

        // prevent other features reacting when clicking a filter field (or any element inside it)
        if (event.target.closest('.' + me.filterFieldCls)) {
            return false;
        }
    }

    /**
     * Called when a column text filter field value is changed by user.
     * @param  {TextField} field Filter text field.
     * @param  {String} value New filtering value.
     * @private
     */
    onColumnFilterFieldChange({ source : field, value }) {
        const me   = this,
            store = me.grid.store,
            filterable = me.getColumnFilterable(field.column);

        // we don't want to hear back store "filter" event
        // so we suspend store tracking
        me.suspendStoreTracking();

        if (value == null || value === '' || Array.isArray(value) && value.length === 0) {
            // remove filter if setting to empty
            store.removeFieldFilter(field.name);
        }
        else if (filterable.filterFn) {
            store.filter({
                filterBy : record => filterable.filterFn({ property : field.name, value, record }),
                // To be able to clear the filter
                property : field.name
            });
        }
        else {
            store.filter(Object.assign({
                property : field.name
            }, me.parseFilterValue(value)));
        }

        me.resumeStoreTracking();
    }

    //endregion

    //region Menu items

    /**
     * Adds a menu item to toggle filter bar visibility.
     * @param column Column
     * @param items Menu items
     * @returns {Object[]} Menu items.
     * @private
     */
    getHeaderMenuItems(column, items) {
        const me = this;

        items.push({
            text   : me.L(me.hidden ? 'enableFilterBar' : 'disableFilterBar'),
            name   : 'toggleFilterBar',
            icon   : 'b-fw-icon b-icon-filter',
            cls    : 'b-separator',
            onItem : () => me.toggleFilterBar()
        });
    }

    //endregion
}

FilterBar.featureClass = 'b-filter-bar';

FilterBar._$name = 'FilterBar'; GridFeatureManager.registerFeature(FilterBar);

//TODO: Expand function?

/**
 * @module Grid/feature/Group
 */

/**
 * Enables rendering and handling of row groups. The actual grouping is done in the store, but triggered by [shift] +
 * clicking headers or by using two finger tap (one on header, one anywhere on grid). Groups can be expanded/collapsed
 * by clicking on the group row or pressing [space] when group row is selected.
 * The actual grouping is done by the store, see {@link Core.data.mixin.StoreGroup#function-group}.
 *
 * Grouping by a field performs sorting by the field automatically. It's not possible to prevent sorting.
 * If you group, the records have to be sorted so that records in a group stick together. You can either control sorting
 * direction, or provide a custom sorting function called `fn` to your grouper.
 *
 * For info on programmatically handling grouping, see {@link Core.data.mixin.StoreGroup StoreGroup}.
 *
 * This feature is **enabled** by default.
 *
 * @example
 * // grouping feature is enabled, no default value though
 * let grid = new Grid({
 *     features : {
 *         group : true
 *     }
 * });
 *
 * // use initial grouping
 * let grid = new Grid({
 *     features : {
 *         group : 'city'
 *     }
 * });
 *
 * // default grouper and custom renderer, which will be applied to each cell except the "group" cell
 * let grid = new Grid({
 *   features : {
 *     group : {
 *       field : 'city',
 *       ascending : false,
 *       renderer : () => 'Text'
 *     }
 *   }
 * });
 *
 * // can also be specified on the store
 * let grid = new Grid({
 *     store : {
 *         groupers : [
 *             { field : 'city', ascending : false }
 *         ]
 *     }
 * });
 *
 * // custom sorting function can also be specified on the store
 * let grid = new Grid({
 *     store : {
 *         groupers : [{
 *             field : 'city',
 *             fn : (recordA, recordB) => {
 *                 // apply custom logic, for example:
 *                 return recordA.city.length < recordB.city.length ? -1 : 1;
 *             }
 *         }]
 *     }
 * });
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @demo Grid/grouping
 * @classtype group
 * @externalexample feature/Group.js
 */
class Group extends InstancePlugin {

    static get $name() {
        return 'Group';
    }

    static get defaultConfig() {
        return {
            /**
             * The name of the record field to group by.
             * @config {String}
             * @default
             */
            field : null,

            /**
             * A function which yields the HTML for a group header.
             * The function is called in the context of this Group feature object.
             * Default group renderer displays the `groupRowFor` and `count`.
             *
             * @config {Function}
             * @property {String} groupRowFor The value of the `field` for the group.
             * @property {Core.data.Model} record The group record representing the group.
             * @property {Object} record.meta Meta data with additional info about the grouping.
             * @property {Array} record.groupChildren The group child records.
             * @property {Number} count Number of records in the group.
             * @property {Grid.column.Column} column The column the renderer runs for.
             * @property {Boolean} isFirstColumn True, if `column` is the first column.
             * If `RowNumberColumn` is the real first column, it's not taken into account.
             * @property {Grid.column.Column} [groupColumn] The column under which the `field` is shown.
             * That is UI part, so do not rely on its existence.
             * @default
             */
            renderer : null
        };
    }

    //region Init

    construct(grid, config) {
        const me = this;

        if (grid.features.tree) {
            return;
        }

        // groupSummary feature needs to be initialized first, if it is used
        me._thisIsAUsedExpression(grid.features.groupSummary);

        // process initial config into an actual config object
        config = me.processConfig(config);

        Object.assign(me, {
            grid       : grid,
            rowManager : grid.rowManager,
            store      : grid.store
        });

        super.construct(grid, config);

        me.store.on({
            group       : me.onStoreGroup,
            groupingoff : me.onStoreGroupingOff,
            thisObj     : me
        });

        me.rowManager.on({
            rendercell : me.renderCell,
            thisObj    : me
        });
    }

    // Group feature handles special config cases, where user can supply a string or a group config object
    // instead of a normal config object
    processConfig(config) {
        if (typeof config === 'string') {
            return {
                field     : config,
                ascending : null
            };
        }

        return config;
    }

    // override setConfig to process config before applying it (used mainly from ReactGrid)
    setConfig(config) {
        if (config === null) {
            this.store.clearGroupers();
        }
        else {
            super.setConfig(this.processConfig(config));
        }
    }

    set renderer(renderer) {
        this.groupRenderer = renderer;
    }

    set field(field) {
        this._field = field;
        this.store.group(field, this.ascending);
    }

    get field() {
        return this._field;
    }

    doDestroy() {
        super.doDestroy();
    }

    doDisable(disable) {
        const { store } = this;

        // Grouping mostly happens in store, need to clear groupers there to remove headers.
        // Use configured groupers as first sorters to somewhat maintain the order
        if (disable && store.isGrouped) {
            const { sorters } = store;
            sorters.unshift(...store.groupers);
            store.clearGroupers();
            store.sort(sorters);
        }

        super.doDisable(disable);
    }

    //endregion

    //region Plugin config

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            assign : ['collapseAll', 'expandAll'],
            chain  : ['renderHeader', 'getHeaderMenuItems',
                'getColumnDragToolbarItems', 'onElementTouchStart',
                'onElementClick', 'onElementKeyDown'],
            override : [
                'onStoreDataChange'
            ]
        };
    }

    //endregion

    //region Expand/collapse

    /**
     * Collapses or expands a group depending on its current state
     * @param recordOrId Record or records id for a group row to collapse or expand
     * @param collapse Force collapse (true) or expand (true)
     * @fires togglegroup
     */
    toggleCollapse(recordOrId, collapse) {
        this.internalToggleCollapse(recordOrId, collapse);
    }

    /**
     * Collapses or expands a group depending on its current state
     * @param recordOrId Record or records id for a group row to collapse or expand
     * @param collapse Force collapse (true) or expand (true)
     * @param skipRender True to not render rows
     * @internal
     * @fires togglegroup
     */
    internalToggleCollapse(recordOrId, collapse, skipRender = false) {
        

        const
            me          = this,
            store       = me.store,
            groupRecord = store.getById(recordOrId),
            meta        = groupRecord.meta;

        if (meta.groupRowFor === undefined) return;

        collapse = collapse === undefined ? !meta.collapsed : collapse;

        if (collapse) {
            store.excludeGroupRecords(groupRecord);
        }
        else {
            store.includeGroupRecords(groupRecord);
        }

        // note to self, all this could be done in collapsed setter on GroupModel if desired...
        meta.collapsed = collapse;

        /**
         * Group expanded or collapsed
         * @event toggleGroup
         * @param groupRecord Group record
         * @param {Boolean} collapse Collapsed (true) or expanded (false)
         */
        me.grid.trigger('toggleGroup', { groupRecord, collapse });

        if (!skipRender) {
            // render from grouprecord and down, no need to touch those above
            me.rowManager.renderFromRecord(groupRecord);
        }
    }

    /**
     * Collapse all groups. This function is exposed on Grid and can thus be called as `grid.collapseAll()`
     */
    collapseAll() {
        const me = this;
        if (me.store.isGrouped && !me.disabled) {
            me.store.groupRecords.forEach(r => me.internalToggleCollapse(r, true, true));
            me.grid.refreshRows(true);
        }
    }

    /**
     * Expand all groups. This function is exposed on Grid and can thus be called as `grid.expandAll()`
     */
    expandAll() {
        const me = this;
        if (me.store.isGrouped && !me.disabled) {
            me.store.groupRecords.forEach(r => me.internalToggleCollapse(r, false, true));
            me.grid.refreshRows();
        }
    }

    //endregion

    //region Rendering

    /**
     * Called when a cell is rendered, styles the group rows first cell.
     * @private
     */
    renderCell(renderData) {
        const me = this;

        // no need to run the code below if not grouping or of feature is disabled
        if (!me.store.isGrouped || me.disabled) {
            return;
        }

        const
            {
                cellElement,
                rowElement,
                column
            }                   = renderData,
            grid                = me.grid,
            meta                = renderData.record.meta,
            firstColumn         = grid.columns.visibleColumns[0],
            firstSubGridColumns = grid.subGrids[grid.regions[0]].columns.visibleColumns;

        if (meta.hasOwnProperty('groupRowFor')) {
            // Let column clear the cell, in case it needs to do some cleanup
            column.clearCell(cellElement);

            // this is a group row, add css classes

            // IE11 doesnt support this
            //rowElement.classList.toggle('b-grid-group-collapsed', meta.collapsed === undefined ? false : meta.collapsed);
            rowElement.classList[meta.collapsed ? 'add' : 'remove']('b-grid-group-collapsed');

            rowElement.classList.add('b-group-row');

            if (
                (firstColumn.type === 'rownumber' && column === firstSubGridColumns[1]) ||
                (firstColumn.type !== 'rownumber' && column === firstSubGridColumns[0])
            ) {
                cellElement.classList.add('b-group-title');
            }

            me.buildGroupHeader(renderData);
        }
        else {
            // not a group row, remove css classes
            // TODO: use dom query to remove before render instead?
            if (cellElement === rowElement.firstElementChild) {
                // IE11 doesnt support this
                //rowElement.classList.remove('b-group-row', 'b-grid-group-collapsed');
                rowElement.classList.remove('b-group-row');
                rowElement.classList.remove('b-grid-group-collapsed');
                cellElement.classList.remove('b-group-title');
            }
        }
    }

    // renderData.cellElement is required
    buildGroupHeader(renderData) {
        const
            me                  = this,
            {
                record,
                cellElement,
                column,
                persist
            }                   = renderData,
            grid                = me.grid,
            meta                = record.meta,
            // Need to adjust count if group summary is used
            // TODO remove this when grouping has been refactored to not store group headers/footers in the Store
            count               = meta.childCount - (grid.features.groupSummary ? 1 : 0),
            firstVisibleColumn  = grid.columns.visibleColumns[0],
            firstSubGridColumns = column && grid.subGrids[grid.regions[0]].columns.visibleColumns,
            isFirstColumn       =
                (firstVisibleColumn.type === 'rownumber' && column === firstSubGridColumns[1]) ||
                (firstVisibleColumn.type !== 'rownumber' && column === firstSubGridColumns[0]);

        let html         = null,
            applyDefault = true;

        if (persist || column) {
            const groupColumn = grid.columns.get(meta.groupField);
            // First try using columns groupRenderer (might not even have a column if grouping programmatically)
            if (groupColumn && groupColumn.groupRenderer) {
                if (isFirstColumn) {
                    // groupRenderer could return nothing and just apply changes directly to DOM element
                    html = groupColumn.groupRenderer(Object.assign({}, renderData, {
                        groupRowFor  : meta.groupRowFor,
                        groupRecords : record.groupChildren,
                        groupColumn,
                        count
                    }));

                    applyDefault = false;
                }
            }
            // Secondly use features groupRenderer, if configured with one
            else if (me.groupRenderer) {
                // groupRenderer could return nothing and just apply changes directly to DOM element
                html = me.groupRenderer(Object.assign({}, renderData, {
                    groupRowFor  : meta.groupRowFor,
                    groupRecords : record.groupChildren,
                    groupColumn,
                    count,
                    isFirstColumn
                }));
            }

            // Third, just display unformatted value and child count (also applied for features groupRenderer that do
            // not output any html of their own)
            if (isFirstColumn && html == null && applyDefault) {
                html = `${meta.groupRowFor == null ? '' : meta.groupRowFor} (${count})`;
            }
        }
        else if (me.groupRenderer) {
            // groupRenderer could return nothing and just apply changes directly to DOM element
            html = me.groupRenderer(renderData);
        }

        // Renderers could return nothing and just apply changes directly to DOM element
        if (typeof html === 'string') {
            cellElement.innerHTML = html;
        }

        // If groupRenderer added elements to the cell, we need to remember that to clear it on re-usage as a normal cell
        if (cellElement.childElementCount > 0) {
            cellElement._hasHtml = true;
        }

        return cellElement.innerHTML;
    }

    /**
     * Called when an header is rendered, adds grouping icon if grouped by that column.
     * @private
     * @param headerContainerElement
     */
    renderHeader(headerContainerElement) {
        const { store, grid } = this;

        if (store.isGrouped) {
            // Sorted from start, reflect in rendering
            for (const groupInfo of store.groupers) {
                // Might be grouping by field without column, which is valid
                const
                    column = grid.columns.get(groupInfo.field),
                    header = column && grid.getHeaderElement(column.id);
                // IE11 doesnt support this
                //header && header.classList.add('b-group', groupInfo.ascending ? 'b-asc' : 'b-desc');
                if (header) {
                    header.classList.add('b-group');
                    header.classList.add(groupInfo.ascending ? 'b-asc' : 'b-desc');
                }
            }
        }
    }

    //endregion

    //region Context menu

    /**
     * Supply items for headers context menu.
     * @private
     * @param column Header for this column
     * @param items Add items to this array
     * @returns {Object[]} Modified items array
     */
    getHeaderMenuItems(column, items) {
        const
            me    = this,
            store = me.store;

        if (column.groupable !== false) {
            items.push({
                text     : me.L('groupAscending'),
                icon     : 'b-fw-icon b-icon-group-asc',
                name     : 'groupAsc',
                cls      : 'b-separator',
                weight   : 110,
                disabled : me.disabled,
                onItem   : ({ item : { column } }) => store.group(column.field, true)
            }, {
                text     : me.L('groupDescending'),
                icon     : 'b-fw-icon b-icon-group-desc',
                name     : 'groupDesc',
                weight   : 110,
                disabled : me.disabled,
                onItem   : ({ item : { column } }) => store.group(column.field, false)
            });
        }

        if (store.isGrouped) {
            items.push({
                text     : me.L('stopGrouping'),
                icon     : 'b-fw-icon b-icon-clear',
                name     : 'groupRemove',
                cls      : column.groupable ? '' : 'b-separator',
                weight   : 110,
                disabled : me.disabled,
                onItem   : ({ item : { column } }) => store.clearGroupers()
            });
        }

    }

    /**
     * Supply items to ColumnDragToolbar
     * @private
     */
    getColumnDragToolbarItems(column, items) {
        const
            me    = this,
            store = me.store;

        items.push({
            text     : me.L('groupAscendingShort'),
            group    : me.L('Group'),
            icon     : 'b-icon b-icon-group-asc',
            name     : 'groupAsc',
            cls      : 'b-separator',
            weight   : 110,
            disabled : me.disabled,
            onDrop   : ({ column }) => store.group(column.field, true)
        });

        items.push({
            text     : me.L('groupDescendingShort'),
            group    : me.L('Group'),
            icon     : 'b-icon b-icon-group-desc',
            name     : 'groupDesc',
            weight   : 110,
            disabled : me.disabled,
            onDrop   : ({ column }) => store.group(column.field, false)
        });

        const grouped = store.groupers && store.groupers.some(col => col.field === column.field) && !me.disabled;
        items.push({
            text     : me.L('stopGroupingShort'),
            group    : me.L('Group'),
            icon     : 'b-icon b-icon-clear',
            name     : 'groupRemove',
            disabled : !grouped,
            weight   : 110,
            onDrop   : ({ column }) => store.removeGrouper(column.field)
        });

        return items;
    }

    //endregion

    //region Events - Store

    /**
     * Called when store grouping changes. Reflects on header and rerenders rows.
     * @private
     */
    onStoreGroup({ groupers }) {
        const
            { grid }        = this,
            { element }     = grid,
            curGroupHeaders = element && DomHelper.children(element, '.b-grid-header.b-group');

        if (element) {
            for (const header of curGroupHeaders) {
                DomHelper.removeClasses(header, ['b-group', 'b-asc', 'b-desc']);
            }

            if (groupers) {
                for (const groupInfo of groupers) {
                    const header = grid.getHeaderElementByField(groupInfo.field);
                    if (header) {
                        DomHelper.addClasses(header, ['b-group', groupInfo.ascending ? 'b-asc' : 'b-desc']);
                    }
                }
            }
        }
    }

    /**
     * Called when grouping is turned of in the store. Updates headers and rows.
     * @private
     */
    onStoreGroupingOff() {
        const curGroupHeaders = DomHelper.children(this.grid.element, '.b-grid-header.b-group');

        for (const header of curGroupHeaders) {
            DomHelper.removeClasses(header, ['b-group', 'b-asc', 'b-desc']);
        }

        this.grid.refreshRows();
    }

    //endregion

    //region Events - Grid

    /**
     * Store touches when user touches header, used in onElementTouchEnd.
     * @private
     */
    onElementTouchStart(event) {
        const
            me     = this,
            target = event.target,
            header = DomHelper.up(target, '.b-grid-header'),
            column = header && me.grid.getColumnFromElement(header);

        // If it's a multi touch, group.
        if (event.touches.length > 1 && column && column.groupable !== false && !me.disabled) {
            me.store.group(column.field);
        }
    }

    /**
     * React to click on headers (to group by that column if [alt] is pressed) and on group rows (expand/collapse).
     * @private
     * @param event
     * @returns {Boolean}
     */
    onElementClick(event) {
        const
            me     = this,
            store  = me.store,
            target = event.target,
            row    = DomHelper.up(target, '.b-group-row'),
            header = DomHelper.up(target, '.b-grid-header'),
            field  = header && header.dataset.column;

        if (target.classList.contains('b-resizer') || me.disabled) {
            return;
        }

        // Header
        if (header && field) {
            const columnGrouper = store.groupers && store.groupers.find(g => g.field === field);

            // Store has a grouper for this column's field; flip grouper order
            if (columnGrouper && !event.shiftKey) {
                store.group(field, !columnGrouper.ascending);
                return false;
            }
            // Group or ungroup
            else if (event.shiftKey) {
                const column = me.grid.columns.get(field);

                if (column.groupable !== false) {
                    if (event.altKey) {
                        store.removeGrouper(field);
                    }
                    else {
                        store.group(field);
                    }
                }
            }
            event.preventDefault();
        }

        // Anywhere on group-row
        if (row) {
            me.internalToggleCollapse(DomDataStore.get(row).id);
            return false;
        }
    }

    /**
     * Toggle groups with [space].
     * @private
     * @param event
     * @returns {*}
     */
    onElementKeyDown(event) {
        const me = this;

        // only catch space on grid element, not in editors etc...
        if (!me.disabled && me.store.isGrouped && event.target === me.client.element && event.key === ' ' && me.grid.focusedCell) {
            event.preventDefault();

            me.internalToggleCollapse(me.grid.focusedCell.id);
        }
    }

    //endregion

    //region Grid overrides

    onStoreDataChange(data) {
        const store = data.source;

        // Grouping mixin needs to process data which then makes sure UI is refreshed
        if (store.isGrouped && store.count > 0) {
            return;
        }

        this.overridden.onStoreDataChange(data);
    }

    //endregion
}

Group._$name = 'Group'; GridFeatureManager.registerFeature(Group, true, ['Grid', 'Scheduler']);

//TODO: Handle date columns

/**
 * @module Grid/feature/QuickFind
 */

/**
 * Feature that allows the user to search in a column by focusing a cell and typing. Navigate between hits using the
 * keyboard, [f3] or [ctrl]/[cmd] + [g] moves to next, also pressing [shift] moves to previous.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @example
 * // enable QuickFind
 * let grid = new Grid({
 *   features: {
 *     quickFind: true
 *   }
 * });
 *
 * // navigate to next hit programmatically
 * grid.features.quickFind.gotoNextHit();
 *
 * @demo Grid/quickfind
 * @classtype quickFind
 * @externalexample feature/QuickFind.js
 */
class QuickFind extends InstancePlugin {
    //region Config

    static get $name() {
        return 'QuickFind';
    }

    static get defaultConfig() {
        return {
            mode : 'header',
            find : ''
        };
    }

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            chain : ['onElementKeyDown', 'onElementKeyPress', 'onCellNavigate']
        };
    }

    //endregion

    //region Init

    construct(grid, config) {
        const me = this;

        me.grid = grid;
        me.store = grid.store;

        super.construct(grid, config);
    }

    doDisable(disable) {
        if (disable) {
            this.clear();
        }

        super.doDisable(disable);
    }

    //endregion

    //region Show/hide QuickFind

    /**
     * Shows a "searchfield" in the header. Triggered automatically when you have a cell focused and start typing.
     * @private
     */
    showQuickFind() {
        const me     = this,
            header = me.grid.getHeaderElement(me.columnId);

        if (header) {
            if (!me.headerField) {
                const [element, field, badge] = DomHelper.createElement({
                    tag       : 'div',
                    className : 'b-quick-hit-header',
                    children  : [
                        { tag : 'div', className : 'b-quick-hit-field' },
                        { tag : 'div', className : 'b-quick-hit-badge' }
                    ]
                }, true);

                if (me.mode === 'header') {
                    header.appendChild(element);
                }
                else {
                    element.className += ' b-quick-hit-mode-grid';
                    me.grid.element.appendChild(element);
                }

                me.headerField = {
                    header    : element,
                    field     : field,
                    badge     : badge,
                    colHeader : header
                };
            }

            me.headerField.field.innerHTML = me.find;
            me.headerField.badge.innerHTML = me.found.length;

            header.classList.add('b-quick-find-header');

            if (!me.renderListenerInitialized) {
                me.grid.rowManager.on({
                    rendercell : me.renderCell,
                    thisObj    : me
                });
                me.renderListenerInitialized = true;
            }
        }
    }

    /**
     * Hide the "searchfield" and remove highlighted hits. Called automatically when pressing [esc] or backspacing away
     * the keywords.
     * @private
     */
    hideQuickFind() {
        const me = this;

        // rerender cells to remove quick-find markup
        for (let hit of (me.prevFound || me.found)) {
            let row = me.grid.getRowById(hit.id);
            if (row) row.renderCell(row.getCell(me.columnId), hit.data);
        }

        if (me.headerField) {
            me.headerField.header.parentNode.removeChild(me.headerField.header);
            me.headerField.colHeader.classList.remove('b-quick-find-header');
            me.headerField = null;
        }

        if (me.renderListenerInitialized) {
            me.grid.rowManager.un({ rendercell : me.renderCell }, me);
            me.renderListenerInitialized = false;
        }

        me.grid.trigger('hideQuickFind');
    }

    //endregion

    //region Search

    /**
     * Performs a search and highlights hits. If find is empty, QuickFind is closed.
     * @param find Text to search for
     * @param columnFieldOrId Column to search
     */
    search(find, columnFieldOrId = this.columnId) {
        let me     = this,
            column = me.grid.columns.getById(columnFieldOrId) || me.grid.columns.get(columnFieldOrId),
            found  = me.store.findByField(column.field, find),
            i      = 1,
            grid   = me.grid;

        Object.assign(me, {
            foundMap  : {},
            prevFound : me.found,
            found     : found,
            find      : find,
            columnId  : column.id
        });

        if (find) {
            me.showQuickFind();
        }
        else {
            me.hideQuickFind();
        }

        // reset column to use its normal settings for htmlEncoding
        if (me.currentColumn && me.currentColumn !== column) me.currentColumn.disableHtmlEncode = false;

        // clear old hits
        for (let cell of DomHelper.children(grid.element, '.b-quick-hit')) {
            //IE11 doesnt support this
            //cell.classList.remove('b-quick-hit', 'b-quick-hit-cell');
            cell.classList.remove('b-quick-hit');
            cell.classList.remove('b-quick-hit-cell');

            // rerender cell to remove quick-hit-text
            let row = DomDataStore.get(cell).row;
            row.renderCell(cell);
        }

        // want to set innerHTML each time for cell decoration to work
        column.disableHtmlEncode = true;
        me.currentColumn = column;

        if (!found) return;

        if (found.length > 0) {
            me.gotoClosestHit(grid.focusedCell, found);
        }

        // highlight hits for visible cells
        for (let hit of found) {
            me.foundMap[hit.id] = i++;

            let row = grid.getRowById(hit.data.id);
            if (row) {
                row.renderCell(row.getCell(column.id));
            }

            // limit highlighted hits
            if (i > 1000) break;
        }

        me.grid.trigger('quickFind', { find, found });
    }

    /**
     * Clears and closes QuickFind.
     */
    clear() {
        if (this.found && this.found.length) {
            this.search('');
        }
    }

    /**
     * Number of results found
     * @type {Number}
     * @readonly
     */
    get foundCount() {
        return this.found ? this.found.length : 0;
    }

    /**
     * Found results (as returned by Store#findByField), an array in format { index: x, data: record }
     * @member {Object[]} found
     * @readonly
     */

    //endregion

    //region Navigation

    /**
     * Go to specified hit.
     * @param index
     */
    gotoHit(index) {
        let me      = this,
            grid    = me.grid,
            nextHit = me.found[index];

        if (nextHit) {
            grid.focusCell({
                columnId : me.columnId,
                id       : nextHit.id
            });
        }

        return !!nextHit;
    }

    gotoClosestHit(focusedCell, found) {
        let focusedIndex = focusedCell ? this.grid.store.indexOf(focusedCell.id) : 0,
            foundSorted  = found.slice().sort(
                (a, b) => Math.abs(a.index - focusedIndex) - Math.abs(b.index - focusedIndex)
            );

        this.gotoHit(found.indexOf(foundSorted[0]));
    }

    /**
     * Go to the first hit.
     */
    gotoFirstHit() {
        this.gotoHit(0);
    }

    /**
     * Go to the last hit.
     */
    gotoLastHit() {
        this.gotoHit(this.found.length - 1);
    }

    /**
     * Select the next hit, scrolling it into view. Triggered with [f3] or [ctrl]/[cmd] + [g].
     */
    gotoNextHit() {
        let me           = this,
            grid         = me.grid,
            // start from focused cell, or if focus has left grid use lastFocusedCell
            currentId    = grid._focusedCell ? grid._focusedCell.id : grid.lastFocusedCell.id,
            currentIndex = grid.store.indexOf(currentId) || 0,
            nextHit      = me.found.find(hit => hit.index > currentIndex);

        if (nextHit) {
            grid.focusCell({
                columnId : me.columnId,
                id       : nextHit.id
            });
        }
        else {
            me.gotoFirstHit();
        }
    }

    /**
     * Select the previous hit, scrolling it into view. Triggered with [shift] + [f3] or [shift] + [ctrl]/[cmd] + [g].
     */
    gotoPrevHit() {
        let me           = this,
            grid         = me.grid,
            currentId    = grid._focusedCell ? grid._focusedCell.id : grid.lastFocusedCell.id,
            currentIndex = grid.store.indexOf(currentId) || 0,
            found        = me.found,
            prevHit;

        if (!found.length) return;

        for (let i = found.length - 1; i--; i >= 0) {
            if (found[i].index < currentIndex) {
                prevHit = found[i];
                break;
            }
        }

        if (prevHit) {
            grid.focusCell({
                columnId : me.columnId,
                id       : prevHit.id
            });
        }
        else {
            me.gotoLastHit();
        }
    }

    //endregion

    //region Render

    /**
     * Called from SubGrid when a cell is rendered.
     * @private
     */
    renderCell(renderData) {
        const
            me          = this,
            cellElement = renderData.cellElement,
            foundMap    = me.foundMap && me.columnId === renderData.column.id && me.foundMap[renderData.record.id];

        if (foundMap) {
            // Check also TreeColumn's special internal `shouldHtmlEncode` flag
            const htmlEncoded = renderData.column.htmlEncode || renderData.column.shouldHtmlEncode;

            // highlight cell
            cellElement.classList.add('b-quick-hit');

            // Special treatment of columns outputting HTML, just highlight whole cell
            if (!htmlEncoded) {
                cellElement.classList.add('b-quick-hit-cell');
            }
            else {
                // if features have added other stuff to the cell, value is in div.b-grid-cell-value
                // highlight in cell if found in innerHTML
                let inner = DomHelper.down(cellElement, '.b-grid-cell-value,.b-tree-cell-value') || cellElement,
                    html  = inner.innerText,
                    where = html && html.toLowerCase().indexOf(me.find.toLowerCase());

                if (where > -1) {
                    let end       = where + me.find.length,
                        casedFind = html.slice(where, end),
                        spaceChar = '';

                    // Insert a space if matching char preceded by whitespace
                    if (html[where - 1] === ' ') {
                        spaceChar = '&nbsp;';
                    }

                    html            = html.slice(0, where) + `<span class="b-quick-hit-text">${spaceChar}${casedFind}</span>` + html.slice(end);
                    inner.innerHTML = html + `<div class="b-quick-hit-cell-badge">${foundMap}</div>`;
                }
                else {
                    cellElement.classList.add('b-quick-hit-cell');
                }
            }
        }
    }

    //endregion

    //region Events

    /**
     * Chained function called on grids keydown event. Handles backspace, escape, f3 and ctrl/cmd + g keys.
     * @private
     * @param event KeyboardEvent
     */
    onElementKeyDown(event) {
        const
            me            = this,
            filterFeature = this.grid.features.filter;

        // Only react to keystrokes on grid cell elements. IE11 gets event.target wrong compared to other browsers...
        if (me.disabled || DomHelper.up(event.target, BrowserHelper.isIE11 ? '.b-widget:not(.b-grid-subgrid):not(.b-grid)' : '.b-widget:not(.b-grid)')) {
            return;
        }

        if (me.find.length > 0) {
            // backspace
            if (event.key === 'Backspace') {
                event.preventDefault();
                me.find = me.find.substr(0, me.find.length - 1);
                //console.log(me.find);

                me.search(me.find);
            }

            // escape
            else if (event.key === 'Escape') {
                event.preventDefault();
                me.find = '';
                me.search(me.find);
            }

            // F3 or CTRL+g
            else if (event.key === 'F3' || (event.key.toLowerCase() === 'g' && (event.ctrlKey || event.metaKey))) {
                event.preventDefault();
                if (event.shiftKey) {
                    me.gotoPrevHit();
                }
                else {
                    me.gotoNextHit();
                }
            }
            // Ctrl+Shift+F
            else if (filterFeature && me.columnId && me.foundCount && event.ctrlKey && event.shiftKey && event.key === 'F') {
                filterFeature.showFilterEditor(me.grid.columns.getById(me.columnId), me.find);
            }
        }
    }

    /**
     * Chained function called on grids keypress event. Handles input for "searchfield".
     * @private
     * @param event
     */
    onElementKeyPress(event) {
        const me = this;

        // Only react to keystrokes on grid cell elements
        if (me.disabled || DomHelper.up(event.target, BrowserHelper.isIE11 ? '.b-widget:not(.b-grid-subgrid):not(.b-grid)' : '.b-widget:not(.b-grid)') || event.key === 'Enter') {
            return;
        }

        if (me.grid._focusedCell) {
            const column = me.grid.columns.getById(me.grid._focusedCell.columnId);
            // if trying to search in invalid column, it's a hard failure
            
            if (column && column.searchable !== false) {
                me.columnId = me.grid._focusedCell.columnId;

                if (event.key && event.key.length === 1) {
                    me.find += event.key;
                    me.search(me.find);
                }
            }
        }
    }

    onCellNavigate(grid, fromCellSelector, toCellSelector, event) {
        const
            me    = this,
            found = me.prevFound || me.found;

        if (found && (!toCellSelector || toCellSelector.columnId !== me.columnId)) {
            me.clear();
        }
    }

    //endregion
}

QuickFind._$name = 'QuickFind'; GridFeatureManager.registerFeature(QuickFind);

/**
 * @module Grid/feature/RegionResize
 */

/**
 * Makes the splitter between grid section draggable so you can resize grid sections.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @example
 * // enable RegionResize
 * let grid = new Grid({
 *   features: {
 *     regionResize: true
 *   }
 * });
 *
 * @demo Grid/features
 * @classtype regionResize
 * @externalexample feature/RegionResize.js
 */
class RegionResize extends InstancePlugin {
    // region Init
    static get $name() {
        return 'RegionResize';
    }

    construct(grid, config) {
        this.grid = grid;

        super.construct(grid, config);
    }

    doDestroy() {
        // TODO: Cleanup
        super.doDestroy();
    }

    //endregion

    //region Plugin config

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            chain : ['onElementTouchStart', 'onElementTouchMove', 'onElementTouchEnd', 'onElementMouseDown',
                'onElementMouseMove', 'onElementDblClick', 'onElementMouseUp', 'onSubGridCollapse', 'onSubGridExpand',
                'render']
        };
    }

    //endregion

    onElementDblClick(event) {
        const me       = this,
            grid       = me.grid,
            splitterEl = DomHelper.up(event.target, '.b-grid-splitter-collapsed');

        // If collapsed splitter is dblclicked and region is not expanding
        // It is unlikely that user might dblclick splitter twice and even if he does, nothing should happen.
        // But just in case lets not expand twice.
        if (splitterEl && !me.expanding) {
            me.expanding = true;

            let region = splitterEl.dataset.region,
                subGrid = grid.getSubGrid(region);

            // Usually collapsed splitter means corresponding region is collapsed. But in case of last two regions one
            // splitter can be collapsed in two directions. So, if corresponding region is expanded then last one is collapsed
            if (!subGrid.collapsed) {
                region = grid.getLastRegions()[1];
                subGrid = grid.getSubGrid(region);
            }

            subGrid.expand().then(() => me.expanding = false);
        }
    }

    //region Move splitter

    /**
     * Begin moving splitter.
     * @private
     * @param splitterElement Splitter element
     * @param clientX Initial x position from which new width will be calculated on move
     */
    startMove(splitterElement, clientX) {
        let me      = this,
            { grid } = me,
            region  = splitterElement.dataset.region,
            gridEl  = grid.element,
            subGrid = grid.getSubGrid(region),
            nextRegion = grid.regions[grid.regions.indexOf(region) + 1],
            nextSubGrid = grid.getSubGrid(nextRegion),
            flip = 1;

        if (subGrid.flex != null) {
            // If subgrid has flex, check if next one does not
            if (nextSubGrid.flex == null) {
                subGrid = nextSubGrid;
                flip = -1;
            }
        }

        if (splitterElement.classList.contains('b-grid-splitter-collapsed')) {
            return;
        }

        const availableWidth = subGrid.element.offsetWidth + nextSubGrid.element.offsetWidth;

        me.dragContext = {
            element       : splitterElement,
            headerEl      : subGrid.header.element,
            subGridEl     : subGrid.element,
            subGrid       : subGrid,
            originalWidth : subGrid.element.offsetWidth,
            originalX     : clientX,
            minWidth      : subGrid.minWidth || 0,
            maxWidth      : Math.min(availableWidth, subGrid.maxWidth || availableWidth),
            flip
        };

        gridEl.classList.add('b-moving-splitter');

        splitterElement.classList.add('b-moving');
    }

    onCollapseClick(subGrid, splitterEl) {
        const me    = this,
            grid    = me.grid,
            region  = splitterEl.dataset.region,
            regions = grid.getLastRegions();

        // Last splitter in the grid is responsible for collapsing/expanding last 2 regions and is always related to the
        // left one. Check if we are working with last splitter
        if (regions[0] === region) {
            const lastSubGrid = grid.getSubGrid(regions[1]);
            if (lastSubGrid.collapsed) {
                lastSubGrid.expand();
                return;
            }
        }

        subGrid.collapse();
    }

    onExpandClick(subGrid, splitterEl) {
        const me    = this,
            grid    = me.grid,
            region  = splitterEl.dataset.region,
            regions = grid.getLastRegions();

        // Last splitter in the grid is responsible for collapsing/expanding last 2 regions and is always related to the
        // left one. Check if we are working with last splitter
        if (regions[0] === region) {
            if (!subGrid.collapsed) {
                const lastSubGrid = grid.getSubGrid(regions[1]);
                lastSubGrid.collapse();
                return;
            }
        }

        subGrid.expand();
    }

    /**
     * Update splitter position.
     * @private
     * @param newClientX
     */
    updateMove(newClientX) {
        const { dragContext } = this;

        if (dragContext) {
            const difX = newClientX - dragContext.originalX,
                newWidth =  Math.min(dragContext.maxWidth, dragContext.originalWidth + difX * dragContext.flip);

            // SubGrids monitor their own size and keep any splitters synced
            dragContext.subGrid.width = Math.max(newWidth, dragContext.minWidth);
        }
    }

    /**
     * Stop moving splitter.
     * @private
     */
    endMove() {
        const me      = this,
            dragContext = me.dragContext;

        if (dragContext) {
            me.grid.element.classList.remove('b-moving-splitter');
            dragContext.element.classList.remove('b-moving');
            me.dragContext = null;
        }
    }

    //endregion

    //region Events

    /**
     * Start moving splitter on touch start.
     * @private
     * @param event
     */
    onElementTouchStart(event) {
        const me     = this,
            target = event.target;

        if (target.classList.contains('b-grid-splitter')) {
            me.startMove(target, event.touches[0].clientX);
        }
    }

    /**
     * Move splitter on touch move.
     * @private
     * @param event
     */
    onElementTouchMove(event) {
        if (this.dragContext) {
            this.updateMove(event.touches[0].clientX);
            event.preventDefault();
        }
    }

    /**
     * Stop moving splitter on touch end.
     * @private
     * @param event
     */
    onElementTouchEnd(event) {
        if (this.dragContext) {
            this.endMove();
            event.preventDefault();
        }
    }

    /**
     * Start moving splitter on mouse down (on splitter).
     * @private
     * @param event
     */
    onElementMouseDown(event) {
        const me     = this,
            target   = event.target,
            splitter = event.target.closest(':not(.b-row-reordering):not(.b-dragging-event):not(.b-dragging-task):not(.b-dragging-header):not(.b-dragselecting) .b-grid-splitter'),
            subGrid  = splitter && me.grid.getSubGrid(splitter.dataset.region);

        // Only care about left clicks, avoids a bug found by monkeys
        if (event.button === 0) {
            // In case of touch screen inner splitter has 100% height and we should handle
            // it as target too
            if (target.classList.contains('b-grid-splitter') || target.classList.contains('b-grid-splitter-inner')) {
                me.startMove(splitter, event.clientX);
            }
            else if (target.classList.contains('b-icon-collapse-gridregion')) {
                me.onCollapseClick(subGrid, splitter);
            }
            else if (target.classList.contains('b-icon-expand-gridregion')) {
                me.onExpandClick(subGrid, splitter);
            }
        }
    }

    /**
     * Move splitter on mouse move.
     * @private
     * @param event
     */
    onElementMouseMove(event) {
        if (this.dragContext) {
            this.updateMove(event.clientX);
            event.preventDefault();
        }
    }

    /**
     * Stop moving splitter on mouse up.
     * @private
     * @param event
     */
    onElementMouseUp(event) {
        if (this.dragContext) {
            this.endMove();
            event.preventDefault();
        }
    }

    onSubGridCollapse(subGrid) {
        const splitterEl = this.grid.resolveSplitter(subGrid),
            regions      = this.grid.getLastRegions();

        // if last region was collapsed
        if (regions[1] === subGrid.region) {
            splitterEl.classList.add('b-grid-splitter-allow-collapse');
        }
    }

    onSubGridExpand(subGrid) {
        const splitterEl = this.grid.resolveSplitter(subGrid);
        splitterEl.classList.remove('b-grid-splitter-allow-collapse');
    }

    //endregion

    render() {
        const { regions, subGrids } = this.grid;

        // Multiple regions, only allow collapsing to the edges by hiding buttons
        if (regions.length > 2) {
            // Only works in a 3 subgrid scenario. To support more subgrids we have to merge splitters or something
            // on collapse. Not going down that path currently...
            subGrids[regions[0]].splitterElement.classList.add('b-left-only');
            subGrids[regions[1]].splitterElement.classList.add('b-right-only');
        }
    }
}

RegionResize.featureClass = 'b-split';

RegionResize._$name = 'RegionResize'; GridFeatureManager.registerFeature(RegionResize);

/**
 * @module Grid/feature/RowReorder
 */

/**
 * Allows user to reorder rows by dragging them. To get notified about row reorder listen to `change` event
 * on the grid {@link Core.data.Store store}.
 *
 * This feature is **disabled** by default.
 * This feature is **enabled** by default for Gantt.
 *
 * If the grid is set to {@link Grid.view.Grid#config-readOnly}, reordering is disabled. Inside all event listeners you have access a `context` object which has a `record` property (the dragged record).
 *
 * You can validate the drag drop flow by listening to the `gridrowdrag` event. Inside this listener you have access the `index` property which is the target drop position.
 * For trees you get access to the `parent` record and `index`, where index means the child index inside the parent.
 *
 * ```
 * features : {
 *     rowReorder : {
 *         listeners : {
 *             gridRowDrag : ({ context }) => {
 *                // Here you have access to context.insertBefore, and additionally context.parent for trees
 *
 *                context.valid = false;
 *             }
 *         }
 *     }
 * }
 * ```
 *
 * @extends Core/mixin/InstancePlugin
 * @demo Grid/rowreorder
 * @classtype rowReorder
 */
class RowReorder extends Delayable(InstancePlugin) {
    //region Events
    /**
     * Fired before dragging starts, return false to prevent the drag operation.
     * @preventable
     * @event gridRowBeforeDragStart
     * @param {DragHelper} source
     * @param {Object} context
     * @param {Core.data.Model} context.record The dragged row record
     * @param {MouseEvent|TouchEvent} event
     */

    /**
     * Fired when dragging starts.
     * @event gridRowDragStart
     * @param {DragHelper} source
     * @param {Object} context
     * @param {Core.data.Model} context.record The dragged row record
     * @param {MouseEvent|TouchEvent} event
     */

    /**
     * Fired while the row is being dragged, in the listener function you have access to `context.insertBefore` a grid / tree record, and additionally `context.parent` (a TreeNode) for trees. You can
     * signal that the drop position is valid or invalid by setting `context.valid = false;`
     * @event gridRowDrag
     * @param {DragHelper} source
     * @param {Object} context
     * @param {Boolean} context.valid Set this to true or false to indicate whether the drop position is valid.
     * @param {Core.data.Model} context.insertBefore The record to insert before (`null` if inserting at last position of a parent node)
     * @param {Core.data.Model} context.parent The parent record of the current drop position (only applicable for trees)
     * @param {Core.data.Model} context.record The dragged row record
     * @param {MouseEvent} event
     */

    /**
     * Fired on row drop
     * @event gridRowDrop
     * @param {DragHelper} source
     * @param {Object} context
     * @param {Boolean} context.valid Set this to true or false to indicate whether the drop position is valid.
     * @param {Core.data.Model} context.insertBefore The record to insert before (`null` if inserting at last position of a parent node)
     * @param {Core.data.Model} context.parent The parent record of the current drop position (only applicable for trees)
     * @param {Core.data.Model} context.record The dragged row record
     * @param {MouseEvent} event
     */

    /**
     * Fired when a row drag operation is aborted
     * @event gridRowAbort
     * @param {DragHelper} source
     * @param {Object} context
     * @param {MouseEvent} event
     */
    //endregion

    //region Init

    static get $name() {
        return 'RowReorder';
    }

    static get defaultConfig() {
        return {
            /**
             * If hovering over a parent node for this period of a time in a tree, the node will expand
             * @config {Number}
             */
            hoverExpandTimeout : 1000
        };
    }

    construct(grid, config) {
        this.grid = grid;

        super.construct(...arguments);
    }

    doDestroy() {
        this.dragHelper && this.dragHelper.destroy();

        super.doDestroy();
    }

    /**
     * Initialize drag & drop (called from render)
     * @private
     */
    init() {
        const
            me       = this,
            { grid } = me;

        me.dragHelper = new DragHelper({
            name               : 'rowReorder',
            mode               : 'translateXY',
            cloneTarget        : true,
            dragThreshold      : 10,
            targetSelector     : '.b-grid-row',
            lockX              : true,
            transitionDuration : grid.transitionDuration,
            scrollManager      : grid.scrollManager,
            dragWithin         : grid.verticalScroller,
            outerElement       : grid.verticalScroller,

            // Since parent nodes can expand after hovering, meaning original drag start position now refers to a different point in the tree
            ignoreSamePositionDrop : false,

            createProxy(element) {
                const clone = element.cloneNode(true),
                      container = document.createElement('div');

                clone.removeAttribute('id');
                // The containing element will be positioned instead
                clone.style.transform = '';

                container.appendChild(clone);

                return container;
            },

            listeners : {
                beforedragstart : me.onBeforeDragStart,
                dragstart       : me.onDragStart,
                drag            : me.onDrag,
                drop            : me.onDrop,
                reset           : me.onReset,
                prio            : 10000, // To ensure our listener is run before the relayed listeners (for the outside world)
                thisObj         : me
            }
        });

        me.dropIndicator = DomHelper.createElement({
            parent    : grid.bodyContainer,
            className : 'b-row-drop-indicator'
        });

        me.relayEvents(me.dragHelper, ['beforeDragStart', 'dragStart', 'drag', 'drop', 'abort'], 'gridRow');
    }

    //endregion

    //region Plugin config

    static get pluginConfig() {
        return {
            after : ['render']
        };
    }

    //endregion

    //region Events (drop)

    onBeforeDragStart({ context }) {
        const
            grid          = this.grid,
            targetSubGrid = grid.regions[0],
            subGridEl     = grid.subGrids[targetSubGrid].element;

        // Disabled for touch devices until implemented fully. https://app.assembla.com/spaces/bryntum/tickets/8185-fix-row-reorder-for-touch-devices/details#
        // Only dragging enabled in the leftmost grid section
        if (this.disabled || grid.readOnly || DomHelper.isTouchEvent || !subGridEl.contains(context.element)) {
            return false;
        }

        const record = context.record = this.grid.getRecordFromElement(context.element);

        return !record.meta.specialRow;
    }

    onDragStart({ context }) {
        const
            me       = this,
            cellEdit = me.grid.features.cellEdit,
            record = me.grid.getRecordFromElement(context.grabbed);

        if (!record) {
            throw new Error('Failed to find record for dragged element');
        }

        if (cellEdit) {
            me.cellEditDisabledState = cellEdit.disabled;
            cellEdit.disabled = true; // prevent editing from being started through keystroke during row reordering
        }

        if (me.grid.features.contextMenu) {
            me.grid.features.contextMenu.hideContextMenu(false);
        }

        me.grid.element.classList.add('b-row-reordering');

        const focusedCell = context.element.querySelector('.b-focused');
        focusedCell && focusedCell.classList.remove('b-focused');

        DomHelper.removeClasses(context.element.firstElementChild, ['b-selected', 'b-hover']);
        me.record = record;
    }

    onDrag({ context, event }) {
        const
            me                    = this,
            { store, rowManager } = me.grid;

        // Ignore if user drags outside grid area
        if (!me.dragHelper.outerElement.contains(event.target) || !event.target.closest('.b-grid-subgrid')) {
            context.valid = false;
            return;
        }

        let valid = context.valid,
            row   = me.grid.rowManager.getRowAt(event.clientY),
            overRecord,
            dataIndex,
            after,
            insertBefore;

        if (row) {
            const
                rowTop  = row.top + me.grid._bodyRectangle.y - me.grid.scrollable.y,
                middleY = rowTop + (row.height / 2);

            dataIndex = row.dataIndex;
            overRecord = row && store.getAt(dataIndex);

            // Drop after row below if mouse is in bottom half of hovered row
            after = event.clientY > middleY;
        }
        // Below the rows. Drop after last row
        else {
            dataIndex = store.count - 1;
            overRecord = store.last;
            row = me.grid.rowManager.getRow(dataIndex);
            after = true;
        }

        // Hovering the dragged record. This is a no-op.
        // But still gather the contextual data.
        if (overRecord === me.record) {
            valid = false;
        }

        if (store.tree) {
            DomHelper.removeClsGlobally(me.grid.element, 'b-row-reordering-target-parent');

            insertBefore = after ? overRecord.nextSibling : overRecord;

            // For trees, prevent moving a parent into its own hierarchy
            if (me.record.contains(overRecord)) {
                valid = false;
            }

            context.parent = overRecord.parent;

            if (!context.parent.isRoot) {
                const parentRow = rowManager.getRowById(context.parent);

                if (parentRow) {
                    parentRow.addCls('b-row-reordering-target-parent');
                }
            }

            me.clearTimeout(me.hoverTimer);

            if (overRecord && overRecord.isParent && !overRecord.isExpanded(store)) {
                me.hoverTimer = me.setTimeout(() => me.grid.expand(overRecord), me.hoverExpandTimeout);
            }
        }
        else {
            // Public property used for validation
            insertBefore = after ? store.getAt(dataIndex + 1) : overRecord;
        }

        // Provide visual clue to user of the drop position
        DomHelper.setTranslateY(me.dropIndicator, row.top + (after ? row.height : 0));

        context.insertBefore = insertBefore;

        context.valid = valid;
    }

    /**
     * Handle drop
     * @private
     */
    async onDrop({ context }) {
        const
            me    = this,
            grid  = me.grid,
            store = grid.store;

        context.asyncCleanup = context.async = true;
        context.element.classList.add('b-dropping');

        me.setTimeout(async () => {
            if (context.valid) {
                let result;

                if (store.tree) {
                    result = await context.parent.tryInsertChild(me.record, context.insertBefore);
                    context.valid = context.valid && result !== false;
                }
                else {
                    store.insert(context.insertBefore ? store.indexOf(context.insertBefore) : store.count, me.record);
                }

                store.clearSorters();

                context.finalize(context.valid);
            }
            grid.element.classList.remove('b-row-reordering');
        }, 300);
    }

    /**
     * Clean up on reset
     * @private
     */
    onReset() {
        const
            me = this,
            cellEdit = me.grid.features.cellEdit;

        me.grid.element.classList.remove('b-row-reordering');

        if (cellEdit) {
            cellEdit.disabled = me.cellEditDisabledState;
        }

        DomHelper.removeClsGlobally(
            me.grid.element,
            'b-row-reordering-target-parent'
        );
    }

    //endregion

    //region Render

    /**
     * Updates DragHelper with updated headers when grid contents is rerendered
     * @private
     */
    render() {
        // columns shown, hidden or reordered
        this.init();
    }

    //endregion
}

RowReorder.featureClass = '';

RowReorder._$name = 'RowReorder'; GridFeatureManager.registerFeature(RowReorder, false);
GridFeatureManager.registerFeature(RowReorder, true, 'Gantt');

//TODO: Should listen for store search also, to work the other way around

/**
 * @module Grid/feature/Search
 */

/**
 * Feature that allows the user to search the entire grid. Navigate between hits using the
 * keyboard, [f3] or [ctrl]/[cmd] + [g] moves to next, also pressing [shift] moves to previous.
 *
 * Note that this feature does not include a UI, please build your own and call appropriate methods in the feature. For
 * a demo implementation, see
 * <a href="../examples/search" target="_blank">Search example</a>.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @example
 * // enable Search
 * let grid = new Grid({
 *   features: {
 *     search: true
 *   }
 * });
 *
 * // perform search
 * grid.features.search.search('steve');
 *
 * @demo Grid/search
 * @classtype search
 * @externalexample feature/Search.js
 */
class Search extends InstancePlugin {
    //region Init

    static get $name() {
        return 'Search';
    }

    construct(grid, config) {
        const me = this;

        super.construct(grid, config);

        Object.assign(me, {
            store  : grid.store,
            grid   : grid,
            find   : '',
            hitEls : []
        });
    }

    doDestroy() {
        this.clear(true);
        super.doDestroy();
    }

    doDisable(disable) {
        if (disable) {
            this.clear();
        }

        super.doDisable(disable);
    }

    //endregion

    //region Plugin config

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            chain : ['getCellMenuItems', 'onElementKeyDown']
        };
    }

    //endregion

    //region Search

    /**
     * Performs a search and highlights hits.
     * @param {String} find Text to search for
     * @param {Boolean} gotoHit Go to first hit after search
     * @param {Boolean} reapply Pass true to force search
     */
    search(find, gotoHit = true, reapply = false) {
        const me = this;

        // empty search considered a clear
        if (!find) {
            return me.clear();
        }

        // searching for same thing again, do nothing
        if (!reapply && find === me.find || me.disabled) {
            return;
        }

        const
            grid    = me.grid,
            // Only search columns in use
            columns = grid.columns.visibleColumns.filter(col => col.searchable !== false),
            fields  = columns.map(col => col.field),
            found   = me.store.search(find, fields);

        let i = 1;

        Object.assign(me, {
            foundMap  : {},
            prevFound : me.found,
            found,
            find
        });

        // clear old hits
        for (let cell of DomHelper.children(grid.element, '.b-search-hit')) {
            // IE11 doesnt support this
            //cell.classList.remove('b-search-hit', 'b-search-hit-cell');
            cell.classList.remove('b-search-hit');
            cell.classList.remove('b-search-hit-cell');

            // rerender cell to remove search-hit-text
            let row = DomDataStore.get(cell).row;
            row.renderCell(cell);
        }

        if (!found) return;

        // columns from previous search, reset htmlEncode
        if (me.hitColumns) {
            me.hitColumns.forEach(col => col.disableHtmlEncode = false);
        }

        me.hitColumns = [];

        // highlight hits for visible cells
        for (let hit of found) {
            me.foundMap[hit.field + '-' + hit.id] = i++;

            // disable htmlEncode for columns with hits
            const column = me.grid.columns.get(hit.field);
            if (column) {
                column.disableHtmlEncode = true;
                me.hitColumns.push(column);
            }
            // limit hits
            if (i > 1000) break;
        }

        if (!me.listenersInitialized) {
            me.grid.rowManager.on({ rendercell : me.renderCell }, me);
            me.store.on({ refresh : me.onStoreRefresh }, me);
            me.listenersInitialized = true;
        }

        grid.refreshRows();

        me.grid.trigger('search', { grid, find, found });

        if (gotoHit && !me.isHitFocused) {
            me.gotoNextHit(true);
        }

        return found;
    }

    /**
     * Clears search results.
     */
    clear(silent = false) {
        const
            me   = this,
            grid = me.grid;

        if (me.foundMap) {
            delete me.foundMap;
        }

        delete me.find;

        DomHelper.forEachSelector(grid.element, '.b-search-hit', cell =>
            DomHelper.removeClasses(cell, ['b-search-hit', 'b-search-hit-cell'])
        );

        DomHelper.removeEachSelector(grid.element, '.b-search-hit-cell-badge,.b-search-hit-text');

        if (me.listenersInitialized) {
            grid.rowManager.un({ rendercell : me.renderCell }, me);
            me.store.un({ refresh : me.onStoreRefresh }, me);
            me.listenersInitialized = false;
        }

        if (!silent) {
            grid.refreshRows();

            me.grid.trigger('clearSearch', { grid });
        }
    }

    /**
     * Number of results found
     * @readonly
     * @returns {Number}
     */
    get foundCount() {
        return (this.found && this.found.length) || 0;
    }

    //endregion

    //region Navigation

    /**
     * Checks if focused row is a search hit.
     * @returns {Boolean} Returns true if focused row is a hit
     * @readonly
     */
    get isHitFocused() {
        const
            me            = this,
            grid          = me.grid,
            currentIndex  = grid.focusedCell ? grid.store.indexOf(grid.focusedCell.id) : -1,
            currentColumn = grid.focusedCell ? grid.columns.getById(grid.focusedCell.columnId) : null;

        return currentIndex !== -1 && me.found.some(hit =>
            hit.index === currentIndex && currentColumn && hit.field === currentColumn.field
        );
    }

    /**
     * Select the next hit, scrolling it into view. Triggered with [f3] or [ctrl]/[cmd] + [g].
     */
    gotoNextHit(fromStart = false) {
        const me = this;

        if (!me.found || !me.found.length) return;

        const grid         = me.grid,
            fromCell     = grid.focusedCell || grid.lastFocusedCell,
            currentIndex = fromCell && !fromStart ? grid.store.indexOf(fromCell.id) : -1,
            nextHit      = me.found.findIndex(hit => hit.index > currentIndex);

        if (nextHit !== -1) {
            me.gotoHit(nextHit);
        }
    }

    /**
     * Select the previous hit, scrolling it into view. Triggered with [shift] + [f3] or [shift] + [ctrl]/[cmd] + [g].
     */
    gotoPrevHit() {
        const me = this;

        if (!me.found || !me.found.length) return;

        const grid         = me.grid,
            fromCell     = grid.focusedCell || grid.lastFocusedCell,
            currentIndex = fromCell ? grid.store.indexOf(fromCell.id) : 0,
            found        = me.found;

        for (let i = found.length - 1; i--; i >= 0) {
            let hit = found[i];
            if (hit.index < currentIndex) {
                me.gotoHit(i);
                break;
            }
        }
    }

    /**
     * Go to specified hit.
     * @param index
     */
    gotoHit(index) {
        let me      = this,
            grid    = me.grid,
            nextHit = me.found[index];

        if (nextHit) {
            grid.focusCell({
                field : nextHit.field,
                id    : nextHit.id
            });
        }

        return !!nextHit;
    }

    /**
     * Go to the first hit.
     */
    gotoFirstHit() {
        this.gotoHit(0);
    }

    /**
     * Go to the last hit.
     */
    gotoLastHit() {
        this.gotoHit(this.found.length - 1);
    }

    //endregion

    //region Render

    /**
     * Called from SubGrid when a cell is rendered. Highlights search hits.
     * @private
     */
    renderCell({ cellElement, column, record, value, cellContent }) {
        const me          = this,
            hitIndex    = me.foundMap && me.foundMap[column.field + '-' + record.id];

        // clear search stuff from cell, might not be done by rendering since it does not always set innerHTML any longer
        //if (me.hitElements.includes(cellElement)) {
        //    const textElement  = cellElement.querySelector('.b-search-hit-text'),
        //        badgeElement = cellElement.querySelector('.b-search-hit-cell-badge');
        //
        //    textElement && textElement.remove();
        //    badgeElement && badgeElement.remove();
        //
        //    cellElement.classList.remove('b-search-hit');
        //    cellElement.classList.remove('b-search-hit-cell');
        //
        //    me.hitElements.splice(me.hitElements.indexOf(cellElement), 1);
        //}

        if (hitIndex) {
            // highlight cell
            cellElement.classList.add('b-search-hit');

            // highlight in cell if found in innerHTML
            const inner = DomHelper.down(cellElement, '.b-grid-cell-value') || cellElement,
                find  = String(me.find).toLowerCase();

            if (String(value).toLowerCase() === find) {
                inner.innerHTML = `<span class="b-search-hit-text">${cellContent}</span><div class="b-search-hit-cell-badge">${hitIndex}</div>`;
            }
            else {
                const find = String(me.find).toLowerCase(),
                    where = cellContent && cellContent.toLowerCase().indexOf(find);

                if (where > -1) {
                    let end       = where + find.length,
                        casedFind = cellContent.slice(where, end);

                    inner.innerHTML = `${cellContent.slice(0, where)}<span class="b-search-hit-text">${casedFind}</span>${cellContent.slice(end)}<div class="b-search-hit-cell-badge">${hitIndex}</div>`;
                }
                else {
                    cellElement.classList.add('b-search-hit-cell');
                }
            }

            me.hitEls.push(cellElement);
        }
    }

    //endregion

    //region Context menu

    /**
     * Add search menu item to cell context menu.
     * @param column
     * @param record
     * @param items
     * @returns {*}
     * @private
     */
    getCellMenuItems(column, record, items) {
        const me = this;

        if (column.searchable) {
            items.push({
                text     : me.L('searchForValue'),
                icon     : 'b-fw-icon b-icon-search',
                cls      : 'b-separator',
                name     : 'search',
                disabled : me.disabled,
                onItem   : ({ item }) => {
                    const { column, record } = item;
                    // TODO: Only extract selection from current cell instead? Lazy way for now
                    let sel = window.getSelection().toString();
                    if (!sel) sel = record[column.field];
                    me.search(sel);
                }
            });
        }

        return items;
    }

    //endregion

    //region Events

    /**
     * Chained function called on grids keydown event. Handles backspace, escape, f3 and ctrl/cmd + g keys.
     * @private
     * @param event KeyboardEvent
     */
    onElementKeyDown(event) {
        const me = this;

        if (me.find && me.find !== '') {
            if (event.key === 'F3' || (event.key.toLowerCase() === 'g' && (event.ctrlKey || event.metaKey))) {
                event.preventDefault();

                if (event.shiftKey) {
                    me.gotoPrevHit();
                }
                else {
                    me.gotoNextHit();
                }
            }
        }
    }

    onStoreRefresh() {
        this.search(this.find, false, true);
    }

    //endregion
}

Search.featureClass = 'b-search';

Search._$name = 'Search'; GridFeatureManager.registerFeature(Search);

//TODO: Allow multisort using multitouch?

/**
 * @module Grid/feature/Sort
 */

/**
 * Allows sorting of grid by clicking (or tapping) headers, also displays which columns grid is sorted by (numbered if
 * using multisort). Use modifier keys for multisorting: ctrl + click to add sorter, ctrl + alt + click to remove sorter.
 * The actual sorting is done by the store, see {@link Core.data.mixin.StoreSort#function-sort}.
 *
 * For info on programmatically handling sorting, see {@link Core.data.mixin.StoreSort StoreSort}.
 *
 * This feature is **enabled** by default.
 *
 * @example
 * // sorting feature is enabled, no default value though
 * let grid = new Grid({
 *     features : {
 *         sort : true
 *     }
 * });
 *
 * // use initial sorting
 * let grid = new Grid({
 *     features : {
 *         sort : 'name'
 *     }
 * });
 *
 * // can also be specified on the store
 * let grid = new Grid({
 *     store : {
 *         sorters : [
 *             { field : 'name', ascending : false }
 *         ]
 *     }
 * });
 *
 * // custom sorting function can also be specified on the store
 * let grid = new Grid({
 *     store : {
 *         sorters : [{
 *             fn : (recordA, recordB) => {
 *                 // apply custom logic, for example:
 *                 return recordA.name.length < recordB.name.length ? -1 : 1;
 *             }
 *         }]
 *     }
 * });
 *
 * @extends Core/mixin/InstancePlugin
 * @demo Grid/sorting
 * @classtype sort
 * @externalexample feature/Sort.js
 */
class Sort extends InstancePlugin {
    //region Config

    static get $name() {
        return 'Sort';
    }

    static get defaultConfig() {
        return {
            /**
             * Enable multi sort
             * @config {Boolean}
             * @default
             */
            multiSort : true,

            ignoreRe : new RegExp([
                // Stop this feature from having to know the internals of two other optional features.
                'b-grid-header-resize-handle',
                'b-filter-icon'
            ].join('|')),

            sortableCls   : 'b-sortable',
            sortedCls     : 'b-sort',
            sortedAscCls  : 'b-asc',
            sortedDescCls : 'b-desc'
        };
    }

    //endregion

    //region Init

    construct(grid, config) {
        const me = this;

        // process initial config into an actual config object
        config = me.processConfig(config);

        me.store = grid.store;
        me.grid = grid;

        me.store.on({
            sort    : me.syncHeaderSortState,
            thisObj : me
        });

        super.construct(grid, config);
    }

    // Sort feature handles special config cases, where user can supply a string or an array of sorters
    // instead of a normal config object
    processConfig(config) {
        if (typeof config === 'string' || Array.isArray(config)) {
            return {
                field     : config,
                ascending : null
            };
        }

        return config;
    }

    // override setConfig to process config before applying it
    setConfig(config) {
        super.setConfig(this.processConfig(config));
    }

    set field(field) {
        // Use columns sortable config for initial sorting if it is specified
        const column = this.grid.columns.get(field);
        if (column && typeof column.sortable === 'object') {
            // Normalization of Store & CollectionSorter differences
            column.sortable.field = column.sortable.property || field;
            field = column.sortable;
        }

        this.store.sort(field, this.ascending);
    }

    doDestroy() {
        super.doDestroy();
    }

    //endregion

    //region Plugin config

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            chain : ['onElementClick', 'getHeaderMenuItems', 'getColumnDragToolbarItems', 'renderHeader']
        };
    }

    //endregion

    //region Headers

    /**
     * Update headers to match stores sorters (displays sort icon in correct direction on them)
     * @private
     */
    syncHeaderSortState() {
        const me = this,
            sorterMap = {};

        if (!me.grid.isConfiguring) {
            let storeSorters = me.store.sorters,
                sorterCount = storeSorters.length,
                classList = new DomClassList(),
                sorter;

            // Key sorters object by field name so we can find them.
            for (let sortIndex = 0; sortIndex < sorterCount; sortIndex++) {
                const sorter = storeSorters[sortIndex];
                if (sorter.field) {
                    sorterMap[sorter.field] = {
                        ascending : sorter.ascending,
                        sortIndex : sortIndex + 1
                    };
                }
            }

            // Sync the sortable, sorted, and sortIndex state of each leaf header element
            for (const leafColumn of me.grid.columns.bottomColumns) {
                const leafHeader = leafColumn.element;

                if (leafHeader) {
                    // TimeAxisColumn in Scheduler has no textWrapper, since it has custom rendering,
                    // but since it cannot be sorted by anyway lets just ignore it
                    const dataset = leafColumn.textWrapper && leafColumn.textWrapper.dataset;

                    // data-sortIndex is 1-based, and only set if there is > 1 sorter.
                    // iOS Safari throws a JS error if the requested delete property is not present.
                    dataset && dataset.sortIndex && delete dataset.sortIndex;

                    classList.value = leafHeader.classList;

                    if (leafColumn.sortable !== false) {
                        classList.add(me.sortableCls);
                        sorter = sorterMap[leafColumn.field];
                        if (sorter) {
                            if (sorterCount > 1 && dataset) {
                                dataset.sortIndex = sorter.sortIndex;
                            }
                            classList.add(me.sortedCls);
                            if (sorter.ascending) {
                                classList.add(me.sortedAscCls);
                                classList.remove(me.sortedDescCls);
                            }
                            else {
                                classList.add(me.sortedDescCls);
                                classList.remove(me.sortedAscCls);
                            }
                        }
                        else {
                            classList.remove(me.sortedCls);
                            // Not optimal, but easiest way to make sure sort feature does not remove needed classes.
                            // Better solution would be to use different names for sorting and grouping
                            if (!classList['b-group']) {
                                classList.remove(me.sortedAscCls);
                                classList.remove(me.sortedDescCls);
                            }
                        }
                    }
                    else {
                        classList.remove(me.sortableCls);
                    }

                    // Update the element's classList
                    DomHelper.syncClassList(leafHeader, classList);
                }
            }
        }
    }

    //endregion

    //region Context menu

    /**
     * Adds sort menu items to header context menu.
     * @param column
     * @param items
     * @returns {Object[]}
     * @private
     */
    getHeaderMenuItems(column, items) {
        const
            me = this,
            { disabled } = me;

        if (column.sortable !== false) {
            items.push({
                text   : me.L('sortAscending'),
                icon   : 'b-fw-icon b-icon-sort-asc',
                name   : 'sortAsc',
                cls    : 'b-separator',
                weight : 105,
                disabled,
                onItem : ({ item : { column } }) => me.store.sort(column.field, true)
            });
            items.push({
                text   : me.L('sortDescending'),
                icon   : 'b-fw-icon b-icon-sort-desc',
                name   : 'sortDesc',
                weight : 105,
                disabled,
                onItem : ({ item : { column } }) => me.store.sort(column.field, false)
            });

            if (me.multiSort && me.grid.columns.records.filter(col => col.sortable).length > 1) {
                const sorter = this.grid.store.sorters.find(s => s.field === column.field);

                items.push({
                    text   : me.L('multiSort'),
                    icon   : 'b-fw-icon b-icon-sort',
                    name   : 'multiSort',
                    weight : 105,
                    disabled,
                    menu   : [{
                        text     : sorter ? me.L('toggleSortAscending') : me.L('addSortAscending'),
                        icon     : 'b-fw-icon b-icon-sort-asc',
                        name     : 'addSortAsc',
                        disabled : sorter && sorter.ascending,
                        weight   : 105,
                        onItem   : ({ item : { column } }) => me.store.addSorter(column.field, true)
                    }, {
                        text     : sorter ? me.L('toggleSortDescending') : me.L('addSortDescending'),
                        icon     : 'b-fw-icon b-icon-sort-desc',
                        name     : 'addSortDesc',
                        disabled : sorter && !sorter.ascending,
                        weight   : 105,
                        onItem   : ({ item : { column } }) => me.store.addSorter(column.field, false)
                    }, {
                        text     : me.L('removeSorter'),
                        icon     : 'b-fw-icon b-icon-remove',
                        name     : 'remove-sorter',
                        weight   : 105,
                        disabled : !sorter,
                        onItem   : ({ item : { column } }) => me.store.removeSorter(column.field)
                    }]
                });
            }
        }
        return items;
    }

    /**
     * Supply items to ColumnDragToolbar
     * @private
     */
    getColumnDragToolbarItems(column, items) {
        const
            me                  = this,
            { store, disabled } = me;

        if (column.sortable !== false) {
            items.push({
                text   : me.L('sortAscendingShort'),
                group  : me.L('Sort'),
                icon   : 'b-icon b-icon-sort-asc',
                name   : 'sortAsc',
                cls    : 'b-separator',
                weight : 105,
                disabled,
                onDrop : ({ column }) => store.sort(column.field, true)
            });
            items.push({
                text   : me.L('sortDescendingShort'),
                group  : me.L('Sort'),
                icon   : 'b-icon b-icon-sort-desc',
                name   : 'sortDesc',
                weight : 105,
                disabled,
                onDrop : ({ column }) => store.sort(column.field, false)
            });

            const sorter = store.sorters.find(s => s.field === column.field);

            Array.prototype.push.apply(items, [
                {
                    text     : me.L('addSortAscendingShort'),
                    group    : me.L('Multisort'),
                    icon     : 'b-icon b-icon-sort-asc',
                    name     : 'multisortAddAsc',
                    disabled : disabled || (sorter && sorter.ascending),
                    weight   : 105,
                    onDrop   : ({ column }) => store.addSorter(column.field, true)
                }, {
                    text     : me.L('addSortDescendingShort'),
                    group    : me.L('Multisort'),
                    icon     : 'b-icon b-icon-sort-desc',
                    name     : 'multisortAddDesc',
                    disabled : disabled || (sorter && !sorter.ascending),
                    weight   : 105,
                    onDrop   : ({ column }) => store.addSorter(column.field, false)
                }, {
                    text     : me.L('removeSorterShort'),
                    group    : me.L('Multisort'),
                    icon     : 'b-icon b-icon-remove',
                    name     : 'multisortRemove',
                    weight   : 105,
                    disabled : disabled || !sorter,
                    onDrop   : ({ column }) => store.removeSorter(column.field)
                }
            ]);
        }
        return items;
    }

    //endregion

    //region Events

    /**
     * Clicked on header, sort Store.
     * @private
     */
    onElementClick(event) {
        const
            me     = this,
            store  = me.store,
            target = event.target,
            header = DomHelper.up(target, '.b-grid-header.b-sortable'),
            field  = header && header.dataset.column;

        if (me.ignoreRe.test(target.className) || me.disabled) return;

        //Header
        if (header && field) {
            const column = me.grid.columns.getById(header.dataset.columnId),
                columnGrouper = store.isGrouped && store.groupers.find(g => g.field === field);

            // The Group feature will handle the change of the grouper's direction
            if (columnGrouper && !event.shiftKey) {
                return;
            }

            if (column.sortable && !event.shiftKey) {
                if (event.ctrlKey && event.altKey) {
                    store.removeSorter(column.field);
                }
                else {
                    let sortBy = column.field;

                    if (typeof column.sortable === 'function') {
                        sortBy = {
                            field : column.field,
                            fn    : column.sortable
                        };
                    }
                    else if (typeof column.sortable === 'object') {
                        sortBy = column.sortable;
                        // Handle mismatch between Store#sort and CollectionSorter (field/property)
                        if (!sortBy.field) {
                            sortBy.field = sortBy.property || column.field;
                        }
                    }
                    store.sort(sortBy, null, event.ctrlKey);
                }
            }
        }
    }

    /**
     * Called when grid headers are rendered, make headers match current sorters.
     * @private
     */
    renderHeader() {
        this.syncHeaderSortState();
    }

    //endregion
}

Sort.featureClass = 'b-sort';

Sort._$name = 'Sort'; GridFeatureManager.registerFeature(Sort, true);

/**
 * @module Grid/feature/Stripe
 */

/**
 * Stripes rows, by adding even (b-even) or odd (b-odd) css classes to row elements.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @example
 * let grid = new Grid({
 *   features: {
 *     stripe: true
 *   }
 * });
 *
 * @demo Grid/columns
 * @classtype stripe
 * @externalexample feature/Stripe.js
 */
class Stripe extends InstancePlugin {

    static get $name() {
        return 'Stripe';
    }

    construct(grid, config) {
        super.construct(grid, config);

        grid.rowManager.on({
            renderrow : 'onRenderRow',
            thisObj   : this
        });
    }

    doDisable(disable) {
        // Refresh rows to add/remove even/odd classes
        this.client.refreshRows();

        super.doDisable(disable);
    }

    /**
     * Applies even/odd CSS when row is rendered
     * @param {Grid.row.Row} rowModel
     * @private
     */
    onRenderRow({ row }) {
        if (!this.disabled) {
            row.addCls(row.dataIndex % 2 === 0 ? 'b-even' : 'b-odd');
        }
    }
}

Stripe._$name = 'Stripe'; GridFeatureManager.registerFeature(Stripe);

//TODO: Handle paths? Like expandPath('Parent A/Sub B/Leaf')

/**
 * @module Grid/feature/Tree
 */

const immediatePromise$3 = new Promise((resolve) => resolve());

/**
 * Feature that makes the grid work more like a tree. Included by default in {@link Grid.view.TreeGrid}. Requires
 * exactly one {@link Grid.column.TreeColumn} among grids columns. That column will have its renderer replaced with a
 * tree renderer that adds padding and icon to give the appearance of a tree. The original renderer is preserved and
 * also called.
 *
 * This feature is <strong>disabled</strong> by default. When enabled, the feature cannot be disabled during runtime.
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @demo Grid/tree
 * @classtype tree
 * @externalexample feature/Tree.js
 */
class Tree extends Delayable(InstancePlugin) {
    //region Config

    static get $name() {
        return 'Tree';
    }

    static get defaultConfig() {
        return {
            /**
             * Expand parent nodes when clicking on their cell
             * @config {Boolean}
             * @default
             */
            expandOnCellClick : false
        };
    }

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            assign : ['collapseAll', 'expandAll', 'collapse', 'expand', 'expandTo', 'toggleCollapse'],
            before : ['navigateRight', 'navigateLeft'],
            chain  : ['onElementClick', 'onElementKeyDown']
        };
    }

    //endregion

    //region Init

    construct(grid, config) {
        const me = this;

        super.construct(grid, config);

        // find column
        const treeColumn = grid.columns.find(col => col instanceof TreeColumn);

        

        Object.assign(me, {
            grid       : grid,
            store      : grid.store,
            rowManager : grid.rowManager,
            treeColumn : treeColumn
        });

        me.store.on({
            beforeLoadChildren    : 'onBeforeLoadChildren',
            loadChildren          : 'onLoadChildren',
            loadChildrenException : 'onLoadChildrenException',
            beforeToggleNode      : 'onBeforeToggleNode',
            thisObj               : me
        });
    }

    doDisable(disable) {
        
    }

    //endregion

    //region Expand & collapse

    /**
     * Collapse an expanded node or expand a collapsed. Optionally forcing a certain state.
     * @param {String|Number|Core.data.Model} idOrRecord Record (the node itself) or id of a node to toggle
     * @param {Boolean} [collapse] Force collapse (true) or expand (false)
     * @param {Boolean} [skipRefresh] Set to true to not refresh rows (if calling in batch)
     * @returns {Promise}
     * @async
     */
    async toggleCollapse(idOrRecord, collapse, skipRefresh = false) {
        

        const
            me                 = this,
            { store, grid }    = me,
            rowManager         = grid.rowManager,
            record             = store.getById(idOrRecord),
            meta               = record.instanceMeta(store);

        if (await store.toggleCollapse(record, collapse)) {
            const row = rowManager.getRowFor(record);
            if (row) {
                const cell = row.getCell(me.treeColumn.id);

                // Toggle cell's expanded/collapsed state
                row.renderCell(cell, record);
            }

            // Add a temporary cls, used by Scheduler & Gantt to prevent transitions on events/tasks
            // Block multiple applications in the case of a recursive collapseAll operation
            if (!me.isTogglingNode) {
                grid.element.classList.add('b-toggling-node');
                me.isTogglingNode = true;
                me.requestAnimationFrame(() => {
                    grid.element.classList.remove('b-toggling-node');
                    me.isTogglingNode = false;
                });
            }

            grid.trigger(meta.collapsed ? 'collapseNode' : 'expandNode', { source : grid, record });
            grid.trigger('toggleNode', { source : grid, record, collapse });
        }
    }

    /**
     * Collapse a single node. This function is exposed on Grid and can thus be called as `grid.collapse()`
     * @param {String|Number|Core.data.Model} idOrRecord Record (the node itself) or id of a node to collapse
     * @returns {Promise}
     */
    async collapse(idOrRecord) {
        return this.toggleCollapse(idOrRecord, true);
    }

    /**
     * Expand a single node. This function is exposed on Grid and can thus be called as `grid.expand()`
     * @param {String|Number|Core.data.Model} idOrRecord Record (the node itself) or id of a node to expand
     * @returns {Promise}
     */
    async expand(idOrRecord) {
        return this.toggleCollapse(idOrRecord, false);
    }

    onBeforeToggleNode({ record, collapse }) {
        this.grid.trigger('beforeToggleNode', { record, collapse });
    }

    onBeforeLoadChildren({ source : store, params }) {
        const
            parent = store.getById(params[store.modelClass.idField]),
            row = this.grid.rowManager.getRowFor(parent);

        if (row) {
            row.addCls('b-loading-children');
        }
    }

    onLoadChildren({ source : store, params }) {
        const
            parent = store.getById(params[store.modelClass.idField]),
            row = this.grid.rowManager.getRowFor(parent);

        if (row) {
            row.removeCls('b-loading-children');
        }
    }

    onLoadChildrenException({ record }) {
        const row = this.grid.rowManager.getRowFor(record);

        if (row) {
            row.removeCls('b-loading-children');
        }
    }

    /**
     * Expand or collapse all nodes, as specified by param, starting at the passed node (which defaults to the root node)
     * @param {Boolean} [collapse] Set to true to collapse, false to expand (defaults to true)
     * @param {Core.data.Model} [topNode] The topmost node from which to cascade a collapse.
     * Defaults to the {@link Core.data.Store#property-rootNode}. Not included in the cascade if
     * the root node is being used.
     * @returns {Promise}
     */
    expandOrCollapseAll(collapse = true, topNode = this.store.rootNode) {
        // TODO: Some logic here and some in the store, keep in same place maybe
        const
            { grid, store } = this,
            promises = [];

        grid.trigger('beforeToggleAllNodes', { source : grid, collapse });

        // Each collapse/expand will trigger events on store, avoid that by suspending
        store.suspendEvents();
        store.traverse(record => {
            const gridMeta = record.instanceMeta(store);
            if (!record.isLeaf) {
                if (collapse && !gridMeta.collapsed) {
                    this.toggleCollapse(record, true, true);
                }
                else if (!collapse && gridMeta.collapsed) {
                    promises.push(this.toggleCollapse(record, false, true));
                }
            }
        }, topNode, topNode === store.rootNode);
        store.resumeEvents();

        return (collapse ? immediatePromise$3 : Promise.all(promises)).then(() => {
            // Return to top when collapsing all
            grid.refreshRows(collapse);

            grid.trigger('toggleAllNodes', { source : grid, collapse });
        });
    }

    /**
     * Collapse all nodes. This function is exposed on Grid and can thus be called as `grid.collapseAll()`
     * @returns {Promise}
     */
    async collapseAll() {
        return this.expandOrCollapseAll(true);
    }

    /**
     * Expand all nodes. This function is exposed on Grid and can thus be called as `grid.expandAll()`
     * @returns {Promise}
     */
    async expandAll() {
        return this.expandOrCollapseAll(false);
    }

    /**
     * Expands parent nodes to make this node "visible". This function is exposed on Grid and can thus be called as
     * `grid.expandTo()`
     * @param {String|Number|Core.data.Model} idOrRecord Record (the node itself) or id of a node
     * @returns {Promise}
     */
    async expandTo(idOrRecord) {
        const me         = this,
            record     = me.store.getById(idOrRecord),
            recordMeta = record.instanceMeta(me.store);

        // Already visible? abort
        if (recordMeta.hiddenByCollapse === false) return;

        // Expand each parent
        let refreshNeeded = false,
            parent        = record.parent,
            parents       = [];

        // To expand path correctly we need to do it from top
        // so parent record for each record will be in the store already
        while (parent && !parent.isRoot) {
            parents.push(parent);
            parent = parent.parent;
        }

        await parents.reverse().forEach(async parent => {
            if (parent.instanceMeta(me.store).collapsed) {
                refreshNeeded = true;
            }
            await me.toggleCollapse(parent, false, true);
        });

        if (refreshNeeded) {
            me.grid.refreshRows();
        }

        await me.grid.scrollRowIntoView(record);
    }

    //endregion

    //region Renderer

    //endregion

    //region Events

    /**
     * Called when user clicks somewhere in the grid. Expand/collapse node on icon click.
     * @private
     */
    onElementClick(event) {
        const me       = this,
            target   = event.target,
            cellData = me.grid.getEventData(event);

        // Checks if click is on node expander icon, then toggles expand/collapse. Also toggles on entire cell if expandOnCellClick is true
        if (target.classList.contains('b-tree-expander') || (me.expandOnCellClick && cellData && cellData.record.isParent)) {
            me.toggleCollapse(cellData.record);
        }
    }

    /**
     * Called on key down in grid. Expand/collapse node on [space]
     * @private
     */
    onElementKeyDown(event) {
        // only catch space on grid element, not in editors etc...
        if (event.target === this.client.element && event.key === ' ') {
            event.preventDefault();

            this.toggleCollapse(this.grid.focusedCell.id);
        }
    }

    //endregion

    navigateRight(event) {
        const me           = this,
            grid         = me.grid,
            cellSelector = grid.focusedCell;

        if (cellSelector) {
            const record = grid.store.getById(cellSelector.id);

            // shift triggers tree navigation behaviour, also used by default for single column which is tree
            if (
                grid.columns.getById(cellSelector.columnId).tree &&
                (event.shiftKey || grid.columns.count === 1)
            ) {
                // on collapsed parent, expand
                if (record.isParent && record.instanceMeta(grid.store).collapsed) {
                    me.expand(record);
                }
                // otherwise go down
                else {
                    grid.navigateDown(event);
                }
                return false;
            }
        }
    }

    navigateLeft(event) {
        const me           = this,
            grid         = me.grid,
            cellSelector = grid.focusedCell;

        if (cellSelector) {
            const record = grid.store.getById(cellSelector.id);

            if (
                grid.columns.getById(cellSelector.columnId).tree &&
                (event.shiftKey || grid.columns.count === 1)
            ) {
                // on expanded parent, collapse
                if (record.isParent && !record.instanceMeta(grid.store).collapsed) {
                    me.collapse(record);
                }
                // otherwise go to parent
                else if (record.parent) {
                    grid.focusCell({
                        id       : record.parent.id,
                        columnId : cellSelector.columnId
                    });
                }
                return false;
            }
        }
    }
}

Tree.featureClass = 'b-tree';

Tree._$name = 'Tree'; GridFeatureManager.registerFeature(Tree, false, 'Grid');
GridFeatureManager.registerFeature(Tree, true, 'TreeGrid');

const RowsRange = {
    all     : 'all',
    visible : 'visible'
};

const PaperFormat = {
    A6 : {
        width  : 4.13,
        height : 5.81
    },
    A5 : {
        width  : 5.81,
        height : 8.25
    },
    A4 : {
        width  : 8.25,
        height : 11.69
    },
    A3 : {
        width  : 11.69,
        height : 16.49
    },
    Legal : {
        width  : 8.5,
        height : 14
    },
    Letter : {
        width  : 8.5,
        height : 11
    }
};

const Orientation = {
    portrait  : 'portrait',
    landscape : 'landscape'
};

const FileFormat = {
    pdf : 'pdf',
    png : 'png'
};

/**
 * @module Core/widget/mixin/LocalizableComboItems
 */

/**
 * A mixin that regenerates a combobox items on locale change.
 * @private
 * @mixin
 */
var LocalizableComboItems = Target => class LocalizableComboItems extends (Target || Combo) {

    static get $name() {
        return 'LocalizableComboItems';
    }

    static get defaultConfig() {
        return {
            items : true
        };
    }

    set items(items) {
        if (items === true) {
            items = this.buildLocalizedItems();
        }
        super.items = items;
    }

    get items() {
        return super.items;
    }

    construct(...args) {
        // set a special flag to skip unneeded store translation on construction step
        this.inConstruct = true;
        super.construct(...args);
        this.inConstruct = false;
    }

    buildLocalizedItems() {
        return [];
    }

    updateLocalizedItems() {
        const me = this;

        if (me.store && !me.inConstruct) {
            const { value } = me;

            // TODO: just updating new data is not enough ..selected value text is shown wrong :(
            // it seems caused by selected record cache
            // review this code after #9387 is fixed
            me.store.data = me.buildLocalizedItems();
            me.value = null;
            me.value = value;
            me.syncInputFieldValue(true);
        }
    }

    updateLocalization() {
        this.updateLocalizedItems();
        super.updateLocalization();
    }
};

class LocalizableCombo extends LocalizableComboItems(Combo) { }

LocalizableCombo._$name = 'LocalizableCombo'; BryntumWidgetAdapterRegister.register('localizablecombo', LocalizableCombo);

class ExportRowsCombo extends LocalizableCombo {
    static get $name() {
        return 'ExportRowsCombo';
    }
    
    static get defaultConfig() {
        return {
            editable : false
        };
    }
    
    buildLocalizedItems() {
        const me = this;
        
        return [
            { id : RowsRange.all, text : me.L(RowsRange.all) },
            { id : RowsRange.visible, text : me.L(RowsRange.visible) }
        ];
    }
}

ExportRowsCombo._$name = 'ExportRowsCombo'; BryntumWidgetAdapterRegister.register(ExportRowsCombo.$name, ExportRowsCombo);

class ExportOrientationCombo extends LocalizableCombo {
    static get $name() {
        return 'ExportOrientationCombo';
    }
    
    static get defaultConfig() {
        return {
            editable : false
        };
    }
    
    buildLocalizedItems() {
        const me = this;
        
        return [
            { id : Orientation.portrait, text : me.L(Orientation.portrait) },
            { id : Orientation.landscape, text : me.L(Orientation.landscape) }
        ];
    }
}

ExportOrientationCombo._$name = 'ExportOrientationCombo'; BryntumWidgetAdapterRegister.register(ExportOrientationCombo.$name, ExportOrientationCombo);

/**
 * @module Grid/view/export/ExportDialog
 */

/**
 * Dialog window which allows to pick export options.
 *
 * ```
 * grid = new Grid({
 *     features : {
 *         pdfExport : { exportServer : '...' }
 *     }
 * });
 *
 * grid.features.pdfExport.showExportDialog();
 * ```
 *
 * @extends Core/widget/Popup
 */
class ExportDialog extends Popup {
    static get $name() {
        return 'ExportDialog';
    }
    
    static get defaultConfig() {
        return {
            autoShow  : false,
            autoClose : false,
            closable  : true,
            centered  : true,
    
            /**
             * Grid instance to build export dialog for
             */
            client : null,
    
            /**
             * Set to `false` to allow using PNG + Multipage config in export dialog
             */
            hidePNGMultipageOption : true,

            title : 'L{exportSettings}',
            
            bbar : [
                {
                    type        : 'button',
                    ref         : 'exportButton',
                    color       : 'b-green',
                    localeClass : this,
                    text        : 'L{export}'
                },
                {
                    type        : 'button',
                    ref         : 'cancelButton',
                    color       : 'b-gray',
                    localeClass : this,
                    text        : 'L{cancel}'
                }
            ]
        };
    }
    
    buildDialogItems(config) {
        const
            me                    = this,
            { exporters, client } = config,
            labelWidth            = me.L('labelWidth');
        
        me.columnsStore = client.columns.chain(record => record.isLeaf);
    
        function buildComboItems(obj, fn = x => x) {
            return Object.keys(obj).map(key => ({ id : key, text : fn(key) }));
        }
    
        return [
            {
                labelWidth,
                type         : 'combo',
                ref          : 'columnsField',
                label        : 'L{columns}',
                localeClass  : this,
                store        : me.columnsStore,
                value        : me.columnsStore.allRecords,
                valueField   : 'id',
                displayField : 'text',
                multiSelect  : true
            },
            {
                labelWidth,
                type        : 'exportrowscombo',
                ref         : 'rowsRangeField',
                label       : 'L{rows}',
                localeClass : this,
                value       : RowsRange.all
            },
            {
                labelWidth,
                type                : 'localizablecombo',
                ref                 : 'exporterTypeField',
                label               : 'L{exporterType}',
                localeClass         : this,
                editable            : false,
                value               : exporters[0].type,
                buildLocalizedItems : () => exporters.map(exporter => ({ id : exporter.type, text : exporter.title })),
                onChange({ value }) {
                    this.owner.widgetMap.alignRowsField.hidden = value !== 'multipage';
                }
            },
            {
                labelWidth,
                type        : 'checkbox',
                ref         : 'alignRowsField',
                label       : 'L{alignRows}',
                localeClass : this,
                checked     : true,
                hidden      : exporters[0].type !== 'multipage'
            },
            {
                labelWidth,
                type        : 'combo',
                ref         : 'fileFormatField',
                label       : 'L{fileFormat}',
                localeClass : this,
                editable    : false,
                value       : FileFormat.pdf,
                items       : buildComboItems(FileFormat, value => value.toUpperCase()),
                onChange({ value, oldValue }) {
                    if (me.hidePNGMultipageOption) {
                        const
                            exporterField = me.widgetMap.exporterTypeField,
                            exporter      = exporterField.store.find(r => r.id === 'singlepage');
                        
                        if (value === FileFormat.png && exporter) {
                            this._previousDisabled = exporterField.disabled;
                            exporterField.disabled = true;
                            
                            this._previousValue = exporterField.value;
                            exporterField.value = 'singlepage';
                        }
                        else if (oldValue === FileFormat.png && this._previousValue) {
                            exporterField.disabled = this._previousDisabled;
                            exporterField.value    = this._previousValue;
                        }
                    }
                }
            },
            {
                labelWidth,
                type        : 'combo',
                ref         : 'paperFormatField',
                label       : 'L{paperFormat}',
                localeClass : this,
                editable    : false,
                value       : 'A4',
                items       : buildComboItems(PaperFormat)
            },
            {
                labelWidth,
                type        : 'exportorientationcombo',
                ref         : 'orientationField',
                label       : 'L{orientation}',
                localeClass : this,
                value       : Orientation.portrait
            }
        ];
    }
    
    construct(config = {}) {
        const
            me         = this,
            { client } = config;
        
        if (!client) {
            throw new Error('`client` config is required');
        }
    
        const items = me.buildDialogItems(config);
        
        if (config.items) {
            if (Array.isArray(config.items)) {
                config.items.push(...items);
            }
            else {
                items.forEach(item => {
                    config.items[item.ref] = item;
                    delete item.ref;
                });
            }
        }
        else {
            config.items = items;
        }
        
        config.width = config.width || me.L('width');
        
        super.construct(config);
        
        me.widgetMap.exportButton.on('click', me.onExportClick, me);
        me.widgetMap.cancelButton.on('click', me.onCancelClick, me);
    
        LocaleManagerSingelton.on({
            locale  : 'onLocaleChange',
            prio    : -1,
            thisObj : me
        });
    }
    
    onLocaleChange() {
        const
            labelWidth = this.L('labelWidth');
        
        this.width = this.L('width');
        
        this.eachWidget(widget => {
            if (widget instanceof Field) {
                widget.labelWidth = labelWidth;
            }
        });
    }
    
    onExportClick() {
        const values = this.values;
    
        /**
         * Fires when export button is clicked
         * @event export
         * @param {Object} values Object containing config for {@link Grid.feature.export.PdfExport#function-export export()} method
         * @group Export
         */
        this.trigger('export', { values });
    }
    
    onCancelClick() {
        /**
         * Fires when cancel button is clicked. Popup will hide itself.
         * @event cancel
         * @group Export
         */
        this.trigger('cancel');
        this.hide();
    }
    
    get values() {
        const
            fieldRe = /field/i,
            result = {};
        
        this.eachWidget(widget => {
            if (fieldRe.test(widget.ref)) {
                result[widget.ref.replace(fieldRe, '')] = widget instanceof Checkbox ? widget.checked : widget.value;
            }
        });
        
        return result;
    }
}
ExportDialog._$name = 'ExportDialog';

/**
 * @module Grid/feature/export/exporter/Exporter
 */

/**
 * Base class for all exporters
 * @mixes Core/localization/Localizable
 * @mixes Core/mixin/Events
 */
class Exporter extends Delayable(Events(Localizable(Base))) {
    static get defaultConfig() {
        return {
            /**
             * `True` to replace all linked CSS files URLs to absolute before passing HTML to the server.
             * When passing a string the current origin of the CSS files URLS will be replaced by the passed origin.
             *
             * For example: css files pointing to /app.css will be translated from current origin to {translateURLsToAbsolute}/app.css
             * @config {Boolean|String}
             * @default
             */
            translateURLsToAbsolute : true,

            /**
             * When true links are converted to absolute by combining current window location (with replaced origin) with
             * resource link.
             * When false links are converted by combining new origin with resource link (for angular)
             * @config {Boolean}
             * @default
             */
            keepPathName : true
        };
    }

    /**
     * Template of an extracted page.
     * @param {Object} data Data for the page template
     * @returns {String}
     */
    pageTpl(data) {
        const
            {
                title,
                header,
                footer,
                styles,
                htmlClasses,
                bodyStyle,
                bodyClasses = [],
                paperHeight,
                paperWidth,
                html
            } = data;

        bodyClasses.push(`b-${this.constructor.type}`);

        return TemplateHelper.tpl`
            <!DOCTYPE html>
            <html class="${htmlClasses}" style="width: ${paperWidth}in; height: ${paperHeight}in;">
                <head>
                    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
                    <title>${title}</title>
                    ${styles.join('')}
                </head>
                <body class="b-export ${bodyClasses.join(' ')}" style="width: ${paperWidth}in; height: ${paperHeight}in; ${bodyStyle}">
                    <div class="b-export-content">
                        ${header && `<div class="b-export-header" style="width: 100%">${header}</div>`}
                        <div class="b-export-body"><div class="b-export-viewport">${html}</div></div>
                        ${footer && `<div class="b-export-footer" style="width: 100%">${footer}</div>`}
                    </div>
                </body>
            </html>`;
    }

    /**
     * Returns all style-related tags: `<style>` and `<link rel="stylesheet">`
     * @property {String[]}
     * @readonly
     */
    get stylesheets() {
        const me = this;

        if (me._stylesheets) {
            return me._stylesheets;
        }

        const
            translate       = me.translateURLsToAbsolute,
            origin          = window.origin,
            styleSheetNodes = Array.from(document.querySelectorAll('link[rel="stylesheet"], style')),
            styles          = [];

        styleSheetNodes.forEach(node => {
            node = node.cloneNode(true);

            // put absolute URL to node `href` attribute
            if (translate && node.href) {
                let result;

                if (translate === true) {
                    result = node.href;
                }
                // translate is truthy if we are here, which means it is string now
                else {
                    if (this.keepPathName) {
                        result = node.href.replace(origin, translate);
                    }
                    else {
                        result = new URL(node.getAttribute('href'), translate);
                    }
                }

                node.setAttribute('href', result);
            }

            let styleText;

            // Empty style tag will be copied in IE, so we need to use cssText
            // http://stackoverflow.com/questions/5227088/creating-style-node-adding-innerhtml-add-to-dom-and-ie-headaches
            if (BrowserHelper.isIE11 && node.styleSheet && /style/i.test(node.tagName)) {
                styleText = `<style type="text/css">${node.styleSheet.cssText}</style>`;
            }
            else {
                styleText = node.outerHTML;
            }

            if (translate && /style/i.test(node.tagName)) {
                const converter = me.getStyleTagURLConverter(translate);
                styleText = styleText.replace(/url\(['"]?(.+?)['"]?\)/g, converter);
            }

            styles.push(styleText);
        });

        styles.push(
            `<style>
                body, html {
                    overflow: auto;
                }
                
                body {
                    position: relative;
                    margin: 0;
                }
            </style>`);

        return me._stylesheets = styles;
    }

    set stylesheets(value) {
        this._stylesheets = value;
    }

    getStyleTagURLConverter(translate) {
        return function(match, url) {
            let result;

            try {
                let base;

                // Filter out local references, e.g. to svg marker
                if (/^#/.test(url)) {
                    result = match;
                }
                else {
                    if (translate === true) {
                        base = window.location.href;
                    }
                    // translate is truthy if we are here, which means it is string now
                    else {
                        if (this.keepPathName) {
                            base = window.location.href.replace(window.location.origin, translate);
                        }
                        else {
                            base = translate;
                        }
                    }

                    result = `url('${new URL(url, base).href}')`;
                }
            }
            catch (e) {
                result = match;
            }

            return result;
        }.bind(this);
    }

    saveState({ client }) {
        this.state = client.state;
    }

    async restoreState({ client }) {
        let waitForScrollEnd = false;

        if (client.scrollable.y !== this.state.scroll.scrollTop) {
            waitForScrollEnd = true;
        }

        client.state = this.state;

        if (waitForScrollEnd) {
            await new Promise(resolve => {
                client.scrollable.on({
                    scrollEnd() {
                        resolve();
                    },
                    once : true
                });
            });
        }
    }

    beforeExport() {
        // Into this element we will put HTML for export
        this.element = document.createElement('div');
    }

    //region DOM helpers

    cloneElement(element, target = this.element, clear = true) {
        if (clear) {
            target.innerHTML = '';
        }

        if (BrowserHelper.isChrome) {
            target.appendChild(element.cloneNode(true));
        }
        else {
            target.innerHTML = element.outerHTML;
        }

        DomHelper.removeEachSelector(target, '.b-grid-row');

        target.querySelector('.b-gridbase > .b-mask').remove();
    }

    /**
     * Appends generated header/footer element to the document body to measure their height
     * @param html
     * @returns {number}
     * @private
     */
    measureElement(html = '') {
        if (html instanceof HTMLElement) {
            html = html.outerHTML;
        }

        const target = DomHelper.createElement({
            parent : document.body,
            style  : {
                visibility : 'hidden',
                position   : 'absolute'
            },
            // Add html to measure to a div between two other divs to take margin into account
            html : `<div style="height: 1px"></div>${html}<div style="height: 1px"></div>`
        });

        const result = target.offsetHeight - 2;

        target.remove();

        return result;
    }

    // Converts local urls to absolute
    prepareHTML(html) {
        if (html instanceof HTMLElement) {
            html = html.outerHTML;
        }

        const target = DomHelper.createElement({
            parent : document.body,
            style  : {
                visibility : 'hidden',
                position   : 'absolute'
            },
            html
        });

        const elements = target.querySelectorAll('img');

        for (let i = 0, l = elements.length; i < l; i++) {
            elements[i].setAttribute('src', elements[i].src);
        }

        const result = target.innerHTML;

        target.remove();

        return result;
    }

    createPlaceholder(el, clear = true) {
        if (clear) {
            el.innerHTML = '';
        }

        return DomHelper.createElement({
            parent : el,
            id     : IdHelper.generateId('export')
        });
    }

    getVirtualScrollerHeight(client) {
        let result = 0;

        // If overlay scroll is enabled, this will return 0
        // when disabled, it will report proper virutalScrollers element height
        client.eachSubGrid(subGrid => {
            if (subGrid.overflowingHorizontally) {
                result = DomHelper.scrollBarWidth;
            }
        });

        // If there's a visible scrollbar, need to also take border height into account
        return result === 0 ? result : (result + 1);
    }

    //endregion

    inchToPx(value) {
        // 1in = 96px for screens
        // https://developer.mozilla.org/en-US/docs/Web/CSS/length#Absolute_length_units
        return value * 96;
    }

    getScaleValue(base, value) {
        return Math.floor((base * 10000 / value)) / 10000;
    }

    async export(config) {
        const me = this;

        let pages;
        
        me.beforeExport();

        me.saveState(config);

        await me.prepareComponent(config);
    
        try {
            pages = await me.getPages(config);
        }
        finally {
            await me.restoreComponent(config);
    
            me.stylesheets = null;
    
            // https://app.assembla.com/spaces/bryntum/tickets/9400-scrollrowintoview-promise-is-not-reliable/details
            // Restoring scroll might trigger rows repaint on next animation frame. We are
            // waiting for next animation frame in such case. Covered in SinglePage.t.js
            await new Promise(resolve => me.requestAnimationFrame(resolve));
    
            await me.restoreState(config);
        }
        
        return pages;
    }

    async getPages(config) {
        const
            generator = this.pagesExtractor(config),
            pages     = [];

        let step;

        while ((step = await generator.next()) && !step.done) {
            pages.push(step.value);
        }

        return pages;
    }

    async prepareComponent(config) {
        const
            me          = this,
            { client, columns, rowsRange } = config,
            exportMeta  = me.exportMeta = {
                totalWidth  : 0,
                totalHeight : 0 - me.getVirtualScrollerHeight(client),
                subGrids    : {}
            };

        client.columns.forEach(column => {
            if (columns.includes(column.id)) {
                column.show();
            }
            else {
                column.hide();
            }
        });

        if (client.rowManager.rowCount > 0) {
            if (rowsRange === RowsRange.all) {
                exportMeta.firstVisibleDataIndex = client.rowManager.rows[0].dataIndex;

                await client.scrollable.scrollTo(0, 0);
            }
            else {
                const firstVisibleDataIndex = exportMeta.firstVisibleDataIndex = client.rowManager.rows.find(row => row.bottom > client.scrollable.y).dataIndex;

                await client.scrollRowIntoView(client.store.getAt(firstVisibleDataIndex), { block : 'start' });

                config.alignRows = true;
            }
        }

        // clone whole grid element to the detached container
        this.cloneElement(client.element);

        const { element } = me;

        client.eachSubGrid(subGrid => {
            const
                placeHolder = me.createPlaceholder(element.querySelector(`[id="${subGrid.id}"]`), false),
                width       = subGrid.columns.visibleColumns.reduce((result, column) => {
                    if (typeof column.width === 'number') {
                        result += column.width;
                    }
                    else {
                        result += client.getHeaderElement(column.id).offsetWidth;
                    }
                    return result;
                }, 0);

            exportMeta.totalWidth += width;

            const splitterEl = subGrid.splitterElement;

            if (splitterEl) {
                exportMeta.totalWidth += splitterEl.offsetWidth;
            }

            exportMeta.subGrids[subGrid.region] = {
                id       : subGrid.id,
                headerId : subGrid.header && subGrid.header.id || null,
                footerId : subGrid.footer && subGrid.footer.id || null,
                rows     : [],
                placeHolder,
                width
            };
        });
    }

    prepareExportElement() {
        const
            me = this,
            { element, exportMeta } = me;

        // Exporters may change subGrid width, e.g. when specific date range is exported
        Object.values(exportMeta.subGrids).forEach(({ width, id, headerId, footerId }) => {
            [id, headerId, footerId].forEach(id => {
                if (id) {
                    element.querySelector(`[id="${id}"]`).style.width = `${width}px`;
                }
            });
        });

        return element.innerHTML;
    }

    async restoreComponent() {}

    async scrollRowIntoView(client, index) {
        await client.scrollRowIntoView(client.store.getAt(index), { block : 'start' });

        // #9400 - scrollRowIntoView promise is not reliable
        await new Promise(resolve => this.requestAnimationFrame(resolve));
    }
}

// HACK: terser/obfuscator doesn't yet support async generators, when processing code it converts async generator to regular async
// function.
/**
 * Pages generator. Value should be string with exported HTML
 * @param {Object} config
 * @returns {AsyncIterableIterator<{value: String, done: Boolean}>}
 * @private
 */
Exporter.prototype.pagesExtractor = async function * pagesExtractor() {
    yield '';
};
Exporter._$name = 'Exporter';

class MultiPageExporter extends Exporter {
    static get type() {
        return 'multipage';
    }
    
    static get title() {
        // In case locale is missing exporter is still distinguishable
        return this.L('multipage');
    }
    
    //region State management
    
    async stateNextPage({ client }) {
        const { exportMeta } = this;
        
        ++exportMeta.currentPage;
        ++exportMeta.verticalPosition;
    
        delete exportMeta.lastExportedRowBottom;
    
        // If current vertical position is greater than max vertical pages, switch to next column
        if (exportMeta.verticalPosition >= exportMeta.verticalPages) {
            exportMeta.verticalPosition = exportMeta.currentPageTopMargin = 0;
            ++exportMeta.horizontalPosition;
            
            await this.scrollRowIntoView(client, exportMeta.firstVisibleDataIndex, { block : 'start' });
        }
    }
    
    //endregion
    
    //region Preparation
    
    async prepareComponent(config) {
        await super.prepareComponent(config);
    
        const
            me              = this,
            { exportMeta }  = me,
            {
                client,
                headerTpl,
                footerTpl,
                alignRows
            }               = config,
            paperFormat     = PaperFormat[config.paperFormat],
            isPortrait      = config.orientation === Orientation.portrait,
            paperWidth      = isPortrait ? paperFormat.width : paperFormat.height,
            paperHeight     = isPortrait ? paperFormat.height : paperFormat.width,
            pageWidth       = me.inchToPx(paperWidth),
            pageHeight      = me.inchToPx(paperHeight),
            horizontalPages = Math.ceil(exportMeta.totalWidth / pageWidth);
    
        // To estimate amount of pages correctly we need to know height of the header/footer on every page
        let
            totalHeight   = exportMeta.totalHeight + client.height - client.bodyHeight + client.scrollable.scrollHeight,
            contentHeight = pageHeight;
        
        if (headerTpl) {
            contentHeight -= me.measureElement(headerTpl({
                totalWidth  : exportMeta.totalWidth,
                totalPages  : -1,
                currentPage : -1
            }));
        }
    
        if (footerTpl) {
            contentHeight -= me.measureElement(footerTpl({
                totalWidth  : exportMeta.totalWidth,
                totalPages  : -1,
                currentPage : -1
            }));
        }
        
        let verticalPages, totalRows = client.store.count;
    
        if (config.rowsRange === RowsRange.visible) {
            totalRows = client.rowManager.visibleRowCount;
        
            const lastRowBottom = client.rowManager.rows[totalRows - 1].bottom;
        
            totalHeight = totalHeight - client.scrollable.scrollHeight + lastRowBottom;
        }
        
        // alignRows config specifies if rows should be always fully visible. E.g. if row doesn't fit on the page, it goes
        // to the top of the next page
        if (alignRows) {
            // we need to estimate amount of vertical pages for case when we only put row on the page if it fits
            // first we need to know how much rows would fit one page, keeping in mind first page also contains header
            // This estimation is loose, because row height might differ much between pages
            const
                rowHeight       = client.rowManager.rowOffsetHeight,
                rowsOnFirstPage = Math.floor((contentHeight - client.headerHeight) / rowHeight),
                rowsPerPage     = Math.floor(contentHeight / rowHeight),
                remainingRows   = totalRows - rowsOnFirstPage;
            
            verticalPages = 1 + Math.ceil(remainingRows / rowsPerPage);
        }
        else {
            verticalPages = Math.ceil(totalHeight / contentHeight);
        }
        
        Object.assign(exportMeta, {
            paperWidth,
            paperHeight,
            pageWidth,
            pageHeight,
            horizontalPages,
            verticalPages,
            totalHeight,
            contentHeight,
            totalRows,
            totalPages           : horizontalPages * verticalPages,
            currentPage          : 0,
            verticalPosition     : 0,
            horizontalPosition   : 0,
            currentPageTopMargin : 0
        });
        
        this.adjustRowBuffer(client);
    }
    
    async restoreComponent(config) {
        await super.restoreComponent(config);
        
        this.restoreRowBuffer(config.client);
    }
    
    // Row buffer has to be adjusted to render complete row set per exported page. See virtual scrolling section in README
    // for more details
    adjustRowBuffer(client) {
        const
            { contentHeight } = this.exportMeta,
            { rowManager }    = client;
        
        this.oldRowManagerConfig = {
            prependRowBuffer : rowManager.prependRowBuffer,
            appendRowBuffer  : rowManager.appendRowBuffer
        };
    
        // render 3 times more rows to get enough to fill exported page
        const adjustedRowBuffer = Math.ceil(contentHeight / rowManager.rowOffsetHeight);
    
        rowManager.prependRowBuffer = adjustedRowBuffer;
        rowManager.appendRowBuffer  = adjustedRowBuffer;
        
        client.renderRows();
    }
    
    restoreRowBuffer(client) {
        client.rowManager.prependRowBuffer = this.oldRowManagerConfig.prependRowBuffer;
        client.rowManager.appendRowBuffer  = this.oldRowManagerConfig.appendRowBuffer;
     
        // There is no need to force rendering rows here, those would be updated during applyState call on a grid.
        // More precisely - during setRowHeight method.
    }
    
    //endregion
    
    async buildPage(config) {
        const
            me = this,
            { exportMeta } = me,
            { client, headerTpl, footerTpl, alignRows } = config,
            { totalWidth, totalPages, currentPage, subGrids, currentPageTopMargin, verticalPosition, totalRows } = exportMeta,
            { rowManager } = client,
            { rows }       = rowManager;
        
        // Rows are stored in shared state object, need to clean it before exporting next page
        Object.values(subGrids).forEach(subGrid => subGrid.rows = []);
        
        // With variable row height total height might change after scroll, update it
        // to show content completely on the last page
        if (config.rowsRange === RowsRange.all) {
            exportMeta.totalHeight = client.height - client.bodyHeight + client.scrollable.scrollHeight - me.getVirtualScrollerHeight(client);
        }
    
        let headerHeight      = 0,
            footerHeight      = 0,
            index             = config.rowsRange === RowsRange.visible
                ? rows.findIndex(r => r.bottom > client.scrollable.y)
                : rows.findIndex(r => r.bottom + currentPageTopMargin + client.headerHeight > 0),
            remainingHeight, header, footer;
        
        const
            firstRowIndex     = index,
            // This is a portion of the row which is not visible, which means it shouldn't affect remaining height
            // Don't calculate for the first page
            overflowingHeight = verticalPosition === 0 ? 0 : rows[index].top + currentPageTopMargin + client.headerHeight;
    
        // Measure header and footer height
        if (headerTpl) {
            header = me.prepareHTML(headerTpl({
                totalWidth,
                totalPages,
                currentPage
            }));
            headerHeight = me.measureElement(header);
        }
    
        if (footerTpl) {
            footer = me.prepareHTML(footerTpl({
                totalWidth,
                totalPages,
                currentPage
            }));
            footerHeight = me.measureElement(footer);
        }
    
        // Calculate remaining height to fill with rows
        // remainingHeight is height of the page content region to fill. When next row is exported, this heights gets
        // reduced. Since top rows may be partially visible, it would lead to increasing error and eventually to incorrect
        // exported rows for the page
        remainingHeight = exportMeta.pageHeight - headerHeight - footerHeight - overflowingHeight;
    
        // first exported page container header
        if (verticalPosition === 0) {
            remainingHeight -= client.headerHeight;
        }
        
        // data index of the last collected row
        let lastDataIndex,
            offset = 0;
        
        while (remainingHeight > 0) {
            const row = rows[index];
            
            if (alignRows && remainingHeight < row.offsetHeight) {
                offset = -remainingHeight;
                remainingHeight = 0;
                // If we skip a row save its bottom to meta data in order to align canvases height
                // properly
                me.exportMeta.lastExportedRowBottom = rows[index - 1].bottom;
            }
            else {
                me.collectRow(row);
    
                remainingHeight -= row.offsetHeight;
    
                lastDataIndex = row.dataIndex;
    
                // Last row is processed, still need to fill the view
                if (++index === rows.length && remainingHeight > 0) {
                    if (lastDataIndex + 1 === client.store.count) {
                        remainingHeight = 0;
                    }
                }
                else if (config.rowsRange === RowsRange.visible && (index - firstRowIndex) === totalRows) {
                    remainingHeight = 0;
                }
            }
        }
    
        await me.onRowsCollected(rows.slice(firstRowIndex, index), config);

        // No scrolling required if we are only exporting currently visible rows
        if (config.rowsRange === RowsRange.visible) {
            exportMeta.scrollableTopMargin = client.scrollable.y;
        }
        else {
            // With variable row height row manager migh relayout rows to fix position, moving them up or down.
            const detacher = rowManager.on('offsetrows', ({ offset : value }) => offset += value);
        
            await me.scrollRowIntoView(client, lastDataIndex + 1);
        
            detacher();
        }
    
        const html = me.buildPageHtml();
        
        return { html, header, footer, offset };
    }
    
    async onRowsCollected() {}
    
    collectRow(row) {
        const subGrids = this.exportMeta.subGrids;
        
        Object.entries(row.elements).forEach(([key, value]) => {
            subGrids[key].rows.push(value.outerHTML);
        });
    }
    
    buildPageHtml() {
        const
            me           = this,
            { subGrids } = me.exportMeta;
        
        // Now when rows are collected, we need to add them to exported grid
        let html = me.prepareExportElement();
        
        Object.values(subGrids).forEach(({ placeHolder, rows }) => {
            const placeHolderText = placeHolder.outerHTML;
            html = html.replace(placeHolderText, rows.join(''));
        });
        
        return html;
    }
    
    prepareExportElement() {
        const
            me = this,
            { element, exportMeta } = me;

        if (exportMeta.scrollableTopMargin) {
            element.querySelector('.b-grid-vertical-scroller').style.marginTop = `-${exportMeta.scrollableTopMargin}px`;
        }

        return super.prepareExportElement();
    }
}

// HACK: terser/obfuscator doesn't yet support async generators, when processing code it converts async generator to regular async
// function.
MultiPageExporter.prototype.pagesExtractor = async function * pagesExtractor(config) {
    const
        me = this,
        {
            exportMeta,
            stylesheets
        }  = me,
        {
            totalWidth,
            totalPages,
            paperWidth,
            paperHeight,
            contentHeight
        }  = exportMeta;
    
    let currentPage;
    
    while ((currentPage = exportMeta.currentPage) < totalPages) {
        me.trigger('exportStep', { text : me.L('exportingPage', { currentPage, totalPages }), progress : Math.round(((currentPage + 1) / totalPages) * 90) });
        
        const { html, header, footer, offset } = await me.buildPage(config);
        
        // TotalHeight might change in case of variable row heights
        // Move exported content in the visible frame
        const styles = [
            ...stylesheets,
            `
                <style>
                    #${config.client.id} {
                        height: ${exportMeta.totalHeight}px !important;
                        width: ${totalWidth}px !important;
                    }
                    
                    .b-export-body .b-export-viewport {
                        margin-left : ${-paperWidth * exportMeta.horizontalPosition}in;
                        margin-top  : ${exportMeta.currentPageTopMargin}px;
                    }
                </style>
            `];
        
        // when aligning rows, offset gets accumulated, so we need to take it into account
        exportMeta.currentPageTopMargin -= contentHeight + offset;
        
        await me.stateNextPage(config);
        
        yield {
            html : me.pageTpl({
                html,
                header,
                footer,
                styles,
                paperWidth,
                paperHeight
            })
        };
    }
};
MultiPageExporter._$name = 'MultiPageExporter';

class SinglePageExporter extends Exporter {
    static get type() {
        return 'singlepage';
    }
    
    static get title() {
        // In case locale is missing exporter is still distinguishable
        return this.L('singlepage');
    }
    
    static get defaultConfig() {
        return {
            /**
             * Set to true to center content horizontally on the page
             * @config {Boolean}
             */
            centerContentHorizontally : false
        };
    }
    
    async prepareComponent(config) {
        await super.prepareComponent(config);
        
        Object.assign(this.exportMeta, {
            verticalPages      : 1,
            horizontalPages    : 1,
            totalPages         : 1,
            currentPage        : 0,
            verticalPosition   : 0,
            horizontalPosition : 0
        });
    }
    
    async onRowsCollected() {}
    
    positionRows(rows) {
        let currentTop = 0;
    
        // In case of variable row height row vertical position is not guaranteed to increase
        // monotonously. Position row manually instead
        return rows.map(([html, height]) => {
            const result = html.replace(/translate\(\d+px, \d+px\)/, `translate(0px, ${currentTop}px)`);
            
            currentTop += height;
            
            return result;
        });
    }
    
    collectRow(row) {
        const subGrids = this.exportMeta.subGrids;
        
        Object.entries(row.elements).forEach(([key, value]) => {
            subGrids[key].rows.push([value.outerHTML, row.offsetHeight]);
        });
    }
    
    buildPageHtml() {
        const
            me           = this,
            { subGrids } = me.exportMeta;
        
        // Now when rows are collected, we need to add them to exported grid
        let html = me.prepareExportElement();
    
        Object.values(subGrids).forEach(({ placeHolder, rows }) => {
            const placeHolderText = placeHolder.outerHTML;
            html = html.replace(placeHolderText, me.positionRows(rows).join(''));
        });
        
        return html;
    }
}

// HACK: terser/obfuscator doesn't yet support async generators, when processing code it converts async generator to regular async
// function.
SinglePageExporter.prototype.pagesExtractor = async function * pagesExtractor(config) {
    // When we prepared grid we stretched it horizontally, now we need to gather all rows
    // There are two ways:
    // 1. set component height to scrollable.scrollHeight value to render all rows at once (maybe a bit more complex
    // if rows have variable height)
    // 2. iterate over rows, scrolling new portion into view once in a while
    // #1 sounds simpler, but that might require too much rendering, let's scroll rows instead
    
    const
        me          = this,
        { client }  = config,
        {
            rowManager,
            store
        }           = client,
        styles      = me.stylesheets,
        portrait    = config.orientation === Orientation.portrait,
        paperFormat = PaperFormat[config.paperFormat],
        paperWidth  = portrait ? paperFormat.width : paperFormat.height,
        paperHeight = portrait ? paperFormat.height : paperFormat.width,
        totalRows   = config.rowsRange === RowsRange.visible && store.count
            ? rowManager.visibleRowCount
            : store.count;
    
    let {
            totalHeight,
            totalWidth
        }                 = me.exportMeta,
        processedRows     = 0,
        lastDataIndex     = -1,
        header, footer;
    
    if (rowManager.rows.length > 0) {
        if (config.rowsRange === RowsRange.visible) {
            lastDataIndex = rowManager.rows.find(row => row.bottom > client.scrollable.y).dataIndex - 1;
        }
    
        // Collecting rows
        while (processedRows < totalRows) {
            const
                rows    = rowManager.rows,
                lastRow = rows[rows.length - 1],
                lastProcessedRowIndex = processedRows;
            
            rows.forEach(row => {
                // When we are scrolling rows will be duplicated even with disabled buffers (e.g. when we are trying to
                // scroll last record into view). So we store last processed row dataIndex (which is always growing
                // sequence) and filter all rows with lower/same dataIndex
                if (row.dataIndex > lastDataIndex && processedRows < totalRows) {
                    ++processedRows;
                    totalHeight += row.offsetHeight;
                    me.collectRow(row);
                }
            });
            
            // Calculate new rows processed in this iteration e.g. to collect events
            const
                firstNewRowIndex = rows.findIndex(r => r.dataIndex === lastDataIndex + 1),
                lastNewRowIndex  = firstNewRowIndex + (processedRows - lastProcessedRowIndex);
            
            await me.onRowsCollected(rows.slice(firstNewRowIndex, lastNewRowIndex), config);
            
            if (processedRows < totalRows) {
                lastDataIndex = lastRow.dataIndex;
                await me.scrollRowIntoView(client, lastDataIndex + 1);
            }
        }
    }
    
    const html = me.buildPageHtml();
    
    // Calculate header height
    totalHeight += client.height - client.bodyHeight;
    
    const totalClientHeight = totalHeight;
    
    // Measure header and footer height
    if (config.headerTpl) {
        header = me.prepareHTML(config.headerTpl({ totalWidth }));
        const height = me.measureElement(header);
        totalHeight += height;
    }
    
    if (config.footerTpl) {
        footer = me.prepareHTML(config.footerTpl({ totalWidth }));
        const height = me.measureElement(footer);
        totalHeight += height;
    }
    
    const
        widthScale  = Math.min(1, me.getScaleValue(me.inchToPx(paperWidth), totalWidth)),
        heightScale = Math.min(1, me.getScaleValue(me.inchToPx(paperHeight), totalHeight)),
        scale       = Math.min(widthScale, heightScale);
    
    // Now add style to stretch grid vertically
    styles.push(
        `<style>
                #${client.id} {
                    height: ${totalClientHeight}px !important;
                    width: ${totalWidth}px !important;
                }
                
                .b-export-content {
                    ${me.centerContentHorizontally ? 'left: 50%;' : ''}
                    transform: scale(${scale}) ${me.centerContentHorizontally ? 'translateX(-50%)' : ''};
                    transform-origin: top left;
                    height: ${scale === 1 ? 'inherit' : 'auto !important'};
                }
            </style>`
    );
    
    // This is a single page exporter so we only yield one page
    yield {
        html : me.pageTpl({
            html,
            header,
            footer,
            styles,
            paperWidth,
            paperHeight
        })
    };
};
SinglePageExporter._$name = 'SinglePageExporter';

/**
 * @module Grid/feature/export/PdfExport
 */

/**
 * Generates PDF/PNG files from the Grid component.
 *
 *
 * **NOTE:** This feature will make a fetch request to the server, posting
 * the HTML fragments to be exported. The {@link #config-exportServer} URL must be configured.
 *
 * ## Usage
 *
 * ```javascript
 * let grid = new Grid({
 *     features : {
 *         pdfExport : {
 *             exportServer : 'http://localhost:8080' // Required
 *         }
 *     }
 * })
 *
 * // Opens popup allowing to customize export settings
 * grid.features.pdfExport.showExportDialog();
 *
 * // Simple export
 * grid.features.pdfExport.export({
 *     columns : grid.columns.map(c => c.id) // Required, set list of column ids to export
 * }).then(result => {
 *     // Response instance and response content in JSON
 *     let { response } = result;
 * });
 * ```
 *
 * ## Exporters
 *
 * There are two exporters available by default: `singlepage` and `multipage`. As name suggests, singlepage exporter generates
 * single page with content scaled to fit the provided {@link #config-paperFormat} and multipage exporters generates as
 * many pages as required to fit all requested content, unscaled
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @demo Grid/export
 * @classtype pdfExport
 */
class PdfExport extends Localizable(InstancePlugin) {
    static get $name() {
        return 'PdfExport';
    }

    static get defaultConfig() {
        return {
            /**
             * URL of the print server.
             * @config {String}
             */
            exportServer : undefined,

            /**
             * Name of the exported file.
             * @config {String}
             */
            fileName : null,

            /**
             * Format of the exported file, selectable from `pdf` or `png`. By default plugin exports panel contents to PDF
             * but PNG file format is also available.
             * @config {String}
             * @default
             * @group Export file config
             */
            fileFormat : 'pdf',

            /**
             * Export server will navigate to this url first and then will change page content to whatever client sent.
             * This option is useful with react dev server, which has pretty strict CORS policy.
             * @config {String}
             */
            clientURL : null,

            /**
             * Export paper format. Available options are A1...A5, Legal, Letter.
             * @config {String}
             * @default
             * @group Export file config
             */
            paperFormat : 'A4',

            /**
             * Orientation. Options are `portrait` and `landscape`.
             * @config {String}
             * @default
             * @group Export file config
             */
            orientation : 'portrait',

            /**
             * Specifies which rows to export. `all` for complete set of rows, `visible` for only rows currently visible.
             * @config {String}
             * @group Export file config
             */
            rowsRange : 'all',

            /**
             * Set to true to align row top to the page top on every exported page. Only applied to multipage export.
             * @config {Boolean}
             * @default
             */
            alignRows : false,

            /**
             * When exporting large views (hundreds of pages) stringified HTML may exceed browser or server request
             * length limit. This config allows to specify how many pages to send to server in one request.
             * @config {Number}
             * @default
             * @private
             */
            pagesPerRequest : 0,

            /**
             * Config for exporter.
             * @config {Object}
             * @private
             */
            exporterConfig : null,

            /**
             * Type of the exporter to use. Should be one of the configured {@link #config-exporters}
             * @config {String}
             * @default
             */
            exporterType : 'singlepage',

            /**
             * List of exporter classes to use in export feature
             * @config {Grid.feature.export.exporter.Exporter[]}
             * @default
             */
            exporters : [SinglePageExporter, MultiPageExporter],

            /**
             * `True` to replace all linked CSS files URLs to absolute before passing HTML to the server.
             * When passing a string the current origin of the CSS files URLS will be replaced by the passed origin.
             *
             * For example: css files pointing to /app.css will be translated from current origin to {translateURLsToAbsolute}/app.css
             * @config {Boolean|String}
             * @default
             */
            translateURLsToAbsolute : true,

            /**
             * When true links are converted to absolute by combining current window location (with replaced origin) with
             * resource link.
             * When false links are converted by combining new origin with resource link (for angular)
             * @config {Boolean}
             * @default
             */
            keepPathName : true,

            /**
             * When true, page will attempt to download generated file.
             * @config {Boolean}
             * @default
             */
            openAfterExport : true,

            /**
             * False to open in the current tab, true - in a new tab
             * @config {Boolean}
             * @default
             */
            openInNewTab : false,

            /**
             * A template function used to generate a page header. It is passed an object with ´currentPage´ and `totalPages´ properties.
             *
             * ```javascript
             * let grid = new Grid({
             *     appendTo   : 'container',
             *     features : {
             *         pdfExport : {
             *             exportServer : 'http://localhost:8080/',
             *             headerTpl : ({ currentPage, totalPages }) => `
             *                 <div class="demo-export-header">
             *                     <img src="coolcorp-logo.png"/>
             *                     <dl>
             *                         <dt>Date: ${DateHelper.format(new Date(), 'll LT')}</dt>
             *                         <dd>${totalPages ? `Page: ${currentPage + 1}/${totalPages}` : ''}</dd>
             *                     </dl>
             *                 </div>`
             *          }
             *     }
             * });
             * ```
             * @config {Function}
             */
            headerTpl : null,

            /**
             * A template function used to generate a page footer. It is passed an object with ´currentPage´ and `totalPages´ properties.
             *
             * ```javascript
             * let grid = new Grid({
             *      appendTo   : 'container',
             *      features : {
             *          pdfExport : {
             *              exportServer : 'http://localhost:8080/',
             *              footerTpl    : () => '<div class="demo-export-footer"><h3>© 2020 CoolCorp Inc</h3></div>'
             *          }
             *      }
             * });
             * ```
             * @config {Function}
             */
            footerTpl : null,
        };
    }

    /**
     * When export is started from GUI ({@link Grid.view.export.ExportDialog}), export promise can be accessed via
     * this property.
     * @property {Promise}
     */
    get currentExportPromise() {
        return this._currentExportPromise;
    }

    set currentExportPromise(value) {
        this._currentExportPromise = value;
    }

    get exportersMap() {
        return this._exportersMap || (this._exportersMap = new Map());
    }

    getExporter(config = {}) {
        const
            me               = this,
            { exportersMap } = me,
            { type }         = config;

        let exporter;

        if (exportersMap.has(type)) {
            exporter = exportersMap.get(type);
        }
        else {
            const exporterClass = this.exporters.find(cls => cls.type === type);

            if (!exporterClass) {
                throw new Error(`Exporter type ${type} is not found. Make sure you've configured it`);
            }

            config = ObjectHelper.clone(config);
            delete config.type;

            exporter = new exporterClass(config);

            exporter.relayAll(me);

            exportersMap.set(type, exporter);
        }

        return exporter;
    }

    buildRequest(pages, config) {
        return {
            html        : JSON.stringify(pages),
            fileFormat  : config.fileFormat,
            format      : config.paperFormat,
            orientation : config.orientation
        };
    }

    buildExportConfig(config) {
        const
            me = this,
            {
                client,
                exportServer,
                clientURL,
                fileFormat,
                paperFormat,
                rowsRange,
                alignRows,
                orientation,
                exporters,
                translateURLsToAbsolute,
                keepPathName,
                headerTpl,
                footerTpl
            }  = me;

        return ObjectHelper.assign({
            client,
            exportServer,
            clientURL,
            fileFormat,
            paperFormat,
            rowsRange,
            alignRows,
            orientation,
            translateURLsToAbsolute,
            keepPathName,
            headerTpl,
            footerTpl,
            exporterType : exporters[0].type,
            fileName     : client.$name
        }, config);
    }

    /**
     * Starts the export process. Accepts a config object which overrides any default configs.
     * **NOTE**. Component should not be interacted with when export is in progress
     *
     * @param {Object} config
     * @param {String[]} config.columns (requried) List of column ids to export. E.g.
     * ```grid.features.pdfExport.export({ columns : grid.columns.map(c => c.id) })```
     * @returns {Promise} Object of the following structure
     * ```
     * {
     *     response // Response instance
     * }
     * ```
     * @async
     */
    async export(config = {}) {
        const
            me = this,
            {
                client,
                pagesPerRequest
            }  = me;

        config = me.buildExportConfig(config);

        let result;

        config.exporterConfig = ObjectHelper.assign({
            type                    : config.exporterType,
            translateURLsToAbsolute : config.translateURLsToAbsolute,
            keepPathName            : config.keepPathName
        }, config.exporterConfig || {});

        /**
         * Fires before export started. Return `false` to cancel the export.
         * @event beforeExport
         * @preventable
         * @param {Object} config Export config
         */
        if (client.trigger('beforeExport', config) !== false) {
            // Raise flag on the client to render all suggested dependencies
            client.ignoreViewBox = true;

            client.mask(client.loadMask);

            try {
                const exporter = me.getExporter(config.exporterConfig);

                if (pagesPerRequest === 0) {
                    const pages = await exporter.export(config);

                    /**
                     * Fires when export progress changes
                     * @event exportStep
                     * @param {Number} progress Current progress, 0-100
                     * @param {String} text Optional text to show
                     */
                    me.trigger('exportStep', { progress : 90, text : me.L('Waiting for response from server...') });

                    const response = await AjaxHelper.fetch(
                        config.exportServer,
                        {
                            method : 'POST',
                            body   : JSON.stringify({
                                html        : pages,
                                orientation : config.orientation,
                                format      : config.paperFormat,
                                fileFormat  : config.fileFormat,
                                fileName    : config.fileName,
                                clientURL   : config.clientURL
                            }),
                            credentials : 'omit',
                            headers     : {
                                'Content-Type' : 'application/json'
                            },
                            parseJson : true
                        }
                    );

                    result = { response };

                    if (response.ok) {
                        const responseJSON = response.parsedJson;

                        if (me.openAfterExport) {
                            if (responseJSON.success) {
                                if (BrowserHelper.isIE11) {
                                    window.open(responseJSON.url, 'ExportedPanel');
                                }
                                else {
                                    const link = document.createElement('a');

                                    link.download = config.fileName;
                                    link.href = responseJSON.url;

                                    if (me.openInNewTab) {
                                        link.target = '_blank';
                                    }

                                    document.body.appendChild(link);

                                    link.click();

                                    document.body.removeChild(link);
                                }
                            }
                            else {
                                WidgetHelper.toast(responseJSON.msg);
                            }
                        }
                    }
                }
            }
            catch (error) {
                if (error instanceof Response) {
                    result = { response : error };
                }
                else {
                    result = { error };
                }

                throw error;
            }
            finally {
                if (me.exportDialog) {
                    me.exportDialog.close();
                }

                client.unmask();

                client.ignoreViewBox = false;

                /**
                 * Fires when export has finished
                 * @event export
                 * @param {Response} [response] Optional response, if received
                 * @param {Error} [error] Optional error, if exception occurred
                 */
                me.trigger('export', result);

                if (result.error) {
                    WidgetHelper.toast(me.L('Export failed'));
                }
                else if (!result.response.ok) {
                    WidgetHelper.toast(me.L('Server error'));
                }

                client.trigger('export', result);
            }
        }

        return result;
    }

    /**
     * Shows {@link Grid.view.export.ExportDialog export dialog}
     */
    showExportDialog() {
        const me = this;

        if (!me.exportDialog) {
            me.exportDialog = new ExportDialog({
                client    : me.client,
                exporters : me.exporters,
                listeners : {
                    export  : me.onExportDialogExport,
                    thisObj : me
                }
            });
        }

        me.exportDialog.show();
    }

    onExportDialogExport({ values }) {
        const me = this;

        me.mask = new Mask({
            progress    : 0,
            maxProgress : 100,
            text        : 'Generating pages...',
            element     : me.exportDialog.element
        });

        const detacher = me.on({
            export() {
                me.mask.close();
                detacher();
            },
            exportstep({ progress, text }) {
                me.mask.progress = progress;
                me.mask.text = text;
            }
        });

        me.currentExportPromise = me.export(values);

        // Clear current export promise
        me.currentExportPromise.then(() => me.currentExportPromise = null);
    }
}

PdfExport._$name = 'PdfExport'; GridFeatureManager.registerFeature(PdfExport, false, 'Grid');

// Format expected by export server
// const pageFormat = {
//     html       : '',
//     column     : 1,
//     number     : 1,
//     row        : 1,
//     rowsHeight : 1
// };
//
// const format = {
//     fileFormat  : 'pdf',
//     format      : 'A4',
//     orientation : 'portrait',
//     range       : 'complete',
//     html        : { array : JSON.stringify(pageFormat) }
// };

/**
 * @module Grid/util/TableExporter
 */

/**
 * This class transforms grid component into two arrays: rows and columns. Columns array contains objects with
 * meta information about column: field name, column name, width and type of the rendered value, rows array contains
 * arrays of cell values.
 *
 * ```javascript
 * const exporter = new TableExporter({ target : grid });
 * exporter.export()
 *
 * // Output
 * {
 *     columns : [
 *         { field : 'name',     value : 'First name', type : 'string',  width : 100 },
 *         { field : 'surname',  value : 'Last name',  type : 'string',  width : 100 },
 *         { field : 'age',      value : 'Age',        type : 'number',  width : 50  },
 *         { field : 'married',  value : 'Married',    type : 'boolean', width : 50  },
 *         { field : 'children', value : 'Children',   type : 'object',  width : 100 }
 *     ],
 *     rows : [
 *         ['Michael', 'Scott',   40, false, []],
 *         ['Jim',     'Halpert', 30, true,  [...]]
 *     ]
 * }
 * ```
 *
 * ## How data is exported
 *
 * Exporter iterates over store records and processes each record for each column being exported. Exporter uses same
 * approach to retrieve data as column: reading record field, configured on the column, or calling renderer function
 * if one is provided. This means data can be of any type: primitives or objects. So children array in the above code
 * snippet may contain instances of child record class.
 *
 * ## Column renderers
 *
 * Column renderers are commonly used to style the cell, or even render more HTML into it, like {@link Grid.column.WidgetColumn}
 * does. This is not applicable in case of export. Also, given grid uses virtual rendering (only renders visible rows) and
 * exporter iterates over all records, not just visible ones, we cannot provide all data necessary to the renderer. Some
 * arguments, like cellElement and row, wouldn't exist. Thus renderer is called with as much data we have: value,
 * record, column, grid, other {@link Grid.column.Column#config-renderer documented arguments} would be undefined.
 *
 * Exporter adds one more flag for renderer function: isExport. When renderer receives this flag it knows
 * data is being exported and can skip DOM work to return simpler value. Below snippet shows simplified code of the
 * widget column handling export:
 *
 * ```javascript
 * renderer({ isExport }) {
 *     if (isExport) {
 *         return null;
 *     }
 *     else {
 *         // widget rendering routine
 *         ...
 *     }
 * }
 * ```
 *
 * ## Column types
 *
 * Column types are not actually a complete list of JavaScript types (you can get actual type of the cell using typeof) it
 * is a simple and helpful meta information.
 *
 * Available column types are:
 *  * string
 *  * number
 *  * boolean
 *  * date
 *  * object
 *
 * Everything which is not primitive like string/number/bool (or a date) is considered an object. This includes null, undefined,
 * arrays, classes, functions etc.
 *
 * ## Getting column type
 *
 * If existing grid column is used, column type first would be checked with {@link Grid.column.Column#config-exportedType exportedType}
 * config. If exportedType is undefined or column does not exist in grid, type is read from a record field definition.
 * If the field is not defined, object type is used.
 *
 * Configuring exported type:
 *
 * ```javascript
 * new Grid({
 *     columns : [
 *         {
 *             name         : 'Name',
 *             field        : 'name',
 *             exportedType : 'object',
 *             renderer     : ({ value, isExport }) => {
 *                 if (isExport) {
 *                     return { value }; // return value wrapped into object
 *                 }
 *             }
 *     ]
 * })
 * ```
 *
 * @extends Core/Base
 */
class TableExporter extends Base {
    static get defaultConfig() {
        return {
            /**
             * Target grid instance to export data from
             * @config {Grid} target
             */
            target : null,

            /**
             * Specifies a default column width if no width specified
             * @config {Number} defaultColumnWidth
             * @default
             */
            defaultColumnWidth : 100,

            /**
             * Set to false to export date as it is displayed by Date column formatter
             * @config {Boolean}
             * @default
             */
            exportDateAsInstance : true,

            /**
             * If true and the grid is grouped, shows the grouped value in the first column. True by default.
             * @config {Boolean} showGroupHeader
             * @default
             */
            showGroupHeader : true,

            /**
             * An array of columns configuration used to specify columns width, headers name, and column fields to get the data from.
             * 'field' config is required. If 'text' is missing, it will try to get it retrieved from the grid column or the 'field' config.
             * If 'width' is missing, it will try to get it retrieved from the grid column or {@link #config-defaultColumnWidth} config.
             * If no columns provided the config will be generated from the grid columns.
             *
             * For example:
             * ```javascript
             * columns : [
             *     'firstName', // field
             *     'age', // field
             *     { text : 'Starts', field : 'start', width : 140 },
             *     { text : 'Ends', field : 'finish', width : 140 }
             * ]
             * ```
             *
             * @config {String[]|Object[]} columns
             * @default
             */
            columns : null,

            /**
             * When true and tree is being exported, node names are indented with {@link #config-indentationSymbol}
             * @config {Boolean}
             * @default
             */
            indent : true,

            /**
             * This symbol (four spaces by default) is used to indent node names when {@link #config-indent} is true
             * @config {String}
             * @default
             */
            indentationSymbol : '\u00A0\u00A0\u00A0\u00A0'
        };
    }

    /**
     * Exports grid data according to provided config
     * @param {Object} config
     * @returns {{ rows : Object[][], columns : Object[] }}
     */
    export(config = {}) {
        const me = this;

        config = ObjectHelper.assign({}, me.config, config);

        me.normalizeColumns(config);

        return me.generateExportData(config);
    }

    generateExportData(config) {
        const
            me      = this,
            columns = me.generateColumns(config),
            rows    = me.generateRows(config);

        return { rows, columns };
    }

    normalizeColumns(config) {
        // In case columns are provided we need to use normalized config. If those are not provided, we are going
        // to use real columns, possible invoking renderers (we need to pass column instance to the renderer to
        // avoid breaking API too much)
        const columns = config.columns || this.target.columns.visibleColumns.filter(rec => rec.exportable !== false);

        config.columns = columns.map(col => {
            if (typeof col === 'string') {
                return this.target.columns.find(column => column.field === col) || { field : col };
            }
            else {
                return col;
            }
        });
    }

    generateColumns(config) {
        return config.columns.map(col => this.processColumn(col, config));
    }

    generateRows(config) {
        const { columns } = config;

        if (!columns.length) {
            return [];
        }

        const
            me         = this,
            { target } = me;

        return target.store
            // although columns are taken from config, it is convenient to provide them as a separate argument
            // becuase that allows to override set of columns to process
            .map(record => me.processRecord(record, columns, config))
            // filter out empty rows
            .filter(cells => cells.length);
    }

    getColumnType(column, store = this.target.store) {
        let result = column.exportedType || 'object';

        if (column.exportedType === undefined) {
            if (column.field) {
                const fieldDefinition = store.modelClass.getFieldDefinition(column.field);

                if (fieldDefinition && fieldDefinition.type) {
                    result = fieldDefinition.type;
                }
            }
        }

        return result;
    }

    /**
     * Extracts export data from the column instance
     * @param {Column} column
     * @param {Object} config
     * @private
     * @returns {Object}
     */
    processColumn(column, config) {
        const
            me                     = this,
            { target }             = me,
            { defaultColumnWidth } = config;

        let { field, text : value, width, minWidth } = column;

        // If column is not configured with field, field is generated (see Column.js around line 514).
        // In export we want empty string there
        if (!(field in target.store.modelClass.fieldMap)) {
            field = '';
        }

        // If name or width is missing try to retrieve them from the grid column and the field, or use default values.
        if (!value || !width) {
            const gridColumn = target.columns.find(col => col.field === field);

            if (!value) {
                value = gridColumn && gridColumn.text || field;
            }

            // null or undefined
            if (width == null) {
                width = gridColumn && gridColumn.width || defaultColumnWidth;
            }
        }

        width = Math.max(width || defaultColumnWidth, minWidth || defaultColumnWidth);

        return { field, value, width, type : me.getColumnType(column) };
    }

    /**
     * Extracts export data from the record instance reading supplied column configs
     * @param {Model|null} record If null is passed, all columns will be filled with empty strings
     * @param {Column[]} columns
     * @param {Object} config
     * @private
     * @returns {Object[]}
     */
    processRecord(record, columns, config) {
        const
            { target } = this,
            {
                showGroupHeader,
                indent,
                indentationSymbol
            }  = config;

        let cells;

        if (!record) {
            cells = columns.map(() => '');
        }
        else if (record.meta.specialRow) {
            if (showGroupHeader && record.meta.groupRowFor) {
                cells = columns.map(column => {
                    return target.features.group.buildGroupHeader({
                        // Create dummy element to get html from
                        cellElement : DomHelper.createElement(),
                        grid        : target,
                        record,
                        column
                    });
                });
            }
        }
        else {
            cells = columns.map(column => {
                let value       = record[column.field],
                    useRenderer = column.renderer || column.defaultRenderer;

                if (useRenderer && !(value && column instanceof DateColumn && config.exportDateAsInstance)) {
                    value = useRenderer.call(column, {
                        value,
                        record,
                        column,
                        grid     : target,
                        isExport : true
                    });
                }

                if (indent && column.tree) {
                    value = `${indentationSymbol.repeat(record.childLevel)}${value}`;
                }

                return value;
            });
        }

        return cells;
    }
}
TableExporter._$name = 'TableExporter';

class BooleanUnicodeSymbol {
    constructor(value) {
        this._value = value;
    }
    
    get value() {
        return this._value;
    }
    
    toString() {
        return Boolean(this.value) ? '✓' : '';
    }
}
BooleanUnicodeSymbol._$name = 'BooleanUnicodeSymbol';

/*global zipcelx*/

/**
 * @module Grid/feature/experimental/ExcelExporter
 */

/**
 * **NOTE**: This class requires a 3rd party library to operate.
 *
 * A feature that allows exporting Grid data to Excel without involving the server. It uses {@link Grid.util.TableExporter}
 * class as data provider, [zipcelx library](https://www.npmjs.com/package/zipcelx)
 * forked and adjusted to support [column width config](https://github.com/bryntum/zipcelx/tree/column-width-build)
 * and [Microsoft XML specification](https://msdn.microsoft.com/en-us/library/office/documentformat.openxml.spreadsheet.aspx).
 * Zipcelx should be either in global scope (window) or can be provided with {@link #config-zipcelx} config.
 *
 * ```
 * // Global scope
 * <script src="zipcelx.js"></script>
 *
 * // importing from package
 * import zipcelx from 'zipcelx';
 *
 * const grid = new Grid({
 *     features : {
 *         excelExporter : {
 *             zipcelx
 *         }
 *     }
 * })
 * ```
 *
 * Here is an example of how to add the feature:
 *
 * ```javascript
 * const grid = new Grid({
 *     features : {
 *         excelExporter : {
 *             // Choose the date format for date fields
 *             dateFormat : 'YYYY-MM-DD HH:mm',
 *
 *             exporterConfig : {
 *                 // Choose the columns to include in the exported file
 *                 columns : ['name', 'role']
 *             }
 *         }
 *     }
 * });
 * ```
 *
 * And how to call it:
 *
 * ```javascript
 * grid.features.excelExporter.export({
 *     filename : 'Export',
 *     columns : [
 *         { text : 'First Name', field : 'firstName', width : 90 },
 *         { text : 'Age', field : 'age', width : 40 },
 *         { text : 'Starts', field : 'start', width : 140 },
 *         { text : 'Ends', field : 'finish', width : 140 }
 *     ]
 * })
 * ```
 *
 * @extends Core/mixin/InstancePlugin
 * @demo Grid/exporttoexcel
 */
class ExcelExporter extends InstancePlugin {
    static get $name() {
        return 'ExcelExporter';
    }

    static get defaultConfig() {
        return {
            /**
             * Name of the exported file
             * @config {String} filename
             * @default
             */
            filename : null,

            /**
             * Defines how date in a cell will be formatted
             * @config {String} dateFormat
             * @default
             */
            dateFormat : 'YYYY-MM-DD',

            /**
             * Exporter class to use as a data provider. {@link Grid.util.TableExporter} by default.
             * @config {Grid.util.TableExporter}
             * @default
             */
            exporterClass : TableExporter,

            /**
             * Configuration object for {@link #config-exporterClass exporter class}.
             * @config {Object}
             */
            exporterConfig : null,

            /**
             * Reference to zipcelx library. If not provided, exporter will look in the global scope.
             * @config
             */
            zipcelx : null,

            /**
             * If this config is true, exporter will convert all empty values to ''. Empty values are:
             * * undefined, null, NaN
             * * Objects/class instances that do not have toString method defined and are stringified to [object Object]
             * * functions
             * @config {Boolean}
             */
            convertEmptyValueToEmptyString : true
        };
    }

    processValue(value) {
        if (
            value === undefined ||
            value === null ||
            Number.isNaN(value) ||
            typeof value === 'function' ||
            (typeof value === 'object' && String(value) === '[object Object]')
        ) {
            return '';
        }
        else {
            return value;
        }
    }

    generateExportData(config) {
        const
            me                = this,
            { rows, columns } = me.exporter.export(config.exporterConfig);

        return {
            rows : rows.map(row => {
                return row.map((value, index) => {
                    if (value instanceof Date) {
                        value = DateHelper.format(value, config.dateFormat);
                    }
                    else if (typeof value === 'boolean') {
                        value = new BooleanUnicodeSymbol(value);
                    }

                    if (me.convertEmptyValueToEmptyString) {
                        value = me.processValue(value);
                    }

                    // when number column is exported with zipcelx, excel warns that sheet is broken and asks for repair
                    // repair works, but having error on open doesn't look acceptable
                    // const type = columns[index].type === 'number' ? 'number' : 'string';
                    const type = 'string';

                    return { value, type };
                });
            }),
            columns : columns.map(col => {
                let { field, value, width, type } = col;

                // when number column is exported with zipcelx, excel warns that sheet is broken and asks for repair
                // repair works, but having error on open doesn't look acceptable
                // type = type === 'number' ? 'number' : 'string';
                type = 'string';

                return { field, value, width, type };
            })
        };
    }

    /**
     * Generate and download a .xslx file.
     * @param {Object} config Optional configuration object, which overrides initial settings of the feature/exporter.
     */
    export(config = {}) {
        const me = this;

        if (!me.zipcelx) {
            throw new Error('ExcelExporter: "zipcelx" library is required');
        }

        if (me.disabled) {
            return;
        }

        config = ObjectHelper.assign({}, me.config, config);
        
        if (!config.filename) {
            config.filename = me.client.$name;
        }

        const
            { filename }      = config,
            { rows, columns } = me.generateExportData(config);

        me.zipcelx({
            filename,
            sheet : {
                data : [columns].concat(rows),
                cols : columns
            }
        });
    }

    construct(grid, config) {
        super.construct(grid, config);

        if (!this.zipcelx) {
            if (typeof zipcelx !== 'undefined') {
                this.zipcelx = zipcelx;
            }
        }
    }

    get exporter() {
        return this._exporter || (this._exporter = new this.exporterClass(Object.assign({ target : this.client }, this.exporterConfig)));
    }
}

ExcelExporter._$name = 'ExcelExporter'; GridFeatureManager.registerFeature(ExcelExporter, false, 'Grid');

/**
 * @module Grid/util/ScrollManager
 */

/**
 * Monitors mouse position over an element and scrolls the element if close to edges. This is used by features to scroll the grid section element, for example dragging rows close to vertical edges.
 * Normally you should not need to interact with this class.
 * @internal
 */
class ScrollManager extends Delayable(Base) {
    //region Default config

    static get defaultConfig() {
        return {
            /**
             * Width in pixels of zone at element edges where scrolling can be triggered
             * @config {Number}
             * @default
             */
            zoneWidth : 50,

            /**
             * Scroll speed, higher number is slower. Calculated as "distance from zone edge / scrollSpeed"
             * @config {Number}
             * @default
             */
            scrollSpeed : 5,

            /**
             * Default element to use for vertical scrolling. Can be overridden in calls to `startMonitoring()`.
             * @config {HTMLElement}
             */
            verticalElement : null,

            /**
             * The direction(s) to scroll ('horizontal', 'vertical' or 'both')
             * @config {String}
             */
            direction : 'both',

            monitoring : [],

            /**
             * Number of milliseconds to wait before scroll starts when the mouse is moved close to an edge monitored by this scroll manager
             * @config {Number}
             * @default
             */
            startScrollDelay : 500,

            testConfig : {
                scrollSpeed      : 2,
                startScrollDelay : 0
            }
        };
    }

    //endregion

    //region Start/stop monitoring

    /**
     * Starts monitoring an element. It will be scrolled if mouse is pressed and within zoneWidth pixels from element edge.
     * @param {HTMLElement|Object} elementOrConfig Element which might be scrolled or config { element, callback, thisObj }
     */
    startMonitoring(elementOrConfig) {
        const me              = this,
            config          = elementOrConfig instanceof HTMLElement ? { element : elementOrConfig } : elementOrConfig,
            element         = config.element,
            verticalElement = config.verticalElement || me.verticalElement || element;

        // only interested in elements that exists and are scrollable
        if (element && (element.scrollWidth > element.offsetWidth || verticalElement.scrollHeight > verticalElement.offsetHeight)) {
            // already monitoring, bail out
            if (me.monitoring.find(m => m.element === element)) return;

            config.direction = config.direction || me.direction;

            // store some stuff needed later
            Object.assign(config, {
                verticalElement,
                scrollManager      : me,
                startScrollLeft    : element.scrollLeft,
                startScrollTop     : verticalElement.scrollTop,
                scrollLeft         : element.scrollLeft,
                scrollTop          : verticalElement.scrollTop,
                scrollRelativeLeft : 0,
                scrollRelativeTop  : 0
            });

            const handler = me.onMouseMove.bind(config);

            // listen to mousemove to determine if scroll needed or not
            me.mouseMoveDetacher = EventHelper.on({
                mousemove  : handler,
                touchmove  : handler,
                mouseleave : () => me.clearTimeout(me.scrollTimeout),
                element
            });

            // Cache scrollWidth because it may actually change in Edge and allow scrolling to empty space when creating
            // dependency
            config.scrollWidth = element.scrollWidth;

            me.monitoring.push(config);
        }
    }

    /**
     * Stops monitoring an element.
     * @param {HTMLElement} element Element for which monitoring is not desired any more and should stop as soon as possible. Preferably right away, but no later than on next frame :)
     */
    stopMonitoring(element) {
        const me     = this,
            config = me.monitoring.find(m => m.element === element);

        // cant stop nothing...
        if (!config) return;

        me.stopScroll(config);
        me.mouseMoveDetacher && me.mouseMoveDetacher();
        me.monitoring.splice(me.monitoring.indexOf(config), 1);
    }

    //endregion

    //region Internals

    /**
     * Starts scrolling (see #performScroll). Called from onMouseMove.
     * @private
     * @param {Object} config Config object
     */
    startScroll(config) {
        config.scrolling = true;
        this.performScroll(config);
    }

    /**
     * Stops scrolling. Called from onMouseMove.
     * @private
     * @param {Object} config
     */
    stopScroll(config) {
        const me = this;

        config.scrolling = false;
        if (config.scrollRequested) {
            me.cancelAnimationFrame(config.frameId);
            config.scrollRequested = false;
        }
        me.clearTimeout(me.scrollTimeout);
        me.scrollTimeout = null;
    }

    /**
     * Scrolls by an amount determined by config.scrollDeltaX/Y on each frame. Start/stop by calling #startScroll and
     * #stopScroll.
     * @private
     * @param {Object} config Config object
     */
    performScroll(config) {
        // this function is called repeatedly on each frame for as long as scrolling is needed

        // check that scrolling is needed
        if (config.scrolling && !config.scrollRequested) {
            let element  = config.element,
                vertical = config.verticalElement;

            // scroll the determined amount of pixels
            if (config.scrollDeltaX !== 0) {
                config.scrollLeft += config.scrollDeltaX;

                // limit to element edges
                config.scrollLeft = Math.max(Math.min(config.scrollLeft, config.scrollWidth - element.clientWidth), 0);

                config.scrollRelativeLeft = config.scrollLeft - config.startScrollLeft;
                element.scrollLeft = config.scrollLeft;
            }

            if (config.scrollDeltaY !== 0) {
                config.scrollTop += config.scrollDeltaY;

                // limit to element edges
                config.scrollTop = Math.max(Math.min(config.scrollTop, vertical.scrollHeight - vertical.clientHeight), 0);

                config.scrollRelativeTop = config.scrollTop - config.startScrollTop;
                vertical.scrollTop = config.scrollTop;
            }

            // call callback if scrolled in any direction
            if ((config.scrollRelativeLeft !== 0 || config.scrollRelativeTop !== 0) && config.callback) {
                config.callback.call(config.thisObj || this, config);
            }

            // scroll some more on next frame
            config.scrollRequested = true;

            config.frameId = this.requestAnimationFrame(() => {
                config.scrollRequested = false;
                this.performScroll(config);
            });
        }
    }

    /**
     * Listener for mouse move on monitored element. Determines if scrolling is needed, and if so how fast to scroll.
     * See #zoneWidth & #scrollSpeed configs.
     * @private
     * @param {MouseEvent} event
     */
    onMouseMove(event) {
        const config   = this,
            me       = config.scrollManager,
            element  = config.element,
            vertical = config.verticalElement,
            box      = element.getBoundingClientRect(),
            vbox     = vertical.getBoundingClientRect(),
            width    = me.zoneWidth,
            speed    = me.scrollSpeed;

        // scroll left or right?
        config.scrollDeltaX = 0;

        if (config.direction !== 'vertical') {
            if (event.clientX > box.right - width) {
                config.scrollDeltaX = Math.round((width - (box.right - event.clientX)) / speed) + 1;
            }
            else if (event.clientX < box.left + width) {
                config.scrollDeltaX = -Math.round((width + (box.left - event.clientX)) / speed) - 1;
            }
        }

        // scroll up or down?
        config.scrollDeltaY = 0;
        if (config.direction !== 'horizontal') {
            if (event.clientY > vbox.bottom - width) {
                config.scrollDeltaY = Math.round((width - (vbox.bottom - event.clientY)) / speed) + 1;
            }
            else if (event.clientY < vbox.top + width) {
                config.scrollDeltaY = -Math.round((width + (vbox.top - event.clientY)) / speed) - 1;
            }
        }


        if (config.scrollDeltaX === 0 && config.scrollDeltaY === 0) {
            me.stopScroll(config);
        } else if (!me.scrollTimeout) {
            me.scrollTimeout = me.setTimeout(() => me.startScroll(config), me.startScrollDelay);
        }
    }
    //endregion
}
ScrollManager._$name = 'ScrollManager';

/**
 * @module Grid/view/Bar
 */

/**
 * Base class used by Header and Footer. Holds an element for each column. Not intended to be used directly.
 *
 * @extends Core/widget/Widget
 * @internal
 * @abstract
 */
class Bar extends Widget {

    static get $name() {
        return 'Bar';
    }

    static get defaultConfig() {
        return {
            scrollable : {} // We need a scroller, but no dimensions scroll by default
        };
    }

    //region Init

    get columns() {
        return this._columns || this.subGrid.columns;
    }

    // Only needed for tests which create standalone Headers with no owning SubGrid.
    set columns(columns) {
        this._columns = columns;
    }

    //endregion

    /**
     * Fix cell widths (flex or fixed width) after rendering.
     * Not a part of template any longer because of CSP
     * @private
     */
    fixCellWidths() {
        const me = this;

        let hasFlex = false,
            flexBasis;

        // single header "cell"
        me.columns.traverse(column => {
            const cellEl = me.getBarCellElement(column.id),
                domWidth = DomHelper.setLength(column.width),
                domMinWidth = DomHelper.setLength(column.minWidth);

            if (cellEl) {
                // We have to work round the IE11 bug that flex-basis affects the content-box
                // and any padding is added as extra.
                // TODO: Remove  this when IE11 retires.
                if (BrowserHelper.isIE11) {
                    flexBasis = `calc(${domWidth} - ${me.getLrPadding(cellEl)}px)`;
                }
                else {
                    flexBasis = domWidth;
                }

                hasFlex = hasFlex || Boolean(column.flex);

                // Parent column without any specified width and flex should have flex calculated if any child has flex
                if (column.isParent && column.width == null && column.flex == null) {
                    const flex = column.children.reduce((result, child) => (result += !child.hidden && child.flex || 0), 0);

                    // Do not want to store this flex value on the column since it is always calculated
                    cellEl.style.flex = flex > 0 ? `${flex} 0 auto` : '';

                    if (flex > 0) {
                        // TODO: Figure out a better way of handling this, minWidth on the columns breaks the flexbox
                        //  calculation compared to cells, making them misalign
                        column.traverse(col => col.data.minWidth = null);
                    }
                }
                // Normal case, set flex, width etc.
                else {
                    if (parseInt(column.minWidth) >= 0) {
                        cellEl.style.minWidth = domMinWidth;
                    }

                    // Clear all the things we might have to set to correct cell widths
                    cellEl.style.flex = cellEl.style.flexBasis = cellEl.style.width = '';

                    if (column.flex) {
                        // If column has children we need to give it
                        // flex-shrink: 0, flex-basis: auto so that it always
                        // shrinkwraps its children without shrinking
                        if (!isNaN(parseInt(column.flex)) && column.children) {
                            cellEl.style.flex = `${column.flex} 0 auto`;
                        }
                        else {
                            cellEl.style.flex = column.flex;
                        }
                    }
                    else if (parseInt(column.width) >= 0) {
                        const parent = column.parent;

                        // Only grid header bar has a notion of group headers
                        // Column is a child of an unwidthed group. We have to use width
                        // to stretch it.
                        if (me.isHeader && !parent.isRoot && !parent.width) {
                            cellEl.style.width = domWidth;
                        }
                        else {
                            // https://app.assembla.com/spaces/bryntum/tickets/8041
                            // Column header widths must be set using flex-basis.
                            // Using width means that wide widths cause a flexed SubGrid
                            // to bust the flex rules.
                            // TODO: When IE11 retires, remove calc() hacks to overcome its flexbox bugs.
                            // Note that grid in Grid#onColumnsResized and SubGrid#fixCellWidths,
                            // cells MUST still be sized using width since rows
                            // are absolutely positioned and will not cause the busting out
                            // problem, and rows will not stretch to shrinkwrap the cells
                            // unless they are widthed with width.
                            cellEl.style.flexBasis = flexBasis;
                        }
                    }
                }

                if (column.height >= 0) {
                    cellEl.style.height = DomHelper.setLength(column.height);
                }
            }
        });

        me.element.classList[hasFlex ? 'add' : 'remove']('b-has-flex');
    }

    getLrPadding(cellEl) {
        if (!this.cellLrPadding) {
            const s = cellEl.ownerDocument.defaultView.getComputedStyle(cellEl);
            this.cellLrPadding = parseInt(s.getPropertyValue('padding-left')) + parseInt(s.getPropertyValue('padding-right')) +
                parseInt(s.getPropertyValue('border-left-width')) + parseInt(s.getPropertyValue('border-right-width'));
        }
        return this.cellLrPadding;
    }

    /**
     * Get the header or footer cell element for the specified column.
     * @param {String} columnId Column id
     * @returns {HTMLElement} Header or footer element, depending on which subclass is in use.
     * @private
     */
    getBarCellElement(columnId) {
        return this.element.querySelector(`[data-column-id="${columnId}"]`);
    }
}
Bar._$name = 'Bar';

//import styles from '../../../resources/sass/grid/view/footer.scss';

/**
 * @module Grid/view/Footer
 */

/**
 * Grid footer, used by Summary feature. You should not need to create instances manually.
 *
 * @extends Grid/view/Bar
 * @internal
 */
class Footer extends Bar {

    static get $name() {
        return 'Footer';
    }

    static get defaultConfig() {
        return {
            isFooter : true
        };
    }

    startConfigure(config) {
        config.scrollable.overflowX = 'hidden-scroll';
        super.startConfigure(config);
    }

    get subGrid() {
        return this._subGrid;
    }

    set subGrid(subGrid) {
        this._subGrid = this.owner = subGrid;
    }

    refreshContent() {
        this.element.firstElementChild.innerHTML = this.contentTemplate();
        this.fixFooterWidths();
    }

    onPaint({ firstPaint }) {
        if (firstPaint) {
            this.refreshContent();
        }
    }

    template() {
        const region = this.subGrid.region;

        return TemplateHelper.tpl`
            <div class="b-grid-footer-scroller b-grid-footer-scroller-${region}">
                <div reference="footersElement" class="b-grid-footers b-grid-footers-${region}" data-region="${region}"></div>
            </div>
        `;
    }

    get overflowElement() {
        return this.footersElement;
    }

    //region Getters

    /**
     * Get the footer cell element for the specified column.
     * @param {String} columnId Column id
     * @returns {HTMLElement} Footer cell element
     */
    getFooter(columnId) {
        return this.getBarCellElement(columnId);
    }

    //endregion

    /**
     * Footer template. Iterates leaf columns to create content.
     * Style not included because of CSP. Widths are fixed up in
     * {@link #function-fixFooterWidths}
     * @private
     */
    contentTemplate() {
        const me = this;

        return me.columns.visibleColumns.map(column => {
            return column.hidden ? '' : TemplateHelper.tpl`
                <div
                    class="b-grid-footer ${column.align ? `b-grid-footer-align-${column.align}` : ''} ${column.cls || ''}"
                    data-column="${column.field || ''}" data-column-id="${column.id}" data-all-index="${column.allIndex}"
                    >
                    ${column.footerText || ''}
                </div>`;
        }).join('');
    }

    /**
     * Fix footer widths (flex or fixed width) after rendering. Not a part of template any longer because of CSP
     * @private
     */
    fixFooterWidths() {
        this.fixCellWidths();
    }
}
Footer._$name = 'Footer';

/**
 * @module Grid/row/Row
 */

/**
 * Represents a single rendered row in the grid. Consists of one row element for each SubGrid in use. The grid only
 * creates as many rows as needed to fill the current viewport (and a buffer). As the grid scrolls
 * the rows are repositioned and reused, there is not a one to one relation between rows and records.
 *
 * For normal use cases you should not have to use this class directly. Rely on using renderers instead.
 * @extends Core/Base
 */
class Row extends Delayable(Base) {
    static get defaultConfig() {
        return {
            cls : 'b-grid-row'
        };
    }

    //region Init

    /**
     * Constructs a Row setting its index.
     * @param {Object} config A configuration object which must contain the following two properties:
     * @param {Grid.view.Grid} config.grid The owning Grid.
     * @param {Grid.row.RowManager} config.rowManager The owning RowManager.
     * @param {Number} index The index of the row within the RowManager's cache.
     * @function constructor
     * @internal
     */
    construct(config) {
        // Set up defaults and properties
        Object.assign(this, {
            _elements      : {},
            _elementsArray : [],
            _cells         : {},
            _allCells      : [],
            _regions       : [],
            lastHeight     : 0,
            lastTop        : -1,
            _dataIndex     : 0,
            _top           : 0,
            _height        : 0,
            _id            : null,
            forceInnerHTML : false,
            isGroupFooter  : false
        }, config);

        super.construct();
    }

    doDestroy() {
        const me = this;

        // No need to clean elements up if the entire thing is being destroyed
        if (!me.rowManager.isDestroying) {

            me.removeElements();

            if (me.rowManager.idMap[me.id] === me) {
                delete me.rowManager.idMap[me.id];
            }

        }

        super.doDestroy();
    }

    //endregion

    //region Data getters/setters

    /**
     * Get index in RowManagers rows array
     * @property {Number}
     * @readonly
     */
    get index() {
        return this._index;
    }

    set index(index) {
        this._index = index;
    }

    /**
     * Get/set this rows current index in grids store
     * @property {Number}
     */
    get dataIndex() {
        return this._dataIndex;
    }

    set dataIndex(dataIndex) {
        if (this._dataIndex !== dataIndex) {
            const elements = this._elementsArray;

            this._dataIndex = dataIndex;
            for (let i = 0; i < elements.length; i++) {
                elements[i].dataset.index = dataIndex;
            }
        }
    }

    /**
     * Get/set id for currently rendered record
     * @property {String|Number}
     */
    get id() {
        return this._id;
    }

    set id(id) {
        const me    = this,
            idObj = { id },
            idMap = me.rowManager.idMap,
            elements = me._elementsArray,
            cells = me._allCells;

        if (me._id != id || idMap[id] !== me) {
            if (idMap[me._id] === me) delete idMap[me._id];
            idMap[id] = me;

            me._id = id;
            for (let i = 0; i < elements.length; i++) {
                DomDataStore.assign(elements[i], idObj);
            }
            for (let i = 0; i < cells.length; i++) {
                DomDataStore.assign(cells[i], idObj);
            }

            for (let i = 0; i < elements.length; i++) {
                elements[i].dataset.id = id;
            }
        }
    }

    //endregion

    //region Row elements

    /**
     * Add a row element for specified region.
     * @param {String} region Region to add element for
     * @param {HTMLElement} element Element
     * @private
     */
    addElement(region, element) {
        const me = this;

        let cellElement = element.firstElementChild;

        me._elements[region] = element;
        me._elementsArray.push(element);
        me._regions.push(region);
        DomDataStore.assign(element, { index : me.index });

        me._cells[region] = [];

        while (cellElement) {
            me._cells[region].push(cellElement);
            me._allCells.push(cellElement);

            DomDataStore.set(cellElement, {
                column     : cellElement.dataset.column, // TODO: dataset is slow, read from columnstore using index instead
                columnId   : cellElement.dataset.columnId,
                rowElement : cellElement.parentNode,
                row        : me
            });

            cellElement = cellElement.nextElementSibling;
        }

        // making css selectors simpler, dataset has bad performance but it is only set once and never read
        element.dataset.index = me.index;
    }

    /**
     * Get the element for the specified region.
     * @param {String} region
     * @returns {HTMLElement}
     */
    getElement(region) {
        return this._elements[region];
    }

    /**
     * Execute supplied function for each regions element.
     * @param {Function} fn
     */
    eachElement(fn) {
        for (let i = 0; i < this._elementsArray.length; i++) {
            fn(this._elementsArray[i], i);
        }
        //this._elementsArray.forEach(fn);
    }

    /**
     * Execute supplied function for each cell.
     * @param {Function} fn
     */
    eachCell(fn) {
        this._allCells.forEach(fn);
    }

    /**
     * Row elements (one for each region)
     * @type {HTMLElement[]}
     * @readonly
     */
    get elements() {
        return this._elements;
    }

    //endregion

    //region Cell elements

    /**
     * Row cell elements
     * @returns {HTMLElement[]}
     * @readonly
     */
    get cells() {
        return this._allCells;
    }

    /**
     * Get cell elements for specified region.
     * @param {String} region Region to get elements for
     * @returns {HTMLElement[]} Array of cell elements
     */
    getCells(region) {
        return this._cells[region];
    }

    /**
     * Get the cell element for the specified column.
     * @param {String|Number} columnId Column id
     * @returns {HTMLElement} Cell element
     */
    getCell(columnId) {
        return this._allCells.find(cell => {
            const cellData = DomDataStore.get(cell);
            return cellData.columnId === columnId || cellData.column === columnId;
        });
    }

    removeElements(onlyRelease = false) {
        const me = this;

        // Triggered before the actual remove to allow cleaning up elements etc.
        me.rowManager.trigger('removeRow', { row : me });

        if (!onlyRelease) {
            me._elementsArray.forEach(element => element.remove());
        }
        me._elements = {};
        me._cells = {};
        me._elementsArray.length = me._regions.length = me._allCells.length = me.lastHeight = me.height = 0;
        me.lastTop = -1;
    }

    //endregion

    //region Height

    /**
     * Get/set row height
     * @property {Number}
     */
    get height() {
        return this._height;
    }

    set height(height) {
        this._height = height;
    }

    /**
     * Get row height including border
     * @property {Number}
     */
    get offsetHeight() {
        // me.height is specified height, add border height to it to get cells height to match specified rowHeight
        // border height is measured in Grid#get rowManager
        return this.height + this.grid._rowBorderHeight;
    }

    /**
     * Sets row height, but only if the height is bigger than currently set height (used when rendering rows to
     * match height for highest region element)
     * @param height Height to set
     * @private
     */
    setHeightIfBigger(height) {
        if (height > this.height) this.height = height;
    }

    /**
     * Sync elements height to rows height
     * @private
     */
    updateElementsHeight() {
        const me = this;
        // prevent unnecessary style updates
        if (me.lastHeight !== me.height) {
            const elements = me._elementsArray;

            for (let i = 0; i < elements.length; i++) {
                elements[i].style.height = `${me.offsetHeight}px`;
            }
            me.lastHeight = me.height;
        }
    }

    //endregion

    //region CSS

    /**
     * Add css classes to each element.
     * @param {...String} classes
     */
    addCls(...classes) {
        this.eachElement(element => DomHelper.addClasses(element, classes));
    }

    /**
     * Remove css classes from each element.
     * @param {...String} classes
     */
    removeCls(...classes) {
        this.eachElement(element => DomHelper.removeClasses(element, classes));
    }

    //endregion

    //region Position

    /**
     * Is this the very first row?
     * @property {Boolean}
     * @readonly
     */
    get isFirst() {
        return this.dataIndex === 0;
    }

    /**
     * Row top coordinate
     * @property {Number}
     * @readonly
     */
    get top() {
        return this._top;
    }

    /**
     * Row bottom coordinate
     * @property {Number}
     * @readonly
     */
    get bottom() {
        return this._top + this._height + this.grid._rowBorderHeight;
    }

    /**
     * Sets top coordinate, translating elements position.
     * @param top Top coordinate
     * @internal
     */
    setTop(top) {
        if (this._top !== top) {
            this._top = top;
            this.translateElements();
        }
    }

    /**
     * Sets bottom coordinate, translating elements position.
     * @param bottom Bottom coordinate
     * @private
     */
    setBottom(bottom) {
        this.setTop(bottom - this.offsetHeight);
    }

    /**
     * Sets css transform to position elements at correct top position (translateY)
     * @private
     */
    translateElements() {
        const me           = this,
            positionMode = me.grid.positionMode;

        if (me.lastTop !== me.top) {
            const elements = me._elementsArray;

            for (let i = 0; i < elements.length; i++) {
                const style = elements[i].style;

                if (positionMode === 'translate') {
                    style.transform = `translate(0,${me.top}px)`;
                }
                else if (positionMode === 'translate3d') {
                    style.transform = `translate3d(0,${me.top}px,0)`;
                }
                else if (positionMode === 'position') {
                    style.top = `${me.top}px`;
                }
            }
            me.rowManager.trigger('translateRow', { row : me });
            me.lastTop = me.top;
        }
    }

    /**
     * Moves all row elements up or down and updates model.
     * @param {Number} offsetTop Pixels to offset the elements
     * @private
     */
    offset(offsetTop) {
        let newTop = this._top + offsetTop;

        // Not allowed to go below zero (won't be reachable on scroll in that case)
        if (newTop < 0) {
            offsetTop -= newTop;
            newTop = 0;
        }
        this.setTop(newTop);
        return offsetTop;
    }

    //endregion

    //region Render

    /**
     * Renders a record into this rows elements (trigger event that subgrids catch to do the actual rendering).
     * @param {Core.data.Model} record
     * @private
     */
    render(recordIndex, record, updatingSingleRow = true, batch = false) {
        const
            me              = this,
            { cells, grid } = me,
            oldId           = me._id,
            elements        = me._elementsArray,
            rowElData       = DomDataStore.get(elements[0]),
            rowManager      = me.rowManager,
            rowHeight       = rowManager._rowHeight,
            oldHeight       = me.height, // not using getter since we don't want to use average row height here
            defaultRowCls   = updatingSingleRow && grid.transitionDuration ? `${me.cls} b-grid-row-updating` : me.cls;

        let i = 0,
            rowElement,
            cell,
            size;

        // no record specified, try looking up in store (false indicates empty row, don't do lookup
        if (!record && record !== false) {
            record = grid.store.getById(rowElData.id);
            recordIndex = grid.store.indexOf(record);
        }

        const selected = record && grid.isSelected(record.id);

        // used by GroupSummary feature to clear row before
        rowManager.trigger('beforeRenderRow', { row : me, record, oldId });

        for (i; i < elements.length; i++) {
            rowElement = elements[i];

            // Clean classList
            rowElement.className = defaultRowCls;

            // Apply cls from data directly to row
            // TODO: should be configurable on grid
            if (selected) {
                rowElement.classList.add('b-selected');
            }

            // no record & data says it is displayed, "undisplay" it
            if (!record) {
                // TODO: Can this scenario still happen?
                rowElData.displayed = false;
                rowElement.classList.add('b-grid-row-not-displayed');
            }
            else {
                if (record.cls) {
                    record.cls.split(' ').forEach(cls => rowElement.classList.add(cls));
                }
                // has record and data says it is not displayed, flag as displayed
                rowElData.displayed = true;
            }
        }

        if (updatingSingleRow && grid.transitionDuration) {
            me.setTimeout(() => {
                // We should iterate all elements, in case we have regions in the grid
                elements.forEach(element => {
                    element.classList.remove('b-grid-row-updating');
                });
            }, grid.transitionDuration);
        }

        // Will be set from renderers
        me.height = 0;

        if (record) {
            me.id = record.id;
            me.dataIndex = recordIndex;
            
        }
        else {
            // More rows then records, render it empty for now...
            me.id = null;
            me.dataIndex = null;
        }

        for (i = 0; i < cells.length; i++) {
            cell = cells[i];

            size = me.renderCell(cell, record, i, updatingSingleRow);
            // we want to make row in all parts as high as the highest cell
            me.setHeightIfBigger((size && size.height) || rowHeight);
        }

        // Height gets set during render, reflect on elements
        me.updateElementsHeight();

        // Rerendering a row might change its height, which forces translation of all following rows
        if (updatingSingleRow) {
            if (oldHeight !== me.height) {
                rowManager.translateFromRow(me, batch);
            }
            rowManager.trigger('updateRow', { row : me, record, oldId });
            rowManager.trigger('renderDone');
        }

        // TODO: Make direct function call if no more features than Stripe needs this
        rowManager.trigger('renderRow', { row : me, record, oldId });

        me.forceInnerHTML = false;
    }

    /**
     * Renders a single cell, calling features to allow them to hook.
     * @param cellElement Cell element to render
     * @param record Record, fetched from store if undefined
     * @param index
     * @param updatingSingleRow
     * @private
     */
    renderCell(cellElement, record, index, updatingSingleRow = true) {
        const me              = this,
            cellElementData = DomDataStore.get(cellElement),
            col             = me.grid.columns.getById(cellElementData.columnId),
            rowElement      = cellElementData.rowElement,
            rowElementData  = DomDataStore.get(rowElement),
            { // Avoid two calls to col's getters by gathering these fields.
                internalCellCls,
                cellCls,
                align,
                renderer,
                defaultRenderer,
                id : columnId
            }               = col,
            cellContext     = { columnId, id : rowElementData.id },
            useRenderer     = renderer || defaultRenderer;

        if (!record) {
            // Clear out row without record
            // Edge case, only happens if groups/tree is collapsed leading to fewer records than row elements
            if (rowElementData.id === null) {
                // setting to ' ' (space) makes it not remove firstChild, thus not breaking
                // when doing real render the next time
                // NOTE: have opted to not clear cell. might be confusing in DOM but simplifies for cells reusing
                // elements internally. Another option would be to have a derenderer per column which is called
                // cell.innerHTML = ' ';
                cellElement.className = 'b-grid-cell';
                return;
            }

            record = me.grid.store.getById(rowElementData.id);

            if (!record) return;
        }

        const newCellClass = {
            'b-grid-cell'                  : 1,
            [internalCellCls]              : internalCellCls,
            // Check cell CSS should not be applied to group header rows
            [cellCls]                      : record.meta.specialRow && col.internalCellCls === 'b-check-cell' ? undefined : cellCls,
            'b-cell-dirty'                 : record.isFieldModified(col.field),
            [`b-grid-cell-align-${align}`] : align,
            'b-selected'                   : me.grid.isSelected(cellContext),
            'b-focused'                    : me.grid.isFocused(cellContext)
        };
        DomHelper.syncClassList(cellElement, newCellClass);

        let // TODO: record.rowHeight should be configurable (which field)
            size             = { height : record.get('rowHeight') || 0 },
            cellContent      = col.getRawValue(record),
            shouldSetContent = true,
            rendererData     = {
                cellElement,
                rowElement,
                value  : cellContent,
                record : record,
                column : col,
                size   : size,
                grid   : me.grid,
                row    : cellElementData.row,
                updatingSingleRow
            };

        // Call renderer or set innerHTML directly if none
        // if renderer returns a value, set it in innerHTML below. render is also free to do it itself
        if (useRenderer) {
            cellContent = useRenderer.call(col, rendererData);
            if (cellContent === undefined) {
                shouldSetContent = false;
            }
        }

        // Allow wrappers to do their own processing of cell contents, for example react wrapper allows JSX
        if (me.grid.processCellContent) {
            shouldSetContent = me.grid.processCellContent({
                cellContent,
                cellElement,
                record,
                cellElementData,
                rendererData
            });
        }

        // Listeners might need to know what string went into the DOM
        // Maintainer: the == null test below ensures that values of both null and undefined
        // result in an empty cell.
        const text = rendererData.cellContent = cellContent == null ? '' : String(cellContent);

        if (shouldSetContent) {
            // row might be flagged by GroupSummary to require full "redraw"
            if (me.forceInnerHTML) {
                cellElement.innerHTML = text;
            }
            // display cell contents as text or use actual html?
            // (disableHtmlEncode set by features that decorate cell contents)
            else if (col.htmlEncode && !col.disableHtmlEncode) {
                // Set innerText if cell currently has html content (from for example group renderer),
                // always do it on Linux, it does not have firstChild.data
                if (BrowserHelper.isLinux || cellElement._hasHtml) {
                    cellElement.innerText = text;
                    cellElement._hasHtml = false;
                }
                else {
                    // setting firstChild.data is faster than innerText (and innerHTML),
                    // but in some cases the inner node is lost and needs to be recreated
                    const firstChild = cellElement.firstChild;
                    if (!firstChild) {
                        cellElement.innerText = text;
                    }
                    else {
                        firstChild.data = text;
                    }
                }
            }
            else {
                const
                    hasStringContent = typeof cellContent === 'string',
                    hasObjectContent = typeof cellContent === 'object';
                if (col.autoSyncHtml && (!hasStringContent || cellElement.childElementCount)) {
                    // String content in html column is handled as a html template string
                    if (hasStringContent) {
                        // update cell with only changed attributes etc.
                        DomHelper.sync(text, cellElement.firstElementChild);
                    }
                    // Other content is considered to be a DomHelper config object
                    else {
                        DomSync.sync({
                            domConfig     : cellContent,
                            targetElement : cellElement
                        });
                    }
                }
                // Consider all returned plain objects to be DomHelper configs for cell content
                else if (hasObjectContent) {
                    DomSync.sync({
                        targetElement : cellElement,
                        domConfig     : {
                            onlyChildren : true,
                            children     : [
                                cellContent
                            ]
                        }
                    });
                }
                else {
                    cellElement.innerHTML = text;
                }
            }
        }

        // Allow others to affect rendering
        me.rowManager.trigger('renderCell', rendererData);

        return size;
    }

//endregion
}
Row._$name = 'Row';

//TODO: Handle vertical resize, add/remove row elements?

/**
 * @module Grid/row/RowManager
 * @private
 */

/**
 * Virtual representation of the grid, using {@link Grid.row.Row} to represent rows. Plugs into {@link Grid.view.Grid}
 * and exposes the following functions on grid itself:
 * * {@link #function-getRecordCoords()}
 * * {@link #function-getRowById()}
 * * {@link #function-getRow()}
 * * {@link #function-getRowFor()}
 * * {@link #function-getRowFromElement()}
 *
 * @example
 * let row = grid.getRowById(1);
 * @private
 */
class RowManager extends InstancePlugin {
    //region Config

    // Plugin configuration.
    static get pluginConfig() {
        return {
            chain : [
                'getRowById', 'topRow', 'bottomRow', 'getRecordCoords', 'getRow', 'getRowFor', 'getRowFromElement', 'destroy'
            ],
            assign : [
                'rowHeight'
            ]
        };
    }

    static get defaultConfig() {
        return {
            /**
             * Number of rows to render above current viewport
             * @config {Number}
             * @default
             */
            prependRowBuffer : 5,

            /**
             * Number of rows to render below current viewport
             * @config {Number}
             * @default
             */
            appendRowBuffer : 5,

            /**
             * Default row height, assigned from Grid at construction (either from config
             * {@link Grid.view.Grid#config-rowHeight} or CSS). Can be set from renderers
             * @config {Number}
             * @default
             */
            rowHeight : null,

            idMap         : {},
            rowScrollMode : 'move',
            autoHeight    : false,
            // TODO: investigate if topIndex can to built away, since topRow is always first in array and has dataIndex??
            topIndex      : 0,
            lastScrollTop : 0,
            _rows         : []
        };
    }

    //endregion

    //region Init

    construct(config) {
        config.grid._rowManager = this;
        this.scrollTargetRecordId = null;
        this.refreshDetails = {
            topRowIndex : 0,
            topRowTop   : 0
        };
        super.construct(config.grid, config);
    }

    // Chained to grids doDestroy
    doDestroy() {
        // To remove timeouts
        this._rows.forEach(row => row.destroy());

        super.doDestroy();
    }

    /**
     * Initializes the RowManager with Rows to fit specified height.
     * @param {Number} height
     * @private
     * @category Init
     */
    initWithHeight(height, isRendering = false) {
        const me = this;

        // no valid height, make room for all rows
        if (me.autoHeight) {
            height = me.store.allCount * me.rowOffsetHeight;
        }

        me.viewHeight = height;
        me.calculateRowCount(isRendering);

        return height;
    }

    /**
     * Releases all elements (not from dom), calculates how many are needed, creates those and renders
     */
    reinitialize(returnToTop = false) {
        const me = this;

        // Calculate and correct the amount of rows needed (without triggering render)
        // Rows which are found to be surplus are destroyed.
        me.calculateRowCount(false, true, true);

        // If our row range is outside of the store's range, force a return to top
        if (me.topIndex + me.rowCount - 1 > me.store.count) {
            returnToTop = true;
        }

        const top = me.topRow && !returnToTop ? me.topRow.top : 0;

        me.scrollTargetRecordId = null;

        if (returnToTop) {
            me.topIndex = me.lastScrollTop = 0;
        }

        const { topRow } = me;

        if (topRow) {
            // Ensure rendering from the topRow starts at the correct position
            topRow.dataIndex = me.topIndex;
            topRow.setTop(top);
        }

        // Need to estimate height in case we have Grid using autoHeight
        me.estimateTotalHeight();

        me.renderFromRow(topRow);
    }

    //endregion

    //region Rows

    /**
     * Add or remove rows to fit row count
     * @private
     * @category Rows
     */
    matchRowCount(skipRender = false) {
        const me      = this,
            rows    = me._rows,
            numRows = rows.length,
            delta   = numRows - me.rowCount,
            grid    = me.grid;

        if (delta) {
            if (delta < 0) {
                const newRows = [];

                // add rows
                for (let index = numRows, dataIndex = numRows ? rows[numRows - 1].dataIndex + 1 : 0; index < me.rowCount; index++, dataIndex++) {
                    newRows.push(new Row({
                        rowManager : me,
                        grid,
                        index,
                        dataIndex
                    }));
                }
                rows.push.apply(rows, newRows);
                // and elements (by triggering event used by SubGrid to add elements)
                me.trigger('addRows', { rows : newRows });

                if (!skipRender) {
                    // render
                    me.renderFromRow(rows[Math.max(0, numRows - 1)]);
                }
            }
            else {
                // remove rows from bottom
                const removedRows = rows.splice(numRows - delta, delta);

                // trigger event in case some feature needs to cleanup when removing (widget column might be interested)
                me.trigger('removeRows', { rows : removedRows });

                removedRows.forEach(row => row.destroy());

                // no need to rerender or such when removing from bottom. all is good :)
            }
        }
    }

    /**
     * Calculates how many rows fit in the available height (view height)
     * @private
     * @category Rows
     */
    calculateRowCount(skipMatchRowCount = false, allowRowCountShrink = true, skipRender = false) {
        // TODO: replace prependRowBuffer, appendXX with bufferSize
        const me                = this,
            store             = me.store,
            visibleRowCount   = Math.ceil(me.viewHeight / me.rowOffsetHeight), // Want whole rows
            maxRenderRowCount = visibleRowCount + me.prependRowBuffer + me.appendRowBuffer;

        // If RowManager is reinitialized in a hidden state the view might not have a height
        if (!me.grid.columns.count || isNaN(visibleRowCount)) {
            me.rowCount = 0;
            return 0;
        }

        // when for example jumping we do not want to remove excess rows,
        // since we know they are needed at other scroll locations
        if (maxRenderRowCount < me.rowCount && !allowRowCountShrink) return me.rowCount;

        me.visibleRowCount = visibleRowCount;
        me.rowCount = Math.min(store.count, maxRenderRowCount); // No need for more rows than data

        if (me.rowScrollMode === 'all') {
            me.rowCount = store.allCount;
        }

        // If the row count doesn't match the calculated, ensure it matches,
        if (!skipMatchRowCount) {
            if (me._rows && me.rowCount !== me._rows.length) {
                me.matchRowCount(skipRender);
            }
            else if (!me.rowCount) {
                me.trigger('changeTotalHeight', { totalHeight : me.totalHeight });
            }
            me.grid.toggleEmptyText();
        }

        return me.rowCount;
    }

    removeAllRows() {
        // remove rows from bottom
        const
            me         = this,
            { topRow } = me,
            result     = topRow ? (me.refreshDetails = {
                topRowIndex : topRow.dataIndex,
                topRowTop   : topRow.top
            }) : me.refreshDetails,
            removedRows = me._rows.slice();

        // trigger event in case some feature needs to cleanup when removing (widget column might be interested)
        me.trigger('removeRows', { rows : removedRows });

        me._rows.forEach(row => row.destroy());
        me._rows.length = 0;
        me.idMap = {};

        // We return a descriptor of the last rendered block before the remove.
        // This is primarily for a full GridBase#renderContents to be able to perform a correct refresh.
        return result;
    }

    setPosition(refreshDetails) {
        // Sets up the rendering position for the next call to reinitialize
        const
            { topRow }                 = this,
            { topRowIndex, topRowTop } = refreshDetails;

        topRow.setTop(topRowTop);
        topRow.dataIndex = topRowIndex;
    }

    //endregion

    //region Rows - Getters

    get store() {
        return this.client.store;
    }

    /**
     * Get all Rows
     * @property {Grid.row.Row[]}
     * @readonly
     * @category Rows
     */
    get rows() {
        return this._rows;
    }

    /**
     * Get the Row at specified index. Returns `undefined` if the row index is not rendered.
     * @param {Number} index
     * @returns {Grid.row.Row}
     * @category Rows
     */
    getRow(index) {
        return this.rowCount && this.rows[index - this.topIndex];
    }

    /**
     * Get Row for specified record id
     * @param {Core.data.Model|String|Number} recordOrId Record id (or a record)
     * @returns {Grid.row.Row} Found Row or null if record not rendered
     * @category Rows
     */
    getRowById(recordOrId) {
        if (recordOrId.isModel) {
            recordOrId = recordOrId.id;
        }
        // Don't use ===, want to match 1 == '1' since id is stored on rowElement in dataset (html attribute, always string)
        return this.idMap[recordOrId];// || this.rows.find(row => row.id == recordOrId);
    }

    /**
     * Get a Row from an HTMLElement
     * @param {HTMLElement} element
     * @returns {Grid.row.Row} Found Row or null if record not rendered
     * @category Rows
     */
    getRowFromElement(element) {
        element = element.closest('.b-grid-row');
        return element && this.getRow(element.dataset.index);
    }

    /**
     * Get the row at the specified Y coordinate, which is by default viewport-based.
     * @param {Number} y The `Y` coordinate to find the Row for.
     * @param {Boolean} [local=false] Pass `true` if the `Y` coordinate is local to the SubGrid's element.
     * @returns {Grid.row.Row} Found Row or null if no row is rendered at that point.
     */
    getRowAt(y, local = false) {
        // Make it local.
        if (!local) {
            // Because this is used with event Y positions which are integers, we must
            // round the Rectangle to the closest integer.
            y -= Rectangle.from(this.grid.bodyContainer, null, true).round(1).top;

            // Adjust for scrolling
            y += this.grid.scrollable.y;
        }
        y = roundPx(y);

        return this.rows.find(r => y >= r.top && y < r.bottom);
    }

    /**
     * Get a Row for either a record, a record id or an HTMLElement
     * @param {HTMLElement|Core.data.Model|String|Number} recordOrId Record or record id or HTMLElement
     * @returns {Grid.row.Row} Found Row or null if record not rendered
     * @category Rows
     */
    getRowFor(recordOrId) {
        if (recordOrId instanceof HTMLElement) return this.getRowFromElement(recordOrId);
        return this.getRowById(recordOrId);
    }

    /**
     * Gets the Row following the specified Row (by index or object). Wraps around the end.
     * @param {Number|Grid.row.Row} indexOrRow index or Row
     * @returns {Grid.row.Row}
     * @category Rows
     */
    getNextRow(indexOrRow) {
        const me    = this,
            index = typeof indexOrRow === 'number' ? indexOrRow : indexOrRow.index;
        return me.getRow((index + 1) % me.rowCount);
    }

    /**
     * Get the Row that is currently displayed at top.
     * @property {Grid.row.Row}
     * @readonly
     * @category Rows
     */
    get topRow() {
        return this._rows[0];
    }

    /**
     * Get the Row currently displayed furthest down.
     * @property {Grid.row.Row}
     * @readonly
     * @category Rows
     */
    get bottomRow() {
        const me       = this,
            // TODO: remove when ticket on making sure rowCount is always up to date is fixed
            rowCount = Math.min(me.rowCount, me.store.count);

        return me.rows[rowCount - 1];
    }

    /**
     * Calls offset() for each Row passing along offset parameter
     * @param {Number} offset Pixels to translate Row elements.
     * @private
     * @category Rows
     */
    offsetRows(offset) {
        if (offset !== 0) {
            const rows   = this.rows,
                length = rows.length;

            for (let i = 0; i < length; i++) {
                rows[i].offset(offset);
            }
        }

        this.trigger('offsetRows', { offset });
    }

    //endregion

    //region Row height

    // TODO: should support setting rowHeight in em and then convert internally to pixels. 1em = font-size. Not needed for 1.0
    /**
     * Set a fixed row height (can still be overridden by renderers) or get configured row height. Setting refreshes all rows
     * @category Rows
     */
    get rowHeight() {
        return this._rowHeight;
    }

    set rowHeight(height) {
        const
            me = this,
            { grid } = me,
            oldRowHeight = me._rowHeight;

        ObjectHelper.assertNumber(height, 'rowHeight');

        if (height < 10) {
            // <debug>
            console.warn(`The rowHeight of ${height} was increased to 10 which is the minimum.`);
            // </debug>
            height = 10;
        }

        me.trigger('beforeRowHeight', { height });

        me._rowHeight = height;

        me.prependBufferHeight = me.prependRowBuffer * me.rowOffsetHeight;
        me.appendBufferHeight = me.appendRowBuffer * me.rowOffsetHeight;

        if (me.rows.length) {
            let average = me.averageRowHeight;
            const
                oldAverage = average,
                oldY       = grid.scrollable.y,
                topRow     = me.getRowAt(oldY, true),
                edgeOffset = topRow.top - oldY;

            // Estimate a new averageRowHeight
            average -= grid._rowBorderHeight;
            average *= height / oldRowHeight;
            me.averageRowHeight = average += grid._rowBorderHeight;

            // Adjust number of rows, since it is only allowed to shrink in refresh()
            me.calculateRowCount(false, true, true);

            // Reposition the top row since it is used to position the rest
            me.topRow.setTop(me.topRow.dataIndex * average);

            me.refresh();

            const newY = oldY * (average / oldAverage);

            // Scroll top row to the same position.
            if (newY !== oldY) {
                grid.scrollRowIntoView(topRow.id, {
                    block : 'start',
                    edgeOffset
                });
            }
        }

        me.trigger('rowHeight', { height });
    }

    /**
     * Get actually used row height, which includes any border and might be an average if using variable row height.
     * @property {Number}
     */
    get rowOffsetHeight() {
        return Math.floor(this.averageRowHeight) || (this._rowHeight + this.grid._rowBorderHeight);
    }

    //endregion

    //region Calculations

    /**
     * Returns top and bottom for rendered row or estimated coordinates for unrendered.
     * @param {Core.data.Model|string|Number} recordOrId Record or record id
     * @param {Boolean} [local] Pass true to get relative record coordinates
     * @returns {Core.helper.util.Rectangle} Record bounds with format { x, y, width, height, bottom, right }
     * @category Calculations
     */
    getRecordCoords(recordOrId, local = false) {
        const
            me  = this,
            id  = typeof recordOrId === 'string' || typeof recordOrId === 'number' ? recordOrId : recordOrId.id,
            row = me.getRowById(recordOrId);

        let scrollingViewport = me.client._bodyRectangle;

        // _bodyRectangle is not updated on page/containing element scroll etc. Need to make sure it is correct in case
        // that has happend. This if-statement should be removed when fixing
        // https://app.assembla.com/spaces/bryntum/tickets/6587-cached-_bodyrectangle-should-be-updated-on--quot-external-quot--scroll/details
        if (!local) {
            scrollingViewport = me.client._bodyRectangle = Rectangle.client(me.client.bodyContainer);
        }

        // Rendered? Then we know position for certain
        if (row) {
            return new Rectangle(
                scrollingViewport.x,
                local ? Math.round(row.top) : Math.round(row.top + scrollingViewport.y - me.client.scrollable.y),
                scrollingViewport.width,
                row.offsetHeight
            );
        }

        return me.getRecordCoordsByIndex(me.store.indexOf(id), local);
    }

    /**
     * Returns estimated top and bottom coordinates for specified row.
     * @param {Number} recordIndex Record index
     * @returns {Core.helper.util.Rectangle} Estimated record bounds with format { x, y, width, height, bottom, right }
     * @category Calculations
     */
    getRecordCoordsByIndex(recordIndex, local = false) {
        const
            me                = this,
            scrollingViewport = me.client._bodyRectangle,
            // Not using rowOffsetHeight since it floors the value and that rounding might give big errors far down
            height            = me.averageRowHeight || (me._rowHeight + me.grid._rowBorderHeight),
            currentTopIndex = me.topRow.dataIndex,
            currentBottomIndex = me.bottomRow.dataIndex,
            // Instead of estimating top from the very top, use closest known coordinate. Makes sure a coordinate is not
            // estimated on wrong side of rendered rows, needed to correctly draw dependencies where one event is located
            // on a unrendered row
            calculateFrom =
                // bottomRow is closest, calculate from it
                recordIndex > currentBottomIndex
                    ? { index : recordIndex - currentBottomIndex - 1, y : me.bottomRow.bottom, from : 'bottomRow' }
                    //  closer to topRow than 0, use topRow
                    : recordIndex > currentTopIndex / 2
                        ? { index : recordIndex - currentTopIndex, y : me.topRow.top, from : 'topRow' }
                        // closer to the very top, use it
                        : { index : recordIndex, y : 0, from : 'top' },
            top               = Math.floor(calculateFrom.y + calculateFrom.index * height),
            //top               = Math.floor(recordIndex * height),
            result            = new Rectangle(
                scrollingViewport.x,
                local ? top : top + scrollingViewport.y - me.client.scrollable.y,
                scrollingViewport.width,
                height
            );

        // Signal that it's not based on an element, so is only approximate.
        // Grid.scrollRowIntoView will have to go round again using the block options below to ensure it's correct.
        result.virtual = true;

        // When the block becomes visible, scroll it to the logical position using the scrollIntoView's block
        // option. If it's above, use block: 'start', if below, use block: 'end'.
        result.block = result.bottom < scrollingViewport.y ? 'start' : (result.y > scrollingViewport.bottom ? 'end' : 'nearest');

        return result;
    }

    /**
     * Total estimated grid height (used for scroller)
     * @property {Number}
     * @readonly
     * @category Calculations
     */
    get totalHeight() {
        return Math.floor(this.store.count * this.rowOffsetHeight);
    }

    //endregion

    //region Iteration etc.

    /**
     * Calls a function for each Row
     * @param {Function} fn Function that will be called with Row as first parameter
     * @category Iteration
     */
    forEach(fn) {
        this.rows.forEach(fn);
    }

    /**
     * Iterator that allows you to do for (let row of rowManager)
     * @category Iteration
     */
    [Symbol.iterator]() {
        return this.rows[Symbol.iterator]();
    }

    //endregion

    //region Scrolling & rendering

    resetAverageRowHeight() {
        this.averageRowHeight = this.rowCount ? (this.bottomRow.bottom - this.topRow.top) / this.rowCount : this.rowHeight;
    }

    /**
     * Renders from the top of the grid, also resetting scroll to top. Used for example when collapsing all groups.
     * @category Scrolling & rendering
     */
    returnToTop() {
        const me = this;

        me.topIndex = 0;
        me.lastScrollTop = 0;
        me.topRow.dataIndex = 0;

        // Force the top row to the top of the scroll range
        me.topRow.setTop(0);

        me.refresh();

        // Rows rendered from top, make sure grid is scrolled to top also
        me.grid.scrollable.y = 0;
    }

    /**
     * Renders from specified records row and down (used for example when collapsing a group, does not affect rows above).
     * @param {Core.data.Model} record Record of first row to render
     * @category Scrolling & rendering
     */
    renderFromRecord(record) {
        const row = this.getRowById(record.id);
        if (row) {
            this.renderFromRow(row);
        }
    }

    /**
     * Renders from specified row and down (used for example when collapsing a group, does not affect rows above).
     * @param {Grid.row.Row} fromRow First row to render
     * @category Scrolling & rendering
     */
    renderFromRow(fromRow = null) {
        const me = this,
            { _rows, store } = me,
            storeCount = store.count;

        // Calculate row count, adding rows if needed, but do not rerender - we are going to do that below.
        // Bail out if no rows. Allow removing rows if we have more than store have rows
        if (me.calculateRowCount(false, storeCount < _rows.length, true) === 0) {
            return;
        }

        let // render from this row
            fromRowIndex  = fromRow ? _rows.indexOf(fromRow) : 0,
            // starting either from its specified dataIndex or from its index (happens on first render, no dataIndex yet)
            dataIndex     = fromRow ? fromRow.dataIndex : _rows[0].dataIndex,
            // amount of records after this one in store
            recordsAfter  = storeCount - dataIndex - 1,
            // render to this row, either the last row or the row which will hold the last record available
            toRowIndex    = Math.min(_rows.length - 1, fromRowIndex + recordsAfter),
            // amount of rows which wont be rendered below last record (if we have fewer records than topRow + row count)
            leftOverCount = _rows.length - toRowIndex - 1,
            // Start with top correctly just below the previous row's bottom
            top           = fromRowIndex > 0 ? _rows[fromRowIndex - 1].bottom : _rows[fromRowIndex].top,
            row;

        // _rows array is ordered in display order, just iterate to the end
        for (let i = fromRowIndex; i <= toRowIndex; i++) {
            row = _rows[i];
            // Needed in scheduler when translating events, happens before render
            row.dataIndex = dataIndex;
            row.setTop(top);
            row.render(dataIndex, store.getAt(dataIndex++), false);
            top += row.offsetHeight;
        }

        // if number for records to display has decreased, for example by collapsing a node, we might get unused rows
        // below bottom. move those to top to not have unused rows laying around
        while (leftOverCount-- > 0) {
            me.displayRecordAtTop();
        }

        if (me.averageRowHeight) {
            // Adjust average, subtracting the rendered block's estimated height and then adding the actual height
            me.averageRowHeight = (me.averageRowHeight * (storeCount - me.rowCount) + (top - me.topRow.top)) / storeCount;
        }
        else {
            me.averageRowHeight = (top - me.topRow.top) / me.rowCount;
        }

        // Reestimate total height
        me.estimateTotalHeight();

        me.trigger('renderDone');
    }

    /**
     * Renders the passed array (or [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)) of {@link Grid.row.Row rows}
     * @param {Grid.row.Row[]|Set} rows The rows to render
     * @category Scrolling & rendering
     */
    renderRows(rows) {
        let oldHeight,
            heightChanged = false;

        rows = Array.from(rows);

        // Render the requested rows.
        for (const row of rows) {
            oldHeight = row.height;

            // Pass updatingSingleRow as false, so that it does not shuffle following
            // rows downwards on each render. We do that once here after the rows are all refreshed.
            row.render(null, null, false);
            heightChanged |= row.height !== oldHeight;
        }

        // If this caused a height change, shuffle following rows.
        if (heightChanged) {
            this.translateFromRow(rows[0], true);

            // Reestimate total height
            this.estimateTotalHeight();
        }

        this.trigger('renderDone');
    }

    /**
     * Translates all rows after the specified row. Used when a single rows height is changed and the others should
     * rearrange. (Called from Row#render)
     * @param {Grid.row.Row} fromRow
     * @private
     * @category Scrolling & rendering
     */
    translateFromRow(fromRow, batch = false) {
        let me         = this,
            top        = fromRow.bottom,
            storeCount = me.store.count,
            row, index;

        for (index = fromRow.dataIndex + 1, row = me.getRow(index); row; row = me.getRow(++index)) {
            row.setTop(top);
            top += row.offsetHeight;
        }

        // Adjust average, subtracting the rendered block's estimated height and then adding the actual height
        me.averageRowHeight = (me.averageRowHeight * (storeCount - me.rowCount) + (me.bottomRow.bottom - me.topRow.top)) / storeCount;

        // Reestimate total height
        if (!batch) {
            me.estimateTotalHeight();
        }
    }

    /**
     * Rerender all rows
     * @category Scrolling & rendering
     */
    refresh() {
        const
            me         = this,
            { topRow } = me;

        // too early
        if (!topRow) {
            return;
        }

        me.idMap = {};

        me.renderFromRow(topRow);

        me.trigger('refresh');
    }

    /**
     * Makes sure that specified record is displayed in view
     * @param newScrollTop Top of visible section
     * @param [forceRecordIndex] Index of record to display at center
     * @private
     * @category Scrolling & rendering
     */
    jumpToPosition(newScrollTop, forceRecordIndex) {
        // There are two very different requirements here.
        // If there is a forceRecordIndex, that takes precedence to get it into the center of the
        // viewport, and wherever we render the calculated row block, we may then *adjust the scrollTop*
        // to get that row to the center.
        //
        // If there's no forceRecordIndex, then the scroll position is the primary objective and
        // we must render what we calculate to be correct at that viewport position.
        const
            me          = this,
            rowHeight   = me.rowOffsetHeight,
            storeCount  = me.store.count,
            // Calculate index of the top of the rendered block.
            // If we are targeting the scrollTop, this will be the top index at the scrollTop minus prepend count.
            // If we are targeting a recordIndex, this will attempt to place that in the center of the rendered block.
            targetIndex = forceRecordIndex == null ? Math.floor(newScrollTop / rowHeight) - me.prependRowBuffer : forceRecordIndex - Math.floor(me.rowCount / 2),
            startIndex  = Math.max(Math.min(targetIndex, storeCount - me.rowCount), 0),
            viewportTop = me.client.scrollable.y,
            viewportBottom = Math.min(me.client._bodyRectangle.height + viewportTop + me.appendBufferHeight, me.totalHeight);

        me.lastScrollTop = newScrollTop;
        me.topRow.dataIndex = me.topIndex = startIndex;
        me.topRow.setTop(startIndex * rowHeight, false);

        // render entire buffer
        me.refresh();

        // TODO: It is likely the approach below will be needed for scrolling in opposite direction also, although no
        //   problem encountered yet

        // Not filled all the way down?
        if (me.bottomRow.bottom < viewportBottom) {
            // Fill with available rows (might be available above buffer because of var row height), stop if we run out of records :)
            while (me.bottomRow.bottom < viewportBottom && me._rows[me.prependRowBuffer].top < viewportTop && me.bottomRow.dataIndex < storeCount - 1) {
                me.displayRecordAtBottom();
            }

            // Average row height in rendered block
            const blockHeight = me.bottomRow.bottom - me.topRow.top;

            // Adjust average, subtracting the rendered block's estimated height and then adding the actual height
            me.averageRowHeight = (me.averageRowHeight * (storeCount - me.rowCount) + blockHeight) / storeCount;

            // TODO: Block below was not needed for current tests, but if row height in one block is enough smaller
            //  than average row height then we will need to add more rows

            // Still not filled all the way down? Need more rows
            // if (me.bottomRow.bottom < viewportBottom) {
            //     //const localAverage = blockHeight / me.rowCount;
            //     while (me.bottomRow.bottom < viewportBottom) {
            //        me.addRecordAtBottom();
            //     }
            // }

        }

        me.estimateTotalHeight();

        // If the row index is our priority, then scroll it into the center
        if (forceRecordIndex != null) {
            const targetRow      = me.getRow(forceRecordIndex),
                // When coming from a block of high rowHeights to one with much lower we might still miss the target...
                // TODO: Jump again in these cases?
                rowCenter      = targetRow && Rectangle.from(targetRow._elementsArray[0]).center.y,
                viewportCenter = me.grid.scrollable.viewport.center.y;

            // Scroll the targetRow into the center of the viewport
            if (targetRow) {
                me.grid.scrollable.y = newScrollTop = Math.floor(me.grid.scrollable.y + (rowCenter - viewportCenter));
            }
        }

        return newScrollTop;
    }

    /**
     * Jumps to a position if it is far enough from current position. Otherwise does nothing.
     * @private
     * @category Scrolling & rendering
     */
    warpIfNeeded(newScrollTop) {
        const me     = this,
            result = { newScrollTop, deltaTop : newScrollTop - me.lastScrollTop };

        // if gap to fill is large enough, better to jump there than to fill row by row
        if (Math.abs(result.deltaTop) > (me.rowCount * me.rowOffsetHeight) * 3) {
            // no specific record targeted
            let index;

            // Specific record specified as target of scroll?
            if (me.scrollTargetRecordId) {
                index = me.store.indexOf(me.scrollTargetRecordId);

                // since scroll is happening async record might have been removed after requesting scroll,
                // in that case we rely on calculated index (as when scrolling without target)
            }

            // perform the jump and return results
            result.newScrollTop = me.jumpToPosition(newScrollTop, index);
            result.deltaTop = 0; // no extra filling needed
        }

        return result;
    }

    /**
     * Handles virtual rendering (only visible rows + buffer are in dom) for rows
     * @param {Number} newScrollTop The `Y` scroll position for which to render rows.
     * @param {Boolean} [force=false] Pass `true` to update the rendered row block even if the scroll position has not changed.
     * @return {Number} Adjusted height required to fit rows
     * @private
     * @category Scrolling & rendering
     */
    updateRenderedRows(newScrollTop, force, ignoreError) {
        const me         = this,
            clientRect = me.client._bodyRectangle;

        // Might be triggered after removing all records, should not crash
        if (me.rowCount === 0) {
            return 0;
        }

        let result = me.estimatedTotalHeight;

        if (
            force ||
            // Only react if we have scrolled by more than one row
            Math.abs(newScrollTop - me.lastScrollTop) > me.rowOffsetHeight ||
            // or if we have a gap at top/bottom (#9375)
            me.topRow.top > newScrollTop ||
            me.bottomRow.bottom < newScrollTop + clientRect.height
        ) {
            // If scrolled by a large amount, jump instead of rendering each row
            const posInfo = me.warpIfNeeded(newScrollTop);

            me.scrollTargetRecordId = null;

            // Cache the last correct render scrollTop before fill.
            // it can be adjusted to hide row position corrections.
            me.lastScrollTop = posInfo.newScrollTop;

            if (posInfo.deltaTop > 0) {
                // Scrolling down
                me.fillBelow(posInfo.newScrollTop);
            }
            else if (posInfo.deltaTop < 0) {
                // Scrolling up
                me.fillAbove(posInfo.newScrollTop);
            }

            // Calculate the new height based on new content
            result = me.estimateTotalHeight();

            // If it's a temporary scroll, we can be told to ignore the drift.
            // Apart from that, we must correct keep the rendered block position correct.
            // Otherwise, when rolling upwards after a teleport, we may not be able to reach
            // the top. Some rows may end up at -ve positions.
            if (!ignoreError) {
                // Only correct the rendered block position if we are in danger of running out of scroll space.
                // That is if we are getting towards the top or bottom of the scroll range.
                if (
                    // Scrolling up within top zone
                    (posInfo.deltaTop < 0 && newScrollTop < clientRect.height * 2) ||
                    // Scrolling down within bottom zone
                    (posInfo.deltaTop > 0 && newScrollTop > me.estimatedTotalHeight - clientRect.height * 2 - 3)
                ) {
                    // Correct the rendered block position if it's not at the calculated position.
                    // Keep the visual position correct by adjusting the scrollTop by the same amount.
                    // When variable row heights are used, this will keep the rendered block top correct.
                    // TODO: Calc could be eased more, using distance left to have less effect the further away from top/bottom
                    const error = me.topRow.top - me.topIndex * me.rowOffsetHeight;
                    if (error) {
                        me.offsetRows(-error);
                        me.grid.scrollable.y = me.lastScrollTop = me.grid.scrollable.y - error;
                    }
                }
            }
        }

        return result;
    }

    /**
     * Moves as many rows from the bottom to the top that are needed to fill to current scroll pos.
     * @param newTop Scroll position
     * @private
     * @category Scrolling & rendering
     */
    fillAbove(newTop) {
        const me         = this,
            fillHeight = newTop - me.topRow.top - me.prependBufferHeight;

        let accumulatedHeight = 0;

        while (accumulatedHeight > fillHeight && me.topIndex > 0) {
            // We want to show prev record at top of rows
            accumulatedHeight -= me.displayRecordAtTop();
        }

        me.trigger('renderDone');
    }

    /**
     * Moves as many rows from the top to the bottom that are needed to fill to current scroll pos.
     * @param newTop Scroll position
     * @private
     * @category Scrolling & rendering
     */
    fillBelow(newTop) {
        const me          = this,
            fillHeight  = newTop - me.topRow.top - me.prependBufferHeight,
            recordCount = me.store.count,
            rowCount    = me.rowCount;

        let accumulatedHeight = 0;

        // Repeat until we have filled empty height
        while (
            accumulatedHeight < fillHeight &&         // fill empty height
            me.topIndex + rowCount < recordCount &&   // as long as we have records left
            me.topRow.top + me.topRow.offsetHeight < newTop // and do not move top row fully into view (can happen with var row height)
        ) {
            // We want to show next record at bottom of rows
            accumulatedHeight += me.displayRecordAtBottom();
        }

        me.trigger('renderDone');
    }

    /**
     * Estimates height needed to fit all rows, based on average row height. Also offsets rows if needed to not be above
     * the reachable area of the view.
     * @returns {Number}
     * @private
     * @category Scrolling & rendering
     */
    estimateTotalHeight() {
        let me            = this,
            recordCount   = me.store.count,
            // When used to estimate initial height in a grid with autoHeight there is no averageRowHeight yet
            estimate      = Math.floor(recordCount * (me.averageRowHeight || me.rowOffsetHeight)),
            { bottomRow } = me;

        if (me.grid.renderingRows) {
            return;
        }

        // No bottomRow yet if estimating initial height in autoHeight grid
        if (bottomRow) {
            const bottom = bottomRow.bottom;
            //top                   = topRow.top;

            // To low estimate or reached the end with scroll left, adjust to fit current bottom
            if (bottom > estimate || (me.topIndex + me.rowCount >= recordCount && estimate > bottom)) {
                estimate = bottom;

                // estimate all the way down
                if (bottomRow.dataIndex < recordCount - 1) {
                    estimate += (recordCount - 1 - bottomRow.dataIndex) * me.rowOffsetHeight;
                }
            }
        }

        if (estimate != me.estimatedTotalHeight) {
            if (me.trigger('changeTotalHeight', { totalHeight : estimate }) !== false) {
                me.estimatedTotalHeight = estimate;
            }
        }

        return estimate;
    }

    /**
     * Moves a row from bottom to top and renders the corresponding record to it.
     * @returns {Number} New row height
     * @private
     * @category Scrolling & rendering
     */
    displayRecordAtTop() {
        const me           = this,
            recordIndex  = me.topIndex - 1,
            record       = me.store.getAt(recordIndex),
            recordCount  = me.store.count,
            // Row currently rendered at the bottom, the row we want to move
            bottomRow    = me.bottomRow,
            bottomRowTop = bottomRow.top;

        me.trigger('beforeTranslateRow', {
            row       : bottomRow,
            newRecord : record
        });

        // estimated top, for rendering that depends on having top
        bottomRow._top = me.topRow.top - me.rowOffsetHeight;
        bottomRow.estimatedTop = true;

        // Render row
        bottomRow.render(recordIndex, record, false);

        // Move it to top. Restore top so that the setter won't reject non-change
        // if the estimate happened to be correct.
        bottomRow._top = bottomRowTop;
        bottomRow.setBottom(me.topRow.top);
        bottomRow.estimatedTop = false;

        // Prev row is now at top
        me.topIndex--;

        // move to start of array (bottomRow becomes topRow)
        me._rows.unshift(me._rows.pop());

        me.averageRowHeight = (me.averageRowHeight * (recordCount - 1) + bottomRow.offsetHeight) / recordCount;

        return bottomRow.offsetHeight;
    }

    /**
     * Moves a row from top to bottom and renders the corresponding record to it.
     * @returns {Number} New row height
     * @private
     * @category Scrolling & rendering
     */
    displayRecordAtBottom() {
        const me          = this,
            //scrollMode  = me.rowScrollMode,
            recordIndex = me.topIndex + me.rowCount,
            record      = me.store.getAt(recordIndex),
            recordCount = me.store.count,
            // Row currently rendered on the top, the row we want to move
            topRow      = me.topRow;

        // if (scrollMode === 'dom') {
        //     // only for performance evaluation, not to be used
        //
        //     // remove divs
        //     topRow.removeElements();
        //
        //     // add new divs
        //     me.grid.regions.forEach(region => {
        //         let div = me.grid.getSubGrid(region).addNewRowElement();
        //         topRow.addElement(region, div);
        //     });
        // }

        me.trigger('beforeTranslateRow', {
            row       : topRow,
            newRecord : record
        });

        topRow.dataIndex = recordIndex;

        // Move it to bottom
        topRow.setTop(me.bottomRow.bottom);
        // Render row
        topRow.render(recordIndex, record, false);

        // Next row is now at top
        me.topIndex++;

        // move to end of array (topRow becomes bottomRow)
        me._rows.push(me._rows.shift());

        me.averageRowHeight = (me.averageRowHeight * (recordCount - 1) + topRow.offsetHeight) / recordCount;

        return topRow.offsetHeight;
    }

    //endregion
}
RowManager._$name = 'RowManager';

/**
 * @module Grid/util/GridScroller
 */

const xAxis$1 = {
    x : 1
};

/**
 * A Scroller subclass which handles scrolling in a grid.
 *
 * If the grid has no parallel scrolling grids (No locked columns), then this functions
 * transparently as a Scroller.
 *
 * If there are locked columns, then scrolling to an _element_ will invoke the scroller
 * of the subgrid which contains that element.
 * @internal
 */
class GridScroller extends Scroller {
    addScroller(scroller) {
        (this.xScrollers || (this.xScrollers = [])).push(scroller);
    }

    addPartner(otherScroller, axes = xAxis$1) {
        if (typeof axes === 'string') {
            axes = {
                [axes] : 1
            };
        }

        // Link up all our X scrollers
        if (axes.x) {
            
            for (let i = 0; i < this.xScrollers.length; i++) {
                this.xScrollers[i].addPartner(otherScroller.xScrollers[i], 'x');
            }
        }
        // We are the only Y scroller
        if (axes.y) {
            super.addPartner(otherScroller, 'y');
        }
    }

    updateOverflowX(overflowX) {
        this.xScrollers && this.xScrollers.forEach(s => s.overflowX = overflowX);
        this.widget.virtualScrollers.classList[overflowX === false ? 'add' : 'remove']('b-hide-display');
    }

    scrollIntoView(element, options) {
        // If we are after an element, we have to ask the scroller of the SubGrid
        // that the element is in. It will do the X scrolling and delegate the Y
        // scrolling up to this GridScroller.
        if (element.nodeType === 1) {
            for (const subGridScroller of this.xScrollers) {
                if (subGridScroller.element.contains(element)) {
                    return subGridScroller.scrollIntoView(element, options);
                }
            }
        }
        else {
            return super.scrollIntoView(element, options);
        }
    }

    set x(x) {
        if (this.xScrollers) {
            this.xScrollers[0].x = x;
        }
    }

    get x() {
        // when trying to scroll grid with no columns xScrollers do not exist
        return this.xScrollers ? this.xScrollers[0].x : 0;
    }
}
GridScroller._$name = 'GridScroller';

/**
 * @module Grid/view/Header
 */

/**
 * The Grid header, which contains simple columns but also allows grouped columns. One instance is created and used per SubGrid
 * automatically, you should not need to instantiate this class manually. See {@link Grid.column.Column} for information about
 * column configuration.
 *
 * @extends Grid/view/Bar
 * @internal
 *
 * @externalexample grid/Header.js
 */
class Header extends Bar {

    static get $name() {
        return 'Header';
    }

    static get defaultConfig() {
        return {
            isHeader : true
        };
    }

    startConfigure(config) {
        config.scrollable.overflowX = 'hidden-scroll';
        super.startConfigure(config);
    }

    get subGrid() {
        return this._subGrid;
    }

    set subGrid(subGrid) {
        this._subGrid = subGrid;
        this.id = subGrid.id + '-header';
    }

    get region() {
        return this.subGrid && this.subGrid.region;
    }

    template() {
        const me     = this,
            region = me.region;

        return TemplateHelper.tpl`
            <div class="b-grid-header-scroller b-grid-header-scroller-${region}">
                <div reference="headersElement" class="b-grid-headers b-grid-headers-${region}" data-region="${region}" data-max-depth="${me.maxDepth}" reference="headersElement"></div>
            </div>
        `;
    }

    get overflowElement() {
        return this.headersElement;
    }

    /**
     * Header template, recursive template for column headers.
     * Style not included because of CSP. Widths are fixed up in
     * {@link #function-fixHeaderWidths}
     * @private
     */
    contentTemplate(column) {
        const me = this;

        if (column.hidden) {
            return '';
        }
        else {
            /* eslint-disable */
            return TemplateHelper.tpl`
                <div class="b-grid-header" data-column="${column.field || ''}" data-column-id="${column.id}" ${column.isLeaf ? 'tabindex="0"' : ''}>
                    <div class="b-grid-header-text">
                        <div class="b-grid-header-text-content"></div>
                    </div>
                    ${column.children ? `
                    <div class="b-grid-header-children">
                            ${column.children.map(child =>
                            me.contentTemplate(child)
                        ).join('')}
                    </div>
                    ` : ''}
                    <div class="b-grid-header-resize-handle"></div>
                </div>
            `;
            /* eslint-enable */
        }
    }

    // used by safari to fix flex when rows width shrink below this value
    calculateMinWidthForSafari() {
        let minWidth = 0,
            columns  = this.columns.visibleColumns;

        columns.forEach(column => {
            minWidth += column.calculateMinWidth();
        });

        return minWidth;
    }

    /**
     * Fix header widths (flex or fixed width) after rendering. Not a part of template any longer because of CSP
     * @private
     */
    fixHeaderWidths() {
        this.fixCellWidths();
    }

    refreshHeaders() {
        const me = this;

        // run renderers, not done from template to work more like cell rendering
        me.columns.traverse(column => {
            const headerElement = me.getBarCellElement(column.id);

            if (headerElement) {
                const classList = new DomClassList({
                    'b-grid-header'                         : 1,
                    'b-grid-header-parent'                  : column.isParent,
                    [`b-level-${column.childLevel}`]        : 1,
                    [`b-depth-${column.meta.depth}`]        : 1,
                    [`b-grid-header-align-${column.align}`] : column.align,
                    'b-grid-header-resizable'               : column.resizable && column.isLeaf,
                    [column.cls]                            : column.cls,
                    'b-last-parent'                         : column.isParent && column.isLastInSubGrid,
                    'b-last-leaf'                           : column.isLeaf && column.isLastInSubGrid
                });

                let html = column.text;

                headerElement.className = classList;

                if (column.headerRenderer) {
                    html = column.headerRenderer.call(column.thisObj || me, { column, headerElement });
                }

                if (column.icon) {
                    html = `<i class="${column.icon}"></i>` + (html || '');
                }

                const innerEl = headerElement.querySelector('.b-grid-header-text-content');
                if (innerEl) {
                    innerEl.innerHTML = html || '';
                }
            }
        });

        me.fixHeaderWidths();
    }

    get columns() {
        const
            me     = this,
            result = super.columns;

        if (!me.columnsDetacher) {
            // columns is a chained store, it will be repopulated from master when columns change.
            // That action always triggers change with action dataset.
            me.columnsDetacher = result.on({
                change() {
                    me.initDepths();
                },
                thisObj : me
            });

            me.initDepths();
        }

        return result;
    }

    set columns(columns) {
        super.columns = columns;
    }

    /**
     * Depths are used for styling of grouped headers. Sets them on meta.
     * @private
     */
    initDepths(columns = this.columns.topColumns, parent = null) {
        let me       = this,
            maxDepth = 0;

        if (parent && parent.meta) parent.meta.depth++;

        for (let column of columns) {
            // TODO: this should maybe move
            column.meta.depth = 0;

            if (column.children) {
                me.initDepths(column.children.filter(me.columns.chainedFilterFn), column);
                if (column.meta.depth && parent) parent.meta.depth += column.meta.depth;
            }

            if (column.meta.depth > maxDepth) maxDepth = column.meta.depth;
        }

        if (!parent) {
            me.maxDepth = maxDepth;
        }

        return maxDepth;
    }

    //endregion

    //region Getters

    /**
     * Get the header cell element for the specified column.
     * @param {String} columnId Column id
     * @returns {HTMLElement} Header cell element
     */
    getHeader(columnId) {
        return this.getBarCellElement(columnId);
    }

    //endregion

    get contentElement() {
        return this.element.firstElementChild;
    }

    refreshContent() {
        const me = this;

        me.content = me.columns.topColumns.map(col => me.contentTemplate(col)).join('');

        me.refreshHeaders();
    }

    onPaint({ firstPaint }) {
        if (firstPaint) {
            this.refreshContent();
        }
    }
}
Header._$name = 'Header';

// We declare consts inside case blocks in this file.

const domEventHandlers = {
    touchstart  : 'onElementTouchStart',
    touchmove   : 'onElementTouchMove',
    touchend    : 'onElementTouchEnd',
    mouseover   : 'onElementMouseOver',
    mouseout    : 'onElementMouseOut',
    mousedown   : 'onElementMouseDown',
    mousemove   : 'onElementMouseMove',
    mouseup     : 'onElementMouseUp',
    click       : 'onHandleElementClick',
    dblclick    : 'onElementDblClick',
    keydown     : 'onElementKeyDown',
    keyup       : 'onElementKeyUp',
    keypress    : 'onElementKeyPress',
    contextmenu : 'onElementContextMenu',
    focus       : 'onGridElementFocus'
};

/**
 * @module Grid/view/mixin/GridElementEvents
 */

/**
 * Mixin for Grid that handles dom events. Some listeners fire own events but all can be chained by features. None of
 * the functions in this class are indented to be called directly.
 *
 * @mixin
 */
var GridElementEvents = Target => class GridElementEvents extends (Target || Base) {
    //region Config

    static get defaultConfig() {
        return {
            /**
             * Time in ms until a longpress is triggered
             * @config {Number}
             * @default
             * @category Events
             */
            longPressTime : 400
        };
    }

    //endregion

    //region Events

    /**
     * User clicked in a grid cell
     * @event cellClick
     * @param {Grid.view.Grid} grid
     * @param {Core.data.Model} record
     * @param {Grid.column.Column} column
     * @param {Object} cellSelector
     * @param {HTMLElement} cellElement
     * @param {HTMLElement} target
     * @param {Event} event
     */

    /**
     * User double clicked in a grid cell
     * @event cellDblClick
     * @param {Grid.view.Grid} grid
     * @param {Core.data.Model} record
     * @param {Grid.column.Column} column
     * @param {Object} cellSelector
     * @param {HTMLElement} cellElement
     * @param {HTMLElement} target
     * @param {Event} event
     */

    /**
     * User activated contextmenu in a grid cell
     * @event cellContextMenu
     * @param {Grid.view.Grid} grid
     * @param {Core.data.Model} record
     * @param {Grid.column.Column} column
     * @param {Object} cellSelector
     * @param {HTMLElement} cellElement
     * @param {HTMLElement} target
     * @param {Event} event
     */

    /**
     * User moved moused to a grid cell
     * @event cellMouseOver
     * @param {Grid.view.Grid} grid
     * @param {Core.data.Model} record
     * @param {Grid.column.Column} column
     * @param {Object} cellSelector
     * @param {HTMLElement} cellElement
     * @param {HTMLElement} target
     * @param {Event} event
     */

    /**
     * User moved moused out of a grid cell
     * @event cellMouseOut
     * @param {Grid.view.Grid} grid
     * @param {Core.data.Model} record
     * @param {Grid.column.Column} column
     * @param {Object} cellSelector
     * @param {HTMLElement} cellElement
     * @param {HTMLElement} target
     * @param {Event} event
     */

    //endregion

    //region Event handling

    /**
     * Init listeners for a bunch of dom events. All events are handled by handleEvent().
     * @private
     * @category Events
     */
    initInternalEvents() {
        const handledEvents = Object.keys(domEventHandlers),
            len           = handledEvents.length,
            listeners     = {
                element : this.element,
                thisObj : this
            };

        // Route all events through handleEvent, so that we can capture this.event
        // before we route to the handlers
        for (let i = 0; i < len; i++) {
            listeners[handledEvents[i]] = 'handleEvent';
        }

        EventHelper.on(listeners);
    }

    /**
     * This method find the cell location of the passed event. It returns an object describing the cell.
     * @param {Event} event A Mouse, Pointer or Touch event targeted at part of the grid.
     * @returns {Object} An object containing the following properties:
     * - `cellElement` - The cell element clicked on.
     * - `columnId` - The `id` of the column clicked under.
     * - `record` - The {@link Core.data.Model record} clicked on.
     * - `id` - The `id` of the {@link Core.data.Model record} clicked on.
     * @private
     * @category Events
     */
    getEventData(event) {
        const
            me          = this,
            cellElement = DomHelper.up(event.target, '.b-grid-cell');

        // There is a cell
        if (cellElement) {
            const
                cellData         = DomDataStore.get(cellElement),
                { id, columnId } = cellData,
                record           = me.store.getById(id);

            // Row might not have a record, since we transition record removal
            // https://app.assembla.com/spaces/bryntum/tickets/6805
            return record ? {
                cellElement,
                cellData,
                columnId,
                id,
                record,
                cellSelector : { id, columnId }
            } : null;
        }
    }

    /**
     * Handles all dom events, routing them to correct functions (touchstart -> onElementTouchStart)
     * @param event
     * @private
     * @category Events
     */
    handleEvent(event) {
        if (!this.disabled) {

            this.event = event;

            if (domEventHandlers[event.type]) {
                this[domEventHandlers[event.type]](event);
            }
        }
    }

    //endregion

    //region Touch events

    /**
     * Touch start, chain this function in features to handle the event.
     * @param event
     * @category Touch events
     * @internal
     */
    onElementTouchStart(event) {
        const me = this;

        DomHelper.isTouchEvent = true;

        if (event.touches.length === 1) {
            me.longPressTimeout = setTimeout(() => {
                me.onElementLongPress(event);
                event.preventDefault();
                me.longPressPerformed = true;
            }, me.longPressTime);
        }
    }

    /**
     * Touch move, chain this function in features to handle the event.
     * @param event
     * @category Touch events
     * @internal
     */
    onElementTouchMove(event) {
        if (this.longPressTimeout) {
            clearTimeout(this.longPressTimeout);
            this.longPressTimeout = null;
        }
    }

    /**
     * Touch end, chain this function in features to handle the event.
     * @param event
     * @category Touch events
     * @internal
     */
    onElementTouchEnd(event) {
        const me = this;

        if (me.longPressPerformed) {
            if (event.cancelable) {
                event.preventDefault();
            }
            me.longPressPerformed = false;
        }

        if (me.longPressTimeout) {
            clearTimeout(me.longPressTimeout);
            me.longPressTimeout = null;
        }
    }

    onElementLongPress(event) {}

    //endregion

    //region Mouse events

    // Trigger events in same style when clicking, dblclicking and for contextmenu
    triggerCellMouseEvent(name, event) {
        const me       = this,
            cellData = me.getEventData(event);

        // There is a cell
        if (cellData) {
            const column = me.columns.getById(cellData.columnId);

            me.trigger('cell' + StringHelper.capitalizeFirstLetter(name), {
                grid         : this,
                record       : cellData.record,
                column,
                cellSelector : cellData.cellSelector,
                cellElement  : cellData.cellElement,
                target       : event.target,
                event
            });
        }
    }

    /**
     * Mouse down, chain this function in features to handle the event.
     * @param event
     * @category Mouse events
     * @internal
     */
    onElementMouseDown(event) {
        const me       = this,
            cellData = me.getEventData(event);

        me.skipFocusSelection = true;

        me.triggerCellMouseEvent('mousedown', event);

        // Browser event unification fires a mousedown on touch tap prior to focus.
        if (cellData && !event.defaultPrevented) {
            me.onFocusGesture(cellData, event);
        }
    }

    /**
     * Mouse move, chain this function in features to handle the event.
     * @param event
     * @category Mouse events
     * @internal
     */
    onElementMouseMove(event) {
        // Keep track of the last mouse position in case, due to OSX sloppy focusing,
        // focus is moved into the browser before a mousedown is delivered.
        // The cached mousemove event will provide the correct target in
        // GridNavigation#onGridElementFocus.
        this.mouseMoveEvent = event;
    }

    /**
     * Mouse up, chain this function in features to handle the event.
     * @param event
     * @category Mouse events
     * @internal
     */
    onElementMouseUp(event) {}

    /**
     * Called before {@link #function-onElementClick}.
     * Fires 'beforeElementClick' event which can return false to cancel further onElementClick actions.
     * @param event
     * @fires beforeElementClick
     * @category Mouse events
     * @internal
     */

    onHandleElementClick(event) {
        if (this.trigger('beforeElementClick', { event }) !== false) {
            this.onElementClick(event);
        }
    }

    /**
     * Click, select cell on click and also fire 'cellClick' event.
     * Chain this function in features to handle the dom event.
     * @param event
     * @fires cellClick
     * @category Mouse events
     * @internal
     */
    onElementClick(event) {
        const me       = this,
            cellData = me.getEventData(event);

        // There is a cell
        if (cellData) {
            me.triggerCellMouseEvent('click', event);

            // Clear hover styling when clicking in a row to avoid having it stick around if you keyboard navigate
            // away from it
            // https://app.assembla.com/spaces/bryntum/tickets/5848
            DomDataStore.get(cellData.cellElement).row.removeCls('b-hover');
        }
    }

    onFocusGesture(cellData, event) {
        //TODO: should be able to cancel focusCell from listeners
        if (cellData) {
            this.focusCell(cellData.cellSelector, {
                scroll   : false,
                doSelect : true,
                event
            });
        }
    }

    /**
     * Double click, fires 'cellDblClick' event.
     * Chain this function in features to handle the dom event.
     * @param {Event} event
     * @fires cellDblClick
     * @category Mouse events
     * @internal
     */
    onElementDblClick(event) {
        const me          = this,
            target      = event.target;

        me.triggerCellMouseEvent('dblClick', event);

        if (target.classList.contains('b-grid-header-resize-handle')) {
            const header = DomHelper.up(target, '.b-grid-header'),
                column = me.columns.getById(header.dataset.columnId);

            column.resizeToFitContent();
        }
    }

    /**
     * Mouse over, adds 'hover' class to elements.
     * @param event
     * @fires mouseOver
     * @category Mouse events
     * @internal
     */
    onElementMouseOver(event) {
        // bail out early if scrolling
        if (!this.scrolling) {
            const cellElement = DomHelper.up(event.target, '.b-grid-cell');

            if (cellElement) {
                const row = DomDataStore.get(cellElement).row;

                // No hover effect needed if a mouse button is pressed (like when resizing window, region, or resizing something etc).
                // NOTE: 'buttons' not supported in Safari
                if (row && (typeof event.buttons !== 'number' || event.buttons === 0)) {
                    this.hoveredRow = row;
                }

                this.triggerCellMouseEvent('mouseOver', event);
            }

            /**
             * Mouse moved in over element in grid
             * @event mouseOver
             * @param {Event} event
             */
            this.trigger('mouseOver', { event });
        }
    }

    /**
     * Mouse out, removes 'hover' class from elements.
     * @param event
     * @fires mouseOut
     * @category Mouse events
     * @internal
     */
    onElementMouseOut(event) {
        this.hoveredRow = null;

        // bail out early if scrolling
        if (!this.scrolling) {
            const cellElement = DomHelper.up(event.target, '.b-grid-cell');

            if (cellElement) {
                this.triggerCellMouseEvent('mouseOut', event);
            }

            /**
             * Mouse moved out from element in grid
             * @event mouseOut
             * @param {Event} event
             */
            this.trigger('mouseOut', { event });
        }
    }

    set hoveredRow(row) {
        const me = this;

        // Unhover
        if (me._hoveredRow && !me._hoveredRow.isDestroyed) {
            me._hoveredRow.removeCls('b-hover');
            me._hoveredRow = null;
        }

        // Hover
        if (row && !me.scrolling) {
            me._hoveredRow = row;
            row.addCls('b-hover');
        }
    }

    //endregion

    //region Keyboard events

    /**
     * Key down, handles arrow keys for selection.
     * Chain this function in features to handle the dom event.
     * @param event
     * @category Keyboard events
     * @internal
     */
    onElementKeyDown(event) {
        const me          = this;

        // flagging event with handled = true used to signal that other features should probably not care about it.
        // for this to work you should specify overrides for onElementKeyDown to be run before this function
        // (see for example CellEdit feature)
        if (event.handled) return;

        if (event.target.matches('.b-grid-header.b-depth-0')) {
            me.handleHeaderKeyDown(event);
        }
        else if (event.target === this.element || (BrowserHelper.isIE11 && event.currentTarget === this.element)) {
            // IE11 Browser check is not placed in EventHelper to maintain built-in delegated functionality
            me.handleViewKeyDown(event);
        }
        // If focus is *within* a cell (eg WidgetColumn or CheckColumn), jump up to focus the cell.
        else if (event.key === 'Escape' && me.isActionableLocation) {
            const focusedCell = ObjectHelper.clone(me.focusedCell);
            focusedCell.element = null;
            me.focusCell(focusedCell);
            DomHelper.focusWithoutScrolling(me.element);
        }
    }

    handleViewKeyDown(event) {
        const me = this;

        switch (event.key) {
            case 'ArrowLeft':
                event.preventDefault();
                return me.navigateLeft(event);
            case 'ArrowRight':
                event.preventDefault();
                return me.navigateRight(event);
            case 'ArrowUp':
                event.preventDefault();
                return me.navigateUp(event);
            case 'ArrowDown':
                event.preventDefault();
                return me.navigateDown(event);
        }
    }

    handleHeaderKeyDown(event) {
        const me = this,
            column = me.columns.getById(event.target.dataset.columnId);

        column.onKeyDown && column.onKeyDown(event);
        switch (event.key) {
            case 'ArrowLeft':
                const prev = me.columns.getAdjacentVisibleLeafColumn(column, false);

                if (prev) {
                    const element = me.getHeaderElement(prev.id);
                    element.focus();
                }

                break;

            case 'ArrowRight':
                const next = me.columns.getAdjacentVisibleLeafColumn(column, true);

                if (next) {
                    const element = me.getHeaderElement(next.id);
                    element.focus();
                }

                break;

            case 'Enter':
                const element = me.getHeaderElement(column.id);

                element.click();
                break;
        }
    }

    /**
     * Key press, chain this function in features to handle the dom event.
     * @param event
     * @category Keyboard events
     * @internal
     */
    onElementKeyPress(event) {}

    /**
     * Key up, chain this function in features to handle the dom event.
     * @param event
     * @category Keyboard events
     * @internal
     */
    onElementKeyUp(event) {}

    //endregion

    //region Other events

    /**
     * Context menu, chain this function in features to handle the dom event.
     * In most cases, include ContextMenu feature instead.
     * @param event
     * @category Other events
     * @internal
     */
    onElementContextMenu(event) {
        const me       = this,
            cellData = me.getEventData(event);

        // There is a cell
        if (cellData) {
            me.triggerCellMouseEvent('contextMenu', event);

            // Focus on tap for touch events.
            // Selection follows from focus.
            if (DomHelper.isTouchEvent) {
                me.onFocusGesture(cellData, event);
            }
        }
    }

    /**
     * Overrides empty base function in View, called when view is resized.
     * @fires resize
     * @param element
     * @param width
     * @param height
     * @param oldWidth
     * @param oldHeight
     * @category Other events
     * @internal
     */
    onInternalResize(element, width, height, oldWidth, oldHeight) {
        const me = this;

        if (me._devicePixelRatio && me._devicePixelRatio !== window.devicePixelRatio) {
            // Pixel ratio changed, likely because of browser zoom. This affects the relative scrollbar width also
            DomHelper.resetScrollBarWidth();
        }

        me._devicePixelRatio = window.devicePixelRatio;
        // cache to avoid recalculations in the middle of rendering code (RowManger#getRecordCoords())
        me._bodyRectangle = Rectangle.client(me.bodyContainer);

        super.onInternalResize(...arguments);

        if (height !== oldHeight) {
            me._bodyHeight = me.bodyContainer.offsetHeight;
            if (me.isPainted) {
                // initial height will be set from render(),
                // it reaches onInternalResize too early when rendering, headers/footers are not sized yet
                me.rowManager.initWithHeight(me._bodyHeight);
            }
        }
        me.refreshVirtualScrollbars();

        if (width !== oldWidth) {
            // Slightly delay to avoid resize loops.
            me.setTimeout(() => {
                if (!me.isDestroyed) {
                    me.updateResponsive(width, oldWidth);
                }
            }, 0);
        }
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

/**
 * @module Grid/view/mixin/GridFeatures
 */

let validConfigTypes = {
    string   : 1,
    object   : 1,
    function : 1 // used by CellTooltip
};

/**
 * Mixin for Grid that handles features. Features are plugins that add functionality to the grid. Feature classes should
 * register with Grid by calling {@link Grid.feature.GridFeatureManager#function-registerFeature-static registerFeature}. This
 * enables features to be specified and configured in grid
 * config.
 *
 * Define which features to use:
 *
 * ```javascript
 * // specify which features to use (note that some features are used by default)
 * const grid = new Grid({
 *   features: {
 *      sort: 'name',
 *      search: true
 *   }
 * });
 * ```
 *
 * Access a feature in use:
 *
 * ```javascript
 * grid.features.search.search('cat');
 * ```
 *
 * Basic example of implementing a feature:
 *
 * ```javascript
 * class MyFeature extends InstancePlugin {
 *
 * }
 *
 * GridFeatures.registerFeature(MyFeature);
 *
 * // using the feature
 * const grid = new Grid({
 *   features: {
 *     myFeature: true
 *   }
 * });
 * ```
 *
 * @mixin
 */
var GridFeatures = Target => class GridFeatures extends (Target || Base) {
    //region Init

    /**
     * Specify which features to use on the grid. Most features accepts a boolean, some also accepts a config object.
     * Please note that if you are not using the bundles you might need to import the features you want to use.
     *
     * ```javascript
     * const grid = new Grid({
     *     features : {
     *         stripe : true,   // Enable stripe feature
     *         sort   : 'name', // Configure sort feature
     *         group  : false   // Disable group feature
     *     }
     * }
     * ```
     *
     * @config {Object} features
     * @category Common
     */

    /**
     * Map of the features available on the grid. Use it to access them on your grid object
     *
     * ```javascript
     * grid.features.group.expandAll();
     * ```
     *
     * @readonly
     * @property {Object}
     * @category Common
     * @typings any
     */
    set features(features) {
        const me              = this,
            defaultFeatures = GridFeatureManager.getInstanceDefaultFeatures(this);

        features = me._features = ObjectHelper.assign({}, features);

        // default features, enabled unless otherwise specified
        if (defaultFeatures) {
            Object.entries(defaultFeatures).forEach(([as, featureClass]) => {
                if (!(as in features)) {
                    features[as] = true;
                }
            });
        }

        // We *prime* the features so that if any configuration code accesses a feature, it
        // will self initialize, but if not, they will remain in a primed state until afterConfigure.
        let featureName, config,
            featureClass;

        const registeredInstanceFeatures = GridFeatureManager.getInstanceFeatures(this);

        for (featureName of Object.keys(features)) {
            config = features[featureName];

            // Create feature initialization property if config is truthy.
            // Config must be a valid configuration value for the feature class.
            if (config) {
                // Feature configs name must start with lowercase letter to be valid
                if (StringHelper.lowercaseFirstLetter(featureName) !== featureName) {
                    throw new Error(me.L('invalidFeatureNameFormat', featureName));
                }

                featureClass = registeredInstanceFeatures[featureName];

                if (!featureClass) {
                    throw new Error(me.L('featureNotFound', featureName));
                }

                // Create a self initializing property on the features object named by the feature name.
                // when accessed, it will create and return the real feature.
                // Now, if some Feature initiualization code attempt to access a feature which has not yet been initialized
                // it will be initialized just in time.
                Reflect.defineProperty(features, featureName, me.createFeatureInitializer(features, featureName, featureClass, config));
            }
        }
    }

    get features() {
        return this._features;
    }

    createFeatureInitializer(features, featureName, featureClass, config) {
        const constructorArgs = [this],
            construct = featureClass.prototype.construct;

        // Only pass config if there is one.
        // The constructor(config = {}) only works for undefined config
        if (validConfigTypes[typeof config]) {
            constructorArgs[1] = config;
        }

        return {
            configurable : true,
            get() {
                // Delete this defined property and replace it with the Feature instance.
                delete features[featureName];

                // Ensure the feature is injected into the features object before initialization
                // so that it is available from call chains from its initialization.
                featureClass.prototype.construct = function(...args) {
                    features[featureName] = this;
                    construct.apply(this, args);
                    featureClass.prototype.construct = construct;
                };

                // Return the Feature instance
                return new featureClass(...constructorArgs);
            }
        };
    }

    //endregion

    //region Other stuff

    /**
     * Check if a feature is included
     * @param {String} name Feature name, as registered with `GridFeatureManager.registerFeature()`
     * @returns {Boolean}
     * @category Misc
     */
    hasFeature(name) {
        return !!(this.features && this.features[name]);
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

/**
 * @module Grid/view/mixin/GridNavigation
 */

const
    defaultFocusOptions = Object.freeze({
        doSelect : true
    }),
    disableScrolling = Object.freeze({
        x : false,
        y : false
    });

/**
 * Mixin for Grid that handles cell to cell navigation.
 *
 * @mixin
 */
var GridNavigation = Target => class GridNavigation extends (Target || Base) {
    //region Cell

    /**
     * User navigated to a grid cell
     * @event navigate
     * @param {Grid.view.Grid} grid
     * @param {Object} last focused location
     * @param {Object} location focus moved to
     * @param {Event} [event] The UI event which caused navigation.
     */

    /**
     * Cell selector for focused cell, set to focus a cell or use {@link #function-focusCell}.
     * @property {Object}
     */
    get focusedCell() {
        const result = this._focusedCell;

        if (result && this.getCell(result)) {
            return result;
        }
        this.clearFocus();
    }

    /**
     * This property is `true` if an element _within_ a cell is focused.
     * @property {Boolean}
     * @readonly
     */
    get isActionableLocation() {
        const focusedCell = this._focusedCell;
        return Boolean(focusedCell && focusedCell.element && this.getCell(focusedCell).contains(focusedCell.element));
    }

    set focusedCell(cellSelector) {
        this.focusCell(cellSelector, {
            doSelect : false
        });
    }

    get focusedRecord() {
        if (this._focusedCell) {
            return this.store.getById(this._focusedCell.id);
        }
    }

    /**
     * CSS selector for currently focused cell. Format is "[data-index=index] [data-column-id=columnId]".
     * @property {String}
     * @readonly
     */
    get cellCSSSelector() {
        const me   = this,
            cell = me._focusedCell,
            row  = cell && me.getRowById(cell.id);

        if (!cell || !row) return '';

        return `[data-index=${row.index}] [data-column-id=${cell.columnId}]`;
    }

    /**
     * Grid element focus, selects first row and cell when grid is focused if none is selected (otherwise user cannot
     * see that grid is focused).
     * Chain this function it features to handle the dom event.
     * @param event
     * @category Other events
     * @internal
     */
    onGridElementFocus(event) {
        // Select first row if none is selected when grid is focused (to show that it has focus)
        const me = this,
            focusOptions = {
                doSelect : false,
                event
            };

        if (me._focusedCell) {
            me.focusCell(me._focusedCell, focusOptions);
        }
        else {
            // If they just clicked in blank space, do not refocus the last focused cell.
            // We focus cell 0, 0 on that gesture.
            const targetContext = me.element.contains(event.relatedTarget) ? null : me.lastFocusedCell;

            if (targetContext) {
                const cell = me.getCell(targetContext);

                // If we're using lastFocusedCell and the cell is no longer in existence, or not visible
                // or the previously focused record has since been removed.
                // Fallback to reverting to where focus entered the grid from.
                // TODO: CellContext should store the record index
                // to fall back to if the actual record is no longer present.
                if (!cell || !DomHelper.isVisible(cell) || !me.store.getById(targetContext.id)) {
                    me.revertFocus();
                    return;
                }

                // flag to not affect selection
                me.returningFocus = true;
                me.focusCell(targetContext, focusOptions);
                me.returningFocus = false;
            }
            else if (!me.scrolling && !me.skipFocusSelection && me.store.first) {
                const
                    {
                        mouseMoveEvent : evt,
                        rowManager     : rm,
                        _bodyRectangle : r
                    }            = me,
                    focusY       = evt ? Math.min(Math.max(evt.clientY, r.y), r.bottom) : r.center.y,
                    defaultRow   = rm.getRowAt(focusY) || rm.rows[Math.floor(rm.rowCount / 2)],
                    focusContext = evt && me.getEventData(evt) || {
                        id       : defaultRow.id,
                        columnId : me.columns.visibleColumns[0].id
                    };

                if (me.getCell(focusContext)) {
                    me.focusCell(focusContext, focusOptions);
                }
            }
        }
        me.skipFocusSelection = false;
    }

    onFocusOut(event) {
        super.onFocusOut(event);

        this.clearFocus();
    }

    /**
     * Checks whether or not a cell is focused.
     * @param {Object|string|Number} cellSelector Cell selector { id: x, columnId: xx } or row id
     * @returns {Boolean} true if cell or row is focused, otherwise false
     */
    isFocused(cellSelector) {
        return Boolean(this._focusedCell) && this.isLocationEqual(cellSelector, this._focusedCell);
    }

    /**
     * Navigates to a cell and/or its row (depending on selectionMode)
     * @param {Object} cellSelector { id: rowId, columnId: 'columnId' }
     * @param {Object} options Modifier options for how to deal with focusing the cell. These
     * are used as the {@link Core.helper.util.Scroller#function-scrollTo} options.
     * @param {Boolean} [options.doSelect=true] Optionally pass `false` to not continue to selection.
     * @param {Event} [options.event] Optionally pass the UI event which instigated the focus request.
     * @param {Object|boolean} [options.scroll=true] Pass `false` to not scroll the cell into view, or a
     * scroll options object to affact the scroll.
     * @returns {Object} Cell selector
     * @fires navigate
     */
    focusCell(cellSelector, options = defaultFocusOptions) {
        // If we're being passed a context object (as opposed to a record), clone in case we were
        // passed the _focusedCell, and after refresh isLocationEqual needs to detect a difference.
        cellSelector = this.normalizeCellContext(cellSelector === Object ? Object.assign({}, cellSelector) : cellSelector);

        const
            me              = this,
            doSelect        = options.doSelect !== false,
            {
                event,
                scroll
            }              = options,
            lastFocusedCell = me.lastFocusedCell = me._focusedCell,
            isNotMove       = me.isLocationEqual(cellSelector, lastFocusedCell),
            lastCell        = lastFocusedCell && me.getCell(lastFocusedCell),
            subGrid         = me.getSubGridFromColumn(cellSelector.columnId);

        let cell = me.getCell(cellSelector);

        // If we're focusing due to a mousedown on a focusable element *within* a cell
        // then we do not "navigate" to the cell - we allow the element to be focused.
        // For example a CheckColumn or WidgetColumn.
        if (event && event.type === 'mousedown') {
            for (let target = event.target; target !== cell; target = target.parentElement) {
                if (DomHelper.isFocusable(target)) {
                    cellSelector.element = target;
                    return;
                }
            }
        }

        // No navigation takes place, but the selection still needs to know if a UI event happened.
        if (isNotMove) {
            if (event) {
                me.onCellNavigate && me.onCellNavigate(me, null, me._focusedCell, event, doSelect);
            }
            return cellSelector;
        }

        if (lastCell) {
            lastCell.classList.remove('b-focused');
        }
    
        const
            testCell    = cell || me.getCell({
                row      : me.rowManager.topIndex,
                columnId : cellSelector.columnId
            }),
            subGridRect = Rectangle.from(subGrid.element),
            bodyRect    = Rectangle.from(me.bodyContainer),
            cellRect    = Rectangle.from(testCell).moveTo(null, subGridRect.y);

        if (scroll === false) {
            options = Object.assign({}, options, disableScrolling);
        }
        else {
            options = Object.assign({}, options, scroll);

            // If the test cell is larger than the subGrid, in any dumension, disable scrolling
            if (cellRect.width > subGridRect.width || cellRect.height > bodyRect.height) {
                options.x = options.y = false;
            }
            // Else ask for the column to be scrolled into view
            else {
                options.column = cellSelector.columnId;
            }

            me.scrollRowIntoView(cellSelector.id, options);
        }

        // Get the newly visible cell *after* it has been scrolled into view.
        // With buffered rendering, it may not have existed before the scroll.
        cell = me.getCell(cellSelector);
        if (cell) {
            cellSelector.element = cell;
            cell.classList.add('b-focused');
        }

        //Remember
        me._focusedCell = cellSelector;

        me.onCellNavigate && me.onCellNavigate(me, lastFocusedCell, me._focusedCell, event, doSelect);

        me.trigger('navigate', { lastFocusedCell, focusedCell : me._focusedCell, event });
        //TODO: should be able to cancel selectcell from listeners

        return cellSelector;
    }

    isLocationEqual(cellSelector, otherCellSelector) {
        return (
            cellSelector && otherCellSelector &&
            cellSelector.id === otherCellSelector.id &&
            cellSelector.columnId === otherCellSelector.columnId &&
            // Normalized cellSelectors are not required to have an element, only compare elements if both selectors
            // have it specified
            (
                !cellSelector.element ||
                !otherCellSelector.element ||
                cellSelector.element === otherCellSelector.element
            )
        );
    }

    blurCell(cellSelector) {
        const me   = this,
            cell = me.getCell(cellSelector);

        if (cell) {
            cell.classList.remove('b-focused');
        }
    }

    clearFocus() {
        const me = this;

        if (me._focusedCell) {
            // set last to have focus return to previous cell when alt tabbing
            me.lastFocusedCell = me._focusedCell;

            me.blurCell(me._focusedCell);
            me._focusedCell = null;
        }
    }

    /**
     * Selects the cell before or after currently focused cell.
     * @private
     * @param next Specify true to select the next cell, false to select the previous
     * @param {Event} [event] Optionally, the UI event which caused navigation.
     * @returns {Object} Used cell selector
     */
    internalNextPrevCell(next = true, event) {
        const
            me           = this,
            cellSelector = me._focusedCell;

        if (cellSelector) {
            return me.focusCell({
                id       : cellSelector.id,
                columnId : me.columns.getAdjacentVisibleLeafColumn(cellSelector.columnId, next, true).id
            }, {
                doSelect : true,
                event
            });
        }
        return null;
    }

    /**
     * Select the cell after the currently focused one.
     * @param {Event} [event] Optionally, the UI event which caused navigation.
     * @returns {Object} Cell selector
     */
    navigateRight(event) {
        return this.internalNextPrevCell(true, event);
    }

    /**
     * Select the cell before the currently focused one.
     * @param {Event} [event] Optionally, the UI event which caused navigation.
     * @returns {Object} Cell selector
     */
    navigateLeft(event) {
        return this.internalNextPrevCell(false, event);
    }

    //endregion

    //region Row

    /**
     * Selects the next or previous record in relation to the current selection. Scrolls into view if outside.
     * @private
     * @param next Next record (true) or previous (false)
     * @param {Boolean} skipSpecialRows True to not return specialRows like headers
     * @param {Event} [event] Optionally, the UI event which caused navigation.
     * @returns {Object|Boolean} Selection context for the focused row (& cell) or false if no selection was made
     */
    internalNextPrevRow(next, skipSpecialRows = true, event) {
        const me = this,
            cell = me._focusedCell;

        if (!cell) return false;

        const record = me.store[`get${next ? 'Next' : 'Prev'}`](cell.id, false, skipSpecialRows);

        if (!record) return false;

        return me.focusCell({
            id       : record.id,
            columnId : cell.columnId,
            scroll   : {
                x : false
            }
        }, {
            doSelect : true,
            event
        });
    }

    /**
     * Navigates to the cell below the currently focused cell
     * @param {Event} [event] Optionally, the UI event which caused navigation.
     * @returns {Object} Selector for focused row (& cell)
     */
    navigateDown(event) {
        return this.internalNextPrevRow(true, false, event);
    }

    /**
     * Navigates to the cell above the currently focused cell
     * @param {Event} [event] Optionally, the UI event which caused navigation.
     * @returns {Object} Selector for focused row (& cell)
     */
    navigateUp(event) {
        return this.internalNextPrevRow(false, false, event);
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

/**
 * @module Grid/view/mixin/GridResponsive
 */

/**
 * Simplifies making grid responsive. Supply levels as {@link #config-responsiveLevels} config, default levels are:
 * <dl>
 * <dt>small <dd>< 400px,
 * <dt>medium <dd>< 600px
 * <dt>large <dd>> 600px
 * </dl>
 *
 * Columns can define configs per level to be resized etc:
 *
 * ```
 * let grid = new Grid({
 *   responsiveLevels: {
 *     small: 300,
 *     medium: 400,
 *     large: '*' // everything above 400
 *   },
 *
 *   columns: [
 *     {
 *       field: 'name',
 *       text: 'Name',
 *       responsiveLevels: {
 *         small: { hidden: true },
 *         '*': { hidden: false } // all other levels
 *       }
 *     },
 *     { field: 'xx', ... }
 *   ]
 * });
 * ```
 *
 * It is also possible to give a [Grid state](#Grid/view/mixin/GridState) object instead of a level width, but in that
 * case the object must contain a `levelWidth` property:
 *
 * ```
 * let grid = new Grid({
 *   responsiveLevels: {
 *     small: {
 *       // Width is required
 *       levelWidth : 400,
 *       // Other configs are optional, see GridState for available options
 *       rowHeight  : 30
 *     },
 *     medium : {
 *       levelWidth : 600,
 *       rowHeight  : 40
 *     },
 *     large: {
 *       levelWidth : '*', // everything above 300
 *       rowHeight  : 45
 *     }
 *   }
 * });
 * ```
 *
 * @demo Grid/responsive
 * @externalexample grid/Responsive.js
 * @mixin
 */
var GridResponsive = Target => class GridResponsive extends (Target || Base) {
    static get defaultConfig() {
        return {
            /**
             * "Break points" for which responsive config to use for columns and css.
             * @config {Object}
             * @category Misc
             * @default <code>{ small : 400, medium : 600, large : '*' }</code>
             */
            responsiveLevels : Object.freeze({
                small  : 400,
                medium : 600,
                large  : '*'
            })
        };
    }

    /**
     * Find closes bigger level, aka level we want to use.
     * @private
     * @category Misc
     */
    getClosestBiggerLevel(width) {
        let me           = this,
            levels       = Object.keys(me.responsiveLevels),
            useLevel     = null,
            minDelta     = 99995,
            biggestLevel = null;

        levels.forEach(level => {
            let levelSize = me.responsiveLevels[level];

            // responsiveLevels can contains config objects, in which case we should use width from it
            if (!['number', 'string'].includes(typeof levelSize)) {
                
                levelSize = levelSize.levelWidth;
            }

            if (levelSize === '*') {
                biggestLevel = level;
            }
            else if (width < levelSize) {
                const delta = levelSize - width;
                if (delta < minDelta) {
                    minDelta = delta;
                    useLevel = level;
                }
            }
        });

        return useLevel || biggestLevel;
    }

    /**
     * Get currently used responsive level (as string)
     * @returns {String}
     * @readonly
     * @category Misc
     */
    get responsiveLevel() {
        return this.getClosestBiggerLevel(this.width);
    }

    /**
     * Check if resize lead to a new responsive level and take appropriate actions
     * @private
     * @fires responsive
     * @param width
     * @param oldWidth
     * @category Misc
     */
    updateResponsive(width, oldWidth) {
        const me       = this,
            oldLevel = me.getClosestBiggerLevel(oldWidth),
            level    = me.getClosestBiggerLevel(width);

        if (oldLevel !== level) {
            // Level might be a state object
            const levelConfig = me.responsiveLevels[level];
            if (!['number', 'string'].includes(typeof levelConfig)) {
                me.applyState(levelConfig);
            }

            // check columns for responsive config
            me.columns.forEach(column => {
                const levels = column.responsiveLevels;
                if (levels) {
                    if (levels[level]) {
                        // using state to apply responsive config, since it already does what we want...
                        column.applyState(levels[level]);
                    }
                    else if (levels['*']) {
                        column.applyState(levels['*']);
                    }
                }
            });

            me.element.classList.remove('b-responsive-' + oldLevel);
            me.element.classList.add('b-responsive-' + level);

            /**
             * Grid resize lead to a new responsive level being applied
             * @event responsive
             * @param {Grid.view.Grid} grid Grid that was resized
             * @param {String} level New responsive level (small, large, etc)
             * @param {Number} width New width in px
             * @param {String} oldLevel Old responsive level
             * @param {Number} oldWidth Old width in px
             */
            me.trigger('responsive', { level, width, oldLevel, oldWidth });
        }
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

const
    validIdTypes = {
        string : 1,
        number : 1
    },
    isSelectAction = {
        dataset : 1,
        batch   : 1
    };

/**
 * @module Grid/view/mixin/GridSelection
 */

/**
 * A mixin for Grid that handles row and cell selection. See {@link #config-selectionMode} for details on how to control what should be selected (rows or cells)
 *
 * @example
 * // select a row
 * grid.selectedRow = 7;
 *
 * // select a cell
 * grid.selectedCell = { id: 5, columnId: 'column1' }
 *
 * // select a record
 * grid.selectedRecord = grid.store.last;
 *
 * // select multiple records by ids
 * grid.selectedRecords = [1, 2, 4, 6]
 *
 * @mixin
 */
var GridSelection = Target => class GridSelection extends (Target || Base) {
    static get defaultConfig() {
        return {
            /**
             * The selection settings, where you can set these boolean flags to control what is selected. Options below:
             * @config {Object} selectionMode
             * @param {Boolean} selectionMode.row select rows
             * @param {Boolean} selectionMode.cell select cells
             * @param {Boolean} selectionMode.rowCheckboxSelection select rows only when clicking in the checkbox column
             * @param {Boolean} selectionMode.multiSelect Allow multiple selection
             * @param {Boolean} selectionMode.checkbox true to add a checkbox selection column to the grid
             * @param {Boolean} selectionMode.showCheckAll  true to add a checkbox to the selection column header to select/delselect all rows
             * @default
             * @category Selection
             */
            selectionMode : {
                row                  : true,
                cell                 : true,
                rowCheckboxSelection : false,
                multiSelect          : true,
                checkbox             : false,
                showCheckAll         : false
            },

            selectedRecordCollection : {}
        };
    }

    //region Init

    afterConfigure() {
        const me = this;

        // Inject our CheckColumn into the ColumnStore
        if (me.selectionMode.checkbox) {
            const checkColumnClass = ColumnStore.getColumnClass('check');

            if (!checkColumnClass) {
                throw new Error('CheckColumn must be imported for checkbox selection mode to work');
            }

            const col = me.checkboxColumn = new checkColumnClass({
                id           : `${me.id}-selection-column`,
                width        : '4em',
                minWidth     : '4em', // Misaligned on IE11 without, since 4em is below columns default minWidth
                field        : null,
                cellCls      : 'b-checkbox-selection',
                // Always put the checkcolumn in the first region
                region       : Object.keys(me.subGridConfigs).sort()[0],
                showCheckAll : me.selectionMode.showCheckAll
            }, me.columns);

            col.meta.depth = 0;
            // This is assigned in Column.js for normal columns
            col._grid      = me;

            // Override renderer to inject the rendered record's selected status into the value
            const checkboxRenderer = col.renderer;
            col.renderer           = renderData => {
                renderData.value = me.isSelected(renderData.record);
                checkboxRenderer.call(col, renderData);
            };

            col.on({
                toggle    : 'onCheckChange',
                toggleAll : 'onCheckAllChange',
                thisObj   : me
            });

            // Insert the checkbox after any rownumber column. If not there, -1 means in at 0.
            const insertIndex = me.columns.indexOf(me.columns.findRecord('type', 'rownumber')) + 1;

            me.columns.insert(insertIndex, col);
        }
        super.afterConfigure();

        me.store.on('idChange', me.onRecordIdChange, me);
    }

    //endregion

    //region Events

    onRecordIdChange({ record, oldValue, value }) {
        const { selectedRecordCollection } = this,
            item = selectedRecordCollection.get(oldValue);

        // having the record registered by the oldValue means we need to rebuild indices
        if (item === record) {
            selectedRecordCollection.rebuildIndices();
        }
    }

    /**
     * The selection has been changed.
     * @event selectionchange
     * @param {String} action `'select'`/`'deselect'`
     * @param {String} mode `'row'`/`'cell'`
     * @param {Grid.view.Grid} source
     * @param {Core.data.Model[]|Object} deselected The records or cells (depending on the `mode`) deselected in this operation.
     * @param {Core.data.Model[]|Object} selected The records or cells (depending on the `mode`) selected in this operation.
     * @param {Core.data.Model[]|Object} selection  The records or cells (depending on the `mode`) in the new selection.
     */

    /**
     * Responds to mutations of the underlying storage Collection
     * @param {Object} event
     * @private
     */
    onSelectedRecordCollectionChange({ source : selectedRecordCollection, action, added = [], removed }) {
        const me = this;

        if (me._selectedCell && !me.isSelectable(me._selectedCell)) {
            me.deselectCell(me._selectedCell);
        }

        // Filter out unselectable rows
        added = added.filter(row => me.isSelectable(row));

        me.triggerChangeEvent({
            mode       : 'row',
            action     : added.length ? 'select' : 'deselect',
            selection  : me.selectedRecords,
            selected   : added,
            deselected : removed
        }, me.silent);
    }

    onCheckChange({ source : column, checked, record }) {
        if (checked) {
            this.selectRow({
                record,
                column,
                addToSelection : this.selectionMode.multiSelect !== false,
                scrollIntoView : false
            });

            if (column.headerCheckbox && this.selectedRecords.length === this.store.count - (this.store.groupRecords ? this.store.groupRecords.length : 0)) {
                column.suspendEvents();
                column.headerCheckbox.checked = true;
                column.resumeEvents();
            }
        }
        else {
            this.deselectRow(record);

            if (column.headerCheckbox) {
                column.suspendEvents();
                column.headerCheckbox.checked = false;
                column.resumeEvents();
            }
        }
    }

    onCheckAllChange({ checked }) {
        this[checked ? 'selectAll' : 'deselectAll']();
    }

    onElementKeyDown(event) {
        const me = this,
            { focusedCell, checkboxColumn } = me;

        super.onElementKeyDown(event);

        // SPACE key on our CheckColumn toggles it
        if (focusedCell && event.key === ' ' && checkboxColumn && me.columns.getById(focusedCell.columnId) === checkboxColumn) {
            const checkbox = me.getCell(focusedCell).widget;

            if (checkbox) {
                checkbox.toggle();
            }
        }
    }

    //endregion

    //region Selection collection

    set selectedRecordCollection(selectedRecordCollection) {
        if (!(selectedRecordCollection instanceof Collection)) {
            selectedRecordCollection = new Collection(selectedRecordCollection);
        }
        this._selectedRecordCollection = selectedRecordCollection;

        // Fire row change events from onSelectedRecordCollectionChange
        selectedRecordCollection.on({
            change  : 'onSelectedRecordCollectionChange',
            thisObj : this
        });
    }

    get selectedRecordCollection() {
        return this._selectedRecordCollection;
    }

    /**
     * Removes and adds records to/from the selection at the same time. Analogous
     * to the `Array` `splice` method.
     *
     * Note that if items that are specified for removal are also in the `toAdd` array,
     * then those items are *not* removed then appended. They remain in the same position
     * relative to all remaining items.
     *
     * @param {Number} index Index at which to remove a block of items. Only valid if the
     * second, `toRemove` argument is a number.
     * @param {Object[]|Number} toRemove Either the number of items to remove starting
     * at the passed `index`, or an array of items to remove (If an array is passed, the `index` is ignored).
     * @param  {Object[]|Object} toAdd An item, or an array of items to add.
     */
    spliceSelectedRecords(index, toRemove, toAdd) {
        this._selectedRecordCollection.splice(index, toRemove, toAdd);
    }

    //endregion

    //region Cell & row

    /**
     * Checks whether or not a cell or row is selected.
     * @param {Object|string|Number|Core.data.Model} cellSelectorOrId Cell selector { id: x, column: xx } or row id, or record
     * @returns {Boolean} true if cell or row is selected, otherwise false
     * @category Selection
     */
    isSelected(cellSelectorOrId) {
        const me = this;

        // A record passed
        if (cellSelectorOrId instanceof Model) {
            cellSelectorOrId = cellSelectorOrId.id;
        }

        if (validIdTypes[typeof cellSelectorOrId]) {
            return me.selectedRecordCollection.includes(cellSelectorOrId);
        }
        else {
            return me._selectedCell && me._selectedCell.id == cellSelectorOrId.id &&
                me._selectedCell.columnId === cellSelectorOrId.columnId;
        }
    }

    /**
     * Checks whether or not a cell or row can be selected.
     * @param recordCellOrId Record or cell or record id
     * @returns {Boolean} true if cell or row cane be selected, otherwise false
     * @category Selection
     */
    isSelectable(recordCellOrId) {
        // Selection disabled for undefined record, special row (group header / footer) and
        // record which was already removed from store

        if (!recordCellOrId) {
            return false;
        }
        const row = this.store.getById(recordCellOrId.id || recordCellOrId);
        return row && !(row.meta && row.meta.specialRow);
    }

    /**
     * Cell selector for selected cell, set to select a cell or use {@link #function-selectCell()}.
     * @property {Object}
     * @category Selection
     */
    get selectedCell() {
        return this._selectedCell;
    }

    set selectedCell(cellSelector) {
        this.selectCell(cellSelector);
    }

    set selectionMode(mode) {
        if (mode && mode.rowCheckboxSelection) {
            mode.row = mode.checkbox = true;
            mode.cell = false;
        }

        this._selectionMode = mode;
    }

    get selectionMode() {
        return this._selectionMode;
    }

    /**
     * The last selected record. Set to select a row or use Grid#selectRow. Set to null to
     * deselect all
     * @property {Core.data.Model}
     * @category Selection
     */
    get selectedRecord() {
        return this.selectedRecordCollection.last || null;
    }

    set selectedRecord(record) {
        this.selectRow({ record });
    }

    /**
     * Selected records.
     * Can be set as array of ids.
     * ```
     * grid.selectedRecords = [1, 2, 4, 6]
     * ```
     *
     * @property {Core.data.Model[]|Number[]}
     * @category Selection
     */
    get selectedRecords() {
        return this.selectedRecordCollection.values;
    }

    set selectedRecords(selectedRecords) {
        const { selectedRecordCollection, store } = this,
            toSelect                    = [];

        if (selectedRecords) {
            for (let record of selectedRecords) {
                record = store.getById(record);
                if (record) {
                    toSelect.push(record);
                }
            }
        }

        // Replace the entire selected collection with the new record set
        selectedRecordCollection.splice(0, selectedRecordCollection.count, toSelect);
    }

    /**
     * CSS selector for the currently selected cell. Format is "[data-index=index] [data-column-id=column]".
     * @type {String}
     * @category Selection
     * @readonly
     */
    get selectedCellCSSSelector() {
        const me   = this,
            cell = me._selectedCell,
            row  = cell && me.getRowById(cell.id);

        if (!cell || !row) return '';

        return `[data-index=${row.dataIndex}] [data-column-id=${cell.columnId}]`;
    }

    /**
     * Selects a row (without selecting a cell).
     * @param {Object} options
     * @param (Core.data.Model|String) options.record Record or record id, specifying null will deselect all
     * @param {Column} [Grid.column.Column|String] The column to scroll into view if `scrollIntoView` is not specified as `false`. Defaults to the grid's first column.
     * @param {Boolean} [options.scrollIntoView] Specify `false` to prevent row from being scrolled into view
     * @param {Boolean} [options.addToSelection] Specify `true` to add to selection, defaults to `false` which replaces
     * @fires selectionchange
     * @category Selection
     */
    selectRow({
        record,
        column = this.columns.bottomColumns[0],
        scrollIntoView = true,
        addToSelection = false
    }) {
        // TODO: Remove this backward compatibility code in 3.0
        if (typeof arguments[0] !== 'object') {
            const args = arguments;

            record = args[0];
            scrollIntoView = args.length > 1 ? args[1] : true;
            addToSelection = args[2] || false;
        }
        const me = this,
            targetRecord = me.store.getById(record);

        if (record) {
            me.selectCell({ id : targetRecord.id, column }, scrollIntoView, addToSelection);
        }
        else {
            me.deselectAll();
        }
    }

    /**
     * Selects a cell and/or its row (depending on selectionMode)
     * @param {Object} cellSelector { id: rowId, columnId: 'columnId' }
     * @param {Boolean} scrollIntoView Specify false to prevent row from being scrolled into view
     * @param {Boolean} addToSelection Specify `true` to add to selection, defaults to `false` which replaces
     * @param {Boolean} silent Specify `true` to not trigger any events when selecting the cell
     * @returns {Object} Cell selector
     * @fires selectionchange
     * @category Selection
     */
    selectCell(cellSelector, scrollIntoView = false, addToSelection = false, silent = false) {
        const
            me                                  = this,
            { selectedRecordCollection, selectionMode } = me,
            selector                            = me.normalizeCellContext(cellSelector),
            record                              = selector.record || me.store.getById(selector.id);

        // Clear selection if row is not selectable
        if (!me.isSelectable(record)) {
            this.deselectAll();
            return;
        }

        if (scrollIntoView) {
            me.scrollRowIntoView(selector.id, {
                column : selector.columnId
            });
        }

        // Row selection (both sides if locked columns)
        if (selectionMode.row) {
            if (silent) {
                me.silent = (me.silent || 0) + 1;
            }
            if (addToSelection) {
                selectedRecordCollection.add(record);
            }
            // Clear all others
            else {
                selectedRecordCollection.splice(0, selectedRecordCollection.count, record);
            }
            if (silent) {
                me.silent--;
            }

            // When starting a selection, register the start cell
            if (me.selectedRecordCollection.count === 1) {
                me.startCell = selector;
                me.lastRange = null;
            }
        }

        // Cell selection
        if (selectionMode.cell && (selector.columnId || selector.column) && !me.isSelected(selector)) {
            const deselected = (me._selectedCell) ? [me._selectedCell] : [];

            //Remember
            me._selectedCell = selector;

            me.triggerChangeEvent({
                mode      : 'cell',
                action    : 'select',
                selected  : [selector],
                deselected,
                selection : [selector]
            }, silent);
        }

        return selector;
    }

    /**
     * Selects all rows
     * @category Selection
     */
    selectAll() {
        this.selectedRecords = this.store.getRange().filter(r => !r.meta.specialRow);
    }

    /**
     * Deselects all selected rows and cells
     * @category Selection
     */
    deselectAll() {
        const me = this;
        me.selectedRecordCollection.clear();

        if (me._selectedCell) {
            me.deselectCell(me._selectedCell);
        }
    }

    /**
     * Deselect a row
     * @param {Core.data.Model|String|Number} recordOrId Record or an id for a record
     * @category Selection
     */
    deselectRow(recordOrId) {
        const record = recordOrId instanceof Model ? recordOrId : this.store.getById(recordOrId);
        record && this.selectedRecordCollection.remove(record);
    }

    /**
     * Deselect a cell/row, depending on settings in Grid#selectionMode
     * @param {Object} cellSelector
     * @returns {Object} Normalized cell selector
     * @category Selection
     */
    deselectCell(cellSelector) {
        const me           = this,
            selector     = me.normalizeCellContext(cellSelector),
            selMode      = me.selectionMode,
            record       = selector.record || me.store.getById(selector.id),
            selectedCell = me._selectedCell;

        // Row selection (both sides if locked columns)
        if (selMode.row) {
            me.selectedRecordCollection.remove(record);
        }

        // Cell selection
        if (selMode.cell && selector.columnId && selectedCell) {
            if (selectedCell.id === selector.id && selectedCell.columnId === selector.columnId) {
                me._selectedCell = null;

                me.triggerChangeEvent({
                    mode       : 'cell',
                    action     : 'deselect',
                    selected   : [],
                    deselected : [selector],
                    selection  : []
                });
            }
        }

        return selector;
    }

    //endregion

    //region Record

    /**
     * Selects rows corresponding to a range of records (from fromId to toId)
     * @param {String|Number} fromId
     * @param {String|Number} toId
     * @category Selection
     */
    selectRange(fromId, toId) {
        const
            { store, selectedRecordCollection } = this,
            fromIndex                   = store.indexOf(fromId),
            toIndex                     = store.indexOf(toId),
            startIndex                  = Math.min(fromIndex, toIndex),
            endIndex                    = Math.max(fromIndex, toIndex);

        if (startIndex === -1 || endIndex === -1) {
            throw new Error('Record not found in selectRange');
        }

        selectedRecordCollection.splice(0, selectedRecordCollection.count, store.getRange(startIndex, endIndex + 1, false));
    }

    /**
     * Triggered from Grid view when records get removed from the store.
     * Deselects all records which have been removed.
     * @private
     * @category Selection
     */
    onStoreRemove(event) {
        // If the next mixin up the inheritance chain has an implementation, call it
        super.onStoreRemove && super.onStoreRemove(event);

        this.selectedRecordCollection.remove(event.records);
    }

    /**
     * Triggered from Grid view when the store changes. This might happen
     * if store events are batched and then resumed.
     * Deselects all records which have been removed.
     * @private
     * @category Selection
     */
    onStoreDataChange({ action, source : store }) {
        // If the next mixin up the inheritance chain has an implementation, call it
        super.onStoreDataChange && super.onStoreDataChange(...arguments);

        if (isSelectAction[action]) {
            const selectedRecords = this.selectedRecordCollection,
                toRemove = [];

            selectedRecords.forEach(record => {
                if (!store.includes(record)) {
                    toRemove.push(record);
                }
            });

            // Remove in one go to fire a single selectionChange event
            selectedRecords.remove(toRemove);
        }
    }

    /**
     * Triggered from Grid view when all records get removed from the store.
     * Deselects all records.
     * @private
     * @category Selection
     */
    onStoreRemoveAll() {
        // If the next mixin up the inheritance chain has an implementation, call it
        super.onStoreRemoveAll && super.onStoreRemoveAll();

        this.deselectAll();
    }

    //endregion

    //region Handle multiSelect

    /**
     * Handles multi selection using the mouse. Called from GridElementEvents on mousedown in a cell and
     * simultaneously pressing a modifier key.
     * @param cellData
     * @param event
     * @private
     * @category Selection
     */
    handleMouseMultiSelect(cellData, event) {
        const me = this,
            id = cellData.id;

        function mergeRange(fromId, toId) {
            const
                { store, selectedRecordCollection } = me,
                fromIndex                   = store.indexOf(fromId),
                toIndex                     = store.indexOf(toId),
                startIndex                  = Math.min(fromIndex, toIndex),
                endIndex                    = Math.max(fromIndex, toIndex);

            if (startIndex === -1 || endIndex === -1) {
                throw new Error('Record not found in selectRange');
            }

            const newRange = store.getRange(startIndex, endIndex + 1, false).filter(row => me.isSelectable(row));
            selectedRecordCollection.splice(0, me.lastRange || 0, newRange);
            me.lastRange = newRange;
        }

        if ((event.metaKey || event.ctrlKey) && me.isSelected(id)) {
            // ctrl/cmd deselects row if selected
            me.deselectRow(id);
        }
        else if (me.selectionMode.multiSelect) {
            if (event.shiftKey && me.startCell) {
                // shift appends selected range (if we have previously focused cell)
                mergeRange(me.startCell.id, id);
            }
            else if (event.ctrlKey || event.metaKey) {
                // ctrl/cmd adds to selection if using multiselect (and not selected)
                me.selectRow({
                    record         : id,
                    scrollIntoView : false,
                    addToSelection : true
                });
            }
        }
    }

    //endregion

    //region Navigation

    /**
     * Triggered from GridNavigation when focus is moved to another cell within the grid. Selects the cell unless
     * modifier keys are pressed, in which case it has already been handled
     * @private
     * @category Selection
     */
    onCellNavigate(me, fromCellSelector, toCellSelector, event, doSelect = true) {
        // CheckColumn events are handled by the CheckColumn itself.
        if (me.columns.getById(toCellSelector.columnId) === me.checkboxColumn || me.selectionMode.rowCheckboxSelection) {
            return;
        }

        // 1.do not affect selection if focus is returning to the grid from some widget
        // 2. don't select when clicking expander icon in a tree
        if (!doSelect || me.returningFocus || (event && event.target.classList.contains('b-tree-expander'))) {
            return;
        }

        const
            isSameRecord = fromCellSelector && toCellSelector.id === fromCellSelector.id,
            isMouse = event && event.type === 'mousedown',
            isMouseCtrl  = isMouse && event.ctrlKey;

        // SHIFT for keyboard / mouse and CTRL for mouse events indicate multiselect
        if (event && (!event.button || event.button === 2) && (event.shiftKey || isMouseCtrl)) {
            me.handleMouseMultiSelect(toCellSelector, event);
        }
        else {
            me.selectCell(toCellSelector, false, (isSameRecord && (!event || event.shiftKey || event.ctrlKey)) ||
                (event && (isMouseCtrl || (event.button === 2 && me.isSelected(toCellSelector.id)))));
        }

        // Remember last cell with ctrl pressed
        if (!me.startCell || isMouseCtrl) {
            me.startCell = toCellSelector;
            me.lastRange = null;
        }

    }

    /**
     * Keeps the UI synced with the selectionchange event before firing it out.
     * Event is not fired if the `silent` parameter is truthy.
     * @param {Object} selectionChangeEvent The change event to sync the UI to, and to possibly fire.
     * @param {Boolean} silent Specify `true` to not trigger any the passed.
     * @private
     * @category Selection
     */
    triggerChangeEvent(selectionChangeEvent, silent) {
        const me = this,
            {
                mode,
                selected,
                deselected
            }  = selectionChangeEvent;

        let i, len, row, cell;

        // Keep the UI up to date with the triggered changes.
        // A mode: 'row' change selects and/or deselects records.
        if (mode === 'row') {
            for (i = 0, len = selected.length; i < len; i++) {
                row = me.getRowFor(selected[i]);
                if (row) {
                    row.addCls('b-selected');
                    if (me.checkboxColumn && !me.checkboxColumn.hidden && !selected[i].meta.specialRow) {
                        row.getCell(me.checkboxColumn.id).widget.checked = true;
                    }
                }
            }
            for (i = 0, len = deselected.length; i < len; i++) {
                row = me.getRowFor(deselected[i]);
                if (row) {
                    row.removeCls('b-selected');
                    if (me.checkboxColumn && !me.checkboxColumn.hidden && !deselected[i].meta.specialRow) {
                        row.getCell(me.checkboxColumn.id).widget.checked = false;
                    }
                }
            }
        }
        // A mode: 'cell' change selects and/or deselects *one* cell right now.
        // But we always use an array for future-proofing.
        else if (mode === 'cell') {
            for (i = 0, len = selected.length; i < len; i++) {
                cell = me.getCell(selected[i]);
                if (cell) {
                    cell.classList.add('b-selected');
                }
            }
            for (i = 0, len = deselected.length; i < len; i++) {
                cell = me.getCell(deselected[i]);
                if (cell) {
                    cell.classList.remove('b-selected');
                }
            }
        }

        if (!silent) {
            me.trigger('selectionChange', selectionChangeEvent);
        }
    }

    //endregion

    //region Getters/setters

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}

    //endregion

};

// TODO: prevent multiple rerenders

/**
 * @module Grid/view/mixin/GridState
 */
const
    suspendStoreEvents = subGrid => subGrid.columns.suspendEvents(),
    resumeStoreEvents = subGrid => subGrid.columns.resumeEvents(),
    fillSubGridColumns = subGrid => {
        subGrid.columns.clearCaches();
        subGrid.columns.fillFromMaster();
    },
    compareStateSortIndex = (a, b) => a.stateSortIndex - b.stateSortIndex;

/**
 * Mixin for Grid that handles state. It serializes the following grid properties:
 *
 * * rowHeight
 * * readOnly
 * * selectedCell
 * * selectedRecords
 * * columns (order, widths, visibility)
 * * store (sorters, groupers, filters)
 * * scroll position
 *
 * See {@link Core.mixin.State} for more information on state.
 *
 * @demo Grid/state
 * @externalexample grid/State.js
 * @mixin
 */
var GridState = Target => class GridState extends (Target || Base) {
    /**
     * Get grids current state for serialization. State includes rowHeight, headerHeight, readOnly, selectedCell,
     * selectedRecordId, column states and store state.
     * @returns {Object} State object to be serialized
     * @private
     */
    getState() {
        const
            me    = this,
            style = me.element.style.cssText,
            state = {
                rowHeight : me.rowHeight,
                readOnly  : me.readOnly
            };

        if (style) {
            state.style = style;
        }

        if (me.selectedCell) {
            // TODO: Create wrapper class to avoid JSON.stringify recursion in state.selectedCell.
            const { id, columnId } = me.selectedCell;
            state.selectedCell = { id, columnId };
        }

        state.selectedRecords = me.selectedRecords.map(entry => entry.id);
        state.columns = me.columns.map(column => column.getState());
        state.store = me.store.state;
        state.scroll = me.storeScroll();
        state.width = {};
        state.collapsed = {};
        me.eachSubGrid(subGrid => {
            if (subGrid.flex == null) {
                state.width[subGrid.region] = subGrid.width;
            }

            state.collapsed[subGrid.region] = subGrid.collapsed;
        });

        return state;
    }

    /**
     * Apply previously stored state.
     * @param {Object} state
     * @private
     */
    applyState(state) {
        const me = this;
        if ('readOnly' in state) {
            me.readOnly = state.readOnly;
        }

        if ('rowHeight' in state) {
            me.rowHeight = state.rowHeight;
        }

        if ('style' in state) {
            me.style = state.style;
        }

        if ('selectedCell' in state) {
            me.selectedCell = state.selectedCell;
        }

        if ('store' in state) {
            me.store.state = state.store;
        }

        if ('selectedRecords' in state) {
            me.selectedRecords = state.selectedRecords;
        }

        if ('columns' in state) {
            let columnsChanged = false,
                needSort = false;

            // We're going to renderContents anyway, so stop the ColumnStores from updating the UI
            me.columns.suspendEvents();
            me.eachSubGrid(suspendStoreEvents);

            // each column triggers rerender at least once...
            state.columns.forEach((columnState, index) => {
                const column = me.columns.getById(columnState.id);

                if (column) {
                    const columnGeneration = column.generation;

                    column.applyState(columnState);
                    columnsChanged = columnsChanged || (column.generation !== columnGeneration);

                    // In case a sort is needed, stamp in the ordinal position.
                    column.stateSortIndex = index;

                    // If we find one out of order, only then do we need to sort
                    if (column.allIndex !== index) {
                        needSort = columnsChanged = true;
                    }
                }
            });

            if (columnsChanged) {
                me.eachSubGrid(fillSubGridColumns);
            }
            if (needSort) {
                me.eachSubGrid(subGrid => {
                    subGrid.columns.records.sort(compareStateSortIndex);
                    subGrid.columns.allRecords.sort(compareStateSortIndex);
                });
                me.columns.sort({
                    fn : compareStateSortIndex
                // always sort ascending
                }, true);
            }

            // If we have been painted, and column restoration changed the column layout, refresh contents
            if (me.isPainted && columnsChanged) {
                me.renderContents();
            }

            // Allow ColumnStores to update the UI again
            me.columns.resumeEvents();
            me.eachSubGrid(resumeStoreEvents);
        }

        if ('width' in state) {
            me.eachSubGrid(subGrid => {
                if (subGrid.region in state.width) {
                    subGrid.width = state.width[subGrid.region];
                }
            });
        }

        if ('collapsed' in state) {
            me.eachSubGrid(subGrid => {
                subGrid.collapsed = state.collapsed[subGrid.region];
            });
        }

        if ('scroll' in state) {
            me.restoreScroll(state.scroll);
        }
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {
    }
};

/**
 * @module Grid/util/SubGridScroller
 */

const immediatePromise$4 = new Promise((resolve) => resolve()),
    defaultScrollOptions$1 = {
        block : 'nearest'
    };

/**
 * A Scroller subclass which handles scrolling in a SubGrid. Needs special treatment since the SubGrid itself only
 * allows horizontal scrolling, while the vertical scrolling is done by an outer element containing all subgrids.
 *
 * @internal
 */
class SubGridScroller extends Scroller {
    scrollIntoView(element, options = defaultScrollOptions$1) {
        const me = this,
            { xDelta, yDelta } = me.getDeltaTo(element, options),
            result = (xDelta || yDelta) ? me.scrollBy(xDelta, yDelta, options) : immediatePromise$4;

        if (options.highlight || options.focus) {
            result.then(() => {
                if (options.highlight) {
                    if (element instanceof Rectangle) {
                        element.translate(-xDelta, -yDelta).highlight();
                    }
                    else {
                        DomHelper.highlight(element);
                    }
                }
                options.focus && element.focus && element.focus();
            });
        }
        return result;
    }

    scrollBy(xDelta, yDelta, options) {
        const yPromise = yDelta && this.yScroller.scrollBy(0, yDelta, options),
            xPromise = xDelta && super.scrollBy(xDelta, 0, options);

        if (xPromise && xPromise.cancel && yPromise && yPromise.cancel) {
            const cancelX = xPromise.cancel,
                cancelY = yPromise.cancel;

            // Set up cross canceling
            xPromise.cancel = yPromise.cancel = () => {
                cancelX();
                cancelY();
            };
            return Promise.all([xPromise, yPromise]);
        }

        return xPromise || yPromise;
    }

    scrollTo(toX, toY, options) {
        const
            yPromise = (toY != null) && this.yScroller.scrollTo(null, toY, options),
            xPromise = (toX != null) && super.scrollTo(toX, null, options);

        // Keep parters in sync immediately unless we are going to animate our position.
        // There are potentially three: The header, the footer and the docked fake horizontal scroller.
        // It will be more efficient and maintain correct state doing it now.
        if (!(options && options.animate)) {
            this.syncPartners();
        }
        
        if (xPromise && xPromise.cancel && yPromise && yPromise.cancel) {
            const cancelX = xPromise.cancel,
                cancelY = yPromise.cancel;

            // Set up cross canceling
            xPromise.cancel = yPromise.cancel = () => {
                cancelX();
                cancelY();
            };
            return Promise.all([xPromise, yPromise]);
        }

        return xPromise || yPromise;
    }

    get viewport() {
        return Rectangle.from(this.element).intersect(Rectangle.from(this.yScroller.element));
    }

    set y(y) {
        if (this.yScroller) {
            this.yScroller.y = y;
        }
    }

    get y() {
        return this.yScroller ? this.yScroller.y : 0;
    }

    get maxY() {
        return this.yScroller ? this.yScroller.maxY : 0;
    }

    get scrollHeight() {
        return this.yScroller ? this.yScroller.scrollHeight : 0;
    }

    get clientHeight() {
        return this.yScroller ? this.yScroller.clientHeight : 0;
    }
}
SubGridScroller._$name = 'SubGridScroller';

/**
 * @module Grid/view/SubGrid
 */

/**
 * A SubGrid is a part of the grid (it has at least one and normally no more than two, called locked and normal). It
 * has its own header, which holds the columns to display rows for in the SubGrid. SubGrids are created by Grid, you
 * should not need to create instances directly.
 *
 * If not configured with a width or flex, the SubGrid will be sized to fit its columns. In this case, if all columns
 * have a fixed width (not using flex) then toggling columns will also affect the width of the SubGrid.
 *
 * @extends Core/widget/Widget
 */
class SubGrid extends Widget {
    //region Config

    static get $name() {
        return 'SubGrid';
    }

    /**
     * Region (name) for this SubGrid
     * @config {String} region
     */

    /**
     * Column store, a store containing the columns for this SubGrid
     * @config {Grid.data.ColumnStore} columns
     */

    static get defaultConfig() {
        return {
            localizableProperties : ['emptyText'],
            localeClass           : 'Grid',

            insertRowsBefore : null,
            appendTo         : null,
            hideHeaders      : null,
            monitorResize    : true,

            /**
             * Set `true` to start subgrid collapsed. To operate collapsed state on subgrid use
             * {@link #function-collapse}/{@link #function-expand} methods.
             * @config {Boolean}
             * @default false
             */
            collapsed : null,

            scrollable : {
                // Each SubGrid only handles scrolling in the X axis.
                // The owning Grid handles the Y axis.
                overflowX : true
            },

            scrollerClass : SubGridScroller,

            // Will be set to true by GridSubGrids if it calculates the subgrids width based on its columns.
            // Used to determine if hiding a column should affect subgrids width
            hasCalculatedWidth : null,

            /**
             * Set `true` to disable moving columns into or out of this SubGrid.
             * @config {Boolean}
             * @default false
             * @private
             */
            sealedColumns : null,

            emptyText : null
        };
    }

    //endregion

    //region Init

    /**
     * SubGrid constructor
     * @param config
     * @private
     */
    construct(config) {
        const me = this;

        super.construct(config);

        me.initHeader();

        me.rowManager.on('addrows', me.onAddRow, me);
    }

    doDestroy() {
        const me = this;

        me.header && me.header.destroy();
        me.footer && me.footer.destroy();
        me.fakeScroller && me.fakeScroller.destroy();

        me.virtualScrollerElement && me.virtualScrollerElement.remove();
        me.splitterElement && me.splitterElement.remove();

        super.doDestroy();
    }

    /**
     * Creates a header for the SubGrid
     * @private
     */
    initHeader() {
        const
            me      = this,
            sgStyle = me.element.style,
            sgWidth = sgStyle.width,
            sgFlex  = sgStyle.flex,
            config  = Object.assign({
                subGrid : me,
                hidden  : me.hideHeaders,
                parent  : me  // Contained widgets need to know their parents
            }, me.headerConfig);

        // If we have been configured with sizing, construct the Bar in sync.
        if (sgFlex) {
            config.flex = sgFlex;
        }
        else if (sgWidth) {
            config.width = sgWidth;
        }

        me.header = new me.headerClass(config);
    }

    /**
     * Initializes elements for the SubGrid and its header and footer (if any)
     * @private
     */
    initElements() {
        const me = this;

        me.footerElement = DomHelper.down(me.grid.element, '.b-grid-footer-scroller-' + me.region);

        me.updateHasFlex();
    }

    //endregion

    //region Template

    template() {
        const
            { grid, region } = this,
            isLastSubGrid    = !grid || region === grid.regions[grid.regions.length - 1];

        // The virtual scroller element in the template below will be moved to the virtual scroller container in grid on
        // render. It is defined as part of the SubGrid template to get references for free

        // Same applies to the splitter. Except for the last SubGrid, it does not have a splitter

        return TemplateHelper.tpl`
            <div class="b-grid-subgrid b-grid-subgrid-${region} b-grid-horizontal-scroller ${this.collapsed ? 'b-grid-subgrid-collapsed' : ''}" data-region="${region}">
                <div reference="virtualScrollerElement" class="b-virtual-scroller" data-region="${region}">
                    <div reference="virtualScrollerWidth" class="b-virtual-width"></div>
                </div>
                ${isLastSubGrid ? '' : TemplateHelper.tpl`
                <div reference="splitterElement" data-region="${region}" class="b-grid-splitter ${this.collapsed ? 'b-grid-splitter-collapsed' : ''}">
                    <div class="b-grid-splitter-inner">
                        <div class="b-grid-splitter-buttons" reference="splitterButtons">
                            <i class="b-icon b-icon-collapse-gridregion"></i>
                            <i class="b-icon b-icon-expand-gridregion"></i>
                        </div>
                    </div>
                </div>`}
            </div>
        `;
    }

    rowTemplate() {
        return `<div class="b-grid-row">${this.columns.visibleColumns.map(this.cellTemplate).join('')}</div>`;
    }

    cellTemplate(column) {
        return `<div class="b-grid-cell" data-column="${column.field || ''}" data-column-id="${column.id}"></div>`;
    }

    //endregion

    //region Render

    render() {
        const
            me               = this,
            { grid, region } = me,
            children         = [{
                className : 'b-grid-splitter-inner'
            }],
            dataset          = {
                region
            };

        // Unit tests create naked SubGrids so we have to do this.
        if (grid) {
            // Move virtual scroller & splitter to grids container for them
            grid.virtualScrollers.appendChild(me.virtualScrollerElement);

            me.renderHeader(grid.headerContainer);
            me.renderFooter(grid.footerContainer);

            me.initElements();
        }

        super.render(...arguments);

        // Splitters go after their owning elements
        if (me.splitterElement) {
            const className = me.splitterElement.className.trim();

            me.element.parentNode.insertBefore(me.splitterElement, me.element.nextElementSibling);

            // The three potential parallel zones also have splitters
            if (me.header) {
                me.headerSplitter = DomHelper.createElement({
                    className,
                    children,
                    dataset,
                    parent      : me.header.element.parentNode,
                    nextSibling : me.header.element.nextSibling
                });

                EventHelper.on({
                    element    : me.headerSplitter,
                    mouseenter : 'onSplitterMouseOver',
                    mouseleave : 'onSplitterMouseOut',
                    thisObj    : me
                });
            }
            if (me.footer) {
                me.footerSplitter = DomHelper.createElement({
                    className,
                    children,
                    dataset,
                    parent      : me.footer.element.parentNode,
                    nextSibling : me.footer.element.nextSibling
                });

                EventHelper.on({
                    element    : me.footerSplitter,
                    mouseenter : 'onSplitterMouseOver',
                    mouseleave : 'onSplitterMouseOut',
                    thisObj    : me
                });
            }
            me.scrollerSplitter = DomHelper.createElement({
                className,
                children,
                dataset,
                parent      : me.virtualScrollerElement.parentNode,
                nextSibling : me.virtualScrollerElement.nextSibling
            });

            EventHelper.on({
                element    : me.splitterElement,
                mouseenter : 'onSplitterMouseOver',
                mouseleave : 'onSplitterMouseOut',
                thisObj    : me
            });
        }

        me._collapsed && me.collapse();
    }

    renderHeader(appendToElement) {
        if (this.header) {
            this.header.render(appendToElement, false);
        }
    }

    renderFooter(appendToElement) {
        if (this.footer) {
            this.footer.render(appendToElement, false);
            // footerContainer starts hidden, since it is not used by default. make sure it is visible here
            this.grid.footerContainer.classList.remove('b-hidden');
        }
    }

    refreshHeader() {
        this.header.refreshContent();
    }

    refreshFooter() {
        this.footer && this.footer.refreshContent();
    }

    // Override to iterate header and footer.
    eachWidget(fn, deep = true) {
        const
            me      = this,
            widgets = [];

        if (me.header) {
            widgets.unshift(me.header);
        }
        if (me.footer) {
            widgets.push(me.footer);
        }

        for (let i = 0; i < widgets.length; i++) {
            const widget = widgets[i];

            if (fn(widget) === false) {
                return;
            }

            if (deep && widget.eachWidget) {
                widget.eachWidget(fn, deep);
            }
        }
    }

    //endregion

    //region Size & resize

    /**
     * Sets cell widths. Cannot be done in template because of CSP
     * @private
     */
    fixCellWidths(rowElement, visibleColumns = null) {
        if (!visibleColumns) visibleColumns = this.columns.bottomColumns.filter(col => !col.hidden);

        // fix cell widths, no longer allowed in template because of CSP
        let cellElement = rowElement.firstElementChild,
            i           = 0;

        while (cellElement) {
            const column = visibleColumns[i];

            if (column.minWidth) {
                DomHelper.setLength(cellElement, 'minWidth', column.minWidth);
            }

            // either flex or width, flex has precedence
            if (column.flex) {
                cellElement.style.flex = column.flex;
                cellElement.style.width = '';
            }
            else if (column.width) {
                // https://app.assembla.com/spaces/bryntum/tickets/8041
                // Although header and footer elements must be sized
                // using flex-basis to avoid the busting out problem,
                // grid cells MUST be sized using width since rows are absolutely
                // positioned and will not cause the busting out problem,
                // and rows will not stretch to shrinkwrap the cells
                // unless they are widthed with width.
                cellElement.style.flex = '';
                cellElement.style.width = DomHelper.setLength(column.width);

                // IE11 calculates flexbox container width based on min-width rather than actual width. When column
                // has width defined greater than minWidth, row may have incorrect width
                if (BrowserHelper.isIE11) {
                    cellElement.style.minWidth = cellElement.style.width;
                }
            }
            else {
                cellElement.style.flex = cellElement.style.width = cellElement.style.minWidth = '';
            }

            cellElement = cellElement.nextElementSibling;
            i++;
        }
    }

    get totalFixedWidth() {
        return this.columns.totalFixedWidth;
    }

    /**
     * Sets header width and scroller width (if needed, depending on if using flex). Might also change the subgrids
     * width, if it uses a width calculated from its columns.
     * @private
     */
    fixWidths() {
        const
            me = this,
            {
                element,
                header,
                footer
            }  = me;

        if (!me.collapsed) {
            if (me.flex) {
                header.flex = me.flex;
                if (footer) {
                    footer.flex = me.flex;
                }
                element.style.flex = me.flex;
            }
            else {
                // If width is calculated and no column is using flex, check if total width is less than width. If so,
                // recalculate width and bail out of further processing (since setting width will trigger again)
                if (
                    me.hasCalculatedWidth &&
                    !me.columns.some(col => !col.hidden && col.flex) &&
                    me.totalFixedWidth !== me.width
                ) {
                    me.width = me.totalFixedWidth;
                    // Setting width above clears the hasCalculatedWidth flag, but we want to keep it set to react correctly
                    // next time
                    me.hasCalculatedWidth = true;
                    return;
                }

                let totalWidth = me.width;

                if (!totalWidth) {
                    totalWidth = 0;

                    // summarize column widths, needed as container width when not using flex widths and for correct
                    // overflow check in Edge
                    for (let col of me.columns) {
                        if (!col.flex && !col.hidden) totalWidth += col.width;
                    }
                }

                // rows are absolutely positioned, meaning that their width won't affect container width
                // hence we must set it, if not using flex
                element.style.width = `${totalWidth}px`;

                header.width = totalWidth;
                if (footer) {
                    footer.width = totalWidth;
                }
            }

            me.syncScrollingPartners(false);
        }
    }

    // Safari/Edge do not shrink cells the same way as chrome & ff does without having a width set on the row
    fixRowWidthsInSafariEdge() {
        if (BrowserHelper.isSafari || BrowserHelper.isEdge) {
            const me                 = this,
                { region, header } = me,
                minWidth           = header.calculateMinWidthForSafari();

            // fix row widths for safari, it does not size flex cells correctly at small widths otherwise.
            // there should be a css solution, but I have failed to find it
            me.rowManager.forEach(row => {
                // This function runs on resize and rendering a SubGrid triggers a resize. When adding a new SubGrid
                // on the fly elements wont exists for it yet, so ignore...
                const element = row.getElement(region);
                // it is worth noting that setting a width does not prevent the row from growing beyond that with
                // when making view wider, it is used in flex calculation more like a min-width
                if (element) {
                    element.style.width = `${minWidth}px`;
                }
            });

            header.headersElement.style.width = `${minWidth}px`;
        }
    }

    /**
     * Get/set SubGrid width, which also sets header and footer width (if available).
     * @property {Number}
     */
    set width(width) {
        const me = this;

        // Width explicitly set, remember that
        me.hasCalculatedWidth = false;

        super.width = width;

        if (me.header) me.header.width = width;
        if (me.footer) me.footer.width = width;

        // When we're live, we can't wait until the  throttled resize occurs - it looks bad.
        if (me.isPainted) {
            me.onElementResize();
        }
    }

    get width() {
        return super.width;
    }

    /**
     * Get/set SubGrid flex, which also sets header and footer flex (if available).
     * @property {Number|String}
     */
    set flex(flex) {
        const me = this;

        // Width explicitly set, remember that
        me.hasCalculatedWidth = false;

        if (me.header) me.header.flex = flex;
        if (me.footer) me.footer.flex = flex;
        super.flex = flex;

        // When we're live, we can't wait until the  throttled resize occurs - it looks bad.
        if (me.isPainted) {
            me.onElementResize();
        }
    }

    get flex() {
        return super.flex;
    }

    /**
     * Called when grid changes size. SubGrid determines if it has changed size and triggers scroll (for virtual
     * rendering in cells to work when resizing etc.)
     * @private
     */
    onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight) {
        const
            me       = this,
            { grid } = me;

        // Widget caches dimensions
        super.onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight);
        if (me.splitterElement) {
            me.syncSplitterButtonPosition();
        }

        // Unit tests create naked SubGrids so we have to do this.
        if (grid) {
            if (newWidth !== oldWidth) {
                // trigger scroll, in case anything is done on scroll it needs to be done now also
                grid.trigger('horizontalScroll', { subGrid : me, grid, scrollLeft : me.scrollable.x });

                me.refreshFakeScroll();

                me.fixRowWidthsInSafariEdge();
            }

            me.trigger('afterInternalResize', me);
        }
    }

    /**
     * Keeps the parallel splitters in the header, footer and fake scroller synced in terms
     * of being collapsed or not.
     * @private
     */
    syncParallelSplitters(collapsed) {
        const
            me       = this,
            { grid } = me,
            method   = collapsed ? 'add' : 'remove';

        if (me.splitterElement) {
            me.splitterElement.classList[method]('b-grid-splitter-collapsed');
            if (me.headerSplitter) {
                me.headerSplitter.classList[method]('b-grid-splitter-collapsed');
            }
            if (me.footerSplitter) {
                me.footerSplitter.classList[method]('b-grid-splitter-collapsed');
            }
            if (me.scrollerSplitter) {
                me.scrollerSplitter.classList[method]('b-grid-splitter-collapsed');
            }
        }

        // If we're the last, we don't own a splitter, we use the previous region's splitter
        else {
            const prevGrid = grid.getSubGrid(grid.getPreviousRegion(me.region));

            // If there's a splitter before us, sync it with our state.
            if (prevGrid && prevGrid.splitterElement) {
                prevGrid.syncParallelSplitters(collapsed);
            }
        }
    }

    onSplitterMouseOver() {
        const
            me = this,
            { nextSibling } = me;

        // No hover effect when collapsed
        if (!me.collapsed && (!nextSibling || !nextSibling.collapsed)) {
            me.splitterElement.classList.add('b-hover');
            me.headerSplitter && me.headerSplitter.classList.add('b-hover');
            me.footerSplitter && me.footerSplitter.classList.add('b-hover');
            me.scrollerSplitter.classList.add('b-hover');
        }

        me.startSplitterButtonSyncing();
    }

    onSplitterMouseOut() {
        const
            me              = this,
            { nextSibling } = me;

        me.splitterElement.classList.remove('b-hover');
        me.headerSplitter && me.headerSplitter.classList.remove('b-hover');
        me.footerSplitter && me.footerSplitter.classList.remove('b-hover');
        me.scrollerSplitter.classList.remove('b-hover');
        if (!me.collapsed && (!nextSibling || !nextSibling.collapsed)) {
            me.stopSplitterButtonSyncing();
        }
    }

    startSplitterButtonSyncing() {
        const me = this;

        if (me.splitterElement) {
            me.syncSplitterButtonPosition();
            if (!me.splitterSyncScrollListener) {
                me.splitterSyncScrollListener = me.grid.scrollable.on({
                    scroll  : 'syncSplitterButtonPosition',
                    thisObj : me
                });
            }
        }
    }

    stopSplitterButtonSyncing() {
        if (this.splitterSyncScrollListener) {
            this.splitterSyncScrollListener();
            this.splitterSyncScrollListener = null;
        }
    }

    syncSplitterButtonPosition() {
        this.splitterButtons.style.transform = `translateY(${(this.grid.scrollable.y + this.grid.bodyHeight / 2) - (this.headerSplitter ? this.grid.headerHeight : 0)}px)`;
    }

    /**
     * Get the "viewport" for the SubGrid as a Rectangle
     * @property {Core.helper.util.Rectangle}
     * @readonly
     */
    get viewRectangle() {
        const me = this;
        return new Rectangle(me.scrollable.x, me.scrollable.y, me._width, me.rowManager.viewHeight);
    }

    /**
     * Called when updating column widths to apply 'b-has-flex' which is used when fillLastColumn is configured.
     * @internal
     */
    updateHasFlex() {
        const hasFlex = this.columns.visibleColumns.some(column => column.flex);

        DomHelper.toggleClasses(this.element, ['b-has-flex'], hasFlex);
    }

    //endregion

    //region Scroll

    /**
     * Fixes widths of fake scrollers
     * @private
     */
    refreshFakeScroll() {
        const me                                                                              = this,
            { element, virtualScrollerElement, virtualScrollerWidth, totalFixedWidth, store } = me,
            scroller                                                                          = me.scrollable;

        // Use a fixed scroll width if grid is empty, to make it scrollable without rows
        // https://app.assembla.com/spaces/bryntum/tickets/7184
        scroller.scrollWidth = store && store.count ? null : totalFixedWidth;

        virtualScrollerElement.style.width = `${element.offsetWidth}px`;

        //if (BrowserHelper.isEdge) {
        // Needed for Edge, it does not size correctly
        if (totalFixedWidth > scroller.clientWidth) {
            element.classList.add('b-overflowing-horizontally');
        }
        else {
            element.classList.remove('b-overflowing-horizontally');
        }
        //}

        if (!me.collapsed) {
            // This is if *this* subGrid has horizontal overflow
            // +1 is for Edge, it messes up otherwise
            if (scroller.scrollWidth > scroller.clientWidth + (BrowserHelper.isEdge ? 1 : 0)) {
                virtualScrollerWidth.style.width = `${scroller.scrollWidth}px`;
                me.header.element.classList.add('b-overflowing');
                me.footer && me.footer.element.classList.add('b-overflowing');
                me.overflowingHorizontally = true;
                // If *any* SubGrids have horizontal overflow, the main grid
                // has to show its virtual horizontal scollbar.
                me.grid.virtualScrollers.classList.remove('b-hide-display');
            }
            else {
                virtualScrollerWidth.style.width = 0;
                me.header.element.classList.remove('b-overflowing');
                me.footer && me.footer.element.classList.remove('b-overflowing');
                me.overflowingHorizontally = false;
            }
        }
    }

    /**
     * Init scroll syncing for header and footer (if available).
     * @private
     */
    initScroll() {
        const
            me                     = this,
            scroller               = me.scrollable,
            virtualScrollerElement = me.virtualScrollerElement;

        me.syncPartnersOnFrame = me.createOnFrame(me.syncScrollingPartners);

        if (BrowserHelper.isFirefox) {
            scroller.element.addEventListener('wheel', event => {
                if (event.deltaX) {
                    scroller.x += event.deltaX;
                    event.preventDefault();
                }
            });
        }

        scroller.yScroller = me.grid.scrollable;

        // Add our Scroller to the controlling GridScroller
        scroller.yScroller.addScroller(scroller);

        // Create a Scroller for the fake horizontal scrollbar so that it can partner
        me.fakeScroller = new Scroller({
            element   : virtualScrollerElement,
            overflowX : true
        });

        // Sync scrolling partners (header, footer) when our xScroller reports a scroll.
        // Also fires horizontalscroll
        scroller.on({
            scroll    : 'onSubGridScroll',
            scrollend : 'onSubGridScrollEnd',
            thisObj   : me
        });

        scroller.addPartner(me.fakeScroller, 'x');
        if (me.header) {
            scroller.addPartner(me.header.scrollable, 'x');
        }
        if (me.footer) {
            scroller.addPartner(me.footer.scrollable, 'x');
        }
    }

    onSubGridScrollEnd() {
        // If we do not have the direct update flag set which would ensure a sync in each scroll event
        // then ensure syncing happens on scroll end. This is for animated scrolls where the scroll
        // impulses come through animation frames.
        if (!this.forceScrollUpdate) {
            this.syncScrollingPartners();
        }
        this.scrolling = false;
    }

    onSubGridScroll() {
        // Force direct update, without waiting for next animation frame
        // TODO: Only used in Scheduler, could perhaps live in Scheduler specific SubGrid in the future
        if (this.forceScrollUpdate) {
            this.syncScrollingPartners();
            this.forceScrollUpdate = false;
        }
        else {
            this.syncPartnersOnFrame();
        }
    }

    set scrolling(scrolling) {
        this._scrolling = scrolling;
    }

    get scrolling() {
        return this._scrolling;
    }

    /**
     * This syncs the horizontal scroll position of the header and the footer with
     * the horizontal scroll position of the grid. Usually, this will be called automatically
     * when the grid scrolls. In some cases, such as a refresh caused by column changes
     * it will need to be called from elsewhere.
     * @internal
     */
    syncScrollingPartners(addCls = true) {
        const
            subGrid    = this,
            { grid }   = subGrid;

        if (!subGrid.scrolling && addCls) {
            subGrid.scrolling = true;
        }

        grid.trigger('horizontalScroll', { subGrid, grid, scrollLeft : subGrid.scrollable.x });
    }

    /**
     * Scrolls a column into view (if it is not already). Called by Grid#scrollColumnIntoView, use it instead to not
     * have to care about which SubGrid contains a column.
     * @param {Grid.column.Column|String|Number} column Column name (data) or column index or actual column object.
     * @param {Object} [options] How to scroll.
     * @param {String} [options.block] How far to scroll the element: `start/end/center/nearest`.
     * @param {Number} [options.edgeOffset] edgeOffset A margin around the element or rectangle to bring into view.
     * @param {Object|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
     * or the number of milliseconds to animate over, or an animation config object.
     * @param {Number} [options.animate.duration] The number of milliseconds to animate over.
     * @param {String} [options.animate.easing] The name of an easing function.
     * @param {Boolean} [options.highlight] Set to `true` to highlight the element when it is in view.
     * @param {Boolean} [options.focus] Set to `true` to focus the element when it is in view.
     * @returns {Promise} If the column exists, a promise which is resolved when the column header element has been scrolled into view.
     */
    scrollColumnIntoView(column, options) {
        const
            me       = this,
            scroller = me.header.scrollable;

        // Allow column,column id,or column index to be passed
        column = (column instanceof Column) ? column : me.columns.get(column) || me.columns.getById(column) || me.columns.getAt(column);

        if (column) {
            // Get the current column header element.
            const columnHeaderElement = me.header.getHeader(column.id);

            if (columnHeaderElement) {
                return scroller.scrollIntoView(Rectangle.from(columnHeaderElement, null, true), options);
            }
        }
    }

    //endregion

    //region Rows

    /**
     * Creates elements for the new rows when RowManager has determined that more rows are needed
     * @private
     */
    onAddRow({ rows }) {
        const
            me             = this,
            html           = me.rowTemplate(),
            visibleColumns = me.columns.bottomColumns.filter(col => !col.hidden),
            frag           = document.createDocumentFragment();

        rows.forEach(row => {
            const rowElement = DomHelper.createElementFromTemplate(html);

            frag.appendChild(rowElement);
            row.addElement(me.region, rowElement);

            // TODO: Stamp the correct width into the cells on creation
            me.fixCellWidths(rowElement, visibleColumns);
        });

        me.fixRowWidthsInSafariEdge();

        // Put the row elements into the SubGrid en masse.
        // If 2nd param is null, insertBefore appends.
        me.element.insertBefore(frag, me.insertRowsBefore);
    }

    /**
     * Get all row elements for this SubGrid.
     * @returns {HTMLElement[]} Row elements
     * @readonly
     */
    get rowElements() {
        return this.fromCache('.b-grid-row', true);
    }

    /**
     * Removes all row elements from the subgrids body and empties cache
     * @private
     */
    clearRows() {
        this.emptyCache();
        const all   = this.element.querySelectorAll('.b-grid-row'),
            range = document.createRange();

        if (all.length) {
            range.setStartBefore(all[0]);
            range.setEndAfter(all[all.length - 1]);
            range.deleteContents();
        }
    }

    // only called when RowManager.rowScrollMode = 'dom', which is not intended to be used
    addNewRowElement() {
        const rowElement = DomHelper.append(this.element, this.rowTemplate());

        this.fixCellWidths(rowElement);

        return rowElement;
    }

    get emptyText() {
        return this._emptyText;
    }

    set emptyText(text) {
        this._emptyText = text;

        this.element.dataset.emptyText = text;
    }

    //endregion

    // region Expand/collapse

    // All usages are commented, uncomment when this is resolved: https://app.assembla.com/spaces/bryntum/tickets/5472
    toggleTransitionClasses(doRemove = false) {
        const me         = this,
            grid       = me.grid,
            nextRegion = grid.getSubGrid(grid.getNextRegion(me.region)),
            splitter   = grid.resolveSplitter(nextRegion);

        nextRegion.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');
        nextRegion.header.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');

        me.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');
        me.header.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');

        splitter.classList[doRemove ? 'remove' : 'add']('b-grid-splitter-animate');
    }

    /**
     * Get/set collapsed state
     * @property {Boolean}
     */
    get collapsed() {
        return this._collapsed;
    }

    set collapsed(collapsed) {
        if (this.isConfiguring) {
            this._collapsed = collapsed;
        }
        else {
            if (collapsed) {
                this.collapse();
            }
            else {
                this.expand();
            }
        }
    }

    /**
     * Collapses subgrid. If collapsing subgrid is the only one expanded, next subgrid to the right (or previous) will
     * be expanded.
     *
     * @example
     * let locked = grid.getSubGrid('locked');
     * locked.collapse().then(() => {
     *     console.log(locked.collapsed); // Logs 'True'
     * });
     *
     * let normal = grid.getSubGrid('normal');
     * normal.collapse().then(() => {
     *     console.log(locked.collapsed); // Logs 'False'
     *     console.log(normal.collapsed); // Logs 'True'
     * });
     *
     * @async
     * @returns {Promise} A Promise which resolves when this SubGrid is fully collapsed.
     */
    async collapse() {
        const
            me            = this,
            grid          = me.grid,
            nextRegion    = grid.getSubGrid(grid.getNextRegion(me.region)),
            splitterOwner = me.splitterElement ? me : me.previousSibling;

        // Count all expanded regions. Grid must have always have at least one expanded
        let expandedRegions = 0;

        grid.eachSubGrid(subGrid => {
            subGrid !== me && !subGrid._collapsed && ++expandedRegions;
        });

        // Current region is the only one expanded, expand next region
        if (expandedRegions === 0) {
            // expandPromise = nextRegion.expand();
            await nextRegion.expand();
        }

        return new Promise((resolve) => {
            if (!me._beforeCollapseState) {
                me._beforeCollapseState = {};

                let widthChanged = false;

                // If current width is zero, the resize event will not be fired. In such case we want to trigger callback immediately
                if (me.width) {
                    widthChanged = true;

                    // Toggle transition classes here, we will actually change width below
                    // me.toggleTransitionClasses();

                    // afterinternalresize event is buffered, it will be fired only once after animation is finished
                    // and element size is final
                    me.on({
                        afterinternalresize : () => {
                            // me.toggleTransitionClasses(true);
                            resolve(me);
                        },
                        thisObj : me,
                        once    : true
                    });
                }

                // When trying to collapse region we need its partner to occupy free space. Considering multiple
                // regions, several cases are possible:
                // 1) Both left and right regions have fixed width
                // 2) Left region has fixed width, right region is flexed
                // 3) Left region is flexed, right region has fixed width
                // 4) Both regions are flexed
                //
                // To collapse flexed region we need to remove flex style, remember it somehow and set fixed width.
                // If another region is flexed, it will fill the space. If it has fixed width, we need to increase
                // its width by collapsing region width. Same logic should be appliead to headers.
                //
                // Save region width first
                me._beforeCollapseState.width = me.width;
                me._beforeCollapseState.elementWidth = me.element.style.width;

                // Next region is not flexed, need to make it fill the space
                if (nextRegion.element.style.flex === '') {
                    me._beforeCollapseState.nextRegionWidth = nextRegion.width;
                    nextRegion.width += me._beforeCollapseState.width;
                }

                // Current region is flexed, store style to restore on expand
                if (me.element.style.flex !== '') {
                    me._beforeCollapseState.flex = me.element.style.flex;
                    // remove flex state to reduce width later
                    me.header.element.style.flex = me.element.style.flex = '';
                }

                // Sets the grid to its collapsed width as defined in SASS: zero
                me.element.classList.add('b-grid-subgrid-collapsed');

                // The parallel elements which must be in sync width-wise must know about collapsing
                me.virtualScrollerElement.classList.add('b-collapsed');
                me.header.element.classList.add('b-collapsed');
                me.footer && me.footer.element.classList.add('b-collapsed');

                me.width = '';
                me._collapsed = true;

                if (!widthChanged) {
                    resolve(false);
                }
            }
        }).then((value) => {
            if (!me.isDestroyed && value !== false) {
                me.syncParallelSplitters(true);
                me.grid.trigger('subGridCollapse', me);

                // Our splitter is permanently visible when collapsed, so keep splitter button set
                // synced in the vertical centre of the view just in time for paint.
                // Uses translateY so will not cause a further layout.
                splitterOwner.startSplitterButtonSyncing && splitterOwner.startSplitterButtonSyncing();
            }
        });
    }

    /**
     * Expands subgrid.
     *
     * @example
     * grid.getSubGrid('locked').expand().then(() => console.log('locked grid expanded'));
     *
     * @async
     * @returns {Promise} A Promise which resolves when this SubGrid is fully expanded.
     */
    async expand() {
        const
            me            = this,
            grid          = me.grid,
            nextRegion    = grid.getSubGrid(grid.getNextRegion(me.region)),
            splitterOwner = me.splitterElement ? me : me.previousSibling;

        return new Promise((resolve) => {
            if (me._beforeCollapseState != null) {
                // If current width matches width expected after expand resize event will not be fired. In such case
                // we want to trigger callback immediately
                let widthChanged = false;

                // See similar clause in collapse method above
                if (me.width !== me._beforeCollapseState.elementWidth) {
                    widthChanged = true;

                    // Toggle transition classes here, we will actually change width below
                    // me.toggleTransitionClasses();

                    me.on({
                        afterinternalresize : () => {
                            // me.toggleTransitionClasses(true);

                            // Delay the resolve to avoid "ResizeObserver loop limit exceeded" errors
                            // collapsing the only expanded region and it has to expand its nextRegion
                            // before it can collapse.
                            me.setTimeout(() => resolve(me), 10);
                        },
                        thisObj : me,
                        once    : true
                    });
                }

                // previous region is not flexed, reduce its width as it was increased in collapse
                if (nextRegion.element.style.flex === '') {
                    nextRegion.width = me._beforeCollapseState.nextRegionWidth;
                }

                me.element.classList.remove('b-grid-subgrid-collapsed');
                me._collapsed = false;

                // The parallel elements which must be in sync width-wise must know about collapsing
                me.virtualScrollerElement.classList.remove('b-collapsed');
                me.header.element.classList.remove('b-collapsed');
                me.footer && me.footer.element.classList.remove('b-collapsed');

                // This region used to be flex, let's restore it
                if (me._beforeCollapseState.flex) {
                    // Always restore width, restoring flex wont trigger resize otherwise
                    me.width = me._beforeCollapseState.width;

                    // Widget flex setting clears style width
                    me.header.flex = me.flex = me._beforeCollapseState.flex;
                    me.footer && (me.footer.flex = me._beforeCollapseState.flex);
                    me._width = null;
                }
                else {
                    me.width = me._beforeCollapseState.elementWidth;
                }

                me.element.classList.remove('b-grid-subgrid-collapsed');
                me._collapsed = false;

                if (!widthChanged) {
                    resolve(false);
                }

                delete me._beforeCollapseState;
            }
        }).then((value) => {
            if (value !== false) {
                // Our splitter is hidden when expanded, so we no longer need to keep splitter button set
                // synced in the vertical centre of the view.
                splitterOwner.stopSplitterButtonSyncing();

                me.syncParallelSplitters(false);
                me.grid.trigger('subGridExpand', me);
            }
        });
    }

    //endregion
}
SubGrid._$name = 'SubGrid';

/**
 * @module Grid/view/mixin/GridSubGrids
 */

/**
 * Mixin for grid that handles SubGrids. Each SubGrid is scrollable horizontally separately from the other SubGrids.
 * Having two SubGrids allows you to achieve what is usually called locked or frozen columns.
 *
 * By default a Grid has two SubGrids, one named 'locked' and one 'normal'. The `locked` region has fixed width, while
 * the `normal` region grows to fill all available width (flex).
 *
 * Which SubGrid a column belongs to is
 * determined using its {@link Grid.column.Column#config-region} config. For example to put a column into the locked
 * region, specify `{ region: 'locked' }`. For convenience, a column can be put in the locked region using
 * `{ locked: true }`.
 *
 * @example
 * { data: 'name', text: 'Name', locked: true }
 * { data: 'age', text: 'Age', region: 'locked' }
 *
 * @demo Grid/features
 * @mixin
 */
var GridSubGrids = Target => class GridSubGrids extends (Target || Base) {
    //region Init

    /**
     * Initializes subGrids from subGrid configs in config.subGridConfigs. Regions specified on columns but not The default config.subGridConfigs is:
     * { normal: { flex: 1 } }
     * @private
     * @category SubGrid
     */
    initSubGrids() {
        const
            me          = this,
            oldRegions  = me._regions,
            usedRegions = new Set();

        let first = true,
            hasCalculatedWidth,
            subGridConfig,
            subGridColumns;

        // TODO: move into subgrid or columnmanager
        for (const column of me.columns.records) {
            if (column.region && !me.subGridConfigs[column.region]) {
                me.subGridConfigs[column.region] = {};
            }
            usedRegions.add(column.region);
        }

        // If "reconfiguring" columns, we are going to create new subgrids so destroy any existing
        if (oldRegions) {
            oldRegions.forEach(region => me.subGrids[region].destroy());
        }

        /**
         * An object containing the {@link Grid.view.SubGrid} region instances, indexed by subGrid id ('locked', normal'...)
         * @property {Object} subGrids
         * @readonly
         */
        me.subGrids = {};

        me._regions = Array.from(usedRegions);
        me._regions.sort();

        // Implementer has provided configs for other subGrids but not normal, put defaults in place
        if (me.subGridConfigs.normal && Object.keys(me.subGridConfigs.normal).length === 0) {
            me.subGridConfigs.normal = GridBase.defaultConfig.subGridConfigs.normal;
        }

        for (const region of me._regions) {
            subGridColumns = me.columns.makeChained(column => column.region === region, ['region']);
            subGridConfig = ObjectHelper.assign({
                parent      : me,
                grid        : me,
                store       : me.store,
                rowManager  : me.rowManager,
                region      : region,
                headerClass : me.subGridConfigs[region].headerClass || me.headerClass,
                columns     : subGridColumns,
                hideHeaders : me.hideHeaders
            }, me.subGridConfigs[region]);

            hasCalculatedWidth = false;

            if (!subGridConfig.flex && !subGridConfig.width) {
                subGridConfig.width = subGridColumns.totalFixedWidth;
                hasCalculatedWidth = true;
            }

            me.subGrids[region] = new SubGrid(subGridConfig);

            // Must be set after creation, otherwise reset in SubGrid#set width
            me.subGrids[region].hasCalculatedWidth = hasCalculatedWidth;

            if (first) {
                // Have already done lookups for this in a couple of places, might as well store it...
                me.subGrids[region].isFirstRegion = true;
                first                             = false;
            }
        }
    }

    get items() {
        // Return ths SubGrids in Region order.
        // This property is referenced by Container#startConfigure, so the regions and SubGrids
        // are initialized early.
        return this.regions.map(r => this.subGrids[r]);
    }

    //endregion

    //region Iteration & calling

    /**
     * Iterate over all subGrids, calling the supplied function for each.
     * @param {Function} fn Function to call for each instance
     * @param {Object} thisObj `this` reference to call the function in, defaults to the subGrid itself
     * @category SubGrid
     * @internal
     */
    eachSubGrid(fn, thisObj = null) {
        const me = this;
        //for (let subGrid of Object.values(this.subGrids)) {
        me.regions.forEach((region, i) => {
            const subGrid = me.subGrids[region];
            fn.call(thisObj || subGrid, subGrid, i++);
        });
    }

    eachWidget(fn, deep = true) {
        const me = this;
        me.regions.forEach((region) => {
            const widget = me.subGrids[region];
            if (fn(widget) === false) {
                return;
            }
            if (deep && widget.eachWidget) {
                widget.eachWidget(fn, deep);
            }
        });
    }

    /**
     * Call a function by name for all subGrids (that have the function).
     * @param {String} fnName Name of function to call, uses the subGrid itself as `this` reference
     * @param params Parameters to call the function with
     * @return {*} Return value from first SubGrid is returned
     * @category SubGrid
     * @internal
     */
    callEachSubGrid(fnName, ...params) {
        // TODO: make object { normal: retval, locked: retval } to return? or store. revisit when needed
        let me          = this,
            returnValue = null;
        //Object.values(this.subGrids).forEach((subGrid, i) => {
        me.regions.forEach((region, i) => {
            const subGrid = me.subGrids[region];
            if (subGrid[fnName]) {
                const partialReturnValue = subGrid[fnName](...params);
                if (i === 0) returnValue = partialReturnValue;
            }
        });
        return returnValue;
    }

    //endregion

    //region Getters

    /**
     * This method should return names of the two last regions in the grid as they are visible in the UI. In case
     * `regions` property cannot be trusted, use different approach. Used by SubGrid and RegionResize to figure out
     * which region should collapse or expand.
     * @returns {String[]}
     * @private
     * @category SubGrid
     */
    getLastRegions() {
        const result = this.regions.slice(-2);
        // ALWAYS return array of length 2 in order to avoid extra conditions. Normally should not be called with 1 region
        return result.length === 2 ? result : [result[0], result[0]];
    }

    /**
     * This method should return right neighbour for passed region, or left neighbour in case last visible region is passed.
     * This method is used to decide which subgrid should take space of the collapsed one.
     * @param {String} region
     * @returns {String}
     * @private
     * @category SubGrid
     */
    getNextRegion(region) {
        const regions = this.regions;

        // return next region or next to last
        return regions[regions.indexOf(region) + 1] || regions[regions.length - 2];
    }

    getPreviousRegion(region) {
        return this.regions[this.regions.indexOf(region) - 1];
    }

    /**
     * Returns the subGrid for the specified region.
     * @param {String} region Region, eg. locked or normal (per default)
     * @returns {Grid.view.SubGrid} A subGrid
     * @category SubGrid
     */
    getSubGrid(region) {
        return this.subGrids[region];
    }

    /**
     * Get the SubGrid that contains specified column
     * @param {String|Grid.column.Column} column Column "name" or column object
     * @returns {Grid.view.SubGrid}
     * @category SubGrid
     */
    getSubGridFromColumn(column) {
        column = column instanceof Column ? column : this.columns.get(column) || this.columns.getById(column);

        return this.getSubGrid(column.region);
    }

    get regions() {
        if (!this._regions) {
            this.initSubGrids();
        }
        return this._regions;
    }

    //endregion

    /**
     * Returns splitter element for subgrid
     * @param {Grid.view.SubGrid|String} subGrid
     * @returns {HTMLElement}
     * @private
     * @category SubGrid
     */
    resolveSplitter(subGrid) {
        const me = this,
            regions = me.getLastRegions();

        let region = subGrid instanceof SubGrid ? subGrid.region : subGrid;

        if (regions[1] === region) {
            region = regions[0];
        }

        return this.subGrids[region].splitterElement;
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

// Extends locale from Core
const locale$2 = {

    //region Columns

    TemplateColumn : {
        noTemplate : 'TemplateColumn needs a template',
        noFunction : 'TemplateColumn.template must be a function'
    },

    ColumnStore : {
        columnTypeNotFound : data => `Column type '${data.type}' not registered`
    },

    //endregion

    //region Features

    ColumnPicker : {
        columnsMenu     : 'Columns',
        hideColumn      : 'Hide column',
        hideColumnShort : 'Hide'
    },

    Filter : {
        applyFilter  : 'Apply filter',
        filter       : 'Filter',
        editFilter   : 'Edit filter',
        on           : 'On',
        before       : 'Before',
        after        : 'After',
        equals       : 'Equals',
        lessThan     : 'Less than',
        moreThan     : 'More than',
        removeFilter : 'Remove filter'
    },

    FilterBar : {
        enableFilterBar  : 'Show filter bar',
        disableFilterBar : 'Hide filter bar'
    },

    Group : {
        groupAscending       : 'Group ascending',
        groupDescending      : 'Group descending',
        groupAscendingShort  : 'Ascending',
        groupDescendingShort : 'Descending',
        stopGrouping         : 'Stop grouping',
        stopGroupingShort    : 'Stop'
    },

    Search : {
        searchForValue : 'Search for value'
    },

    Sort : {
        sortAscending          : 'Sort ascending',
        sortDescending         : 'Sort descending',
        multiSort              : 'Multi sort',
        removeSorter           : 'Remove sorter',
        addSortAscending       : 'Add ascending sorter',
        addSortDescending      : 'Add descending sorter',
        toggleSortAscending    : 'Change to ascending',
        toggleSortDescending   : 'Change to descending',
        sortAscendingShort     : 'Ascending',
        sortDescendingShort    : 'Descending',
        removeSorterShort      : 'Remove',
        addSortAscendingShort  : '+ Ascending',
        addSortDescendingShort : '+ Descending'
    },

    Tree : {
        noTreeColumn : 'To use the tree feature one column must be configured with tree: true'
    },

    //endregion

    //region Grid

    Grid : {
        featureNotFound          : data => `Feature '${data}' not available, make sure you have imported it`,
        invalidFeatureNameFormat : data => `Invalid feature name '${data}', must start with a lowercase letter`,
        removeRow                : 'Delete record',
        removeRows               : 'Delete records',
        loadFailedMessage        : 'Data loading failed.',
        moveColumnLeft           : 'Move to left section',
        moveColumnRight          : 'Move to right section'
    },

    GridBase : {
        loadMask : 'Loading...',
        syncMask : 'Saving changes, please wait...',
        noRows   : 'No records to display'
    },

    //endregion

    //region Export

    PdfExport : {
        'Waiting for response from server...' : 'Waiting for response from server...',
        'Export failed'                       : 'Export failed',
        'Server error'                        : 'Server error'
    },

    ExportDialog : {
        width          : '40em',
        labelWidth     : '12em',
        exportSettings : 'Export settings',
        export         : 'Export',
        exporterType   : 'Control pagination',
        cancel         : 'Cancel',
        fileFormat     : 'File format',
        rows           : 'Rows',
        alignRows      : 'Align rows',
        columns        : 'Columns',
        paperFormat    : 'Paper format',
        orientation    : 'Orientation'
    },

    ExportRowsCombo : {
        all     : 'All rows',
        visible : 'Visible rows'
    },

    ExportOrientationCombo : {
        portrait  : 'Portrait',
        landscape : 'Landscape'
    },

    SinglePageExporter : {
        singlepage : 'Single page'
    },

    MultiPageExporter : {
        multipage     : 'Multiple pages',
        exportingPage : ({ currentPage, totalPages }) => `Exporting page ${currentPage}/${totalPages}`
    }

    //endregion
};

// Cannot use Object.assign above in IE11. also dont want to have polyfill in locale
for (const i in locale$1) {
    locale$2[i] = locale$1[i];
}

LocaleManagerSingelton.registerLocale('En', { desc : 'English', locale : locale$2 });

//region Import

//endregion

/**
 * @module Grid/view/GridBase
 */

const
    resolvedPromise = new Promise(resolve => resolve()),
    defaultScrollOptions$2 = {
        block  : 'nearest',
        inline : 'nearest'
    },
    preserveScroll = {
        dataset : 1,
        filter  : 1
    };

/**
 * A thin base class for {@link Grid.view.Grid}. Does not include any features by default, allowing smaller custom built bundles if used
 * in place of {@link Grid.view.Grid}.
 *
 * **NOTE:** In most scenarios you probably want to use Grid instead of GridBase.

 * @extends Core/widget/Widget
 * @mixes Core/mixin/Events
 * @mixes Core/mixin/Pluggable
 * @mixes Core/mixin/State
 * @mixes Grid/view/mixin/GridElementEvents
 * @mixes Grid/view/mixin/GridFeatures
 * @mixes Grid/view/mixin/GridResponsive
 * @mixes Grid/view/mixin/GridSelection
 * @mixes Grid/view/mixin/GridState
 * @mixes Grid/view/mixin/GridSubGrids
 */
class GridBase extends base(Container).mixes(
    Pluggable,
    State,
    GridElementEvents,
    GridFeatures,
    GridNavigation,
    GridResponsive,
    GridSelection,
    GridState,
    GridSubGrids
) {
    //region Config

    static get $name() {
        return 'GridBase';
    }

    // Default settings, applied in grids constructor.
    static get defaultConfig() {
        return {
            /**
             * Row height in pixels. When set to null, an empty row will be measured and its height will be used as
             * default row height, enabling it to be controlled using CSS
             * @config {Number}
             * @default null
             * @category Common
             */
            rowHeight : null,

            // used if no rowHeight specified and none found in CSS. not public since our themes have row height
            // specified and this is more of an internal failsafe
            defaultRowHeight : 45,

            /**
             * Text to display when there is no data to display in the grid
             * @config {String}
             * @default
             * @category Common
             */
            emptyText : 'L{noRows}',

            /**
             * Refresh entire row when a record changes (`true`) or, if possible, only the cells affected (`false`).
             *
             * When this is set to `false`, then if a column uses a renderer, cells in that column will still
             * be updated because it is impossible to know whether the cells value will be affected.
             *
             * If a standard, provided Column class is used with no custom renderer, its cells will only be updated
             * if the column's {@link Grid.column.Column#config-field} is changed.
             * @config {Boolean}
             * @default
             * @category Misc
             */
            fullRowRefresh : true,

            /**
             * Read only or not
             * @config {Boolean}
             * @default false
             * @category Common
             */
            readOnly : null,

            /**
             * True to not create any grid column headers
             * @config {Boolean}
             * @default false
             * @category Misc
             */
            hideHeaders : null,

            /**
             * Show "Remove row" item in context menu (if enabled and grid not read only)
             * @config {Boolean}
             * @default
             * @category Misc
             */
            showRemoveRowInContextMenu : true,

            /**
             * Automatically set grids height to fit all rows (no scrolling in the grid). In general you should avoid
             * using `autoHeight: true`, since it will bypass Grids virtual rendering and render all rows at once, which
             * in a larger grid is really bad for performance.
             * @config {Boolean}
             * @default false
             * @category Layout
             */
            autoHeight : null,

            /**
             * Store that holds records to display in the grid, or a store config object.
             * A store will be created if none is specified
             * @config {Core.data.Store|Object}
             * @category Common
             */
            store : {},

            /**
             * Data to set in grids store (a Store will be created if none is specified)
             * @config {Object[]}
             * @category Common
             */
            data : null,

            /**
             * Column definitions for the grid, will be used to create Column instances that are added to a ColumnStore:
             *
             * ```
             * new Grid({
             *   columns : [
             *     { text : 'Alias', field : 'alias' },
             *     { text : 'Superpower', field : 'power' }
             *   ]
             * });
             * ```
             *
             * Also accepts a store config object:
             *
             * ```
             * new Grid({
             *   columns : {
             *     data : [
             *       { text : 'Alias', field : 'alias' },
             *       { text : 'Superpower', field : 'power' }
             *     ],
             *     listeners : {
             *       update() {
             *         // Some update happened
             *       }
             *     }
             *   }
             * });
             * ```
             *
             * This store can be accessed using {@link #property-columns}:
             *
             * ```
             * grid.columns.add({ field : 'column', text : 'New column' });
             * ```
             * @config {Object[]|Object}
             * @category Common
             */
            columns : [],

            /**
             * Region to which columns are added when they have none specified
             * @config {String}
             * @default
             * @category Misc
             */
            defaultRegion : 'normal',

            /**
             * true to destroy the store when the grid is destroyed
             * @config {Boolean}
             * @default false
             * @category Misc
             */
            destroyStore : null,

            /**
             * Set to true to allow text selection in the grid cells
             * @config {Boolean}
             * @default false
             * @category Selection
             */
            enableTextSelection : null,

            /**
             * A message to be shown when a store is performing a remote operation.
             * @config {String}
             * @default "Loading..."
             * @category Misc
             */
            loadMask : 'L{loadMask}',

            /**
             * A message to be shown when Crud Manager is persisting changes on the server.
             * @config {String}
             * @default "Saving changes, please wait..."
             * @category Misc
             */
            syncMask : 'L{syncMask}',

            /**
             * Set to `false` to inhibit column lines
             * @config {Boolean}
             * @default
             * @category Misc
             */
            columnLines : true,

            /**
             * Set to `true` to stretch the last column in a grid with all fixed width columns
             * to fill extra available space if the grid's width is wider than the sum of all
             * configured column widths.
             * @config {Boolean}
             * @default
             * @category Layout
             */
            fillLastColumn : true,

            /**
             * Set to `false` to only measure cell contents when double clicking the edge between column headers.
             * @config {Boolean}
             * @default
             * @category Layout
             */
            resizeToFitIncludesHeader : true,

            /**
             * Set to `false` to prevent remove row animation and remove the delay related to that.
             * @config {Boolean}
             * @default
             * @category Misc
             */
            animateRemovingRows : !BrowserHelper.isIE11, // IE11 doesn't have reliable firing of transitionend

            /**
             * Set to `true` to not get a warning when using another base class than GridRowModel for your grid data. If
             * you do, and would like to use the full feature set of the grid then include the fields from GridRowModel
             * in your model definition.
             * @config {Boolean}
             * @default false
             * @category Misc
             */
            disableGridRowModelWarning : null,

            loadMaskErrorIcon : 'b-icon b-icon-warning',

            headerClass : Header,

            testPerformance : false,
            // TODO: break out as strategies
            positionMode    : 'translate', // translate, translate3d, position
            rowScrollMode   : 'move', // move, dom, all

            /**
             * Grid monitors window resize by default.
             * @config {Boolean}
             * @default true
             * @category Misc
             */
            monitorResize : true,

            /**
             * An object containing Feature configuration objects (or `true` if no configuration is required)
             * keyed by the Feature class name in all lowercase.
             * @config {Object}
             * @category Common
             * @typings any
             */
            features : true,

            /**
             * An object containing sub grid configuration objects keyed by a `region` property.
             * By default, grid has a 'locked' region (if configured with locked columns) and a 'normal' region.
             * The 'normal' region defaults to use `flex: 1`.
             *
             * This config can be used to reconfigure the "built in" sub grids or to define your own.
             * ```
             * // Redefining the "built in" regions
             * new Grid({
             *   subGridConfigs : {
             *     locked : { flex : 1 },
             *     normal : { width : 100 }
             *   }
             * });
             *
             * // Defining your own multi region sub grids
             * new Grid({
             *   subGridConfigs : {
             *     left   : { width : 100 },
             *     middle : { flex : 1 },
             *     right  : { width  : 100 }
             *   },
             *
             *   columns : {
             *     { field : 'manufacturer', text: 'Manufacturer', region : 'left' },
             *     { field : 'model', text: 'Model', region : 'middle' },
             *     { field : 'year', text: 'Year', region : 'middle' },
             *     { field : 'sales', text: 'Sales', region : 'right' }
             *   }
             * });
             * ```
             * @config {Object}
             * @category Misc
             */
            subGridConfigs : {
                normal : { flex : 1 }
            },

            /**
             * Configures whether the grid is scrollable in the `Y` axis. This is used to configure a {@link Grid.util.GridScroller}.
             * See the {@link #config-scrollerClass} config option.
             * @config {Boolean|Object|Core.helper.util.Scroller}
             * @category Scrolling
             */
            scrollable : {
                // Just Y for now until we implement a special grid.view.Scroller subclass
                // Which handles the X scrolling of subgrids.
                overflowY : true
            },

            /**
             * The class to instantiate to use as the {@link #config-scrollable}. Defaults to {@link Grid.util.GridScroller}.
             * @config {Core.helper.util.Scroller}
             * @category Scrolling
             */
            scrollerClass : GridScroller,

            /**
             * Configure as `true` to have the grid show a red "changed" tag in cells who's
             * field value has changed and not yet been committed.
             * @config {Boolean}
             * @default false
             * @category Misc
             */
            showDirty : null,

            loadMaskHideTimeout : 3000,

            transitionDurationTimeout : 500,

            refreshSuspended : 0,

            /**
             * Animation transition duration in milliseconds.
             * @config {number}
             * @default
             */
            transitionDuration : 500,

            /**
             * Event which is used to show context menus.
             * Available options are: 'contextmenu', 'click', 'dblclick'.
             * Default value is 'contextmenu'
             * @config {String}
             * @category Misc
             */
            contextMenuTriggerEvent : 'contextmenu',

            localizableProperties : ['emptyText', 'loadMask', 'syncMask'],

            localeClass : 'Grid'

            // Grid requires a size to be considered visible
            //requireSize : true
        };
    }

    /**
     * Animation transition duration in milliseconds.
     * @property {number}
     * @name transitionDuration
     */

    static getLKey() {
        return '5ba3a32a-5174-11ea-83f7-d094663d5c88';
    }

    static get properties() {
        return {
            _selectedRecords      : [],
            _verticalScrollHeight : 0,
            virtualScrollHeight   : 0,
            _scrollTop            : null
        };
    }

    //endregion

    //region Init-destroy

    finishConfigure(config) {
        const me = this;

        super.finishConfigure(config);

        me.scrollManager = new ScrollManager({
            grid            : me,
            // Horizontal scrolling might happen on different subgrids, but vertical is always on same element
            verticalElement : me.scrollable.element
        });

        // When locale is applied columns react and change, which triggers `change` event on columns store for each
        // changed column, and every change normally triggers rendering view. This overhead becomes noticeable with
        // larger amount of columns. So we set two listeners to locale events: prioritized listener to be executed first
        // and suspend renderContents method and unprioritized one to resume method and call it immediately.
        LocaleManagerSingelton.on({
            locale  : 'onBeforeLocaleChange',
            prio    : 1,
            thisObj : me
        });

        LocaleManagerSingelton.on({
            locale  : 'onLocaleChange',
            prio    : -1,
            thisObj : me
        });

        GlobalEvents.on({
            theme   : 'onThemeChange',
            thisObj : me
        });

        me.on({
            subGridExpand : 'onSubGridExpand',
            prio          : -1,
            thisObj       : me
        });

        // Add the extra grid classes to the element
        me.setGridClassList(me.element.classList);
    }

    onSubGridExpand() {
        // Need to rerender all rows, because if the rows were rerendered (by adding a new column to another region for example)
        // while the region was collapsed, cells in the region will be empty.
        this.renderContents();
    }

    onBeforeLocaleChange() {
        this._suspendRenderContentsOnColumnsChanged = true;
    }

    onLocaleChange() {
        this._suspendRenderContentsOnColumnsChanged = false;
        if (this.isPainted) {
            this.renderContents();
        }
    }

    finalizeInit() {
        super.finalizeInit();

        if (this.store.isLoading) {
            // Maybe show loadmask if store is already loading when grid is constructed
            this.onStoreBeforeRequest();
        }
    }

    /**
     * Cleanup
     * @private
     */
    doDestroy() {
        const me = this;

        me.storeDetacher && me.storeDetacher();

        for (const feature of Object.values(me.features)) {
            feature.destroy && feature.destroy();
        }

        if (me.columns) {
            me.columns = null;
        }

        if (me.store) {
            me.store = null;
        }

        super.doDestroy();
    }

    /**
     * Adds extra classes to the Grid element after it's been configured.
     * Also iterates through features, thus ensuring they have been initialized.
     * @private
     */
    setGridClassList(classList) {
        const me = this;

        classList.add(`b-grid-${me.positionMode}`);

        // TODO: enableTextSelection should be a setter, enabling toggling at any time
        if (!me.enableTextSelection) {
            classList.add('b-grid-notextselection');
        }

        if (me.autoHeight) {
            classList.add('b-autoheight');
        }

        if (me.readOnly) {
            classList.add('b-readonly');
        }

        if (me.fillLastColumn) {
            classList.add('b-fill-last-column');
        }

        if (me.showDirty) {
            classList.add('b-show-dirty');
        }

        for (const featureName in me.features) {
            const feature = me.features[featureName];

            let featureClass;

            if (Object.prototype.hasOwnProperty.call(feature.constructor, 'featureClass')) {
                featureClass = feature.constructor.featureClass;
            }
            else {
                featureClass = `b-${(feature instanceof Base ? feature.$name : feature.constructor.name)}`;
            }

            if (featureClass) {
                classList.add(featureClass.toLowerCase());
            }
        }
    }

    //endregion

    //region Functions & events injected by features

    // For documentation & typings purposes

    //region Feature events

    /**
     * *Only when the {@link Grid.feature.Tree} feature is enabled*.
     * <p>Fired before a record toggles its collapsed state.
     * @event beforeToggleNode
     * @param {Core.data.Model} record The record being toggled.
     * @param {Boolean} collapse `true` if the node is being collapsed.
     */
    /**
     * *Only when the {@link Grid.feature.Tree} feature is enabled*.
     * <p>Fired after a record has been collapsed.
     * @event collapseNode
     * @param {Core.data.Model} record The record which has been collapsed.
     */
    /**
     * *Only when the {@link Grid.feature.Tree} feature is enabled*.
     * <p>Fired after a record has been expanded.
     * @event expandNode
     * @param {Core.data.Model} record The record which has been expanded.
     */
    /**
     * *Only when the {@link Grid.feature.Tree} feature is enabled*.
     * <p>Fired after a record toggles its collapsed state.
     * @event toggleNode
     * @param {Core.data.Model} record The record being toggled.
     * @param {Boolean} collapse `true` if the node is being collapsed.
     */

    //endregion

    /**
     * Collapse all groups/parent nodes.
     *
     * *NOTE: Only available when the {@link Grid/feature/Group Group} or the {@link Grid/feature/Tree Tree} feature is enabled.*
     *
     * @function collapseAll
     * @category Feature shortcuts
     */

    /**
     * Expand all groups/parent nodes.
     *
     * *NOTE: Only available when the {@link Grid/feature/Group Group} or the {@link Grid/feature/Tree Tree} feature is enabled.*
     *
     * @function expandAll
     * @category Feature shortcuts
     */

    /**
     * Start editing specified cell. If no cellContext is given it starts with the first cell in the first row.
     *
     * *NOTE: Only available when the {@link Grid/feature/CellEdit CellEdit} feature is enabled.*
     *
     * @function startEditing
     * @param {Object} cellContext Cell specified in format { id: 'x', columnId/column/field: 'xxx' }. See {@link Grid.view.Grid#function-getCell} for details.
     * @returns {Boolean}
     * @category Feature shortcuts
     */

    /**
     * Collapse an expanded node or expand a collapsed. Optionally forcing a certain state.
     *
     * *NOTE: Only available when the {@link Grid/feature/Tree Tree} feature is enabled.*
     *
     * @function toggleCollapse
     * @param {String|Number|Core.data.Model} idOrRecord Record (the node itself) or id of a node to toggle
     * @param {Boolean} [collapse] Force collapse (true) or expand (false)
     * @param {Boolean} [skipRefresh] Set to true to not refresh rows (if calling in batch)
     * @returns {Promise}
     * @category Feature shortcuts
     */

    /**
     * Collapse a single node.
     *
     * *NOTE: Only available when the {@link Grid/feature/Tree Tree} feature is enabled.*
     *
     * @function collapse
     * @param {String|Number|Core.data.Model} idOrRecord Record (the node itself) or id of a node to collapse
     * @returns {Promise}
     * @category Feature shortcuts
     */

    /**
     * Expand a single node.
     *
     * *NOTE: Only available when the {@link Grid/feature/Tree Tree} feature is enabled.*
     *
     * @function expand
     * @param {String|Number|Core.data.Model} idOrRecord Record (the node itself) or id of a node to expand
     * @returns {Promise}
     * @category Feature shortcuts
     */

    /**
     * Expands parent nodes to make this node "visible".
     *
     * *NOTE: Only available when the {@link Grid/feature/Tree Tree} feature is enabled.*
     *
     * @function expandTo
     * @param {String|Number|Core.data.Model} idOrRecord Record (the node itself) or id of a node
     * @returns {Promise}
     * @category Feature shortcuts
     */

    //endregion

    //region Grid template & elements

    template(data) {
        const virtualScrollerStyle = BrowserHelper.isFirefox ? `height:${DomHelper.scrollBarWidth}px` : '';

        return TemplateHelper.tpl`
            <div tabindex="-1">
                <header reference="headerContainer" class="b-grid-header-container ${this.hideHeaders ? 'b-hidden' : ''}"></header>
                <div reference="bodyContainer" class="b-grid-body-container">
                    <div reference="verticalScroller" class="b-grid-vertical-scroller"></div>
                </div>
                <div reference="virtualScrollers" class="b-virtual-scrollers ${DomHelper.scrollBarWidth ? '' : 'b-overlay-scrollbar'}" style="${virtualScrollerStyle}"></div>
                <footer reference="footerContainer" class="b-grid-footer-container b-hidden"></footer>
            </div>
        `;
    }

    get contentElement() {
        return this.verticalScroller;
    }

    get overflowElement() {
        return this.bodyContainer;
    }

    get focusElement() {
        return this.element;
    }

    //endregion

    //region Columns

    set columns(columns) {
        const me = this;

        if (me._columnStore) {
            if (columns) {
                // TODO: @johan: reconfiguring, ie changing whole column set should work.
                // That could mean a total recalculation of subGrids.
                // That's not possible right now, so
                //throw new Error('Cannot reconfigure column set');
                // me._columnStore.clear();
                me._columnStore.data = columns;
            }
            else {
                me._columnStore.destroy();
            }
        }
        else {
            // ColumnStore instance
            if (columns instanceof ColumnStore) {
                if (!columns.grid) {
                    columns.grid = me;
                }
                me._columnStore = columns;
            }
            // Array of columns
            else if (Array.isArray(columns)) {
                me._columnStore = new ColumnStore({
                    grid : me,
                    data : columns
                });
            }
            // Store config object
            else if (columns) {
                me._columnStore = new ColumnStore(Object.assign({ grid : me }, columns));
            }

            // changes might be triggered when applying state, before grid is rendered
            // TODO: have this run a lighter weight, non-destructive response.
            // onColumnsChanged is a start, but lots of machinery is hooked to render.
            me._columnStore.on('change', me.onColumnsChanged, me);
            me._columnStore.on(columnResizeEvent(me.onColumnsResized, me));

            // Add touch class for touch devices
            if (BrowserHelper.isTouchDevice) {
                me.touch = true;

                // apply touchConfig for columns that defines it
                me._columnStore.forEach(column => {
                    const touchConfig = column.touchConfig;
                    if (touchConfig) {
                        column.applyState(touchConfig);
                    }
                });
            }
        }
    }

    /**
     * Get the {@link Grid.data.ColumnStore ColumnStore} used by this Grid.
     *
     * @property {Grid.data.ColumnStore}
     * @category Common
     * @readonly
     */
    get columns() {
        return this._columnStore;
    }

    onColumnsChanged({ action, changes, record : column }) {
        const me = this;

        // this.onPaint will handle changes caused by updateResponsive
        if (!me.isPainted) {
            return;
        }

        if (action === 'update') {
            // Just updating width is already handled in a minimal way.
            if ('width' in changes || 'minWidth' in changes || 'flex' in changes) {
                // Update any leaf columns that want to be repainted on size change
                if (me.isPainted) {
                    const region = column.region;

                    me.columns.visibleColumns.forEach((col) => {
                        if (col.region === region && col.repaintOnResize) {
                            me.refreshColumn(col);
                        }
                    });
                }
                return;
            }

            // Column toggled, need to recheck if any visible column has flex
            if ('hidden' in changes) {
                const subGrid = me.getSubGridFromColumn(column.id);
                subGrid.header.fixHeaderWidths();
                if (subGrid.footer) {
                    subGrid.footer.fixFooterWidths();
                }
                subGrid.updateHasFlex();
            }
        }

        // New columns set ("reconfiguring"), or moved to previously not available region
        if (action === 'dataset' || (changes && ('region' in changes) && !me.regions.includes(changes.region.value))) {
            // Create required subgrids (removing existing)
            me.initSubGrids();
            // Render and jump start them
            me.eachSubGrid(subGrid => {
                subGrid.render(me.verticalScroller);
                subGrid.initScroll();
            });
        }

        if (!me._suspendRenderContentsOnColumnsChanged) {
            me.renderContents();
        }
    }

    onColumnsResized({ changes, record : column }) {
        const
            me       = this,
            setWidth = changes.width && column.flex == null,
            setMinWidth = changes.minWidth && column.flex == null,
            setFlex  = changes.flex && column.width == null,
            domWidth = DomHelper.setLength(column.width),
            domMinWidth = DomHelper.setLength(column.minWidth),
            subGrid  = me.getSubGridFromColumn(column.id);

        // Let header and footer fix their own widths
        subGrid.header.fixHeaderWidths();
        if (subGrid.footer) {
            subGrid.footer.fixFooterWidths();
        }
        subGrid.updateHasFlex();

        if (!me.cellEls || column !== me.lastColumnResized) {
            me.cellEls = DomHelper.children(
                me.element,
                `.b-grid-cell[data-column-id=${column.id}]`
            );
            me.lastColumnResized = column;
        }

        for (const cell of me.cellEls) {
            if (setWidth) {
                // https://app.assembla.com/spaces/bryntum/tickets/8041
                // Although header and footer elements must be sized
                // using flex-basis to avoid the busting out problem,
                // grid cells MUST be sized using width since rows are absolutely
                // positioned and will not cause the busting out problem,
                // and rows will not stretch to shrinkwrap the cells
                // unless they are widthed with width.
                cell.style.width = domWidth;
                cell.style.flex = '';

                // IE11 calculates flexbox container width based on min-width rather than actual width. When column
                // has width defined greater than minWidth, row may have incorrect width
                if (BrowserHelper.isIE11) {
                    cell.style.minWidth = domWidth;
                }
            }
            else if (setMinWidth) {
                cell.style.minWidth = domMinWidth;
            }
            else if (setFlex) {
                cell.style.flex = column.flex;
                cell.style.width = '';
            }
            else {
                cell.style.flex = cell.style.width = cell.style.minWidth = '';
            }
        }

        // If we're being driven by the ColumnResizer, it will
        // call afterColumnsResized.
        if (!me.dragResizing) {
            me.afterColumnsResized();
        }
    }

    afterColumnsResized() {
        const me = this;

        me.refreshVirtualScrollbars();
        me.eachSubGrid(subGrid => {
            if (!subGrid.collapsed) {
                subGrid.fixWidths();
                subGrid.fixRowWidthsInSafariEdge();
                subGrid.refreshFakeScroll();
            }
        });
        me.onHeightChange();
        me.lastColumnResized = me.cellEls = null;
    }

    // Hook that can be overridden to prepare custom editors, can be used by framework wrappers
    processCellEditor(editorConfig) {}

    //endregion

    //region Rows

    /**
     * Get the Row that is currently displayed at top.
     * @member {Grid.row.Row} topRow
     * @readonly
     * @category Rows
     * @private
     */

    /**
     * Get the Row currently displayed furthest down.
     * @member {Grid.row.Row} bottomRow
     * @readonly
     * @category Rows
     * @private
     */

    /**
     * Get Row for specified record id.
     * @function getRowById
     * @param {Core.data.Model|String|Number} recordOrId Record id (or a record)
     * @returns {Grid.row.Row} Found Row or null if record not rendered
     * @category Rows
     * @private
     */

    /**
     * Returns top and bottom for rendered row or estimated coordinates for unrendered.
     * @function getRecordCoords
     * @param {Core.data.Model|string|Number} recordOrId Record or record id
     * @returns {Object} Record bounds with format { top, height, bottom }
     * @category Calculations
     * @private
     */

    /**
     * Get the Row at specified index. "Wraps" index if larger than available rows.
     * @function getRow
     * @param {Number} index
     * @returns {Grid.row.Row}
     * @category Rows
     * @private
     */

    /**
     * Get a Row for either a record, a record id or an HTMLElement
     * @function getRowFor
     * @param {HTMLElement|Core.data.Model|String|Number} recordOrId Record or record id or HTMLElement
     * @returns {Grid.row.Row} Found Row or null if record not rendered
     * @category Rows
     * @private
     */

    /**
     * Get a Row from an HTMLElement
     * @function getRowFromElement
     * @param {HTMLElement} element
     * @returns {Grid.row.Row} Found Row or null if record not rendered
     * @category Rows
     * @private
     */

    get rowManager() {
        const me = this;

        // Use row height from CSS if not specified in config. Did not want to turn this into a getter/setter for
        // rowHeight since RowManager will plug its implementation into Grid when created below, and after initial
        // configuration that is what should be used
        if (!me._isRowMeasured) {
            me.measureRowHeight();
        }

        // RowManager is a plugin, it is configured with its grid as its "client".
        // It uses client.store as its record source.

        return me._rowManager || (me._rowManager = new RowManager({
            grid          : me,
            rowHeight     : me.rowHeight,
            rowScrollMode : me.rowScrollMode || 'move',
            autoHeight    : me.autoHeight,
            listeners     : {
                changetotalheight   : me.onRowManagerChangeTotalHeight,
                requestscrollchange : me.onRowManagerRequestScrollChange,
                thisObj             : me
            }
        }));
    }

    toggleEmptyText() {
        this.bodyContainer && this.bodyContainer.classList[this.rowManager.rowCount || this.store.isLoading ? 'remove' : 'add']('b-grid-empty');
    }

    //endregion

    //region Store

    /**
     * Hooks up data store listeners
     * @private
     * @category Store
     */
    bindStore(store) {
        if (store) {
            const me = this;

            me.storeDetacher = store.on({
                refresh       : me.onStoreDataChange,
                update        : me.onStoreUpdateRecord,
                add           : me.onStoreAdd,
                remove        : me.onStoreRemove,
                move          : me.onStoreMove,
                replace       : me.onStoreReplace,
                removeall     : me.onStoreRemoveAll,
                beforerequest : me.onStoreBeforeRequest,
                afterrequest  : me.onStoreAfterRequest,
                clearchanges  : me.onStoreDataChange,
                exception     : me.onStoreException,
                commit        : me.onStoreCommit
            }, me);
        }
    }

    get store() {
        return this._store;
    }

    /**
     * Get/set the store used by this Grid. The setter accepts Store or a configuration object for a store.
     * If the configuration contains a `readUrl`, an AjaxStore will be created.
     * @property {Core.data.Store|Object}
     * @category Common
     */
    set store(store) {
        const
            me             = this,
            { rowManager } = me,  // We must force instantiation of the RowManager when the store is set
            features       = me.initialConfig.features;

        if (store !== me._store) {
            if (me.storeDetacher) {
                me.storeDetacher();
                me.storeDetacher = null;
            }

            if (store) {

                if (store instanceof Store) ;
                else {
                    const storeCfg = {};
                    if (me.data) {
                        storeCfg.data = me.data;
                    }
                    if (features && features.tree) {
                        storeCfg.tree = true;
                    }
                    // extend GridRowModel to not pollute it with custom fields (if we have multiple grids on page)
                    if (!store.modelClass) {
                        storeCfg.modelClass = class extends GridRowModel {};
                    }

                    store = new (store.readUrl ? AjaxStore : Store)(Object.assign(storeCfg, store));
                }

                me._store = store;

                me.bindStore(store);

                // Changing store when painted -> refresh rows to reflect new data
                if (me.isPainted) {
                    rowManager.reinitialize();
                }
            }
            else {
                if (me.destroyStore) {
                    me._store.destroy();
                }
                me._store = null;
            }
        }
    }

    /**
     * Rerenders a cell if a record is updated in the store
     * @private
     * @category Store
     */
    onStoreUpdateRecord({ source : store, record, changes }) {
        const me = this;

        if (me.forceFullRefresh) {
            // flagged to need full refresh (probably from using GroupSummary)
            me.rowManager.refresh();

            me.forceFullRefresh = false;
        }
        else {
            let row;
            // Search for old row if id was changed
            if (record.isFieldModified('id')) {
                row = me.getRowFor(record.meta.modified.id);
            }

            row = row || me.getRowFor(record);
            // not rendered, bail out
            if (!row) return;

            // We must refresh the full row if it's a special row which has signalled
            // an update because it has no cells.
            if (me.fullRowRefresh || record.meta.specialRow) {
                const index = store.indexOf(record);
                if (index !== -1) {
                    row.render(index, record);
                }
            }
            else {
                me.columns.visibleColumns.forEach(column => {
                    const
                        field = column.field,
                        isSafe = column.constructor.simpleRenderer && !(Object.prototype.hasOwnProperty.call(column.data, 'renderer'));

                    // If there's a  non-safe renderer, that is a renderer which draws values from elsewhere
                    // than just its configured field, that column must be refreshed on every record update.
                    // Obviously, if the column's configured field is changed that also means it's refreshed.
                    if (!isSafe || changes[field]) {
                        const cell = row.getCell(field);
                        if (cell) {
                            row.renderCell(cell, record);
                        }
                    }
                });
            }
        }
    }

    refreshFromRowOnStoreAdd(row, context) {
        const
            me             = this,
            { rowManager } = me;

        rowManager.renderFromRow(row);
        rowManager.trigger('changeTotalHeight', { totalHeight : rowManager.totalHeight });

        // First record? Also update fake scrollers
        // TODO: Consider making empty grid scrollable to not have to do this
        if (me.store.count === 1) {
            me.callEachSubGrid('refreshFakeScroll');
        }
    }

    /**
     * Refreshes rows when data is added to the store
     * @private
     * @category Store
     */
    onStoreAdd({ source : store, records, index, oldIndex, isChild, oldParent, isMove }) {
        // Do not react if the content has not been rendered
        if (!this.isPainted) {
            return;
        }

        // If it's the addition of a child to a collapsed zone, the UI does not change.
        if (isChild && !records[0].ancestorsExpanded(store)) {
            return;
        }

        this.rowManager.calculateRowCount(false, true, true);

        const
            me             = this,
            { rowManager } = me,
            {
                topIndex,
                rows,
                rowCount
            }              = rowManager,
            bottomIndex    = rowManager.topIndex + rowManager.rowCount - 1,
            dataStart      = index,
            dataEnd        = index + records.length - 1,
            atEnd          = bottomIndex >= store.count - records.length - 1;

        // When moving a node within a tree we might need the redraw to include its old parent and its children. Not worth
        // the complexity of trying to do a partial render for this, rerender all rows to be safe.
        // Moving records within a flat store is handled elsewhere, in onStoreMove
        // TODO: Moving within a tree should also trigger 'move' (https://app.assembla.com/spaces/bryntum/tickets/7270)
        if (oldParent || oldIndex > -1 || (isChild && isMove)) {
            rowManager.refresh();
        }
        // Added block starts in our visible block. Render from there downwards.
        else if (dataStart >= topIndex && dataStart < topIndex + rowCount) {
            me.refreshFromRowOnStoreAdd(rows[dataStart - topIndex], ...arguments);
        }
        // Added block ends in our visible block, render block
        else if (dataEnd >= topIndex && dataEnd < topIndex + rowCount) {
            rowManager.refresh();
        }
        // If added block is outside of the visible area, no visible change
        // but potentially a change in total dataset height.
        else {
            // If we are against the end of the dataset, and have appended records
            // ensure they are rendered below
            if (atEnd && index > bottomIndex) {
                rowManager.fillBelow(me._scrollTop);
            }
            rowManager.trigger('changeTotalHeight', { totalHeight : rowManager.totalHeight });
        }
    }

    /**
     * Responds to exceptions signalled by the store
     * @private
     * @category Store
     */
    onStoreException(event) {
        const me = this;

        let message;

        switch (event.type) {
            case 'server':
                message = (event.response.message || 'Unspecified failure');
                break;

            case 'exception':
                if (event.exceptionType === 'network') {
                    message = 'Network error';
                }
                else {
                    // Server sent something that couldn't be parsed
                    message =  event.error && event.error.message || 'Failed to parse server response';
                }
                break;

            default:
                message = ((event.response.status + ' - ' + event.response.statusText) || 'Unknown error');
        }

        // eslint-disable-next-line
        const messageHTML = `<div class="b-grid-load-failure">
                <div class="b-grid-load-fail">${me.L('loadFailedMessage')}</div>
                <div class="b-grid-load-fail">${event.response && event.response.url ? (event.response.url + ' responded with') : ''}</div>
                <div class="b-grid-load-fail">${message}</div>
            </div>`;

        if (me.activeMask) {
            me.activeMask.icon = me.loadMaskErrorIcon;
            me.activeMask.text = messageHTML;

            me.loadmaskHideTimer = me.setTimeout(() => {
                me.unmaskBody();
            }, me.loadMaskHideTimeout);
        }
    }

    /**
     * Refreshes rows when data is changed in the store
     * @private
     * @category Store
     */
    onStoreDataChange({ action, changes, source : store }) {
        // If the next mixin up the inheritance chain has an implementation, call it
        super.onStoreDataChange && super.onStoreDataChange(...arguments);

        const
            me = this,
            isGroupFieldChange = store.isGrouped && changes && store.groupers.some(grouper => grouper.field in changes);

        // If it's new data, the old calculation is invalidated.
        if (action === 'dataset') {
            me.rowManager.averageRowHeight = null;
        }
        // No need to rerender if it's a change of the value of the group field which
        // will be responded to by StoreGroup
        if (me.isPainted && !isGroupFieldChange) {
            // Return to top if setting new data or is filtering
            me.renderRows(null, preserveScroll[action]);
        }

        me.toggleEmptyText();
    }

    /**
     * Shows a load mask while the connected store is loading
     * @private
     * @category Store
     */
    onStoreBeforeRequest() {
        if (this.loadMask) {
            this.maskBody(this.loadMask);
        }
    }

    /**
     * Hides load mask after a load request ends either in success or failure
     * @private
     * @category Store
     */
    onStoreAfterRequest(event) {
        if (this.activeMask && !event.exception) {
            this.unmaskBody();
            this.toggleEmptyText();
        }
    }

    /**
     * Animates removal of record.
     * @private
     * @category Store
     */
    onStoreRemove({ records, isCollapse, isChild, isMove }) {
        // Do not react if the content has not been rendered,
        // or if it is a move, which will be handled by onStoreAdd
        if (!this.isPainted || isMove) {
            return;
        }

        // GridSelection mixin does its job on records removing
        super.onStoreRemove && super.onStoreRemove(...arguments);

        let topRowIndex = (2 ** 53) - 1;

        const
            me             = this,
            { rowManager } = this,
            // Gather all visible rows which need to be removed.
            rowsToRemove   = records.reduce((result, record) => {
                const row = rowManager.getRowById(record.id);
                if (row) {
                    result.push(row);
                    // Rows are repositioned in the array, it matches visual order. Need to find actual index in it
                    topRowIndex = Math.min(topRowIndex, rowManager.rows.indexOf(row));
                }
                return result;
            }, []);

        if (me.animateRemovingRows && rowsToRemove.length && !isCollapse && !isChild) {
            const topRow = rowsToRemove[0];

            me.isAnimating = true;

            // As soon as first row has disappeared, rerender the view
            EventHelper.onTransitionEnd({
                element  : topRow._elementsArray[0],
                property : 'left',

                // Detach listener after timeout even if event wasn't fired
                timeout : me.transitionDurationTimeout,
                thisObj : me,
                handler() {
                    me.isAnimating = false;

                    rowsToRemove.forEach(row => !row.isDestroyed && row.removeCls('b-removing'));
                    rowManager.refresh();

                    // undocumented internal event for scheduler
                    me.trigger('rowRemove');
                }
            });

            rowsToRemove.forEach(row => row.addCls('b-removing'));
        }
        else {
            // Potentially remove rows and change dataset height
            rowManager.calculateRowCount(false, true, true);

            // If there were rows below which have moved up into place
            // then repurpose them with their new records
            if (rowManager.rows[topRowIndex]) {
                rowManager.renderFromRow(rowManager.rows[topRowIndex]);
            }
            // If nothing to render below, just update dataset height
            else {
                rowManager.trigger('changeTotalHeight', { totalHeight : rowManager.totalHeight });
            }
            me.trigger('rowRemove', { isCollapse });
        }
    }

    onStoreMove({ from, to }) {
        const
            { rowManager }       = this,
            {
                topIndex,
                rowCount
            }                    = rowManager,
            [dataStart, dataEnd] = [from, to].sort();

        // Changed block starts in our visible block. Render from there downwards.
        if (dataStart >= topIndex && dataStart < topIndex + rowCount) {
            rowManager.renderFromRow(rowManager.rows[dataStart - topIndex]);
        }
        // Changed block ends in our visible block, render block
        else if (dataEnd >= topIndex && dataEnd < topIndex + rowCount) {
            rowManager.refresh();
        }
        // If changed block is outside of the visible area, this is a no-op
    }

    onStoreReplace({ records, all }) {
        if (all) {
            this.rowManager.refresh();
        }
        else {
            const rows = records.reduce((rows, [, record]) => {
                const row = this.getRowFor(record);
                if (row) {
                    rows.push(row);
                }
                return rows;
            }, []);

            this.rowManager.renderRows(rows);
        }
    }

    /**
     * Rerenders grid when all records have been removed
     * @private
     * @category Store
     */
    onStoreRemoveAll() {
        // GridSelection mixin does its job on records removing
        super.onStoreRemoveAll && super.onStoreRemoveAll(...arguments);

        if (this.isPainted) {
            this.renderRows();
            this.toggleEmptyText();
        }
    }

    // Refresh dirty cells on commit
    onStoreCommit({ changes }) {
        if (this.showDirty && changes.modified.length) {
            const rows = [];
            changes.modified.forEach(record => {
                const row = this.rowManager.getRowFor(record);
                row && rows.push(row);
            });
            this.rowManager.renderRows(rows);
        }
    }

    /**
     * Convenience functions for getting/setting data in related store
     * @property {Object[]}
     * @category Common
     */
    get data() {
        if (this._store) {
            return this._store.records;
        }
        else {
            return this._data;
        }
    }

    set data(data) {
        if (this._store) {
            this._store.data = data;
        }
        else {
            this._data = data;
        }
    }

    get emptyText() {
        return this._emptyText;
    }

    set emptyText(text) {
        this._emptyText = text;
        this.eachSubGrid(subGrid => subGrid.emptyText = text);
    }

    //endregion

    //region Context menu items

    /**
     * Populates the header context menu. Chained in features to add menu items.
     * @param column Column for which the menu will be shown
     * @param items Array of menu items, add to it and return it
     * @category Menu items
     * @internal
     */
    getHeaderMenuItems(column, items) {
        const me       = this,
            { subGrids, regions } = me;

        let first = true;

        Object.entries(subGrids).forEach(([region, subGrid]) => {
            // If SubGrid is configured with a sealed column set, do not allow moving into it
            if (subGrid.sealedColumns) {
                return;
            }

            if (column.draggable &&
                region !== column.region &&
                (!column.parent && subGrids[column.region].columns.count > 1 ||
                    column.parent && column.parent.children.length > 1)
            ) {
                const moveRight = subGrid.element.compareDocumentPosition(subGrids[column.region].element) === document.DOCUMENT_POSITION_PRECEDING,
                    // With 2 regions, use Move left, Move right. With multiple, include region name
                    text = regions.length > 2
                        ? me.L('Move column to ') + region
                        : me.L(moveRight ? 'moveColumnRight' : 'moveColumnLeft');

                items.push({
                    targetSubGrid : region,
                    text,
                    icon          : 'b-fw-icon ' + (moveRight ? 'b-icon-column-move-right' : 'b-icon-column-move-left'),
                    name          : 'moveColumn',
                    cls           : first ? 'b-separator' : '',
                    onItem        : ({ item }) => {
                        const { column } = item;

                        column.traverse(col => col.region = region);

                        // Changing region will move the column to the correct SubGrid, but we want it to go last
                        me.columns.insert(me.columns.indexOf(subGrids[item.targetSubGrid].columns.last) + 1, column);

                        me.scrollColumnIntoView(column);
                    }
                });

                first = false;
            }
        });
    }

    /**
     * Populates the cell context menu. Chained in features to add menu items.
     * @param column {Grid.column.Column} Column for which the menu will be shown
     * @param record {Core.data.Model} Record (row) for which the menu will be shown
     * @param items {Object[]} Array of menu items, add to it and return it
     * @category Menu items
     * @internal
     */
    getCellMenuItems(column, record, items) {
        const me = this;

        if (me.showRemoveRowInContextMenu && !me.readOnly && record && !record.meta.specialRow) {
            if (me.selectedRecords.length > 1) {
                items.push(
                    {
                        text   : me.L('removeRows'),
                        icon   : 'b-fw-icon b-icon-trash',
                        name   : 'removeRows',
                        onItem : () => me.store.remove(me.selectedRecords)
                    }
                );
            }
            else {
                items.push(
                    {
                        text   : me.L('removeRow'),
                        icon   : 'b-fw-icon b-icon-trash',
                        name   : 'removeRow',
                        onItem : () => me.store.remove(record)
                    }
                );
            }
        }
    }

    getColumnDragToolbarItems(column, items) {
        return items;
    }

    //endregion

    //region Getters

    normalizeCellContext(cellContext) {
        const { columns, store } = this;

        // TODO: should clone instead of modify?
        // TODO: The answer is to use the Grid/util/Location class to robustly encapsulate a record/column intersection
        // And have them immutable, so that to change is to clone, as explained by MaximGB,
        // we want to use columnId for precision, but allow user to specify column name for ease of use...
        // modify cellContext to include columnId in those cases
        if (cellContext instanceof store.modelClass) {
            return {
                record   : cellContext,
                id       : cellContext.id,
                columnId : columns.bottomColumns[0].id
            };
        }
        if (!('columnId' in cellContext)) {
            if ('field' in cellContext) {
                const column = columns.get(cellContext.field);
                cellContext.columnId = column && column.id;
            }
            else if ('column' in cellContext) {
                const column = (typeof cellContext.column === 'number') ? columns.bottomColumns[cellContext.column] : cellContext.column;
                cellContext.columnId = column && column.id;
            }

            // Fall back to first leaf column
            if (!('columnId' in cellContext)) {
                cellContext.columnId = columns.bottomColumns[0].id;
            }
        }

        if ('id' in cellContext) {
            // If the context is for an element, but it's stale (for a removed record)
            // then fix it up to refer to the record id at the same index.
            if (cellContext.element && (!store.getById(cellContext.id))) {
                // This uses the data-index property to get the row at that index.
                const newRec = this.getRecordFromElement(cellContext.element);

                // We have a record at the same index.
                if (newRec) {
                    cellContext.id = newRec.id;
                }
            }
        }
        else {
            if ('row' in cellContext) {
                cellContext.id = store.getAt(cellContext.row).id;
            }
            else if ('record' in cellContext) {
                cellContext.id = cellContext.record.id;
            }
        }

        return cellContext;
    }

    // TODO: move to RowManager? Or create a CellManager?
    /**
     * Returns a cell if rendered.
     * @param {Object} cellContext { id: rowId, columnId: columnId [,column: column number, field: column field] }
     * @param {Number} [cellContext.row] The row index of the row to access. Exclusive with `id` and 'record'.
     * @param {String|Number} [cellContext.id] The record id of the row to access. Exclusive with `row` and 'record'.
     * @param {Core.data.Model} [cellContext.record] The record of the row to access. Exclusive with `id` and 'row'.
     * @param {Number} [cellContext.column] The column instance or the index of the cell to access.  Exclusive with `columnId`.
     * @param {String|Number} [cellContext.columnId] The column id of the column to access. Exclusive with `column`.
     * @param {String} [cellContext.field] The field of the column to access. Exclusive with `column`.
     * @returns {HTMLElement}
     * @category Getters
     */
    getCell(cellContext) {
        let row,
            result = null;

        cellContext = this.normalizeCellContext(cellContext);

        if ('id' in cellContext) {
            row = this.getRowById(cellContext.id);
        }

        if (row && ('columnId' in cellContext)) {
            result = row.getCell(cellContext.columnId);
        }

        return result;
    }

    //TODO: Should move to ColumnManager? Or Header?
    /**
     * Returns the header element for the column
     * @param {String|Number|Grid.column.Column} columnId or Column instance
     * @returns {HTMLElement} Header element
     * @category Getters
     */
    getHeaderElement(columnId) {
        if (typeof columnId !== 'string') {
            columnId = columnId.id;
        }

        return this.fromCache(`.b-grid-header[data-column-id="${columnId}"]`);
    }

    getHeaderElementByField(field) {
        const column = this.columns.get(field);

        return column ? this.getHeaderElement(column) : null;
    }

    /**
     * Body height
     * @property {Number}
     * @readonly
     * @category Layout
     */
    get bodyHeight() {
        return this._bodyHeight;
    }

    /**
     * Header height
     * @property {Number}
     * @readonly
     * @category Layout
     */
    get headerHeight() {
        const me = this;
        // measure header if rendered and not stored
        if (me.isPainted && !me._headerHeight) {
            me._headerHeight = me.headerContainer.offsetHeight;
        }

        return me._headerHeight;
    }

    /**
     * Searches up from the specified element for a grid row and returns the record associated with that row.
     * @param {HTMLElement} element Element somewhere within a row or the row container element
     * @returns {Core.data.Model} Record for the row
     * @category Getters
     */
    getRecordFromElement(element) {
        const el = element.closest('.b-grid-row');

        if (!el) return null;

        return this.store.getAt(el.dataset.index);
    }

    /**
     * Searches up from specified element for a grid cell or an header and returns the column which the cell belongs to
     * @param {HTMLElement} element Element somewhere in a cell
     * @returns {Grid.column.Column} Column to which the cell belongs
     * @category Getters
     */
    getColumnFromElement(element) {
        const cell = DomHelper.up(element, '.b-grid-cell, .b-grid-header');
        if (!cell) return null;

        if (cell.matches('.b-grid-header')) {
            return this.columns.getById(cell.dataset.columnId);
        }

        const cellData = DomDataStore.get(cell);
        return this.columns.getById(cellData.columnId);
    }

    // Getter and setter for autoHeight only added for type checking, since it seems common to get it wrong in react/angular
    get autoHeight() {
        return this._autoHeight;
    }

    set autoHeight(autoHeight) {
        ObjectHelper.assertBoolean(autoHeight, 'autoHeight');

        this._autoHeight = autoHeight;
    }

    /**
     * Toggle column line visibility. End result might be overruled by/differ between themes.
     * @property {Boolean}
     */
    get columnLines() {
        return this._columnLines;
    }

    set columnLines(columnLines) {
        ObjectHelper.assertBoolean(columnLines, 'columnLines');

        DomHelper.toggleClasses(this.element, 'b-no-column-lines', !columnLines);

        this._columnLines = columnLines;
    }

    //endregion

    //region ReadOnly

    /**
     * Get/set read only mode, which prevents cell editing etc.
     * Exactly what is prevented is up to each feature.
     * @property {Boolean}
     * @fires readonly
     * @category Common
     */
    set readOnly(readOnly) {
        const me = this;
        me._readOnly = readOnly;
        if (me.isPainted) {
            /**
             * Fired when grids read only state is toggled
             * @event readOnly
             * @param {Boolean} readOnly Read only or not
             */
            me.trigger('readOnly', { readOnly });

            // IE11 doesnt support this
            //me.element.classList.toggle('b-readonly', readOnly);
            if (readOnly) {
                me.element.classList.add('b-readonly');
            }
            else {
                me.element.classList.remove('b-readonly');
            }
        }
    }

    get readOnly() {
        return this._readOnly;
    }

    //endregion

    //region Fix width & height

    /**
     * Sets widths and heights for headers, rows and other parts of the grid as needed
     * @private
     * @category Width & height
     */
    fixSizes() {
        // subGrid width
        this.callEachSubGrid('fixWidths');
    }

    onRowManagerChangeTotalHeight({ totalHeight }) {
        return this.refreshTotalHeight(totalHeight);
    }

    /**
     * Makes height of vertical scroller match estimated total height of grid. Called when scrolling vertically and
     * when showing/hiding rows.
     * @param {Number} height
     * @private
     * @category Width & height
     */
    refreshTotalHeight(height = this.rowManager.totalHeight) {
        const me = this;

        // Veto change of estimated total height while rendering rows or if triggered while in a hidden state
        if (me.renderingRows || !me.isVisible) {
            return false;
        }
        if (me.rowManager.bottomRow) {
            height = Math.max(height, me.rowManager.bottomRow.bottom);
        }

        const
            scroller     = me.scrollable,
            delta        = Math.abs(me.virtualScrollHeight - height),
            clientHeight = me._bodyRectangle.height,
            newMaxY      = height - clientHeight;

        if (delta) {
            const
                // We must update immediately if we are nearing the end of the scroll range.
                isCritical = (newMaxY - me._scrollTop < clientHeight * 2) ||
                    // Or if we have scrolled pass visual height
                    (me._verticalScrollHeight && (me._verticalScrollHeight - clientHeight < me._scrollTop));

            // Update the true scroll range using the scroller. This will not cause a repaint.
            scroller.scrollHeight = me.virtualScrollHeight = height;

            // If we are scrolling, put this off because it causes
            // a full document layout and paint.
            if (me.scrolling && !isCritical) {
                if (!me.virtualScrollHeightDirty) {
                    me.virtualScrollHeightDirty = scroller.on({
                        scrollend : me.fixElementHeights,
                        thisObj   : me,
                        once      : true
                    });
                }
            }
            else {
                me.virtualScrollHeightDirty && me.virtualScrollHeightDirty();
                me.fixElementHeights(height);
            }
        }
    }

    fixElementHeights() {
        const
            me         = this,
            height     = me.virtualScrollHeight,
            heightInPx = `${height}px`;

        me._verticalScrollHeight = height;
        me.verticalScroller.style.height = heightInPx;
        me.virtualScrollHeightDirty = false;

        if (me.autoHeight) {
            me.bodyContainer.style.height = heightInPx;
            me._bodyHeight = height;
            me._bodyRectangle = Rectangle.client(me.bodyContainer);
        }

        me.refreshVirtualScrollbars();
    }

    //endregion

    //region Scroll & virtual rendering

    set scrolling(scrolling) {
        this._scrolling = scrolling;
    }

    get scrolling() {
        return this._scrolling;
    }

    /**
     * Activates automatic scrolling of a subGrid when mouse is moved closed to the edges
     * @param {Grid.view.SubGrid|String} subGrid A subGrid instance or its region name
     */
    enableScrollingCloseToEdges(subGrid) {
        if (typeof subGrid === 'string') {
            subGrid = this.subGrids[subGrid];
        }

        this.scrollManager.startMonitoring({
            element : subGrid.element
        });
    }

    /**
     * Deactivates automatic scrolling of a subGrid when mouse is moved closed to the edges
     * @param {Grid.view.SubGrid|String} subGrid A subGrid instance or its region name
     */
    disableScrollingCloseToEdges(subGrid) {
        if (typeof subGrid === 'string') {
            subGrid = this.subGrids[subGrid];
        }

        this.scrollManager.stopMonitoring(subGrid.element);
    }

    /**
     * Responds to request from RowManager to adjust scroll position. Happens when jumping to a scroll position with
     * variable row height.
     * @param {Number} bottomMostRowY
     * @private
     * @category Scrolling
     */
    onRowManagerRequestScrollChange({ bottom }) {
        this.scrollable.y = bottom - this.bodyHeight;
    }

    

    /**
     * Scroll syncing for normal headers & grid + triggers virtual rendering for vertical scroll
     * @private
     * @fires scroll
     * @category Scrolling
     */
    initScroll() {
        const me = this;
        // This method may be called early, before render calls it, so ensure that it's
        // only executed once.
        if (!me.scrollInitialized) {
            let scrollTop;

            const onScroll = me.createOnFrame(() => {
                scrollTop = me.scrollable.y;

                // Was getting scroll events in FF where scrollTop was unchanged, ignore those
                if (scrollTop !== me._scrollTop) {
                    me._scrollTop = scrollTop;

                    if (!me.scrolling) {
                        me.scrolling = true;
                        me.eachSubGrid(s => s.suspendResizeMonitor = true);
                    }

                    

                    me.rowManager.updateRenderedRows(scrollTop);

                    /**
                        * Grid has scrolled vertically
                        * @event scroll
                        * @param {Grid.view.Grid} grid
                        * @param {Number} scrollTop
                        */
                    me.trigger('scroll', { scrollTop });
                }
            });

            me.scrollInitialized = true;

            me.scrollable.on({
                scroll : onScroll,
                scrollend() {
                    me.scrolling = false;
                    me.eachSubGrid(s => s.suspendResizeMonitor = false);
                }
            });

            me.callEachSubGrid('initScroll');

            
        }
    }

    // TODO: rename to scrollRecordIntoView? Or have an alias?
    /**
     * Scrolls a row into view. If row isn't rendered it tries to calculate position
     * @param {Core.data.Model|String|Number} recordOrId Record or record id
     * @param {Object} [options] How to scroll.
     * @param {String} [options.column] Field name or ID of the column, or the Column instance to scroll to.
     * @param {String} [options.block] How far to scroll the element: `start/end/center/nearest`.
     * @param {Number} [options.edgeOffset] edgeOffset A margin around the element or rectangle to bring into view.
     * @param {Boolean|Number} [options.animate] Set to `true` to animate the scroll, or the number of milliseconds to animate over.
     * @param {Boolean} [options.highlight] Set to `true` to highlight the element when it is in view.
     * @category Scrolling
     * @returns {Promise} A promise which resolves when the specified row has been scrolled into view.
     */
    scrollRowIntoView(recordOrId, options = defaultScrollOptions$2) {
        const
            me            = this,
            blockPosition = options.block || 'nearest',
            rowManager    = me.rowManager;

        recordOrId = me.store.getById(recordOrId);

        if (recordOrId) {
            // check that record is "displayable", not filtered out or hidden by collapse
            if (me.store.indexOf(recordOrId) === -1) {
                return resolvedPromise;
            }

            let scroller   = me.scrollable,
                recordRect = me.getRecordCoords(recordOrId);

            const scrollerRect = Rectangle.from(scroller.element);

            // If it was calculated from the index, update the rendered rowScrollMode
            // and scroll to the actual element. Note that this should only be necessary
            // for variableRowHeight.
            // But to "make the tests green", this is a workaround for a buffered rendering
            // bug when teleporting scroll. It does not render the rows at their correct
            // positions. Please do not try to "fix" this. I will do it. NGW
            if (recordRect.virtual) {
                const virtualBlock = recordRect.block;

                // Scroll the calculated position to the center of the scrollingViewport
                // and then update the rendered block while asking the RowManager to
                // display the required recordOrId.
                scroller.scrollIntoView(recordRect, {
                    block : 'center'
                });
                rowManager.scrollTargetRecordId = recordOrId;
                rowManager.updateRenderedRows(scroller.y, true);
                recordRect = me.getRecordCoords(recordOrId);
                rowManager.lastScrollTop = scroller.y;

                if (recordRect.virtual) {
                    
                    // bail out to not get caught in infinite loop, since code above is cut out of bundle
                    // eslint-disable-next-line no-useless-return,no-unreachable
                    return resolvedPromise;
                }

                const innerOptions = blockPosition !== 'nearest' ? options : {
                    block : virtualBlock
                };

                // Scroll the target just less than append/prepend buffer height out of view so that the animation looks good
                if (options.animate) {
                    // Do not fire scroll events during this scroll sequence - it's a purely cosmetic operation.
                    // We are scrolling the desired row out of view merely to *animate scroll* it to the requested position.
                    scroller.suspendEvents();

                    // Scroll to its final position
                    if (blockPosition === 'end' || blockPosition === 'nearest' && virtualBlock === 'end') {
                        scroller.y -= (scrollerRect.bottom - recordRect.bottom);
                    }
                    else if (blockPosition === 'start' || blockPosition === 'nearest' && virtualBlock === 'start') {
                        scroller.y += (recordRect.y - scrollerRect.y);
                    }

                    // Ensure rendered block is correct at that position
                    rowManager.updateRenderedRows(scroller.y, false, true);

                    // Scroll away from final position to enable a cosmetic scroll to final position
                    if (virtualBlock === 'end') {
                        scroller.y -= (rowManager.appendRowBuffer * rowManager.rowHeight - 1);
                    }
                    else {
                        scroller.y += (rowManager.prependRowBuffer * rowManager.rowHeight - 1);
                    }

                    // The row will still be rendered, so scroll it using the scroller directly
                    const result = scroller.scrollIntoView(me.getRecordCoords(recordOrId), Object.assign({}, options, innerOptions));

                    // Now we're at the required position, resume events
                    return result.then(() => scroller.resumeEvents());
                }
                else {
                    return me.scrollRowIntoView(recordOrId, Object.assign({}, options, innerOptions));
                }
            }
            else {
                let { column } = options;

                if (column) {
                    if (typeof column === 'string') {
                        column = me.columns.getById(column) || me.columns.get(column);
                    }

                    // If we are targetting a column, we must use the scroller of that column's SubGrid
                    if (column) {
                        scroller = me.getSubGridFromColumn(column).scrollable;

                        const cellRect = Rectangle.from(rowManager.getRowFor(recordOrId).getCell(column.id));

                        recordRect.x = cellRect.x;
                        recordRect.width = cellRect.width;
                    }
                }
                // No column, then tell the scroller not to scroll in the X axis
                else {
                    options.x = false;
                }
                return scroller.scrollIntoView(recordRect, options);
            }
        }
    }

    /**
     * Scrolls a column into view (if it is not already)
     * @param {Grid.column.Column|String|Number} column Column name (data) or column index or actual column object.
     * @param {Object} [options] How to scroll.
     * @param {String} [options.block] How far to scroll the element: `start/end/center/nearest`.
     * @param {Number} [options.edgeOffset] edgeOffset A margin around the element or rectangle to bring into view.
     * @param {Object|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
     * or the number of milliseconds to animate over, or an animation config object.
     * @param {Number} [options.animate.duration] The number of milliseconds to animate over.
     * @param {String} [options.animate.easing] The name of an easing function.
     * @param {Boolean} [options.highlight] Set to `true` to highlight the element when it is in view.
     * @param {Boolean} [options.focus] Set to `true` to focus the element when it is in view.
     * @returns {Promise} If the column exists, a promise which is resolved when the column header element has been scrolled into view.
     * @category Scrolling
     */
    scrollColumnIntoView(column, options) {
        column = (column instanceof Column) ? column : this.columns.get(column) || this.columns.getById(column) || this.columns.getAt(column);

        return this.getSubGridFromColumn(column).scrollColumnIntoView(column, options);
    }

    // TODO The API { id: recordId, column: 'columnName' } is not clear: id has to be renamed to `record` or `recordId` to be self-explanatory;
    /**
     * Scrolls a cell into view (if it is not already)
     * @param {Object} cellContext Cell selector { id: recordId, column: 'columnName' }
     * @category Scrolling
     */
    scrollCellIntoView(cellContext, options) {
        return this.scrollRowIntoView(cellContext.id, Object.assign({
            column : cellContext.columnId
        }, typeof options === 'boolean' ? { animate : options } : options));
    }

    /**
     * Scroll all the way down
     * @returns {Promise} A promise which resolves when the bottom is reached.
     * @category Scrolling
     */
    scrollToBottom(options) {
        // triggers scroll to last record. not using current scroller height because we do not know if it is correct
        return this.scrollRowIntoView(this.store.last, options);
    }

    /**
     * Scroll all the way up
     * @returns {Promise} A promise which resolves when the top is reached.
     * @category Scrolling
     */
    scrollToTop(options) {
        return this.scrollable.scrollBy(0, -this.scrollable.y, options);
    }

    /**
     * Store scroll state (scrollTop for entire grid and scrollLeft per sub grid)
     * @returns {{scrollTop: (*|string|number), scrollLeft: {}}}
     * @category Scrolling
     */
    storeScroll() {
        const
            me    = this,
            state = me.storedScrollState = {
                scrollTop  : me.scrollable.y,
                scrollLeft : {}
            };

        // TODO: Implement special multi-element Scroller subclass for Grids which
        // encapsulates the x axis only Scrollers of all its SubGrids.
        me.eachSubGrid(subGrid => {
            state.scrollLeft[subGrid.region] = subGrid.scrollable.x;
        });

        return state;
    }

    /**
     * Restore scroll state. If state is not specified, restores the last stored state.
     * @param state Scroll state, optional
     * @category Scrolling
     */
    restoreScroll(state = this.storedScrollState) {
        const me = this;

        // TODO: Implement special multi-element Scroller subclass for Grids which
        // encapsulates the x axis only Scrollers of all its SubGrids.
        me.eachSubGrid(subGrid => {
            subGrid.scrollable.x = state.scrollLeft[subGrid.region];
        });

        me.scrollable.y = state.scrollTop;
    }

    //endregion

    //region Theme & measuring

    /**
     * Creates a fake subgrid with one row and mesaures its height. Result is used as rowHeight.
     * @private
     */
    measureRowHeight() {
        const
            me                = this,
            // Create a fake subgrid with one row, since styling for row is specified on .b-grid-subgrid .b-grid-row
            rowMeasureElement = DomHelper.createElement({
                tag       : 'div',
                // TODO: should either get correct widgetClassList or query features for measure classes
                className : 'b-grid ' + (me.features.stripe ? 'b-stripe' : ''),
                style     : 'position: absolute; visibility: hidden',
                html      : '<div class="b-grid-subgrid"><div class="b-grid-row"></div></div>',
                parent    : document.getElementById(me.appendTo) || document.body
            });

        // Use style height or default height from config.
        // Not using clientHeight since it will have some value even if no height specified in CSS
        const
            rowEl        = rowMeasureElement.firstElementChild.firstElementChild,
            styleHeight  = parseInt(DomHelper.getStyleValue(rowEl, 'height')),
            borderTop    = parseInt(DomHelper.getStyleValue(rowEl, 'border-top-width')),
            borderBottom = parseInt(DomHelper.getStyleValue(rowEl, 'border-bottom-width'));

        // Change rowHeight if specified in styling, also remember that value to replace later if theme changes and
        // user has not explicitly set some other height
        if (me.rowHeight == null || me.rowHeight === me._rowHeightFromStyle) {
            me.rowHeight = !isNaN(styleHeight) && styleHeight ? styleHeight : me.defaultRowHeight;
            me._rowHeightFromStyle = me.rowHeight;
        }

        // this measurement will be added to rowHeight during rendering, to get correct cell height
        me._rowBorderHeight = borderTop + borderBottom;

        me._isRowMeasured = true;

        rowMeasureElement.remove();

        // There is a ticket about measuring the actual first row instead:
        // https://app.assembla.com/spaces/bryntum/tickets/5735-measure-first-real-rendered-row-for-rowheight/details
    }

    /**
     * Handler for global theme change event (triggered by shared.js). Remeasures row height.
     * @private
     */
    onThemeChange({ theme }) {
        this.measureRowHeight();
        this.trigger('theme', { theme });
    }

    //endregion

    //region Rendering of rows

    /**
     * Triggers a render of records to all row elements. Call after changing order, grouping etc to reflect changes
     * visually. Preserves scroll.
     * @category Rendering
     */
    refreshRows(returnToTop = false) {
        this.element.classList.add('b-notransition');

        if (returnToTop) {
            this.rowManager.returnToTop();
        }
        else {
            this.rowManager.refresh();
        }

        this.element.classList.remove('b-notransition');
    }

    /**
     * Triggers a render of all the cells in a column.
     * @param {Grid.column.Column} column
     * @category Rendering
     */
    refreshColumn(column) {
        const field = column.field;

        this.rowManager.forEach(row => {
            const cell = row.getCell(field);

            row.renderCell(cell);
        });
    }
    //endregion

    //region Render the grid

    /**
     * Recalculates virtual scrollbars widths and scrollWidth
     * @private
     */
    refreshVirtualScrollbars() {
        // NOTE: This was at some point changed to only run on platforms with width-occupying scrollbars, but it needs
        // to run with overlayed scrollbars also to make them show/hide as they should.

        const
            me                    = this,
            {
                headerContainer,
                footerContainer,
                virtualScrollers,
                scrollable
            }                     = me,
            hasVerticalOverflow   = BrowserHelper.isEdge || BrowserHelper.isIE11
            // IE11 and Edge report 1px scroll when no scroll actually exist, which breaks header margin
            // caught by FilterBar test
                ? Math.abs(scrollable.scrollHeight - scrollable.clientHeight) > 1
                : scrollable.scrollHeight > scrollable.clientHeight,
            // We need to ask each subGrid if it has horizontal overflow.
            // If any do, we show the virtual scroller, otherwise we hide it.
            hasHorizontalOverflow = Object.values(me.subGrids).some(subGrid => subGrid.overflowingHorizontally),
            method = hasVerticalOverflow ? 'add' : 'remove';

        if (hasHorizontalOverflow) {
            virtualScrollers.classList.remove('b-hide-display');
        }
        else {
            virtualScrollers.classList.add('b-hide-display');
        }

        headerContainer.classList[method]('b-grid-vertical-overflow');
        footerContainer.classList[method]('b-grid-vertical-overflow');
        virtualScrollers.classList[method]('b-grid-vertical-overflow');

        // Change of scrollbar status means height change
        me.onHeightChange();

        // Create margin after the headerContainer if the grid has a visible vertical scrollbar
        if (DomHelper.scrollBarWidth) {
            if (hasVerticalOverflow) {
                headerContainer.style.marginRight = footerContainer.style.paddingRight = `${DomHelper.scrollBarWidth - 1}px`;
            }
            else {
                headerContainer.style.marginRight =  footerContainer.style.paddingRight = 0;
            }
        }
    }

    /**
     * Returns content height calculated from row manager
     * @private
     */
    get contentHeight() {
        const rowManager = this.rowManager;
        return Math.max(rowManager.totalHeight, rowManager.bottomRow ? rowManager.bottomRow.bottom : 0);
    }

    onContentChange() {
        const
            me         = this,
            rowManager = me.rowManager;

        if (me.isVisible) {
            rowManager.estimateTotalHeight();
            me.paintListener = null;
            me.refreshTotalHeight(me.contentHeight);
            me.callEachSubGrid('refreshFakeScroll');
            me.onHeightChange();
        }
        // If not visible, this operation MUST be done when we become visible.
        // This is announced by the paint event which is triggered when a Widget
        // really gains visibility, ie is shown or rendered, or it's not hidden,
        // and a hidden/non-rendered ancestor is shown or rendered.
        // See Widget#triggerPaint.
        else if (!me.paintListener) {
            me.paintListener = me.on({
                paint   : 'onContentChange',
                once    : true,
                thisObj : me
            });
        }
    }

    onHeightChange() {
        const
            me = this;
        // cache to avoid recalculations in the middle of rendering code (RowManger#getRecordCoords())
        me._bodyRectangle = Rectangle.client(me.bodyContainer);
        me._bodyHeight = me.autoHeight ? me.contentHeight : me.bodyContainer.offsetHeight;
    }

    /**
     * Called after headers have been rendered to the headerContainer.
     * This does not do anything, it's just for Features to hook in to.
     * @param {HTMLElement} headerContainer DOM element which contains the headers.
     * @param {HTMLElement} element Grid element
     * @private
     * @category Rendering
     */
    renderHeader(headerContainer, element) {}

    /**
     * Called after footers have been rendered to the footerContainer.
     * This does not do anything, it's just for Features to hook in to.
     * @param {HTMLElement} footerContainer DOM element which contains the footers.
     * @param {HTMLElement} element Grid element
     * @private
     * @category Rendering
     */
    renderFooter(footerContainer, element) {}

    suspendRefresh() {
        this.refreshSuspended++;
    }

    resumeRefresh(trigger) {
        if (this.refreshSuspended && !--this.refreshSuspended) {
            if (trigger) {
                this.refreshRows();
            }
        }
    }

    /**
     * Rerenders all grid rows, completely replacing all row elements with new ones
     * @category Rendering
     */
    renderRows(keepScroll = true, returnToTop = false) {
        const
            me          = this,
            scrollState = keepScroll && me.storeScroll();

        if (me.refreshSuspended) {
            return;
        }

        /**
         * Grid rows are about to be rendered
         * @event beforeRenderRows
         * @param {Grid.view.Grid} source This grid.
         */
        me.trigger('beforeRenderRows');
        me.renderingRows = true;

        // This allows us to do things like disable animations on a refresh
        me.element.classList.add('b-grid-refreshing');

        if (returnToTop) {
            me.scrollable.y = me._scrollTop = 0;
        }
        me.rowManager.reinitialize(returnToTop);

        /**
         * Grid rows have been rendered
         * @event renderRows
         * @param {Grid.view.Grid} source This grid.
         */
        me.trigger('renderRows');

        me.renderingRows = false;
        me.onContentChange();

        if (keepScroll) {
            me.restoreScroll(scrollState);
        }

        me.element.classList.remove('b-grid-refreshing');
    }

    /**
     * Rerenders the grids rows, headers and footers, completely replacing all row elements with new ones
     * @category Rendering
     */
    renderContents() {
        const
            me = this,
            { element, headerContainer, footerContainer, rowManager } = me;

        me.emptyCache();

        // columns will be "drawn" on render anyway, bail out
        if (me.isPainted) {
            // reset measured header height, to make next call to get headerHeight measure it
            me._headerHeight = null;

            me.callEachSubGrid('refreshHeader', headerContainer);
            me.callEachSubGrid('refreshFooter', footerContainer);

            // Note that these are hook methods for features to plug in to. They do not do anything.
            me.renderHeader(headerContainer, element);
            me.renderFooter(footerContainer, element);

            me.fixSizes();

            // any elements currently used for rows should be released.
            // actual removal of elements is done in SubGrid#clearRows
            const refreshContext = rowManager.removeAllRows();

            rowManager.calculateRowCount(false, true, true);

            if (rowManager.rowCount) {
                // Sets up the RowManager's position for when renderRows calls RowManager#reinitialize
                // so that it renders the correct data block at the correct position.
                rowManager.setPosition(refreshContext);

                me.renderRows();
            }
        }
    }

    // Render rows etc. on first paint, to make sure Grids element has been laid out
    onPaint() {
        const
            me = this,
            {
                rowManager,
                store,
                element,
                headerContainer,
                bodyContainer,
                footerContainer
            } = me;

        if (me.isPainted) {
            return;
        }

        let columnsChanged,
            maxDepth = 0;

        // See if updateResponsive changed any columns.
        me.columns.on({
            change : () => columnsChanged = true,
            single : true
        });

        // Cached, updated on resize. Used by RowManager and by the subgrids upon their render
        me._bodyRectangle = Rectangle.client(me.bodyContainer);
        const bodyOffsetHeight = me.bodyContainer.offsetHeight;

        // Apply any responsive configs before rendering rows.
        me.updateResponsive(me.width, 0);

        // If there were any column changes, apply them
        if (columnsChanged) {
            me.callEachSubGrid('refreshHeader', headerContainer);
            me.callEachSubGrid('refreshFooter', footerContainer);
        }

        // Note that these are hook methods for features to plug in to. They do not do anything.
        // SubGrids take care of their own rendering.
        me.renderHeader(headerContainer, element);
        me.renderFooter(footerContainer, element);

        if (me.autoHeight) {
            me._bodyHeight = rowManager.initWithHeight(element.offsetHeight - headerContainer.offsetHeight - footerContainer.offsetHeight, true);
            bodyContainer.style.height = me.bodyHeight + 'px';
        }
        else {
            me._bodyHeight = bodyOffsetHeight;
            rowManager.initWithHeight(me._bodyHeight, true);
        }

        me.eachSubGrid(subGrid => {
            if (subGrid.header.maxDepth > maxDepth) {
                maxDepth = subGrid.header.maxDepth;
            }
        });

        headerContainer.dataset.maxDepth = maxDepth;

        me.fixSizes();

        if (store.count || !store.isLoading) {
            me.renderRows(false, false);
        }

        me.initScroll();

        me.initInternalEvents();
    }

    render() {
        const me = this;

        // When displayed inside one of our containers, require a size to be considered visible. Ensures it is painted
        // on display when for example in a tab
        me.requireSize = Boolean(me.owner);

        // Render as a container. This renders the child SubGrids
        super.render(...arguments);

        // Sanity check that main element has been given some sizing styles, unless autoHeight is used in which case
        // it will be sized programmatically instead
        if (!me.autoHeight && me.headerContainer.offsetHeight && !me.bodyContainer.offsetHeight) {
            console.warn('Grid element not sized correctly, please check your CSS styles and review how you size the widget');
        }
    }

    //endregion

    // region Masking

    /**
     * Show a load mask with a spinner and the specified message. When using an AjaxStore masking and unmasking is
     * handled automatically, but if you are loading data in other ways you can call this function manually when your
     * load starts.
     * ```
     * myLoadFunction() {
     *   // Show mask before initiating loading
     *   grid.maskBody('Loading data');
     *   // Your custom loading code
     *   load.then(() => {
     *      // Hide the mask when loading is finished
     *      grid.unmaskBody();
     *   });
     * }
     * ```
     * @param {String} loadMask Message to show next to the spinner
     * @returns {Core.widget.Mask}
     */
    maskBody(loadMask) {
        const me = this;

        if (!me.bodyContainer) {
            return;
        }

        // remove any existing mask
        me.unmaskBody();

        const { maskElement } = (me.activeMask = Mask.mask(loadMask, me.element));
        maskElement.style.marginTop = `${me.bodyContainer.offsetTop}px`;
        maskElement.style.height = `${me.virtualScrollers.offsetTop + me.virtualScrollers.offsetHeight - me.bodyContainer.offsetTop}px`;

        return me.activeMask;
    }

    /**
     * Hide the load mask.
     */
    unmaskBody() {
        const me = this;

        me.loadmaskHideTimer && me.clearTimeout(me.loadmaskHideTimer);
        me.loadmaskHideTimer = null;

        me.activeMask && me.activeMask.destroy();
        me.activeMask = null;
    }

    // endregion
}

// To not break all translations
GridBase.localeClass = 'Grid';

GridBase._$name = 'GridBase'; BryntumWidgetAdapterRegister.register('gridbase', GridBase);

//region Import

//endregion

/**
 * @module Grid/view/Grid
 */

/**
 * The Grid component is a very powerful and performant UI component that shows tabular data (or tree data using the {@link Grid.view.TreeGrid}).
 *
 * <h2>Intro</h2>
 * The Grid widget has a wide range of features and a large API to allow users to work with data efficiently in the browser. The two
 * most important configs are {@link #config-store} and {@link #config-columns}. With the store config, you decide which data to load into the grid.
 * You can work with both in-memory arrays or load data using ajax. See the {@link Core.data.Store} class to learn more about loading data into stores.
 *
 * The columns config accepts an array of {@link Grid.column.Column Column} descriptors defining which fields that will be displayed in the grid.
 * The {@link Grid.column.Column#config-field} property in the column descriptor maps to a field in your dataset. The simplest grid configured with inline data and two columns would
 * look like this:
 *
 *      let grid = new Grid({
 *          appendTo : document.body,
 *
 *          columns: [
 *              { field: 'name', text: 'Name' },
 *              { field: 'job', text: 'Job', renderer: ({value}) => value ? value : 'Unemployed' }
 *          ],
 *
 *          data: [
 *              { name: 'Bill', job: 'Retired' },
 *              { name: 'Elon', job: 'Visionary' },
 *              { name: 'Me' }
 *          ]
 *      });
 *
 * {@inlineexample grid/Grid.js}
 * <h2>Features</h2>
 * To avoid the Grid core being bloated, its main features are implemented in separate ´feature´ classes. These can be turned on and off based
 * on your requirements. To configure (or disable) a feature, use the {@link #config-features} object to provide your desired configuration for the features
 * you want to use. Each feature has an ´id´ that you use as a key in the features object:
 *
 *      let grid = new Grid({
 *          appendTo : document.body,
 *
 *          features : {
 *              cellEdit     : false,
 *              regionResize : true,
 *              cellTooltip  : {
 *                  tooltipRenderer : (data) => {
 *                  }
 *              },
 *              ...
 *          }
 *      });
 *
 * {@region Column configuration options}
 * A grid contains a number of columns that control how your data is rendered. The simplest option is to simply point a Column to a field in your dataset, or define a custom {@link Grid.column.Column#config-renderer}.
 * The renderer function receives one object parameter containing rendering data for the current cell being rendered.
 *
 *      let grid = new Grid({
 *          appendTo : document.body,
 *
 *          columns: [
 *              {
 *                  field: 'task',
 *                  text: 'Task',
 *                  renderer: (renderData) => {
 *                      const record = renderData.record;
 *
 *                      if (record.percentDone === 100) {
 *                          renderData.cellElement.classList.add('taskDone');
 *                          renderData.cellElement.style.background = 'green';
 *                      }
 *
 *                      return renderData.value;
 *                  }
 *              }
 *          ]
 *      });
 *
 * {@endregion}
 * {@region Grid sections (aka "locked" or "frozen" columns)}
 * The grid can be divided horizontally into individually scrollable sections. This is great if you have lots of columns that
 * don't fit the available width of the screen. To enable this feature, simply mark the columns you want to `lock`.
 * Locked columns are then displayed in their own section to the left of the other columns:
 *
 *      let grid = new Grid({
 *          appendTo : document.body,
 *          width    : 500,
 *          subGridConfigs : {
 *              // set a fixed locked section width if desired
 *              locked : { width: 300 }
 *          },
 *          columns : [
 *              { field : 'name', text : 'Name', width : 200, locked : true },
 *              { field : 'firstName', text : 'First name', width : 100, locked : true },
 *              { field : 'surName', text : 'Last name', width : 100, locked : true },
 *              { field : 'city', text : 'City', width : 100 },
 *              { type : 'number', field : 'age', text : 'Age', width : 200 },
 *              { field : 'food', text : 'Food', width : 200 }
 *          ]
 *      });
 *
 * {@inlineexample grid/LockedGrid.js}
 * You can also move columns between sections by using drag and drop, or use the built-in header context menu. If you want to be able to resize the
 * locked grid section, enable the {@link Grid.feature.RegionResize regionResize} feature.
 * {@endregion}
 * {@region Filtering}
 * One important requirement of a good Grid component is the ability to filter large datasets to quickly find what you're looking for. To
 * enable filtering (through the context menu), add the {@link Grid.feature.Filter filter} feature:
 *
 *      let grid = new Grid({
 *          features: {
 *              filter: true
 *          }
 *      });
 *
 * Or activate a default filter at initial rendering:
 *
 *      let grid = new Grid({
 *          features: {
 *              filter: { property : 'city', value : 'New York' }
 *          }
 *      });
 *
 * {@inlineexample feature/Filter.js}
 * {@endregion}
 * {@region Tooltips}
 * If you have a data models with many fields, and you want to show
 * additional data when hovering over a cell, use the {@link Grid.feature.CellTooltip cellTooltip} feature. To show a tooltip for all cells:
 *
 *      let grid = new Grid({
 *          features: {
 *              cellTooltip: ({value}) => value
 *          }
 *      });
 *
 * {@inlineexample feature/CellTooltip.js}
 * {@endregion}
 * {@region Inline Editing (default <strong>on</strong>)}
 * To enable inline cell editing in the grid, simply add the {@link Grid.feature.CellEdit cellEdit} feature:
 *
 *      let grid = new Grid({
 *          appendTo : document.body,
 *
 *          features : {
 *              cellEdit : true
 *          },
 *          columns: [
 *              {
 *                  field: 'task',
 *                  text: 'Task'
 *              }
 *          ]
 *      });
 *
 * {@inlineexample feature/CellEdit.js}
 * {@endregion}
 * {@region Context Menu}
 * Use the {@link Grid.feature.ContextMenu contextMenu} feature if you want your users to be able to interact with the data through the context menu:
 *
 *      let grid = new Grid({
 *          features: {
 *              contextMenu: {
 *                  headerItems: [
 *                      {
 *                          text: 'Show info',
 *                          icon: 'fa fa-info-circle',
 *                          weight: 200,
 *                          onItem : ({ item }) => console.log(item.text)
 *                      }
 *                  ],
 *
 *              cellItems: [
 *                  { text: 'Show options', icon: 'fa fa-cog', weight: 200 }
 *              ]
 *          }
 *      }
 *
 * {@inlineexample feature/ContextMenu.js}
 * {@endregion}
 * {@region Grouping}
 * To group rows by a field in your dataset, use the {@link Grid.feature.Group group} feature.
 * {@inlineexample feature/Group.js}
 * {@endregion}
 * {@region Searching}
 * When working with lots of data, a quick alternative to filtering is the {@link Grid.feature.Search search} feature. It highlights
 * matching values in the grid as you type.
 * {@inlineexample feature/Search.js}
 * {@endregion}
 * {@region Loading and saving data}
 * The grid keeps all its data in a {@link Core.data.Store}, which is essentially an Array of {@link Core.data.Model Model} items.
 * You define your own Model representing your data entities and use the Model API to get and set values.
 *
 *      class Person extends Model {}
 *
 *      let person = new Person({
 *          name: 'Steve',
 *          age: 38
 *      });
 *
 *      person.name = 'Linda'; // person object is now `dirty`
 *
 *      let store = new Store({
 *          data : [
 *              { name : 'Don', age : 40 }
 *          ]
 *      });
 *
 *      store.add(person);
 *
 *      console.log(store.count()); // === 2
 *
 *      store.remove(person); // Remove from store
 *
 * When you update a record in a store, it's considered dirty, until you call {@link Core.data.mixin.StoreCRUD#function-commit commit} on the containing Store. You can also configure your Store to commit automatically (like Google docs).
 * If you use an AjaxStore, it will send changes to your server when commit is called.
 * Any changes you make to the Store or its records are immediately reflected in the Grid, so there is no need to tell it to refresh manually.
 *
 * To learn more about loading and saving data, please refer to [this guide](#guides/data/displayingdata.md).
 * {@endregion}
 * {@region Default configs}
 * There is a myriad of configs and features available for Grid, some of them on by default and some of them requiring
 * extra configuration. The code below tries to illustrate the major things that are used by default:
 *
 * ```javascript
 * let grid = new Grid({
 *    // The following features are enabled by default:
 *    features : {
 *        cellEdit      : true,
 *        columnPicker  : true,
 *        columnReorder : true,
 *        columnResize  : true,
 *        contextMenu   : true,
 *        group         : true,
 *        sort          : true
 *    },
 *
 *    animateRemovingRows       : true,  // Rows will slide out on removal
 *    autoHeight                : false, // Grid needs to have a height supplied through CSS (strongly recommended) or by specifying `height`
 *    columnLines               : true,  // Themes might override it to hide lines anyway
 *    emptyText                 : 'No rows to display',
 *    enableTextSelection       : false, // Not allowed to select text in cells by default,
 *    fillLastColumn            : true,  // By default the last column is stretched to fill the grid
 *    fullRowRefresh            : true,  // Refreshes entire row when a cell value changes
 *    loadMask                  : 'Loading...',
 *    resizeToFitIncludesHeader : true,  // Also measure header when auto resizing columns
 *    responsiveLevels : {
 *      small : 400,
 *      medium : 600,
 *      large : '*'
 *    },
 *    rowHeight                  : null,  // Determined using CSS, it will measure rowHeight
 *    showDirty                  : false, // No indicator for changed cells
 *    showRemoveRowInContextMenu : true   // Context menu has "Remove row" item
 * });
 * ```
 * {@endregion}
 * {@region Performance}
 * In general the Grid widget has very good performance and you can try loading any amount of data in the <a target="_blank" href="../examples/bigdataset">bigdataset</a> demo.
 * The overall rendering performance is naturally affected by many other things than
 * the data volume. Other important factors that can impact performance: number of columns, complex cell renderers, locked columns, the number of features enabled
 * and of course the browser (Chrome fastest, IE slowest).
 * {@endregion}
 *
 * @extends Grid/view/GridBase
 * @classType grid
 */
class Grid extends GridBase {
    static get $name() {
        return 'Grid';
    }
}

Grid._$name = 'Grid'; BryntumWidgetAdapterRegister.register('grid', Grid);

VersionHelper.setVersion('grid', '3.1.0');

/**
 * @module Grid/view/TreeGrid
 */

/**
 * A TreeGrid, a Tree combined with a Grid. Must be configured with exactly one {@link Grid.column.TreeColumn} (`type: tree`), but can also have an
 * arbitrary number of other columns. Most features that can be used with Grid also works with TreeGrid, with the
 * exception of the Group feature.
 * @extends Grid/view/Grid
 *
 * @classtype treegrid
 * @externalexample grid/TreeGrid.js
 */
class TreeGrid extends Grid {

    static get $name() {
        return 'TreeGrid';
    }

    //region Plugged in functions / inherited configs

    /**
     * Store that holds records to display in the TreeGrid, or a store config object.
     * If you supply a Store, make sure it is configured with `tree : true` to handle tree data.
     * A store will be created if none is specified
     * @config {Core.data.Store|Object} store
     * @default
     */

    /**
     * Collapse an expanded node or expand a collapsed. Optionally forcing a certain state.
     *
     * @function toggleCollapse
     * @param {String|Number|Core.data.Model} idOrRecord Record (the node itself) or id of a node to toggle
     * @param {Boolean} [collapse] Force collapse (true) or expand (false)
     * @param {Boolean} [skipRefresh] Set to true to not refresh rows (if calling in batch)
     * @returns {Promise}
     * @category Feature shortcuts
     */

    /**
     * Collapse a single node.
     *
     * @function collapse
     * @param {String|Number|Core.data.Model} idOrRecord Record (the node itself) or id of a node to collapse
     * @returns {Promise}
     * @category Feature shortcuts
     */

    /**
     * Expand a single node.
     *
     * @function expand
     * @param {String|Number|Core.data.Model} idOrRecord Record (the node itself) or id of a node to expand
     * @returns {Promise}
     * @category Feature shortcuts
     */

    /**
     * Expands parent nodes to make this node "visible".
     *
     * @function expandTo
     * @param {String|Number|Core.data.Model} idOrRecord Record (the node itself) or id of a node
     * @returns {Promise}
     * @category Feature shortcuts
     */

    //endregion

    //region Store

    /**
     * Get/set the store used by this TreeGrid. Accepts a config or a Store. If assigning an already existing Store,
     * it must be configured with `tree: true`
     * @property {Core.data.Store|Object}
     */
    set store(store) {
        if (store && !store.tree) {
            // existing store instance, not much we can do about it
            if (store instanceof Store) {
                throw new Error('TreeGrid requires a Store configured with tree : true');
            }
            // store config, enable tree
            else {
                store.tree = true;
            }
        }

        super.store = store;
    }

    get store() {
        return super.store;
    }

    //endregion
}

TreeGrid._$name = 'TreeGrid'; BryntumWidgetAdapterRegister.register('treegrid', TreeGrid);

// This class is intended to keep common localizations used by different components, dependency types mostly. This
// class allows to have minimal dependencies to access localized strings
class SchedulerCommon extends Localizable() {}
SchedulerCommon._$name = 'SchedulerCommon';

/**
 * @module Scheduler/crud/AbstractCrudManagerMixin
 */

const
    storeSortFn = function(lhs, rhs, sortProperty) {
        // TODO: get rid of these StoreDescriptors. Just use Stores.
        if (lhs.store) {
            lhs = lhs.store;
        }
        if (rhs.store) {
            rhs = rhs.store;
        }

        lhs = lhs[sortProperty] || 0;
        rhs = rhs[sortProperty] || 0;
        return (lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0);
    },

    // Sorter function to keep stores in loadPriority order
    storeLoadSortFn = function(lhs, rhs) {
        return storeSortFn(lhs, rhs, 'loadPriority');
    },

    // Sorter function to keep stores in syncPriority order
    storeSyncSortFn = function(lhs, rhs) {
        return storeSortFn(lhs, rhs, 'syncPriority');
    },

    nullFn$1 = () => {};

/**
 * An abstract mixin that supplies most of the CrudManager functionality.
 * It implements basic mechanisms of collecting stores to organize batch communication with a server.
 * Yet it does not contain methods related to _data transfer_ nor _encoding_.
 * These methods are to be provided in sub-classes.
 * Out of the box there are mixins implementing {@link Scheduler.crud.transport.AjaxTransport support of AJAX for data transferring}
 * and {@link Scheduler.crud.encoder.JsonEncoder JSON for data encoding system}.
 * For example this is how we make a model that will implement CrudManager protocol and use AJAX/JSON to pass the dada to the server:
 *
 * ```javascript
 * class SystemSettings extends JsonEncode(AjaxTransport(AbstractCrudManagerMixin(Model))) {
 *     ...
 * }
 * ```
 *
 * ## Data transfer and encoding methods
 *
 * These are methods that must be provided by subclasses of this class:
 *
 * - {@link #function-sendRequest sendRequest}
 * - {@link #function-cancelRequest cancelRequest}
 * - {@link #function-encode encode}
 * - {@link #function-decode decode}
 *
 * @mixin
 * @abstract
 */
var AbstractCrudManagerMixin = Target => class AbstractCrudManagerMixin extends Delayable(Target) {
    //region Default config

    static get defaultConfig() {
        return {
            // overrideCrudStoreLoad : false,

            /**
             * The server revision stamp.
             * The _revision stamp_ is a number which should be incremented after each server-side change.
             * This property reflects the current version of the data retrieved from the server and gets updated after each {@link #function-load} and {@link #function-sync} call.
             * @property {Number}
             * @readonly
             */
            crudRevision : null,

            /**
             * A list of registered stores whose server communication will be collected into a single batch.
             * Each store is represented by a _store descriptor_, an object having following structure:
             * @member {Object[]} crudStores
             * @property {String} stores.storeId Unique store identifier.
             * @property {Core.data.Store} stores.store Store itself.
             * @property {String} [stores.phantomIdField] Set this if store model has a predefined field to keep phantom record identifier.
             * @property {String} [stores.idField] id field name, if it's not specified then class will try to get it from a store model.
             */

            /**
             * Sets the list of stores controlled by the CRUD manager.
             * Store can be provided by itself, its storeId or an object having the following structure:
             * @property {String} stores.storeId Unique store identifier. Under this name the store related requests/responses will be sent.
             * @property {Core.data.Store} stores.store The store itself.
             * @property {String} [stores.phantomIdField] Set this if the store model has a predefined field to keep phantom record identifier.
             * @property {String} [stores.idField] id field name, if it's not specified then class will try to get it from a store model.
             * @config {Core.data.Store[]|String[]|Object[]}
             */
            crudStores : [],

            /**
             * Name of a store property to retrieve store identifiers from.
             * Store identifier is used as a container name holding corresponding store data while transferring them to/from the server.
             * By default `storeId` property is used. And in case a container identifier has to differ this config can be used:
             *
             * ```javascript
             * class CatStore extends Store {
             *     // storeId is "meow" but for sending/receiving store data
             *     // we want have "cats" container in JSON, so we create a new property "storeIdForCrud"
             *     storeId          : 'meow',
             *     storeIdForCrud   : 'cats'
             * });
             *
             * class MyCrudManager extends CrudManager {
             *     ...
             *     crudStores           : ['meow'],
             *     // crud manager will get store identifier from "storeIdForCrud" property
             *     storeIdProperty  : 'storeIdForCrud'
             * });
             * ```
             * The `storeIdProperty` property can also be specified directly on a store:
             *
             * ```javascript
             * class CatStore extends Store {
             *     // storeId is "meow" but for sending/receiving store data
             *     // we want have "cats" container in JSON
             *     storeId          : 'meow',
             *     // so we create a new property "storeIdForCrud"..
             *     storeIdForCrud  : 'cats',
             *     // and point CrudManager to use it as the store identifier source
             *     storeIdProperty  : 'storeIdForCrud'
             * });
             *
             * class DogStore extends Store {
             *     // storeId is "dogs" and it will be used as a container name for the store data
             *     storeId          : 'dogs'
             * });
             *
             * class MyCrudManager extends CrudManager {
             *     ...
             *     crudStores           : ['meow', 'dogs']
             * });
             * ```
             * @config {String}
             */
            storeIdProperty : 'storeId',

            // TODO: no support for remote filtering yet
            // /**
            //  * The name of the 'filter' parameter to send in a load request.
            //  * @config {String}
            //  * @default
            //  */
            crudFilterParam : 'filter',

            /**
             * Sends request to the server.
             * @function sendRequest
             * @param {Object} request The request to send. An object having following properties:
             * @param {String} request.data {@link #function-encode Encoded} request.
             * @param {String} request.type Request type, can be either `load` or `sync`
             * @param {Function} request.success Callback to be started on successful request transferring
             * @param {Function} request.failure Callback to be started on request transfer failure
             * @param {Object} request.thisObj `this` reference for the above `success` and `failure` callbacks
             * @return {Promise} The request promise.
             * @abstract
             */

            /**
             * Cancels request to the server.
             * @function cancelRequest
             * @param {Object} request The request to cancel (a value returned by corresponding {@link #function-sendRequest} call).
             * @abstract
             */

            /**
             * Encodes request to the server.
             * @function encode
             * @param {Object} request The request to encode.
             * @returns {String} The encoded request.
             * @abstract
             */

            /**
             * Decodes response from the server.
             * @function decode
             * @param {String} response The response to decode.
             * @returns {Object} The decoded response.
             * @abstract
             */

            transport : {},

            /**
             * When `true` forces the CRUD manager to process responses depending on their `type` attribute.
             * So `load` request may be responded with `sync` response for example.
             * Can be used for smart server logic allowing the server to decide when it's better to respond with a complete data set (`load` response)
             * or it's enough to return just a delta (`sync` response).
             * @config {Boolean}
             * @default
             */
            trackResponseType : false,

            /**
             * Field name to be used to transfer a phantom record identifier.
             * @config {String}
             * @default
             */
            phantomIdField : '$PhantomId',

            /**
             * `true` to automatically call {@link #function-load} method after creation.
             * @config {Boolean}
             * @default
             */
            autoLoad : false,

            /**
             * The timeout in milliseconds to wait before persisting changes to the server.
             * Used when {@link #config-autoSync} is set to `true`.
             * @config {Number}
             * @default
             */
            autoSyncTimeout : 100,

            /**
             * `true` to automatically persist store changes after edits are made in any of the stores monitored.
             * Please note that sync request will not be invoked immediately but only after {@link #config-autoSyncTimeout} interval.
             * @config {Boolean}
             * @default
             */
            autoSync : false,

            /**
             * `True` to reset identifiers (defined by `idField` config) of phantom records before submitting them to the server.
             * @config {Boolean}
             * @default
             */
            resetIdsBeforeSync : true,

            /**
             * @member {Object[]} syncApplySequence
             * An array of stores presenting an alternative sync responses apply order.
             * Each store is represented by a _store descriptor_, an object having following structure:
             * @property {String} syncApplySequence.storeId Unique store identifier.
             * @property {Core.data.Store} syncApplySequence.store Store itself.
             * @property {String} [syncApplySequence.phantomIdField] Set this if store model has a predefined field to keep phantom record identifier.
             * @property {String} [syncApplySequence.idField] id field name, if it's not specified then class will try to get it from a store model.
             */

            /**
             * An array of store identifiers sets an alternative sync responses apply order.
             * By default the order in which sync responses are applied to the stores is the same as they registered in.
             * But in case of some tricky dependencies between stores this order can be changed:
             *
             *```javascript
             * class MyCrudManager extends CrudManager {
             *     // register stores (they will be loaded in the same order: 'store1' then 'store2' and finally 'store3')
             *     crudStores : ['store1', 'store2', 'store3'],
             *     // but we apply changes from server to them in an opposite order
             *     syncApplySequence : ['store3', 'store2', 'store1']
             * });
             *```
             * @config {String[]}
             */
            syncApplySequence : [],

            orderedCrudStores : [],

            /**
             * true to write all fields from the record to the server. If set to false it will only send the fields that
             * were modified. Note that any fields that have `persist` set to false will still be ignored while those
             * with `critical` set to true will be included.
             * @config {Boolean}
             * @default
             */
            writeAllFields : false,

            crudIgnoreUpdates : 0,

            // Flag that shows if crud manager performed successful load request
            crudLoaded : false,

            createMissingRecords : false,
            autoSyncTimerId      : null,

            applyingLoadResponse : false,
            applyingSyncResponse : false,

            callOnFunctions : true
        };
    }

    //endregion

    get isCrudManager() {
        return true;
    }

    //region Init

    construct(config = {}) {
        this._requestId      = 0;
        this.activeRequests  = {};
        this.crudStoresIndex = {};

        super.construct(config);
    }

    afterConstruct() {
        super.afterConstruct();

        if (this.autoLoad) {
            this.load().catch((e) => {});
        }
    }

    //endregion

    //region Store descriptors & index

    /**
     * Returns a registered store descriptor.
     * @param {String|Core.data.Store} storeId The store identifier or registered store instance.
     * @returns {Object} The descriptor of the store.
     */
    getStoreDescriptor(storeId) {
        if (!storeId) return null;

        if (storeId instanceof Store) return this.crudStores.find(storeDesc => storeDesc.store === storeId);

        if (typeof storeId === 'object') return this.crudStoresIndex[storeId.storeId];

        return this.crudStoresIndex[storeId] || this.getStoreDescriptor(Store.getStore(storeId));
    }

    fillStoreDescriptor(descriptor) {
        const
            { store } = descriptor,
            {
                storeIdProperty = this.storeIdProperty,
                modelClass
            }         = store;

        if (!descriptor.storeId) {
            descriptor.storeId = store[storeIdProperty];
        }
        if (!descriptor.idField) {
            descriptor.idField = modelClass.idField;
        }
        if (!descriptor.phantomIdField) {
            descriptor.phantomIdField = modelClass.phantomIdField;
        }
        if (!('writeAllFields' in descriptor)) {
            descriptor.writeAllFields = store.writeAllFields;
        }

        return descriptor;
    }

    updateCrudStoreIndex() {
        const crudStoresIndex = this.crudStoresIndex = {};

        this.crudStores.forEach(store => store.storeId && (crudStoresIndex[store.storeId] = store));
    }

    //endregion

    //region Store collection (add, remove, get & iterate)

    /**
     * Returns a registered store.
     * @param {String} storeId Store identifier.
     * @returns {Core.data.Store} Found store instance.
     */
    getCrudStore(storeId) {
        const storeInfo = this.getStoreDescriptor(storeId);
        return storeInfo && storeInfo.store;
    }

    forEachCrudStore(fn, thisObj = this) {
        if (!fn) return;

        this.crudStores.every(store =>
            fn.call(thisObj, store.store, store.storeId, store) !== false
        );
    }

    set crudStores(stores) {
        this._crudStores = [];

        this.addCrudStore(stores);

        // Ensure preconfigured stores stay stable at the start of the array when
        // addPrioritizedStore attempts to insert in order. Only featured gantt/scheduler stores
        // must participate in the ordering. If they were configured in, they must not move.
        for (const store of this._crudStores) {
            store.loadPriority = store.syncPriority = 0;
        }
    }

    get crudStores() {
        return this._crudStores;
    }

    get orderedCrudStores() {
        return this._orderedCrudStores;
    }

    set orderedCrudStores(stores) {
        return this._orderedCrudStores = stores;
    }

    set syncApplySequence(stores) {
        this._syncApplySequence = [];

        this.addStoreToApplySequence(stores);
    }

    get syncApplySequence() {
        return this._syncApplySequence;
    }

    internalAddCrudStore(store) {
        const me = this;

        let storeInfo;

        // if store instance provided
        if (store instanceof Store) {
            storeInfo = { store };
        }
        else if (typeof store === 'object') {
            // normalize sub-stores (if any)
            if (store.stores) {
                if (!Array.isArray(store.stores)) {
                    store.stores = [store.stores];
                }

                store.stores.forEach((subStore, j) => {
                    let subStoreInfo = subStore;

                    if (typeof subStore === 'string') {
                        subStoreInfo = { storeId : subStore };
                    }

                    // keep reference to the "master" store descriptor
                    subStoreInfo.masterStoreInfo = store;

                    store.stores[j] = subStoreInfo;
                });
            }

            storeInfo = store;
        }
        // if it's a store identifier
        else {
            storeInfo = { store : Store.getStore(store) };
        }

        me.fillStoreDescriptor(storeInfo);

        // store instance
        store = storeInfo.store;

        // if the store has "setCrudManager" hook - use it
        if (store.setCrudManager) {
            store.setCrudManager(me);
        }
        // otherwise decorate the store w/ "crudManager" property
        else {
            store.crudManager = me;
        }

        // Stores have a defaultConfig for pageSize. CrudManager does not support that.
        // TODO: PORT currently no support for paging.
        store.pageSize = null;

        // Prevent AjaxStores from performing their own CRUD operations
        if (me.overrideCrudStoreLoad && store.load) {
            store.load = store.commit = () => {};
        }

        // listen to store changes
        me.bindCrudStoreListeners(store);

        return storeInfo;
    }

    /**
     * Adds a store to the collection.
     *
     *```javascript
     * // append stores to the end of collection
     * crudManager.addCrudStore([
     *     store1,
     *     // storeId
     *     'bar',
     *     // store descriptor
     *     {
     *         storeId : 'foo',
     *         store   : store3
     *     },
     *     {
     *         storeId         : 'bar',
     *         store           : store4,
     *         // to write all fields of modified records
     *         writeAllFields  : true
     *     }
     * ]);
     *```
     *
     * **Note:** Order in which stores are kept in the collection is very essential sometimes.
     * Exactly in this order the loaded data will be put into each store.
     * @param {Core.data.Store|String|Object|Core.data.Store[]|String[]|Object[]} store
     * A store or list of stores. Each store might be specified by its instance, `storeId` or _descriptor_.
     * The _store descriptor_ is an object having following properties:
     * @param {String} store.storeId The store identifier that will be used as a key in requests.
     * @param {Core.data.Store} store.store The store itself.
     * @param {String} [store.idField] The idField of the store. If not specified will be taken from the store model.
     * @param {String} [store.phantomIdField] The field holding unique Ids of phantom records (if store has such model).
     * @param {Boolean} [store.writeAllFields] Set to true to write all fields from modified records
     * @param {Number} [position] The relative position of the store. If `fromStore` is specified the this position will be taken relative to it.
     * If not specified then store(s) will be appended to the end of collection.
     * Otherwise it will be just a position in stores collection.
     *
     * ```javascript
     * // insert stores store4, store5 to the start of collection
     * crudManager.addCrudStore([ store4, store5 ], 0);
     * ```
     *
     * @param {String|Core.data.Store|Object} [fromStore] The store relative to which position should be calculated. Can be defined as a store identifier, instance or descriptor (the result of {@link #function-getStoreDescriptor} call).
     *
     * ```javascript
     * // insert store6 just before a store having storeId equal to 'foo'
     * crudManager.addCrudStore(store6, 0, 'foo');
     *
     * // insert store7 just after store3 store
     * crudManager.addCrudStore(store7, 1, store3);
     * ```
     */
    addCrudStore(store, position, fromStore) {
        if (!store) return;

        if (!Array.isArray(store)) store = [store];

        if (!store.length) return;

        const me   = this,
            stores = store.map(me.internalAddCrudStore, me);

        // if no position specified then append stores to the end
        if (typeof position === 'undefined') {
            me.crudStores.push(...stores);
        }
        // if position specified
        else {
            let pos = position;
            // if specified the store relative to which we should insert new one(-s)
            if (fromStore) {
                if (fromStore instanceof Store || typeof fromStore !== 'object') fromStore = me.getStoreDescriptor(fromStore);
                // get its position
                pos += me.crudStores.indexOf(fromStore);
            }
            // insert new store(-s)
            //me.crudStores.splice.apply(me.crudStores, [].concat([pos, 0], stores));
            me.crudStores.splice(pos, 0, ...stores);
        }

        me.orderedCrudStores.push(...stores);

        me.updateCrudStoreIndex();
    }

    // Adds configured scheduler stores to the store collection ensuring correct order
    // unless they're already registered.
    addPrioritizedStore(store) {
        const me = this;

        if (!me.hasCrudStore(store)) {
            this.addCrudStore(store, ArrayHelper.findInsertionIndex(store, me.crudStores, storeLoadSortFn));
        }
        if (!me.hasApplySequenceStore(store)) {
            this.addStoreToApplySequence(store, ArrayHelper.findInsertionIndex(store, me.syncApplySequence, storeSyncSortFn));
        }
    }

    hasCrudStore(store) {
        return this.crudStores.some(s => s === store || s.store === store || s.storeId === store);
    }

    /**
     * Removes a store from collection. If the store was registered in alternative sync sequence list
     * it will be removed from there as well.
     *
     * ```javascript
     *    // remove store having storeId equal to "foo"
     *    crudManager.removeCrudStore("foo");
     *
     *    // remove store3
     *    crudManager.removeCrudStore(store3);
     * ```
     *
     * @param {Object|String|Core.data.Store} store The store to remove. Either the store descriptor, store identifier or store itself.
     */
    removeCrudStore(store) {
        const me     = this,
            stores = me.crudStores;

        for (let i = 0, l = stores.length; i < l; i++) {
            const s = stores[i];
            if (s === store || s.store === store || s.storeId === store) {
                // unbind store listeners
                me.unbindCrudStoreListeners(s.store);

                delete me.crudStoresIndex[s.storeId];
                stores.splice(i, 1);
                if (me.syncApplySequence) {
                    me.removeStoreFromApplySequence(store);
                }

                break;
            }
        }
    }

    //endregion

    //region Store listeners

    bindCrudStoreListeners(store, un) {
        const me        = this,
            listeners = {
                update     : me.onCrudStoreChange, //me.onStoreUpdate,
                removeall  : me.onCrudStoreChange,
                detachable : true,
                thisObj    : me
            };

        // TODO: destroying a store should remove listeners from it (should be default behaviour in Events)

        Object.assign(listeners, {
            add    : me.onCrudStoreChange,
            remove : me.onCrudStoreChange
        });

        store.crudDetatcher = store.on(listeners);
    }

    unbindCrudStoreListeners(store) {
        store.crudDetatcher && store.crudDetatcher();
    }

    //endregion

    //region Apply sequence

    /**
     * Adds a store to the alternative sync responses apply sequence.
     * By default the order in which sync responses are applied to the stores is the same as they registered in.
     * But this order can be changes either on construction step using {@link #config-syncApplySequence} option
     * or but calling this method.
     *
     * **Please note**, that if the sequence was not initialized before this method call then
     * you will have to do it yourself like this for example:
     *
     *    ```javascript
     *    // alternative sequence was not set for this crud manager
     *    // so let's fill it with existing stores keeping the same order
     *    crudManager.addStoreToApplySequence(crudManager.crudStores);
     *
     *    // and now we can add our new store
     *
     *    // we will load its data last
     *    crudManager.addCrudStore(someNewStore);
     *    // but changes to it will be applied first
     *    crudManager.addStoreToApplySequence(someNewStore, 0);
     *    ```
     * add registered stores to the sequence along with the store(s) you want to add
     *
     * @param {Core.data.Store|Object|Core.data.Store[]|Object[]} store The store to add or its _descriptor_ (or array of stores or descriptors).
     * Where _store descriptor_ is an object having following properties:
     * @param {String} store.storeId The store identifier that will be used as a key in requests.
     * @param {Core.data.Store} store.store The store itself.
     * @param {String} [store.idField] The idField of the store. If not specified will be taken from the store model.
     * @param {String} [store.phantomIdField] The field holding unique Ids of phantom records (if store has such model).

     * @param {Number} [position] The relative position of the store. If `fromStore` is specified the this position will be taken relative to it.
     * If not specified then store(s) will be appended to the end of collection.
     * Otherwise it will be just a position in stores collection.
     *
     *    ```javascript
     *    // insert stores store4, store5 to the start of sequence
     *    crudManager.addStoreToApplySequence([ store4, store5 ], 0);
     *    ```
     * @param {String|Core.data.Store|object} [fromStore] The store relative to which position should be calculated. Can be defined as a store identifier, instance or its descriptor (the result of {@link #function-getStoreDescriptor} call).
     *
     *    ```javascript
     *    // insert store6 just before a store having storeId equal to 'foo'
     *    crudManager.addStoreToApplySequence(store6, 0, 'foo');
     *
     *    // insert store7 just after store3 store
     *    crudManager.addStoreToApplySequence(store7, 1, store3);
     *    ```
     */
    addStoreToApplySequence(store, position, fromStore) {
        if (!store) return;

        if (!Array.isArray(store)) store = [store];

        const me   = this,
            // loop over list of stores to add
            data = store.reduce((collection, store) => {
                const s = me.getStoreDescriptor(store);
                if (s) collection.push(s);
                return collection;
            }, []);

        // if no position specified then append stores to the end
        if (typeof position === 'undefined') {
            me.syncApplySequence.push(...data);

            // if position specified
        }
        else {
            let pos = position;
            // if specified the store relative to which we should insert new one(-s)
            if (fromStore) {
                if (fromStore instanceof Store || typeof fromStore !== 'object') fromStore = me.getStoreDescriptor(fromStore);
                // get its position
                pos += me.syncApplySequence.indexOf(fromStore);
            }
            // insert new store(-s)
            //me.syncApplySequence.splice.apply(me.syncApplySequence, [].concat([pos, 0], data));
            me.syncApplySequence.splice(pos, 0, ...data);
        }

        const sequenceKeys = me.syncApplySequence.map(desc => desc.storeId);

        me.orderedCrudStores = [...me.syncApplySequence];
        me.crudStores.forEach(desc => {
            if (!sequenceKeys.includes(desc.storeId)) {
                me.orderedCrudStores.push(desc);
            }
        });
    }

    /**
     * Removes a store from the alternative sync sequence.
     *
     *    ```javascript
     *    // remove store having storeId equal to "foo"
     *    crudManager.removeCrudStore("foo");
     *
     *    // remove store3
     *    crudManager.removeCrudStore(store3);
     *    ```
     *
     * @param {Object|String|Core.data.Store} store The store to remove. Either the store descriptor, store identifier or store itself.
     */
    removeStoreFromApplySequence(store) {
        const index = this.syncApplySequence.findIndex(s => s === store || s.store === store || s.storeId === store);
        if (index > -1) {
            this.syncApplySequence.splice(index, 1);

            // ordered crud stores list starts with syncApplySequence, we can use same index
            this.orderedCrudStores.splice(index, 1);
        }
    }

    hasApplySequenceStore(store) {
        return this.syncApplySequence.some(s => s === store || s.store === store || s.storeId === store);
    }

    //endregion

    //region Events

    // onNodeRemove(oldParent) {
    //     var treeStore = oldParent && oldParent.getTreeStore();
    //     // "noderemove" event is fired too early and getRemovedRecords() don't not have the removed node yet
    //     // so we wait till tree store "endupdate" event and only then invoke "onCrudStoreChange" method
    //     treeStore && treeStore.on('endupdate', this.onCrudStoreChange, this, { once : true });
    // }

    // onStoreUpdate(store, record, operation, fields) {
    //     if ((!store.isTreeStore || record !== store.getRoot())) {
    //         // If only a single field was changed, make sure it's a persistable field to avoid full scan of the store
    //         // Collapsing/expanding a tree node will trigger this behavior otherwise
    //         var isSingleNonPersistField = fields && fields.length === 1 && record.getField(fields[0]) && !record.getField(fields[0]).persist;
    //
    //         if (!isSingleNonPersistField) {
    //             this.onCrudStoreChange();
    //         }
    //     }
    // }

    // onTreeStoreInsertOrAppend(parent, child) {
    //     if (!child.isRoot()) {
    //         this.onCrudStoreChange();
    //     }
    // }

    onCrudStoreChange() {
        const me = this;

        if (me.crudIgnoreUpdates) return;

        /**
         * Fires when any record in a registered stores is changed.
         * ```javascript
         *     crudManager.on('hasChanges', function (crud) {
         *         // enable persist changes button when some store gets changed
         *         saveButton.enable();
         *     });
         * ```
         * @event crudStoreHasChanges
         * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
         */

        if (me.crudStoreHasChanges()) {
            me.trigger('hasChanges');

            if (me.autoSync) {
                // add deferred call if it's not scheduled yet
                if (!me.autoSyncTimerId) {
                    me.autoSyncTimerId = me.setTimeout(() => {
                        me.autoSyncTimerId = null;
                        me.sync();
                    }, me.autoSyncTimeout);
                }
            }
        }
        else {
            me.trigger('noChanges');
        }
    }

    async internalOnResponse(requestType, responseText, fetchOptions, options) {
        // reset last requested package ID
        const me = this;

        me.activeRequests[requestType] = null;

        const response = responseText ? me.decode(responseText) : null;

        if (!response || !response.success) {
            /**
             * Fires when a request fails.
             * @event requestFail
             * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager instance.
             * @param {String} requestType The request type (`sync` or `load`).
             * @param {Object} response The decoded server response object.
             * @param {String} responseText The raw server response text
             * @param {Object} responseOptions The response options.
             */
            me.trigger('requestFail', { requestType, response, responseText, responseOptions : fetchOptions });
            /**
             * Fires when a {@link #function-load load request} fails.
             * @event loadFail
             * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager instance.
             * @param {Object} response The decoded server response object.
             * @param {String} responseText The raw server response text
             * @param {Object} responseOptions The response options.
             * @params {Object} options Options provided to the {@link #function-load} method.
             */
            /**
             * Fires when a {@link #function-sync sync request} fails.
             * @event syncFail
             * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager instance.
             * @param {Object} response The decoded server response object.
             * @param {String} responseText The raw server response text
             * @param {Object} responseOptions The response options.
             */
            me.trigger(requestType + 'Fail', { response, responseOptions : fetchOptions, responseText, options });

            me.warn('CrudManager: ' + requestType + ' failed, please inspect the server response');

            return response;
        }

        /**
         * Fires before server response gets applied to the stores. Return `false` to prevent data applying.
         * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
         * @event beforeResponseApply
         * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
         * @param {String} requestType The request type (`sync` or `load`).
         * @param {Object} response The decoded server response object.
         */
        /**
         * Fires before loaded data get applied to the stores. Return `false` to prevent data applying.
         * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
         * @event beforeLoadApply
         * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
         * @param {Object} response The decoded server response object.
         * @param {Object} options Options provided to the {@link #function-load} method.
         */
        /**
         * Fires before sync response data get applied to the stores. Return `false` to prevent data applying.
         * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
         * @event beforeSyncApply
         * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
         * @param {Object} response The decoded server response object.
         */
        if ((me.trigger('beforeResponseApply', { requestType, response }) !== false) &&
            (me.trigger('before' + StringHelper.capitalizeFirstLetter(requestType) + 'Apply', {
                response,
                options
            }) !== false)) {
            me.crudRevision = response.revision;

            await me.applyResponse(requestType, response, options);

            /**
             * Fires on successful request completion after data gets applied to the stores.
             * @event requestDone
             * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
             * @param {String} requestType The request type (`sync` or `load`).
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The server response options.
             */
            me.trigger('requestDone', { requestType, response, responseOptions : fetchOptions });
            /**
             * Fires on successful {@link #function-load load request} completion after data gets loaded to the stores.
             * @event load
             * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The server response options.
             * @params {Object} options Options provided to the {@link #load} method.
             */
            /**
             * Fires on successful {@link #function-sync sync request} completion.
             * @event sync
             * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The server response options.
             */
            me.trigger(requestType, { response, responseOptions : fetchOptions, options });

            if (requestType === 'load' || !me.crudStoreHasChanges()) {
                /**
                 * Fires when registered stores get into state when they don't have any
                 * not persisted change. This happens after {@link #function-load load} or {@link #function-sync sync} request
                 * completion. Or this may happen after a record update which turns its fields back to their original state.
                 *
                 * ```javascript
                 *     crudManager.on('nochanges', function (crud) {
                 *         // disable persist changes button when there is no changes
                 *         saveButton.disable();
                 *     });
                 * ```
                 *
                 * @event noChanges
                 * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
                 */
                me.trigger('noChanges');
            }
        }

        return response;
    }

    async internalOnLoad(responseText, fetchOptions, options) {
        // Successful load request, mark crud manager as loaded
        this.crudLoaded = true;

        return this.internalOnResponse('load', responseText, fetchOptions, options);
    }

    async internalOnSync(responseText, fetchOptions, options) {
        return this.internalOnResponse('sync', responseText, fetchOptions, options);
    }

    //endregion

    //region Changes tracking

    suspendChangesTracking() {
        this.crudIgnoreUpdates++;
    }

    resumeChangesTracking(triggerCheck) {
        if (this.crudIgnoreUpdates && !--this.crudIgnoreUpdates) {
            if (triggerCheck) {
                this.onCrudStoreChange();
            }
        }
    }

    /**
     * Returns `true` if any of registered stores (or some particular store) has non persisted changes.
     *
     *    ```javascript
     *    // if we have any unsaved changes
     *    if (crudManager.crudStoreHasChanges()) {
     *        // persist them
     *        crudManager.sync();
     *    // otherwise
     *    } else {
     *        alert("There are no unsaved changes...");
     *    }
     *    ```
     *
     * @param {String|Core.data.Store} [storeId] The store identifier or store instance to check changes for.
     * If not specified then will check changes for all of the registered stores.
     * @returns {Boolean} `true` if there are not persisted changes.
     */
    crudStoreHasChanges(storeId) {
        if (storeId) {
            const store = this.getCrudStore(storeId);
            return store && this.isCrudStoreDirty(store);
        }

        return this.crudStores.some(this.isCrudStoreDirty);

        // for (var i = 0, l = this.crudStores.length; i < l; i++) {
        //     if (this.isCrudStoreDirty(this.crudStores[i].store)) return true;
        // }
        //
        // return false;
    }

    isCrudStoreDirty(store) {
        return store.store.changes != null;
    }

    //endregion

    //region Load

    emitCrudStoreEvents(stores, eventName) {
        const event   = { action : 'read' + eventName };

        for (const store of this.crudStores) {
            if (stores.includes(store.storeId)) {
                store.store.trigger(eventName, event);
            }
        }
    }

    getLoadPackage(options) {
        const pack   = {
                type      : 'load',
                requestId : this.requestId
            },
            stores = this.crudStores,
            optionsCopy = Object.assign({}, options);

        pack.stores = stores.map(store => {
            const //filterParam = store.filterParam || store.store.filterParam || this.crudFilterParam,
                opts     = optionsCopy && optionsCopy[store.storeId],
                pageSize = store.pageSize || store.store && store.store.pageSize;

            // TODO: PORT currently no support for remote filters
            // if the store uses remote filtering
            // if (store.store.remoteFilter && filterParam) {
            //
            //     opts = opts || {};
            //
            //     var filters = [];
            //
            //     store.store.getFilters().each(function(f) {
            //         filters.push(f.serialize());
            //     });
            //
            //     // put filters info into the package
            //     opts[filterParam] = filters;
            // }

            // TODO: PORT currently no support for paging
            if (opts || pageSize) {
                const params = Object.assign({
                    storeId  : store.storeId,
                    page     : 1,
                    pageSize : pageSize
                }, opts);

                store.currentPage = params.page;

                // Remove from common request options
                if (opts) {
                    delete optionsCopy[store.storeId];
                }

                return params;
            }

            return store.storeId;
        });

        // Apply common request options
        Object.assign(pack, optionsCopy);

        return pack;
    }

    loadCrudStore(store, data, options, storeDesc) {
        const rows = data && data.rows;

        if (options && options.append || data.append) {
            store.add(rows);
        }
        else {
            store.data = rows;
        }

        store.trigger('load', { source : store, data : rows });
    }

    loadDataToCrudStore(storeDesc, data, options) {
        const
            me        = this,
            store     = storeDesc.store,
            // nested stores list
            subStores = storeDesc.stores,
            idField   = storeDesc.idField || 'id', //model && model.meta.idField || 'id',
            isTree    = store.tree,
            rows      = data && data.rows;

        store.__loading = true;

        //TODO: PORT meta data on store?
        // apply server provided meta data to the store
        // if (metaData) {
        //     if (store.applyMetaData) {
        //         store.applyMetaData(metaData);
        //     } else {
        //         store.metaData = metaData;
        //     }
        // }

        if (rows) {
            let subData;

            if (subStores) {
                subData = me.getSubStoresData(rows, subStores, idField, isTree);
            }

            me.loadCrudStore(store, data, options, storeDesc);

            if (subData) {
                // load sub-stores as well (if we have them)
                subData.forEach(sub => {
                    me.loadDataToCrudStore(
                        Object.assign({
                            store : store.getById(sub.id).get(sub.storeDesc.storeId) // TODO: PORT have to check what this does
                        }, sub.storeDesc),
                        sub.data
                    );
                });
            }
        }

        store.__loading = false;
    }

    loadCrudManagerData(response, options = {}) {
        // we don't want reacting on store changes during loading of them
        this.suspendChangesTracking();

        // we load data to the stores in the order they're kept in this.stores array
        this.crudStores.forEach(storeDesc => {
            const storeId = storeDesc.storeId,
                data    = response[storeId];

            if (data) {
                this.loadDataToCrudStore(storeDesc, data, options[storeId]);
            }
        });

        this.resumeChangesTracking();
    }

    /**
     * Returns true if the crud manager is currently loading data
     * @property {Boolean}
     * @readonly
     * @category CRUD
     */
    get isCrudManagerLoading() {
        return Boolean(this.activeRequests.load || this.applyingLoadResponse);
    }

    /**
     * Loads data to the stores registered in the crud manager. For example:
     *
     * ```javascript
     * crudManager.load(
     *     // here are request parameters
     *     {
     *         store1 : { append : true, page : 3, smth : 'foo' },
     *         store2 : { page : 2, bar : '!!!' }
     *     }
     * ).then(
     *     () => alert('OMG! It works!'),
     *     ({ response, cancelled }) => console.log(`Error: ${cancelled ? 'Cancelled' : response.message}`)
     * );
     * ```
     *
     * ** Note: ** If there is an incomplete load request in progress then system will try to cancel it by calling {@link #function-cancelRequest}.
     * @param {Object} [options] The request parameters. This argument can be omitted like this:
     *
     * ```javascript
     * crudManager.load().then(
     *     () => alert('OMG! It works!'),
     *     ({ response, cancelled }) => console.log(`Error: ${cancelled ? 'Cancelled' : response.message}`)
     * );
     * ```
     *
     * When presented it should be an object where keys are store Ids and values are, in turn, objects
     * of parameters related to the corresponding store. And these parameters will be transferred with a load request.
     *
     * ```javascript
     * {
     *     store1 : { page : 3, append : true, smth : 'foo' },
     *     store2 : { page : 2, bar : '!!!' }
     * },
     * ```
     *
     * Additionally for flat stores `append: true` can be specified to add loaded records to the existing records, default is to remove corresponding store's existing records first.
     * **Please note** that for delta loading you can also use an {@link #config-trackResponseType alternative approach}.
     * @returns {Promise} Promise, which is resolved if request was successful.
     * Both the resolve and reject functions are passed a `state` object. State object has following structure:
     *
     *     {
     *         cancelled       : Boolean, // **optional** flag, which is present when promise was rejected
     *         rawResponse     : String,  // raw response from ajax request, either response xml or text
     *         rawResponseText : String,  // raw response text as String from ajax request
     *         response        : Object,  // processed response in form of object
     *         options         : Object   // options, passed to load request
     *     }
     *
     * If promise was rejected by {@link #event-beforeLoad} event, `state` object will have structure:
     *
     *     {
     *         cancelled : true
     *     }
     *
     */
    load(options) {
        const me = this,
            pack = me.getLoadPackage(options);

        return new Promise((resolve, reject) => {
            /**
             * Fires before {@link #function-load load request} is sent. Return `false` to cancel load request.
             * @event beforeLoad
             * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.
             * @param {Object} pack The data package which contains data for all stores managed by the crud manager.
             */
            if (me.trigger('beforeLoad', { pack }) !== false) {
                // if another load request is in progress let's cancel it
                if (me.activeRequests.load) {
                    me.cancelRequest(me.activeRequests.load.desc);

                    me.trigger('loadCanceled', { pack });
                }

                me.trigger('loadStart', { pack });

                me.emitCrudStoreEvents(pack.stores, 'loadStart');

                me.activeRequests.load = {
                    options,
                    pack,
                    resolve,
                    reject,
                    id   : pack.requestId,
                    desc : me.sendRequest({
                        data    : me.encode(pack),
                        type    : 'load',
                        success : me.onLoadSuccess,
                        failure : me.onLoadFailure,
                        thisObj : me
                    })
                };
            }
            else {
                /**
                 * Fired after {@link #function-load load request} was canceled by some {@link #event-beforeLoad}
                 * listener or due to incomplete prior load request.
                 * @event loadCanceled
                 * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.
                 * @param {Object} pack The data package which contains data for all stores managed by the crud manager.
                 */
                me.trigger('loadCanceled', { pack });
                reject({ cancelled : true });
            }
        });
    }

    async onLoadSuccess(rawResponse, fetchOptions) {
        let responseText = '';

        const
            request     = this.activeRequests.load,
            { options } = request;

        await rawResponse.text().then(value => responseText = value).catch(nullFn$1);

        const response = await this.internalOnLoad(responseText, fetchOptions, options);

        this.emitCrudStoreEvents(request.pack.stores, 'afterRequest');

        if (!response || !response.success) {
            request.reject({ cancelled : false, response, rawResponse, responseText, options });
        }
        else {
            request.resolve({ response, rawResponse, responseText, options });
        }
    }

    async onLoadFailure(rawResponse, fetchOptions = {}) {
        const
            request     = this.activeRequests.load,
            { options } = request,
            wasAborted  = Boolean(fetchOptions.signal && fetchOptions.signal.aborted);

        if (!wasAborted) {
            let responseText = '';

            await rawResponse.text().then(value => responseText = value).catch(nullFn$1);

            const response = await this.internalOnLoad(responseText, fetchOptions, options);

            this.emitCrudStoreEvents(request.pack.stores, 'afterRequest');

            request.reject({ cancelled : wasAborted, response, rawResponse, responseText, options });
        }
    }

    getSubStoresData(rows, subStores, idField, isTree) {
        if (!rows) return;

        const result = [];

        function processRow(row, subStores) {
            subStores.forEach(subStore => {
                const storeId = subStore.storeId;

                // if row contains data for this sub-store
                if (row[storeId]) {
                    // keep them for the later loading
                    result.push({
                        id        : row[idField],
                        storeDesc : subStore,
                        data      : row[storeId]
                    });
                    // and remove reference from the row
                    delete row[storeId];
                }
            });
        }

        // if it's a TreeStore
        if (isTree) {
            // loop over nodes
            rows.forEach(row => {
                processRow(row, subStores);

                // also let's grab sub-stores from node children
                const childrenSubData = this.getSubStoresData(row.children, subStores, idField, true);
                if (childrenSubData) {
                    result.push(...childrenSubData);
                }
            });
            // if it's a "flat" store
        }
        else {
            rows.forEach(row => processRow(row, subStores));
        }

        return result;
    }

    //endregion

    //region Changes (prepare, process, get)

    prepareAdded(list, phantomIdField, stores) {
        return list.filter(record => record.isValid).map(record => {
            const
                cls  = record.constructor,
                data = Object.assign(record.persistableData, {
                    [phantomIdField] : record.id
                });

            if (this.resetIdsBeforeSync) delete ObjectHelper.deletePath(data, cls.getFieldDataSource(cls.idField));

            // if the store has embedded ones
            if (stores) {
                this.processSubStores(record, data, stores);
            }

            return data;
        });
    }

    prepareUpdated(list, stores, storeInfo) {
        const writeAllFields = storeInfo.writeAllFields || (storeInfo.writeAllFields !== false && this.writeAllFields);

        // TODO: root node included into store.modified
        // need to get rid of it since we don't persist it
        if (storeInfo.store.tree) {
            const rootNode = storeInfo.store.rootNode;
            list = list.filter(record => record !== rootNode);
        }

        return list.filter(record => record.isValid).reduce((data, record) => {
            let recordData;

            // write all fields
            if (writeAllFields) {
                recordData = record.persistableData;
            }
            else {
                recordData = record.modificationData;

                // TODO: PORT critical fields
                // critical fields should always be presented
                // const criticalFields = record.getCriticalFields();
                //
                // for (var j = 0; j < criticalFields.length; j++) {
                //     field = criticalFields[j];
                //
                //     if (field.serialize) {
                //         data[field.getName()] = field.serialize(record.get(field.getName()), record);
                //     } else {
                //         data[field.getName()] = record.get(field.getName());
                //     }
                // }
            }

            // if the store has embedded ones
            if (stores) {
                this.processSubStores(record, recordData, stores);
            }

            // recordData can be null
            if (!ObjectHelper.isEmpty(recordData)) {
                data.push(recordData);
            }

            return data;
        }, []);
    }

    prepareRemoved(list) {
        return list.map(record => {
            const cls = record.constructor;

            return ObjectHelper.setPath({}, cls.getFieldDataSource(cls.idField), record.id);
        });
    }

    processSubStores(record, data, stores) {
        stores.forEach(store => {
            const id       = store.storeId,
                subStore = record.get(id);
            // if embedded store is assigned to the record
            if (subStore) {
                // let's collect its changes as well
                const changes = this.getCrudStoreChanges(Object.assign({ store : subStore }, store));

                if (changes) {
                    data[id] = Object.assign(changes, { $store : true });
                }
                else {
                    delete data[id];
                }
            }
            else {
                delete data[id];
            }
        });
    }

    getCrudStoreChanges(storeDescriptor, phantomIdField = storeDescriptor.phantomIdField || this.phantomIdField) {
        const { store, stores } = storeDescriptor;

        let
            added   = store.added.values,
            updated = store.modified.values,
            removed = store.removed.values,
            // sub-stores
            result;

        if (added.length) added = this.prepareAdded(added, phantomIdField, stores);
        if (updated.length) updated = this.prepareUpdated(updated, stores, storeDescriptor);
        if (removed.length) removed = this.prepareRemoved(removed);

        // if this store has changes
        if (added.length || updated.length || removed.length) {
            result = {};

            if (added.length) result.added = added;
            if (updated.length) result.updated = updated;
            if (removed.length) result.removed = removed;
        }

        return result;
    }

    getChangeSetPackage() {
        const pack = {
            type      : 'sync',
            requestId : this.requestId,
            revision  : this.crudRevision
        };

        let found = 0;

        this.crudStores.forEach(store => {
            const changes = this.getCrudStoreChanges(store);
            if (changes) {
                found++;
                pack[store.storeId] = changes;
            }
        });

        return found ? pack : null;
    }

    //endregion

    //region Apply

    applyChangesToRecord(record, rawChanges, stores, store) {
        const
            me      = this,
            modelClass = record.constructor,
            { fieldDataSourceMap } = modelClass,
            recProto = modelClass.prototype,
            changes  = {},
            data    = record.data,
            done    = {
                [me.phantomIdField] : true
            };

        let hasChanges;

        // if this store has sub-stores assigned to some fields
        if (stores) {
            // then first we apply changes to that stores
            stores.forEach(store => {
                const name = store.storeId;

                if (Object.prototype.hasOwnProperty.call(rawChanges, name)) {
                    // remember that we processed this field
                    done[name] = true;

                    const subStore = record.get(name);
                    if (subStore) {
                        me.applyChangesToStore(Object.assign({ store : subStore }, store), rawChanges[name]);
                    }
                    else {
                        console.log("Can't find store for the response sub-package");
                    }
                }
            });
        }

        // Collect the changes into a change set for field names.
        for (const dataSource in rawChanges) {
            if (Object.prototype.hasOwnProperty.call(rawChanges, dataSource) && !done[dataSource]) {
                const
                    field = fieldDataSourceMap[dataSource],
                    propName = field ? field.name : dataSource,
                    value = modelClass.processField(propName, rawChanges[dataSource]),
                    oldValue = dataSource in recProto ? record[propName] : ObjectHelper.getPath(data, dataSource);

                if (!ObjectHelper.isEqual(oldValue, value)) {
                    hasChanges = true;
                    changes[propName] = value;
                }
            }
        }

        if (hasChanges) {
            me.suspendChangesTracking();

            // Set each field seperately until https://app.assembla.com/spaces/bryntum/tickets/9123 is fixed.
            for (const fieldName in changes) {
                record[fieldName] = changes[fieldName];
            }

            // TODO: Re-enable record.set when https://app.assembla.com/spaces/bryntum/tickets/9123 is fixed.
            // Set fields one go
            // record.set(changes);
            me.resumeChangesTracking();
        }

        // Clear changes only for the passed record,
        // not descendant nodes.
        // TODO: they *might* also be genuinely new
        // so might have to stay.
        record.clearChanges(true, false);
    }

    applyRemovals(store, removed, context) {
        const
            {
                removed : removedStash,
                modelClass
            }              = store,
            findByIdFn     = context.findByIdFn,
            removeRecordFn = context.removeRecordFn,
            dataSource     = modelClass.getFieldDataSource(modelClass.idField);

        let applied = 0;

        removed.forEach(remove => {
            const id = remove[dataSource];

            let done = false;

            // just remove the record from the removed stash
            if (removedStash.includes(id)) {
                removedStash.remove(id);
                done = true;
                // number of removals applied
                applied++;
            }

            // if responded removed record isn`t found in store.removed
            // probably don't removed on the client side yet (server driven removal)
            if (!done) {
                const record = findByIdFn(id);

                if (record) {
                    this.suspendChangesTracking();

                    removeRecordFn(record);

                    removedStash.remove(record);
                    // number of removals applied
                    applied++;

                    this.resumeChangesTracking();
                }
                else {
                    console.log('Can\'t find record to remove from the response package');
                }
            }
        });

        return applied;
    }

    getApplyChangesToStoreHelpers(store) {
        // if it's a tree store
        if (store.tree) {
            return {
                findByPhantomFn : id => store.getById(id),
                findByIdFn      : id => store.getById(id),
                // TODO: need to support parentIdProperty
                addRecordFn     : data => {
                    const parent = (data.parentId && store.getById(data.parentId)) || store.rootNode;

                    return parent.appendChild(data);
                },
                removeRecordFn : (record) => record.remove()
            };

            // plain store
        }
        else {
            return {
                findByPhantomFn : id => store.getById(id),
                findByIdFn      : id => store.getById(id),
                addRecordFn     : data => store.add(data)[0],
                removeRecordFn  : record => store.remove(record)
            };
        }
    }

    applyChangesToStore(storeDesc, storeResponse) {
        const
            me                = this,
            phantomIdField    = storeDesc.phantomIdField || me.phantomIdField,
            store             = storeDesc.store,
            { modelClass }    = store,
            idDataSource      = modelClass.getFieldDataSource(modelClass.idField),
            {
                findByPhantomFn,
                findByIdFn,
                addRecordFn,
                removeRecordFn
            }                 = me.getApplyChangesToStoreHelpers(store),
            { rows, removed } = storeResponse;

        // process added/updated records
        if (rows) {
            // sub-stores
            const stores = storeDesc.stores;

            rows.forEach(data => {
                const
                    phantomId = data[phantomIdField],
                    id        = ObjectHelper.getPath(data, idDataSource);

                let record    = null;

                // if phantomId is provided then we will use it to find added record
                if (phantomId != null) {
                    record = findByPhantomFn(phantomId);
                }
                // if id is provided then we will use it to find updated record
                else if (id != null) {
                    record = findByIdFn(id);
                }

                if (record) {
                    me.applyChangesToRecord(record, data, stores, store);
                }
                else {
                    me.suspendChangesTracking();

                    // create new record in the store
                    record = addRecordFn(data);

                    me.resumeChangesTracking();

                    record.clearChanges();
                }
            });
        }

        // process removed records
        if (removed && me.applyRemovals(store, removed, {
            findByIdFn,
            removeRecordFn
        })) {
            store.trigger('dataChanged', { source : store });
        }
    }

    applySyncResponse(response) {
        const
            me     = this,
            stores = me.orderedCrudStores;

        me.applyingSyncResponse = true;

        for (const store of stores) {
            const storeResponse = response[store.storeId];

            if (storeResponse) {
                me.applyChangesToStore(store, storeResponse);
            }
        }

        me.applyingSyncResponse = false;
    }

    applyLoadResponse(response, options) {
        this.applyingLoadResponse = true;

        this.loadCrudManagerData(response, options);

        this.applyingLoadResponse = false;
    }

    async applyResponse(requestType, response, options) {
        // in trackResponseType we check response type before deciding how to react on the response
        if (this.trackResponseType) {
            requestType = response.type || requestType;
        }

        switch (requestType) {
            case 'load' :
                this.applyLoadResponse(response, options);
                break;
            case 'sync' :
                this.applySyncResponse(response);
                break;
        }
    }

    //endregion

    /**
     * Generates unique request identifier.
     * @internal
     * @template
     * @return {Number} The request identifier.
     */
    get requestId() {
        return Date.now() + '' + (this._requestId++);
    }

    /**
     * Persists changes made on the registered stores to the server. Usage:
     *
     * ```javascript
     * // persist and run a callback on request completion
     * crud.sync().then(
     *     () => console.log("Changes saved..."),
     *     ({ response, cancelled }) => console.log(`Error: ${cancelled ? 'Cancelled' : response.message}`)
     * );
     * ```
     *
     * ** Note: ** If there is an incomplete sync request in progress then system will queue the call and delay it until previous request completion.
     * In this case {@link #event-syncDelayed} event will be fired.
     *
     * ** Note: ** Please take a look at {@link #config-autoSync} config. This option allows to persist changes automatically after any data modification.
     * @returns {Promise} Promise, which is resolved if request was successful.
     * Both the resolve and reject functions are passed a `state` object. State object has following structure:
     *
     *     {
     *         cancelled       : Boolean, // **optional** flag, which is present when promise was rejected
     *         rawResponse     : String,  // raw response from ajax request, either response xml or text
     *         rawResponseText : String,  // raw response text as String from ajax request
     *         response        : Object,  // processed response in form of object
     *     }
     *
     * If promise was rejected by {@link #event-beforeSync} event, `state` object will have structure:
     *
     *     {
     *         cancelled : true
     *     }
     *
     */
    sync() {
        const me = this;

        if (me.activeRequests.sync) {
            // let's delay this call and start it only after server response
            /**
             * Fires after {@link #function-sync sync request} was delayed due to incomplete previous one.
             * @event syncDelayed
             * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
             * @param {Object} arguments The arguments of {@link #function-sync} call.
             */
            me.trigger('syncDelayed');

            // Queue sync request after current one
            return me.activeSyncPromise = me.activeSyncPromise.then(() => me.sync(), () => me.sync());
        }

        // Store current requrest promise. While this one is pending, all following sync requests will create chain
        // of sequential promises
        return me.activeSyncPromise = new Promise((resolve, reject) => {
            // get current changes set package
            const pack = me.getChangeSetPackage();

            // if no data to persist we resolve immediately
            if (!pack) {
                resolve(null);
                return;
            }

            /**
             * Fires before {@link #function-sync sync request} is sent. Return `false` to cancel sync request.
             *
             * ```javascript
             *     crudManager.on('beforesync', function() {
             *        // cannot persist changes before at least one record is added
             *        // to the `someStore` store
             *        if (!someStore.getCount()) return false;
             *     });
             * ```
             * @event beforeSync
             * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.
             * @param {Object} pack The data package which contains data for all stores managed by the crud manager.
             */
            if (me.trigger('beforeSync', { pack }) !== false) {

                me.trigger('syncStart', { pack });

                // keep active request details
                me.activeRequests.sync = {
                    pack,
                    resolve,
                    reject,
                    id   : pack.requestId,
                    desc : me.sendRequest({
                        data    : me.encode(pack),
                        type    : 'sync',
                        success : me.onSyncSuccess,
                        failure : me.onSyncFailure,
                        thisObj : me
                    })
                };
            }
            else {
                // if this sync was canceled let's fire event about it
                /**
                 * Fires after {@link #function-sync sync request} was canceled by some {@link #event-beforeSync} listener.
                 * @event syncCanceled
                 * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.
                 * @param {Object} pack The data package which contains data for all stores managed by the crud manager.
                 */
                me.trigger('syncCanceled', { pack });
                reject({ cancelled : true });
            }
        });
    }

    async onSyncSuccess(rawResponse, fetchOptions) {
        let responseText = '';

        await rawResponse.text().then(value => responseText = value).catch(nullFn$1);

        const
            request  = this.activeRequests.sync,
            response = await this.internalOnSync(responseText, fetchOptions);

        if (!response || !response.success) {
            request.reject({ cancelled : false, response, rawResponse, responseText, request });
        }
        else {
            request.resolve({ response, rawResponse, responseText, request });
        }
    }

    async onSyncFailure(rawResponse, fetchOptions = {}) {
        let responseText = '',
            response     = null;

        const
            request    = this.activeRequests.sync,
            wasAborted = Boolean(fetchOptions.signal && fetchOptions.signal.aborted);

        if (!wasAborted) {
            await rawResponse.text().then(value => responseText = value).catch(nullFn$1);

            response = await this.internalOnSync(responseText, fetchOptions);
        }

        if (!wasAborted) {
            request.reject({ cancelled : wasAborted, response, rawResponse, responseText, request });
        }
    }

    /**
     * Commits all records changes of all the registered stores.
     */
    commitCrudStores() {
        this.crudStores.forEach(store => store.store.commit());
    }

    /**
     * Rejects all records changes on all stores and re-insert any records that were removed locally. Any phantom records will be removed.
     */
    rejectCrudStores() {
        this.orderedCrudStores.forEach(store => store.store.clearChanges());
    }

    warn() {
        if ('console' in window) {
            const c = console;
            c.log && c.log.apply && c.log.apply(c, arguments);
        }
    }

    /**
     * Removes all stores and cancels active requests.
     */
    doDestroy() {
        const me = this;

        me.activeRequests.load && me.cancelRequest(me.activeRequests.load.desc);
        me.activeRequests.sync && me.cancelRequest(me.activeRequests.sync.desc);

        while (me.crudStores.length > 0) {
            me.removeCrudStore(me.crudStores[0]);
        }

        clearTimeout(me.autoSyncTimerId);

        me.destroyed = true;

        super.doDestroy && super.doDestroy();
    }

    // set crudRevision(value) {
    //     debugger
    //     this._crudRevision = value;
    // }

    // get crudRevision() {
    //     return this._crudRevision;
    // }
};

/**
 * @module Scheduler/crud/AbstractCrudManager
 */

/**
 * This is an abstract class serving as the base for the {@link Scheduler.data.CrudManager} class.
 * It implements basic mechanisms to organize batch communication with a server.
 * Yet it does not contain methods related to _data transfer_ nor _encoding_.
 * These methods are to be provided in sub-classes by consuming the appropriate mixins.
 *
 * For example, this is how the class can be used to implement an JSON encoding system:
 *
 * ```javascript
 * // let's make new CrudManager using AJAX as a transport system and JSON for encoding
 * class MyCrudManager extends JsonEncode(AjaxTransport(AbstractCrudManager)) {
 *
 * }
 * ```
 *
 * ## Data transfer and encoding methods
 * These are methods that must be provided by subclasses of this class:
 *
 * - [#sendRequest](#Scheduler/crud/AbstractCrudManagerMixin#function-sendRequest)
 * - [#cancelRequest](#Scheduler/crud/AbstractCrudManagerMixin#function-cancelRequest)
 * - [#encode](#Scheduler/crud/AbstractCrudManagerMixin#function-encode)
 * - [#decode](#Scheduler/crud/AbstractCrudManagerMixin#function-decode)
 *
 * @extends Core/Base
 * @mixes Core/mixin/Events
 * @mixes Scheduler/crud/AbstractCrudManagerMixin
 * @abstract
 */
class AbstractCrudManager extends AbstractCrudManagerMixin(Events(Base)) {
    //region Default config

    /**
     * The server revision stamp.
     * The _revision stamp_ is a number which should be incremented after each server-side change.
     * This property reflects the current version of the data retrieved from the server and gets updated after each {@link Scheduler/crud/AbstractCrudManagerMixin#function-load} and {@link Scheduler/crud/AbstractCrudManagerMixin#function-sync} call.
     * @property {Number} revision
     * @readonly
     */
    get revision() {
        return this.crudRevision;
    }

    set revision(value) {
        this.crudRevision = value;
    }

    static get defaultConfig() {
        // debugger
        return Object.assign({}, this.crudManagerDefaultConfig, {
            overrideCrudStoreLoad : true,

            /**
             * Sets the list of stores controlled by the CRUD manager.
             * Store can be provided by itself, its storeId or an object having the following structure:
             * @property {String} stores.storeId Unique store identifier. Under this name the store related requests/responses will be sent.
             * @property {Core.data.Store} stores.store The store itself.
             * @property {String} [stores.phantomIdField] Set this if the store model has a predefined field to keep phantom record identifier.
             * @property {String} [stores.idField] id field name, if it's not specified then class will try to get it from a store model.
             * @config {Core.data.Store[]|String[]|Object[]}
             */
            stores : null

            /**
             * Encodes request to the server.
             * @function encode
             * @param {Object} request The request to encode.
             * @returns {String} The encoded request.
             * @abstract
             */

            /**
             * Decodes response from the server.
             * @function decode
             * @param {String} response The response to decode.
             * @returns {Object} The decoded response.
             * @abstract
             */
        });
    }

    //endregion

    //region Init

    construct(config = {}) {
        if (config.stores) {
            config.crudStores = config.stores;
            delete config.stores;
        }

        super.construct(config);
    }

    //endregion

    //region Store collection (add, remove, get & iterate)

    set stores(stores) {
        // debugger
        if (stores !== this.crudStores) {
            this.crudStores = stores;
        }
    }

    /**
     * A list of registered stores whose server communication will be collected into a single batch.
     * Each store is represented by a _store descriptor_, an object having following structure:
     * @member {Object[]} stores
     * @property {String} stores.storeId Unique store identifier.
     * @property {Core.data.Store} stores.store Store itself.
     * @property {String} [stores.phantomIdField] Set this if store model has a predefined field to keep phantom record identifier.
     * @property {String} [stores.idField] id field name, if it's not specified then class will try to get it from a store model.
     */
    get stores() {
        return this.crudStores;
    }

    //endregion

    /**
     * Returns true if the crud manager is currently loading data
     * @property {Boolean}
     * @readonly
     * @category CRUD
     */
    get isLoading() {
        return this.isCrudManagerLoading;
    }

    /**
     * Commits all records changes of all the registered stores.
     */
    commit() {
        this.commitCrudStores();
    }

    /**
     * Rejects all records changes on all stores and re-insert any records that were removed locally. Any phantom records will be removed.
     */
    reject() {
        this.rejectCrudStores();
    }

    /**
     * Adds a store to the collection.
     *
     *```javascript
     * // append stores to the end of collection
     * crudManager.addStore([
     *     store1,
     *     // storeId
     *     'bar',
     *     // store descriptor
     *     {
     *         storeId : 'foo',
     *         store   : store3
     *     },
     *     {
     *         storeId         : 'bar',
     *         store           : store4,
     *         // to write all fields of modified records
     *         writeAllFields  : true
     *     }
     * ]);
     *```
     *
     * **Note:** Order in which stores are kept in the collection is very essential sometimes.
     * Exactly in this order the loaded data will be put into each store.
     * @param {Core.data.Store|String|Object|Core.data.Store[]|String[]|Object[]} store
     * A store or list of stores. Each store might be specified by its instance, `storeId` or _descriptor_.
     * The _store descriptor_ is an object having following properties:
     * @param {String} store.storeId The store identifier that will be used as a key in requests.
     * @param {Core.data.Store} store.store The store itself.
     * @param {String} [store.idField] The idField of the store. If not specified will be taken from the store model.
     * @param {String} [store.phantomIdField] The field holding unique Ids of phantom records (if store has such model).
     * @param {Boolean} [store.writeAllFields] Set to true to write all fields from modified records
     * @param {Number} [position] The relative position of the store. If `fromStore` is specified the this position will be taken relative to it.
     * If not specified then store(s) will be appended to the end of collection.
     * Otherwise it will be just a position in stores collection.
     *
     * ```javascript
     * // insert stores store4, store5 to the start of collection
     * crudManager.addStore([ store4, store5 ], 0);
     * ```
     *
     * @param {String|Core.data.Store|Object} [fromStore] The store relative to which position should be calculated. Can be defined as a store identifier, instance or descriptor (the result of {@link Scheduler/crud/AbstractCrudManagerMixin#function-getStoreDescriptor} call).
     *
     * ```javascript
     * // insert store6 just before a store having storeId equal to 'foo'
     * crudManager.addStore(store6, 0, 'foo');
     *
     * // insert store7 just after store3 store
     * crudManager.addStore(store7, 1, store3);
     * ```
     */
    addStore(...args) {
        return this.addCrudStore(...args);
    }

    removeStore(...args) {
        return this.removeCrudStore(...args);
    }

    getStore(...args) {
        return this.getCrudStore(...args);
    }

    hasChanges(...args) {
        return this.crudStoreHasChanges(...args);
    }

    loadData(...args) {
        return this.loadCrudManagerData(...args);
    }
}
AbstractCrudManager._$name = 'AbstractCrudManager';

/**
 * @module Scheduler/crud/transport/AjaxTransport
 */

/**
 * Implements data transferring functional that can be used for {@link Scheduler.crud.AbstractCrudManager} super classing.
 * Uses the fetch API for transport, https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
 *
 * @example
 * // create a new CrudManager using AJAX as a transport system and JSON for encoding
 * class MyCrudManager extends AjaxTransport(JsonEncode(AbstractCrudManager)) {}
 *
 * @abstract
 * @mixin
 */
var AjaxTransport = Target => class AjaxTransport extends (Target || Base) {
    /**
     * Configuration of the AJAX requests used to communicate with a server-side.
     * An object where you can set the following possible properties:
     * @config {Object} transport
     * @property {Object} transport.load Load requests configuration:
     * @property {String} transport.load.url URL to request for data loading.
     * @property {String} [transport.load.method='POST'] HTTP method to be used for load requests.
     * @property {String} [transport.load.paramName] Name of parameter in which a packet will be transfered. If not specified then a packet will be transfered in a request body (default).
     * @property {Object} [transport.load.params] Extra load request params if needed.
     * @property {Object} [transport.load.requestConfig] Ajax request config. Can be used instead of above `url`, `method`, `params` and some more:
     * @property {Object} [transport.load.requestConfig.headers] An object containing headers to pass to each server request.
     * @property {Object} [transport.load.requestConfig.fetchOptions] An object containing the Fetch options to pass to each server request.
     * Use this to control if credentials are sent and other options, read more at [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).
     *
     * ```javascript
     * transport   : {
     *     load    : {
     *         requestConfig : {
     *             url             : 'http://some-url',
     *             method          : 'GET',
     *             // get rid of cache-buster parameter
     *             disableCaching  : false,
     *             // extra request parameters
     *             params          : {
     *                 foo         : 'bar'
     *             },
     *             // custom request headers
     *             headers         : {
     *                 ...
     *             },
     *             fetchOptions    : {
     *                 credentials : 'include'
     *             }
     *         }
     *     }
     * }
     * ```
     *
     * @property {Object} transport.sync Sync requests configuration:
     * @property {String} transport.sync.url URL to request for data persisting.
     * @property {String} [transport.sync.method='POST'] HTTP method to be used for sync requests.
     * @property {String} [transport.sync.paramName] Name of parameter in which a packet will be transfered. If not specified then a packet will be transfered in a request body (default).
     * @property {Object} [transport.sync.params] Extra sync request params if needed.
     * @property {Object} [transport.sync.requestConfig] Ajax request config. Can be used instead of above `url`, `method`, `params` and some more:
     * @property {Object} [transport.sync.requestConfig.headers] An object containing headers to pass to each server request.
     * @property {Object} [transport.sync.requestConfig.fetchOptions] An object containing the Fetch options to pass to each server request.
     * Use this to control if credentials are sent and other options, read more at [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).
     *
     * ```javascript
     * transport   : {
     *     sync    : {
     *         requestConfig : {
     *             url             : 'http://some-url',
     *             method          : 'GET',
     *             // get rid of cache-buster parameter
     *             disableCaching  : false,
     *             // extra request parameters
     *             params          : {
     *                 foo         : 'bar'
     *             },
     *             // custom request headers
     *             headers         : {
     *                 ...
     *             },
     *             fetchOptions    : {
     *                 credentials : 'include'
     *             }
     *         }
     *     }
     * }
     * ```
     */

    static get defaultMethod() {
        return {
            load : 'GET',
            sync : 'POST'
        };
    }

    /**
     * Cancels a sent request.
     * @param {Promise} requestPromise The Promise object wrapping the Request to be cancelled.
     * The _requestPromise_ is the return value returned from the corresponding {@link #function-sendRequest} call.
     */
    cancelRequest(requestPromise) {
        requestPromise.abort();
    }

    /**
     * Sends request to the server.
     * @param {Object} request The request configuration object having following properties:
     * @param {String} request.data The encoded request.
     * @param {String} request.type The request type. Either `load` or `sync`.
     * @param {Function} request.success A function to be started on successful request transferring.
     * @param {String} request.success.rawResponse `Response` object returned by the [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
     * @param {Function} request.failure A function to be started on request transfer failure.
     * @param {String} request.failure.rawResponse `Response` object returned by the [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
     * @param {Object} request.thisObj `this` reference for the above `success` and `failure` functions.
     * @return {Promise} The fetch Promise object.
     * @fires beforesend
     */
    sendRequest(config) {
        const
            me            = this,
            pack          = config.data,
            packCfg       = me.transport[config.type] || {},
            paramName     = packCfg.paramName,
            params        = Object.assign({}, packCfg.params),
            method        = packCfg.method || AjaxTransport.defaultMethod[config.type],
            requestConfig = Object.assign({
                url    : packCfg.url,
                method : method,
                params : params
            }, packCfg.requestConfig);

        // if no param name specified then we'll transfer package in the request body
        if (!paramName) {
            // TODO: get rid of this legacy code in the next major release
            // ..here we should simply make: requestConfig.body = pack
            requestConfig.jsonData = pack;
        // ..otherwise we use parameter
        }
        else {
            requestConfig.params = requestConfig.params || {};
            requestConfig.params[paramName] = pack;
        }

        /**
         * Fires before a request is sent to the server.
         *
         * ```javascript
         * crudManager.on('beforesend', function (crud, params, requestType) {
         *     // let's set "sync" request parameters
         *     if (requestType == 'sync') {
         *         // dynamically depending on "flag" value
         *         if (flag) {
         *             params.foo = 'bar';
         *         } else {
         *             params.foo = 'smth';
         *         }
         *     }
         * });
         * ```
         * @event beforeSend
         * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.
         * @param {Object} params Request params
         * @param {String} requestType Request type (`load`/`sync`)
         * @param {Object} requestConfig Configuration object for Ajax request call
         */
        me.trigger('beforeSend', { params, type : config.type, requestConfig, config });

        const
            fetchOptions = Object.assign({
                method,
                headers     : requestConfig.headers,
                queryParams : params,
                body        : method === 'HEAD' || method === 'GET' ? undefined : requestConfig.jsonData
            }, requestConfig.fetchOptions),
            ajaxPromise  = AjaxHelper.fetch(requestConfig.url, fetchOptions);

        ajaxPromise.catch(error => {
            if (!fetchOptions.signal && !fetchOptions.signal.aborted) {
                console.warn(error);
            }
        }).then(response => {
            if (response && response.ok) {
                config.success && config.success.call(config.thisObj || me, response, fetchOptions);
            }
            else {
                config.failure && config.failure.call(config.thisObj || me, response, fetchOptions);
            }
        });

        return ajaxPromise;
    }
};

/**
 * @module Scheduler/crud/mixin/CrudManagerView
 */

/**
 * This mixin class adds Crud Manager functionality to a {@link Grid.view.GridBase} instance.
 *
 * It adds {@link #config-crudManager} config allowing to provide a Crud Manager either as a class instance or as a configuration object
 * (for later the mixin provides {@link #config-crudManagerClass} config defining which class should be instantiated).
 *
 * The mixin also tracks Crud Manager requests to the server and masks the view during them. For masking it
 * uses the grid {@link Grid.view.GridBase#config-loadMask} and {@link Grid.view.GridBase#config-syncMask} properties.
 *
 * @mixin
 */
var CrudManagerView = Target => class CrudManagerView extends (Target) {

    //region Config

    static get $name() {
        return 'CrudManagerView';
    }

    static get defaultConfig() {
        return {
            /**
             * Class that should be used to instantiate a CrudManager in case it's provided as a simple object to {@link #config-crudManager} config
             * @config {Scheduler.crud.AbstractCrudManagerMixin}
             * @category Data
             */
            crudManagerClass : null,

            /**
             * Supply a CrudManager instance or a config object if you want to use CrudManager for handling data
             * @config {Object|Scheduler.crud.AbstractCrudManagerMixin}
             * @category Data
             */
            crudManager : null
        };
    }

    //endregion

    //region Init

    afterConstruct() {
        const me = this;

        if (me.crudManager && me.loadMask && me.crudManager.isCrudManagerLoading) {
            // Show loadMask if crud manager is already loading
            me.maskBody(me.loadMask);
        }
    }

    //endregion

    onCrudManagerLoadStart() {
        // Show loadMask before crud manager starts loading
        if (this.loadMask) {
            this.maskBody(this.loadMask);
        }
    }

    onCrudManagerSyncStart() {
        if (this.syncMask) {
            this.maskBody(this.syncMask);
        }
    }

    onCrudManagerRequestFinalize() {
        if (this.activeMask) {
            this.unmaskBody();
            this.toggleEmptyText();
        }
    }

    onCrudManagerLoadCanceled() {
        this.onCrudManagerRequestFinalize();
    }

    onCrudManagerSyncCanceled() {
        this.onCrudManagerRequestFinalize();
    }

    onCrudManagerLoad() {
        this.onCrudManagerRequestFinalize();
    }

    onCrudManagerSync() {
        this.onCrudManagerRequestFinalize();
    }

    /**
     * Hooks up crud manager listeners
     * @private
     * @category Store
     */
    bindCrudManager(crudManager) {
        this.detachListeners('crudManager');

        crudManager && crudManager.on({
            name         : 'crudManager',
            loadStart    : 'onCrudManagerLoadStart',
            load         : 'onCrudManagerLoad',
            loadCanceled : 'onCrudManagerLoadCanceled',
            syncStart    : 'onCrudManagerSyncStart',
            sync         : 'onCrudManagerSync',
            syncCanceled : 'onCrudManagerSyncCanceled',
            thisObj      : this
        });
    }

    /**
     * Get/set the CrudManager instance
     * @property {Scheduler.data.CrudManager}
     * @category Data
     */
    get crudManager() {
        return this._crudManager;
    }

    set crudManager(crudManager) {
        const me = this;

        if (crudManager && crudManager.isCrudManager) {
            me._crudManager = crudManager;
        }
        else if (crudManager && me.crudManagerClass) {
            // TODO: get rid of this ugliness - crud manager cannot accept "scheduler" config
            // since it's meant to be a pure data class

            // CrudManager injects itself into is Scheduler's _crudManager property
            // because code it triggers needs to access it through its getter.
            crudManager = new me.crudManagerClass(Object.assign({
                scheduler : me
            }, crudManager));
        }
        else {
            me._crudManager = null;
        }

        me.bindCrudManager(me._crudManager);
    }
};

/**
 * @module Scheduler/crud/encoder/JsonEncoder
 */

/**
 * Implements data encoding functional that should be mixed to a {@link Scheduler.crud.AbstractCrudManager} sub-class.
 * Uses _JSON_ as an encoding system.
 *
 * @example
 * // create a new CrudManager using AJAX as a transport system and JSON for encoding
 * class MyCrudManager extends JsonEncode(AjaxTransport(AbstractCrudManager)) {}
 *
 * @mixin
 */
var JsonEncoder = Target => class JsonEncoder extends (Target || Base) {
    //format  : 'json',

    /**
     * Encodes an request object to _JSON_ encoded string. If encoding fails (due to circular structure), it returns null.
     * @param {Object} request The request to encode.
     * @returns {String} The encoded request.
     */
    encode(requestConfig) {
        return StringHelper.safeJsonStringify(requestConfig);
    }

    /**
     * Decodes (parses) a _JSON_ response string to an object. If parsing fails, it returns null.
     * @param {String} responseText The response text to decode.
     * @returns {Object} The decoded response.
     */
    decode(responseText) {
        return StringHelper.safeJsonParse(responseText);
    }
};

class AbstractRecurrenceIterator extends Base {

    static get frequency() {
        return 'NONE';
    }

    static get MAX_OCCURRENCES_COUNT() {
        return 1000000;
    }

    /**
     * Returns Nth occurrence of a week day in the provided period of time.
     * @param  {Date} startDate Period start date.
     * @param  {Date} endDate   Period end date.
     * @param  {Integer} day    Week day (0 - Sunday, 1 - Monday, 2 - Tuesday, etc.)
     * @param  {Integer} index  Index to find.
     * @return {Date}           Returns the found date or null if there is no `index`th entry.
     * @private
     */
    static getNthDayInPeriod(startDate, endDate, day, index) {
        let result, sign, borderDate;

        if (index) {
            const dayDurationInMs = 86400000,
                weekDurationInMs  = 604800000;

            if (index > 0) {
                sign = 1;
                borderDate = startDate;
            } else {
                sign = -1;
                borderDate = endDate;
            }

            // delta between requested day and border day
            const delta = day - borderDate.getDay();

            // if the requested day goes after (before, depending on borderDate used (start/end))
            // we adjust index +/-1
            if (sign * delta < 0) {
                index += sign;
            }

            // measure "index" weeks forward (or backward) ..take delta into account
            result = new Date(borderDate.getTime() + (index - sign) * weekDurationInMs + delta * dayDurationInMs);

            // if resulting date is outside of the provided range there is no "index"-th entry
            // of the day
            if (result < startDate || result > endDate) {
                result = null;
            }
        }

        return result;
    }

    static buildDate(year, month, date) {
        const dt = new Date(year, month, date);

        if (dt.getFullYear() == year && dt.getMonth() == month && dt.getDate() == date) {
            return dt;
        }
    }

    static isValidPosition(position) {
        return Boolean(position);
    }

    static forEachDateAtPositions(dates, positions, fn, scope) {
        const datesLength = dates.length,
            processed     = {};

        for (let i = 0; i < positions.length; i++) {

            const index = positions[i];

            if (this.isValidPosition(index)) {
                const date = index > 0 ? dates[index - 1] : dates[datesLength + index];

                if (date && !processed[date.getTime()]) {

                    // remember that we've returned the date
                    processed[date.getTime()] = true;

                    // return false if it's time to stop recurring
                    if (fn.call(scope, date) === false) {
                        return false;
                    }
                }
            }
        }
    }
}
AbstractRecurrenceIterator._$name = 'AbstractRecurrenceIterator';

/**
 * @module Scheduler/model/AssignmentModel
 */

/**
 * This class represent a single assignment of a resource to an event in scheduler.
 * It is a subclass of {@link Core.data.Model} class.
 * Please refer to the documentation for that class to become familiar with the base interface of this class.
 *
 * An Assignment has the following fields:
 * - `id` - The id of the assignment
 * - `resourceId` - The id of the resource assigned
 * - `eventId` - The id of the event to which the resource is assigned
 *
 * The data source for these fields can be customized by subclassing this class.
 *
 * @extends Core/data/Model
 */
class AssignmentModel extends Model {
    //region Fields
    static get fields() {
        return [
            /**
             * Id for the resource assigned
             * @field {String|Number} resourceId
             */
            { name : 'resourceId' },

            /**
             * Id for the event assigned
             * @field {String|Number} eventId
             */
            { name : 'eventId' }
        ];
    }

    static get relationConfig() {
        return [
            /**
             * Resource assigned
             * @member {Scheduler.model.ResourceModel} resource
             */
            { relationName : 'resource', fieldName : 'resourceId', store : 'resourceStore', collectionName : 'assignments' },

            /**
             * Event assigned
             * @member {Scheduler.model.EventModel} event
             */
            { relationName : 'event', fieldName : 'eventId', store : 'eventStore', collectionName : 'assignments' }
        ];
    }
    //endregion

    //region Stores

    /**
     * A key made up from the event id and the id of the resource assigned to.
     * @property eventResourceKey
     * @readonly
     */
    get eventResourceKey() {
        return `${this.event ? this.eventId : this.data.eventId || this.internalId}-${this.resource ? this.resourceId : this.data.resourceId || this.internalId}`;
    }

    /**
     * Returns an assigment store this assignment is part of. Assignment must be part of an assigment store
     * to be able to retrieve it.
     *
     * @return {Scheduler.data.AssignmentStore}
     */
    get assignmentStore() {
        return this.stores && this.stores[0];
    }

    /**
     * Returns an event store this assignment uses as default event store. Assignment must be part
     * of an assignment store to be able to retrieve default event store.
     *
     * @return {Scheduler.data.EventStore}
     */
    get eventStore() {
        const { assignmentStore } = this;
        return assignmentStore && assignmentStore.eventStore;
    }

    /**
     * Returns a resource store this assignment uses as default resource store. Assignment must be part
     * of an assignment store to be able to retrieve default resource store.
     *
     * @return {Scheduler.data.ResourceStore}
     */
    get resourceStore() {
        const { eventStore } = this;
        return eventStore && eventStore.resourceStore;
    }

    //endregion

    //region Event & resource

    /**
     * Convenience property to get the name of the associated event.
     * @property {String}
     * @readonly
     */
    get eventName() {
        return this.event && this.event.name;
    }

    /**
     * Convenience property to get the name of the associated resource.
     * @property {String}
     * @readonly
     */
    get resourceName() {
        return this.resource && this.resource.name;
    }

    // /**
    //  * Returns an event associated with this assignment.
    //  *
    //  * @privateparam  {Scheduler.data.EventStore} [eventStore]
    //  * @return {Scheduler.model.TimeSpan} Event instance
    //  */
    // getEvent(eventStore = this.eventStore) {
    //     // removed assignment will not have "this.joined" so we are providing a way to get an event via provided
    //     // event store
    //     return eventStore && eventStore.getById(this.eventId);
    // }

    /**
     * Returns the resource associated with this assignment.
     *
     * @privateparam {Scheduler.data.ResourceStore} [resourceStore]
     * @return {Scheduler.model.ResourceModel} Instance of resource
     */
    getResource(resourceStore = this.resourceStore) {
        // removed assignment will not have "this.joined" so we are providing a way to get a resource via provided
        // resource store
        return resourceStore && resourceStore.getById(this.resourceId);
    }

    // /**
    //  * Convenience method to get a name of the associated event.
    //  *
    //  * @privateparam  {Scheduler.data.EventStore} [eventStore]
    //  * @return {String} name
    //  */
    // getEventName(eventStore) {
    //     const evnt = this.getEvent(eventStore);
    //     return evnt && evnt.name || '';
    // }

    // /**
    //  * Convenience method to get a name of the associated resource.
    //  *
    //  * @privateparam {Scheduler.data.ResourceStore} [resourceStore]
    //  * @return {String} name
    //  */
    // getResourceName(resourceStore) {
    //     const resource = this.getResource(resourceStore);
    //     return resource && resource.name || '';
    // }

    //endregion

    // Convenience getter to not have to check `instanceof AssignmentModel`
    get isAssignment() {
        return true;
    }

    /**
     * Returns true if the Assignment can be persisted (e.g. task and resource are not 'phantoms')
     *
     * @return {Boolean} true if this model can be persisted to server.
     */
    get isPersistable() {
        const
            {
                event,
                resource,
                stores,
                unjoinedStores
            }     = this,
            store = stores[0];

        let result;

        if (store) {
            // if crud manager is used it can deal with phantom event/resource since it persists all records in one batch
            // if no crud manager used we have to wait till event/resource are persisted
            result = this.isValid && (store.crudManager || !event.hasGeneratedId && !resource.hasGeneratedId);
        }
        // if we remove the record
        else {
            result = unjoinedStores[0];
        }

        return Boolean(result);
    }

    get isValid() {
        return this.resource != null && this.event != null;
    }

    fullCopy() {
        // NOT IMPLEMENTED
        //return this.copy.apply(this, arguments);
        throw new Error('Not implemented');
    }

    // private
    get eventResourceCompositeKey() {
        return AssignmentModel.makeAssignmentEventResourceCompositeKey(
            this.eventId,
            this.resourceId
        );
    }

    static makeAssignmentEventResourceCompositeKey(eventId, resourceId) {
        return `event(${eventId})-resource(${resourceId})`;
    }
}

AssignmentModel.exposeProperties();
AssignmentModel._$name = 'AssignmentModel';

/**
 * @module Scheduler/data/AssignmentStore
 */

/**
 * A class representing a collection of assignments between events in the {@link Scheduler.data.EventStore} and resources
 * in the {@link Scheduler.data.ResourceStore}.
 *
 * Contains a collection of {@link Scheduler.model.AssignmentModel} records.
 *
 * @extends Core/data/Store
 */
class AssignmentStore extends AjaxStore {
    static get defaultConfig() {
        return {
            /**
             * CrudManager must load stores in the correct order. Lowest first.
             * @private
             */
            loadPriority : 300,
            /**
             * CrudManager must sync stores in the correct order. Lowest first.
             * @private
             */
            syncPriority : 300,

            modelClass : AssignmentModel
        };
    }

    add(newAssignments) {
        if (!Array.isArray(newAssignments)) {
            newAssignments = [newAssignments];
        }
        for (let i = 0; i < newAssignments.length; i++) {
            let a = newAssignments[i];

            if (!(a instanceof Model)) {
                newAssignments[i] = a = this.createRecord(a);
            }
            if (this.storage.findIndex('eventResourceKey', a.eventResourceKey, true) !== -1) {
                throw new Error(`Duplicate assignment Event: ${a.eventId} to resource: ${a.resourceId}`);
            }
        }
        return super.add(newAssignments);
    }

    //region Init & destroy

    set storage(storage) {
        super.storage = storage;

        // This allows a map based, fast lookup of assignments by their eventResourceKey.
        // This is so that the test for duplicate assignment adding is fast.
        this.storage.addIndex('eventResourceKey');
    }

    get storage() {
        return super.storage;
    }

    doDestroy() {
        const me = this;
        me.eventStoreDetacher && me.eventStoreDetacher();
        me.resourceStoreDetacher && me.resourceStoreDetacher();
        super.doDestroy();
    }

    //endregion

    //region Stores

    /**
     * Get/set the associated event store instance.  Usually it is configured automatically, by the event store itself.
     *
     * @param {Scheduler.data.EventStore}
     */
    get eventStore() {
        return this._eventStore;
    }

    set eventStore(eventStore) {
        const me       = this,
            oldStore = me._eventStore;

        me._eventStore = eventStore || null;

        me.attachToEventStore(me._eventStore);

        if ((oldStore || eventStore) && oldStore !== eventStore) {
            /**
             * Fires when new event store is set via {@link #property-eventStore} method.
             * @event eventstorechange
             * @param {Scheduler.data.AssignmentStore} this
             * @param {Scheduler.data.EventStore} newEventStore
             * @param {Scheduler.data.EventStore} oldEventStore
             */
            me.trigger('eventStoreChange', { newEventStore : eventStore, oldEventStore : oldStore });
        }
    }

    attachToEventStore(eventStore) {
        const me = this;

        me.eventStoreDetacher && me.eventStoreDetacher();

        if (eventStore) {
            me.eventStoreDetacher = eventStore.on({
                remove              : me.onEventRemove,
                resourcestorechange : me.onEventStoreResourceStoreChange,
                thisObj             : me,
                prio                : 200 // higher then in cache, we need those handlers to do their job before cache update
            });
        }

        // If store is assigned after configuration we need to init relations
        if (!me.isConfiguring) {
            me.initRelations(true);
        }

        me.attachToResourceStore(eventStore && eventStore.resourceStore);
    }

    attachToResourceStore(resourceStore) {
        const me = this;

        me.resourceStore = resourceStore;

        me.resourceStoreDetacher && me.resourceStoreDetacher();

        if (resourceStore) {
            me.resourceStoreDetacher = resourceStore.on({
                remove    : me.onResourceRemove,
                removeAll : me.onResourceRemoveAll,
                thisObj   : me,
                prio      : 200 // higher then in cache
            });

            // If store is assigned after configuration we need to init relations
            if (!me.isConfiguring) {
                me.initRelations(true);
            }
        }
    }

    onEventStoreResourceStoreChange({ newResourceStore }) {
        this.attachToResourceStore(newResourceStore);
    }

    //endregion

    //region Event & resource events

    // TODO: We have no isMove in our stores
    onEventRemove({ records, isMove, isCollapse }) {
        if (!isMove && !isCollapse) {
            const assignments = [];

            records.forEach(record => {
                // traversing in a flat structure will only call fn on self, no need to handle tree case differently
                record.traverse(eventRecord => {
                    assignments.push(...eventRecord.assignments);
                });
            });

            // Flag that remove is caused by removing events, to prevent getting stuck in removal loop in SchedulerStores
            this.isRemovingEvent = true;
            assignments.length && this.remove(assignments);
            this.isRemovingEvent = false;
        }
    }

    // TODO: We have no isMove in our stores
    onResourceRemove({ records, isMove, isCollapse }) {
        if (!isMove && !isCollapse) {
            const assignments = [];

            records.forEach(record => {
                // traversing in a flat structure will only call fn on self, no need to handle tree case differently
                record.traverse(resourceRecord => {
                    assignments.push(...resourceRecord.assignments);
                });
            });

            // TODO: Make resource removal behaviour configurable
            assignments.length && this.remove(assignments);
        }
    }

    onResourceRemoveAll() {
        // TODO: Make resource removal behaviour configurable
        this.removeAll();
    }

    //endregion

    //region Mapping

    /**
     * Maps over event assignments.
     *
     * @param {Scheduler.model.EventModel} event
     * @param {Function} [fn]
     * @param {Function} [filterFn]
     * @return {Array}
     */
    mapAssignmentsForEvent(event, fn, filterFn) {
        const me          = this,
            fnSet       = Boolean(fn),
            filterFnSet = Boolean(filterFn),
            eventId     = Model.asId(event),
            assignmentCache = me.relationCache.event && me.relationCache.event[eventId];

        if (!assignmentCache) return [];

        fn       = fn || (a => a);
        filterFn = filterFn || (() => true);

        if (fnSet || filterFnSet) {
            return assignmentCache.reduce((result, assignment) => {
                const mapResult = fn(assignment);

                if (filterFn(mapResult)) {
                    //result = result.concat([mapResult]);
                    result.push(mapResult);
                }

                return result;
            }, []);
        }

        return assignmentCache;
    }

    /**
     * Maps over resource assignments.
     *
     * @param {Scheduler.model.ResourceModel|Number|String} resource
     * @param {Function} [fn]
     * @param {Function} [filterFn]
     * @return {Scheduler.model.ResourceModel[]}
     */
    mapAssignmentsForResource(resource, fn, filterFn) {
        const me          = this,
            fnSet       = Boolean(fn),
            filterFnSet = Boolean(filterFn),
            resourceId  = Model.asId(resource),
            assignmentCache = me.relationCache.resource && me.relationCache.resource[resourceId];

        if (!assignmentCache) return [];

        fn       = fn || (a => a);
        filterFn = filterFn || (() => true);

        if (fnSet || filterFnSet) {
            return assignmentCache.reduce((result, assignment) => {
                const mapResult = fn(assignment);

                if (filterFn(mapResult)) {
                    //result = result.concat([mapResult]);
                    result.push(mapResult);
                }

                return result;
            }, []);
        }

        return assignmentCache;
    }

    /**
     * Returns all assignments for a given event.
     *
     * @param {Scheduler.model.TimeSpan} event
     * @return {Scheduler.model.AssignmentModel[]}
     */
    getAssignmentsForEvent(event) {
        return event.assignments;
    }

    /**
     * Removes all assignments for given event
     *
     * @param {Scheduler.model.TimeSpan|Object} event
     */
    removeAssignmentsForEvent(event) {
        return this.remove(event.assignments);
    }

    /**
     * Returns all assignments for a given resource.
     *
     * @param {Scheduler.model.ResourceModel|Object} event
     * @return {Scheduler.model.TimeSpan[]}
     */
    getAssignmentsForResource(resource) {
        return this.mapAssignmentsForResource(resource);
    }

    /**
     * Removes all assignments for given resource
     *
     * @param {Scheduler.model.ResourceModel|*} resource
     */
    removeAssignmentsForResource(resource) {
        this.remove(this.getAssignmentsForResource(resource));
    }

    /**
     * Returns all resources assigned to an event.
     *
     * @param {Scheduler.model.EventModel} event
     * @return {Scheduler.model.ResourceModel[]}
     */
    getResourcesForEvent(event) {
        const me = this;

        // TODO: cache event -> resource
        //if (!me.relationCache.events) return []; //return me.eventResourceCache.get(event);

        return me.mapAssignmentsForEvent(
            event,
            assignment => assignment.resource,
            resource => Boolean(resource)
        );
    }

    /**
     * Returns all events assigned to a resource
     *
     * @param {Scheduler.model.ResourceModel|*} resource
     * @return {Scheduler.model.TimeSpan[]}
     */
    getEventsForResource(resource) {
        const me = this;

        //if (me.resourceEventsCache) return me.resourceEventsCache.get(resource);

        return me.mapAssignmentsForResource(
            resource,
            assignment => assignment.event,
            event => !!event
        );
    }

    /**
     * Creates and adds assignment record(s) for a given event and resource.
     *
     * @param {Scheduler.model.TimeSpan|*} event
     * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]} resources The resource(s) to assign to the event
     * @privateparam {Function} [assignmentSetupFn]
     * @privateparam {Boolean} [removeExistingAssignments] true to first remove existing assignments
     * @return {Scheduler.model.AssignmentModel[]} An array with the created assignment(s)
     */
    assignEventToResource(event, resources, assignmentSetupFn = o => o, removeExistingAssignments = false) {
        const
            me            = this,
            oldAutoCommit = me.autoCommit;

        resources = Array.isArray(resources) ? resources : [resources];

        let newAssignments = [];

        me.autoCommit = false;

        if (removeExistingAssignments && event.resources) {
            // First unassign from old resources
            event.resources.forEach(resource => {
                if (!resources.includes(resource)) {
                    me.unassignEventFromResource(event, resource);
                }
            });
        }

        // Assign
        resources.forEach(resource => {
            if (!me.isEventAssignedToResource(event, resource)) {
                let assignment = new me.modelClass({
                    eventId    : Model.asId(event),
                    resourceId : Model.asId(resource)
                });

                assignment = assignmentSetupFn(assignment);

                newAssignments.push(assignment);
            }
        });

        newAssignments = me.add(newAssignments);

        // If true, will trigger a commit
        me.autoCommit = oldAutoCommit;

        return newAssignments;
    }

    /**
     * Removes assignment record for a given event and resource.
     *
     * @param {Scheduler.model.TimeSpan|String|Number} event
     * @param {Scheduler.model.ResourceModel|String|Number} [resources] The resource to unassign the event from. If omitted, all resources of the events will be unassigned
     * @return {Scheduler.model.AssignmentModel|Scheduler.model.AssignmentModel[]}
     */
    unassignEventFromResource(event, resources) {
        const
            me = this,
            assignmentsToRemove = [];

        if (!resources) {
            return me.removeAssignmentsForEvent(event);
        }

        if (!Array.isArray(resources)) {
            resources = [resources];
        }

        for (let i = 0; i < resources.length; i++) {
            if (me.isEventAssignedToResource(event, resources[i])) {
                assignmentsToRemove.push(me.getAssignmentForEventAndResource(event, resources[i]));
            }
        }
        return me.remove(assignmentsToRemove);
    }

    /**
     * Checks whether an event is assigned to a resource.
     *
     * @param {Scheduler.model.EventModel|String|Number} event Event record or id
     * @param {Scheduler.model.ResourceModel|String|Number} resource Resource record or id
     * @return {Boolean}
     */
    isEventAssignedToResource(event, resource) {
        const me       = this,
            records    = me.getResourcesForEvent(event),
            resourceId = Model.asId(resource);

        // noinspection EqualityComparisonWithCoercionJS
        return records.some(res => res.id == resourceId);
    }

    /**
     * Returns an assignment record for a given event and resource
     *
     * @param {Scheduler.model.EventModel|String|Number} event The event or its id
     * @param {Scheduler.model.ResourceModel|String|Number} resource The resource or its id
     * @return {Scheduler.model.AssignmentModel}
     */
    getAssignmentForEventAndResource(event, resource) {
        const me = this;

        event    = me.eventStore.getById(event);
        resource = me.resourceStore.getById(resource);

        //const key = me.modelClass.makeAssignmentEventResourceCompositeKey(event, resource);

        //TODO: PORT key map
        //return me.records.find(a => key == me.modelClass.makeAssignmentEventResourceCompositeKey(a.eventId, a.resourceId));

        // noinspection EqualityComparisonWithCoercionJS
        return me.records.find(assignment => assignment.event == event && assignment.resource == resource);
    }

    //endregion
}
AssignmentStore._$name = 'AssignmentStore';

/**
 * @module Scheduler/model/CalendarDayModel
 */

/**
 * A model representing a single day in the calendar. Depending on the `type` field, day may be a concrete day per se (2012/01/01),
 * a certain weekday (all Thursdays), or an override for all certain weekdays in the timeframe
 * (all Fridays between 2012/01/01 - 2012/01/15, inclusive).
 *
 * A collection of CalendarDayModel instances to be provided for the {@link Scheduler.data.Calendar calendar}
 *
 * @extends Core/data/Model
 */
class CalendarDayModel extends Model {
    static get fields() {
        return [

            /**
             * The id of the date. Can be an arbitrary unique value, assigned by the server
             * @field {String|Number} id
             */

            /**
             * The date for this day in the ISO 8601 format. Any time information in this field will be cleared. If this
             * instance represents a weekday or week override, this field will be ignored.
             * @field {String|Date} date
             */
            {
                name    : 'date',
                type    : 'date',
                format  : 'YYYY-MM-DD',
                persist : true
            },

            /**
             * The index of the week day (0 - Sunday, 1 - Monday and so on) if this instance contains information about the week day (applicable for `WEEKDAY` and `WEEKDAYOVERRIDE`).
             * Should be set to -1 for the "main" instance of the week overrides.
             * @field {Number} weekday
             */
            { name : 'weekday', type : 'int' },

            /**
             * The start date of the timespan for week day override.
             * @field {Date} overrideStartDate
             */
            {
                name       : 'overrideStartDate',
                type       : 'date',
                dateFormat : 'YYYY-MM-DD'
            },

            /**
             * The end date of the timespan for week day override.
             * @field {Date} overrideEndDate
             */
            {
                name       : 'overrideEndDate',
                type       : 'date',
                dateFormat : 'YYYY-MM-DD'
            },

            /**
             * The type of this calendar day. Can be one of the following `DAY`, `WEEKDAY`, `WEEKDAYOVERRIDE`:
             * - Default value is `DAY` meaning this day represents a "real" day in the calendar (2012/01/01 for example) and contains availability information for that particular day only.
             * The date is stored in the `Date` field.
             * - The `WEEKDAY` value means calendar day contains information about all weekdays with the index, given in the `Weekday` field (0 - Sunday, 1 - Monday and so on).
             * For example - all Fridays. `Date` field is ignored.
             * - <p>The `WEEKDAYOVERRIDE` value means calendar day contains information about all weekdays within certain timespan. For example - all Fridays between 2012/01/01 - 2012/01/15.
             * Week day index should be stored in the `Weekday` field again, beginning of the timespan - in the `OverrideStartDate` field and the end of timespan - in the `OverrideEndDate`.
             * </p>
             * <p>
             * A single day instance contains the override for a single week day. So, to define overrides for several days (Monday and Tuesday for example) - add an additional instance
             * to the calendar with the same `Name/OverrideStartDate/OverrideEndDate` values. There's no need to define an override for every weekday - if some day is not defined - the
             * default availability will be used.
             * </p>
             * <p>
             * * **Note** Every week override should also have a "main" calendar day instance, representing the override itself. It should have the same
             * values for `Name/OverrideStartDate/OverrideEndDate` fields and -1 for `Weekday`. Also, the timespans of all week overrides should not intersect.
             * </p>
             * <p>
             * To avoid manual creation of week overrides you can use the calendar API (for example, {@link Scheduler.data.Calendar#function-addNonStandardWeek addNonStandardWeek},
             * {@link Scheduler.data.Calendar#function-removeNonStandardWeek removeNonStandardWeek} methods).
             * </p>
             * @field {String} type
             * @default 'DAY'
             */
            {
                name         : 'type',
                defaultValue : 'DAY' // 'DAY', 'WEEKDAY', 'WEEKDAYOVERRIDE'
            },

            /**
             * Optional boolean flag, allowing you to specify exceptions - working days which falls on weekends. Default value is `false`. **Please note**, that simply setting this
             * field to "true" is not enough - you also need to specify the exact hours that are available for work with the `Availability` field (see below).
             * @field {Boolean} isWorkingDay
             * @default false
             */
            { name : 'isWorkingDay', type : 'boolean', defaultValue : false },

            /**
             * Optional name of the CSS class, which can be used by various plugins working with weekends and holidays.
             * Default value is `gnt-holiday` If a holiday lasts for several days, then all days should have the same
             * `cls` value.
             * @field {String} cls
             */
            {
                name : 'cls'//,
                //defaultValue : 'b-sch-nonworkingtime'
            },

            /**
             * Optional name of the day (holiday name for example)
             * @field {String} name
             */
            { name : 'name' },

            /**
             * Availability information for this day. Should be an array of strings or objects, containing the hourly
             * availability for this day. Strings should have the following format:
             * ```javascript
             * // two working intervals
             * [ '08:00-12:00', '13:00-17:00' ]
             *
             * // whole 24 hours are available
             * [ '00:00-24:00' ]
             * ```
             * Objects:
             * ```
             * [{
             *    startTime       : new Date(0, 0, 0, 8),
             *    endTime         : new Date(0, 0, 0, 12)
             * }]
             * ```
             * **Please note**, that this field overrides `isWorkingDay` - for example, a day with
             * "isWorkingDay : false" and "Availability : [ '08:00-12:00' ]" - will be considered a working day.
             * @field {String[]|Object[]} availability
             */
            {
                name    : 'availability',
                persist : true//,
                // convert : function(value, record) {
                //     if (value) {
                //         return typeof value === 'string' ? [value] : value;
                //     } else {
                //         return [];
                //     }
                // }
            }
        ];
    }

    set date(date) {
        if (date) date = DateHelper.startOf(date, 'day');

        this.set('date', date);
    }

    get date() {
        return this.get('date');
    }

    /**
     * Clears the date for this day
     */
    clearDate() {
        this.set('date', null);
    }

    // needed since you cannot override setter only
    get availability() {
        return this.get('availability');
    }

    set availability(intervals) {
        // clear cache
        this.availabilityCache = null;

        this.set('availability', this.stringifyIntervals(intervals));

        // to trigger the `verifyAvailability`
        this.getAvailability();
    }

    /**
     * This method returns the availability for this day. By default it will decode an array of strings '08:00-12:00' to
     * an array of objects like:
     * ```javascript
     * {
     *    startTime       : new Date(0, 0, 0, 8),
     *    endTime         : new Date(0, 0, 0, 12)
     * }
     * ```
     * You can pass the "asString" flag to disable that and just return strings.
     *
     * @param {Boolean} asString Whether to just return an array of strings, instead of objects.
     * @return {Object[]|String[]} Array of objects with "startTime", "endTime" properties.
     */
    getAvailability(asString) {
        const me = this;

        // Return the raw availability array with strings
        if (asString) return me.get('availability');

        if (me.availabilityCache) return me.availabilityCache;

        const parsed = me.get('availability').map(value =>
            typeof value === 'string' ? me.parseInterval(value) : value
        );

        me.verifyAvailability(parsed);

        return me.availabilityCache = parsed;
    }

    verifyAvailability(intervals) {
        const me = this;

        intervals.sort((a, b) => a.startTime - b.startTime);

        intervals.forEach((interval, i) => {
            if (interval.startTime > interval.endTime) {
                throw new Error(`Start time ${DateHelper.format(interval.startTime, 'HH:mm')} is greater than end time ${DateHelper.format(interval.endTime, 'HH:mm')}`);
            }

            if (i > 0 && intervals[i - 1].endTime > interval.startTime) {
                throw new Error(`Availability intervals should not intersect: [${me.stringifyInterval(intervals[i - 1])}] and [${me.stringifyInterval(interval)}]`);
            }
        });
    }

    //prependZero(value) {
    //    return value < 10 ? '0' + value : value;
    //}

    stringifyInterval(interval) {
        const startTime = interval.startTime,
            endTime   = interval.endTime;

        return DateHelper.format(startTime, 'HH:mm') + '-' + DateHelper.format(endTime, 'HH:mm');

        //return this.prependZero(startTime.getHours()) + ':' + this.prependZero(startTime.getMinutes()) + '-' +
        //    (endTime.getDate() == 1 ? 24 : this.prependZero(endTime.getHours())) + ':' + this.prependZero(endTime.getMinutes());
    }

    stringifyIntervals(intervals) {
        const me = this;

        return intervals.map(interval =>
            typeof interval === 'string' ? interval : me.stringifyInterval(interval)
        );
    }

    parseInterval(string) {
        const match = /(\d\d):(\d\d)-(\d\d):(\d\d)/.exec(string);

        if (!match) throw new Error(`Invalid format for availability string: ${String}. It should have exact format: hh:mm-hh:mm`);

        return {
            startTime : new Date(0, 0, 0, match[1], match[2]),
            endTime   : new Date(0, 0, 0, match[3], match[4])
        };
    }

    /**
     * Returns the total length of all availability intervals for this day in hours.
     *
     * @property {Number}
     * @readonly
     */
    get totalHours() {
        return this.getTotalMS() / 1000 / 60 / 60;
    }

    /**
     * Returns the total length of all availability intervals for this day in milliseconds.
     *
     * @property {Number}
     * @readonly
     */
    get totalMS() {
        return this.getAvailability().reduce((totalMS, interval) => totalMS += interval.endTime - interval.startTime, 0);
    }

    /**
     * Adds a new availability interval to this day. Both arguments should have the same format.
     *
     * @param {Date|String} startTime Start time of the interval. Can be a Date object (new Date(0, 0, 0, 8)) or just a plain string: '08'
     * @param {Date|String} endTime End time of the interval. Can be a Date object (new Date(0, 0, 0, 12)) or just a plain string: '12'
     */
    addAvailabilityInterval(startTime, endTime) {
        let interval;

        if (startTime instanceof Date) {
            interval = {
                startTime : startTime,
                endTime   : endTime
            };
        }
        else {
            interval = this.parseInterval(startTime + (endTime ? '-' + endTime : ''));
        }

        const intervals = this.getAvailability().concat(interval);

        this.verifyAvailability(intervals);

        this.setAvailability(intervals);
    }

    /**
     * Removes the availability interval by its index.
     *
     * @param {Number} index Ordinal position of the interval to be removed
     */
    removeAvailabilityInterval(index) {
        const intervals = this.getAvailability();

        intervals.splice(index, 1);

        this.setAvailability(intervals);
    }

    /**
     * Applies the availability intervals to a concrete day. For example the availability intervals [ '08:00-12:00', '13:00-17:00' ],
     * applied to a day 2012/01/01 will return the following result:
     * ```javascript
     * [
     * {
     *     startDate       : new Date(2012, 0, 1, 8),
     *     endDate         : new Date(2012, 0, 1, 12)
     * },
     * {
     *     startDate       : new Date(2012, 0, 1, 13),
     *     endDate         : new Date(2012, 0, 1, 17)
     * }
     * ]
     * ```
     * @param {Date} timeDate The date to apply the intervals to
     * @returns {Object[]} Array of objects with "startDate / endDate" properties.
     */
    getAvailabilityIntervalsFor(timeDate) {
        timeDate = typeof timeDate === 'number' ? new Date(timeDate) : timeDate;

        const year  = timeDate.getFullYear(),
            month = timeDate.getMonth(),
            date  = timeDate.getDate();

        return this.getAvailability().map(interval => {
            const endDate = interval.endTime.getDate();

            return {
                startDate : new Date(year, month, date, interval.startTime.getHours(), interval.startTime.getMinutes()),
                endDate   : new Date(year, month, date + (endDate == 1 ? 1 : 0), interval.endTime.getHours(), interval.endTime.getMinutes())
            };
        });
    }

    /**
     * Returns the earliest available time for the given date. If this day has no availability intervals it returns `null`.
     *
     * @param {Date} timeDate The date to get the earliest availability time for.
     * @return {Date}
     */
    getAvailabilityStartFor(timeDate) {
        const intervals = this.getAvailabilityIntervalsFor(timeDate);

        if (!intervals.length) return null;

        return intervals[0].startDate;
    }

    /**
     * Returns the latest available time for the given date. If this day has no availability intervals, it returns `null`.
     *
     * @param {Date} timeDate The date to get the latest availability time for.
     * @return {Date}
     */
    getAvailabilityEndFor(timeDate) {
        const intervals = this.getAvailabilityIntervalsFor(timeDate);

        if (!intervals.length) return null;

        return intervals[intervals.length - 1].endDate;
    }
}
CalendarDayModel._$name = 'CalendarDayModel';

/**
 * @module Scheduler/model/TimeSpan
 */

/**
 * This class represent a simple date range. It is being used in various subclasses and plugins which operate on date ranges.
 *
 * Its a subclass of  {@link Core.data.Model}.
 * Please refer to documentation of those classes to become familar with the base interface of this class.
 *
 * A TimeSpan has the following fields:
 *
 * - `startDate`    - start date of the task in the ISO 8601 format
 * - `endDate`      - end date of the task in the ISO 8601 format (not inclusive)
 * - `duration`     - duration, time between start date and end date
 * - `durationUnit` - unit used to express the duration
 * - `name`         - an optional name of the range
 * - `cls`          - an optional CSS class to be associated with the range.
 *
 * The data source of any field can be customized in the subclass. Please refer to {@link Core.data.Model} for details. To specify
 * another date format:
 *
 * ```javascript
 * class MyTimeSpan extends TimeSpan {
 *   static get fields() {
 *      { name: 'startDate', type: 'date', dateFormat: 'DD/MM/YY' }
 *   }
 * }
 * ```
 *
 * @extends Core/data/Model
 */
class TimeSpan extends Model {
    //region Field definitions

    static get fields() {
        return [
            /**
             * The start date of a time span (or Event / Task).
             *
             * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a
             * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and
             * change the dateFormat for this field.
             *
             * @field {String|Date} startDate
             */
            { name : 'startDate', type : 'date' },

            /**
             * The end date of a time span (or Event / Task).
             *
             * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a
             * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and
             * change the dateFormat for this field.
             *
             * @field {String|Date} endDate
             */
            { name : 'endDate', type : 'date' },

            /**
             * The numeric part of the timespan's duration (the number of units).
             * @field {Number} duration
             */
            { name : 'duration', type : 'number', allowNull : true },

            /**
             * The unit part of the TimeSpan duration, defaults to "d" (days). Valid values are:
             *
             * - "ms" (milliseconds)
             * - "s" (seconds)
             * - "m" (minutes)
             * - "h" (hours)
             * - "d" (days)
             * - "w" (weeks)
             * - "M" (months)
             * - "y" (years)
             *
             * This field is readonly after creation, to change durationUnit use #setDuration().
             * @field {String} durationUnit
             */
            {
                name         : 'durationUnit',
                type         : 'string',
                defaultValue : 'd'
            },

            {
                name    : 'fullDuration',
                persist : false
            },

            /**
             * An encapsulation of the CSS classes to add to the rendered time span element.
             * @field {Core.helper.util.DomClassList|String} cls
             *
             * This may be accessed as a string, but for granular control of adding and
             * removing individual classes, it is recommended to use the
             * {@link Core.helper.util.DomClassList DomClassList} API.
             */
            {
                name         : 'cls',
                defaultValue : ''
            },

            /**
             * CSS class specifying an icon to apply to the rendered time span element.
             * @field {String} iconCls
             */
            'iconCls',

            /**
             * A CSS style string (applied to `style.cssText`) or object (applied to `style`)
             * ```
             * record.style = 'color: red;font-weight: 800';
             * ```
             *
             * @field {String} style
             */
            {
                name : 'style',
                type : 'object'
            },

            /**
             * The name of the time span (or Event / Task)
             * @field {String} name
             */
            { name : 'name', type : 'string' }
        ];
    }

    //endregion

    //region Init

    afterConstruct() {
        super.afterConstruct();

        // This should probably be a property setter of some mandatory config, then we would not need an afterConfigure implementation.
        this.normalize();
    }

    normalize() {
        const
            me                                             = this,
            { startDate, endDate, duration, durationUnit } = me,
            hasDuration                                    = duration != null;

        // need to calculate duration (checking first since seemed most likely to happen)
        if (startDate && endDate && !hasDuration) {
            me.setData('duration', DateHelper.diff(startDate, endDate, durationUnit, true));
        }
        // need to calculate endDate?
        else if (startDate && !endDate && hasDuration) {
            me.setData('endDate', DateHelper.add(startDate, duration, durationUnit));
        }
        // need to calculate startDate
        else if (!startDate && endDate && hasDuration) {
            me.setData('startDate', DateHelper.add(endDate, -duration, durationUnit));
        }

        this.clearCachedValues();
    }

    //endregion

    //region Getters & Setters

    get cls() {
        if (!this._cls) {
            this._cls = new DomClassList(super.get('cls'));
        }
        return this._cls;
    }

    set cls(cls) {
        const me = this;

        if (me._cls) {
            me._cls.value = cls;
        }
        else {
            me._cls = new DomClassList(cls);
        }
        me.set('cls', me._cls.value);
    }

    get startDate() {
        return this.get('startDate');
    }

    set startDate(date) {
        this.setStartDate(date);
    }

    get endDate() {
        return this.get('endDate');
    }

    set endDate(date) {
        this.setEndDate(date);
    }

    get duration() {
        return this.get('duration');
    }

    set duration(duration) {
        this.setDuration(duration, this.durationUnit);
    }

    get durationUnit() {
        return this.get('durationUnit');
    }

    /**
     * Sets duration and durationUnit in one go. Only allowed way to change durationUnit, the durationUnit field is
     * readonly after creation
     * @param {Number} duration Duration value
     * @param {String} durationUnit Unit for specified duration value, see {@link #field-durationUnit} for valid values
     */
    setDuration(duration, durationUnit = this.durationUnit) {
        // Must be a number
        duration = parseFloat(duration);

        const toSet = {
            duration,
            durationUnit
        };

        if (this.startDate) {
            toSet.endDate = DateHelper.add(this.startDate, duration, durationUnit);
        }
        else if (this.endDate) {
            toSet.startDate = DateHelper.add(this.endDate, -duration, durationUnit);
        }

        this.set(toSet);
    }

    /**
     * Property which encapsulates the duration's magnitude and units.
     */
    get fullDuration() {
        // Used for formatting during export
        return new Duration({
            unit      : this.durationUnit,
            magnitude : this.duration
        });
    }

    set fullDuration(duration) {
        if (typeof duration === 'string') {
            duration = DateHelper.parseDuration(duration, true, this.durationUnit);
        }

        this.setDuration(duration.magnitude, duration.unit);
    }

    /**
     * Sets the range start date
     *
     * @param {Date} date The new start date
     * @param {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the event), `false` to change the duration ("resize" the event).
     * Defaults to `true`
     */
    setStartDate(date, keepDuration = true) {
        const me    = this,
            toSet = {
                startDate : date
            };

        if (date) {
            let calcEndDate;

            if (keepDuration) {
                calcEndDate = me.duration != null;
            }
            else {
                if (me.endDate) {
                    toSet.duration = DateHelper.diff(date, me.endDate, me.durationUnit, true);

                    if (toSet.duration < 0) throw new Error('Negative duration');
                }
                else {
                    calcEndDate = this.duration != null;
                }
            }

            if (calcEndDate) {
                toSet.endDate = DateHelper.add(date, me.duration, me.durationUnit);
            }
        }
        else {
            toSet.duration = null;
        }

        me.set(toSet);
    }

    /**
     * Sets the range end date
     *
     * @param {Date} date The new end date
     * @param {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the event), `false` to change the duration ("resize" the event).
     * Defaults to `false`
     */
    setEndDate(date, keepDuration = false) {
        const me    = this,
            toSet = {
                endDate : date
            };

        if (date) {
            let calcStartDate;

            if (keepDuration === true) {
                calcStartDate = me.duration != null;
            }
            else {
                if (me.startDate) {
                    toSet.duration = DateHelper.diff(me.startDate, date, me.durationUnit, true);

                    if (toSet.duration < 0) throw new Error('Negative duration');
                }
                else {
                    calcStartDate = this.duration != null;
                }
            }

            if (calcStartDate) {
                toSet.startDate = DateHelper.add(date, -me.duration, me.durationUnit);
            }
        }

        me.set(toSet);
    }

    /**
     * Sets the event start and end dates
     *
     * @param {Date} start The new start date
     * @param {Date} end The new end date
     */
    setStartEndDate(start, end) {
        this.set({
            startDate : start,
            endDate   : end
        });
    }

    /**
     * Returns an array of dates in this range. If the range starts/ends not at the beginning of day, the whole day will be included.
     * @return {Date[]}
     */
    get dates() {
        const dates     = [],
            startDate = DateHelper.startOf(this.startDate, 'day'),
            endDate   = this.endDate;

        for (let date = startDate; date < endDate; date = DateHelper.add(date, 1, 'day')) {
            dates.push(date);
        }

        return dates;
    }

    /**
     * Returns the duration of this Event in milliseconds.
     * @private
     */
    get durationMS() {
        if (this.endDate && this.startDate) {
            return this.endDateMS - this.startDateMS;
        }
        else {
            return DateHelper.asMilliseconds(this.duration || 0, this.durationUnit);
        }
    }

    // Caching isMilestone, startDate and endDate ms conversion since it costs a bit during rendering
    clearCachedValues() {
        this._startDateMS = null;
        this._endDateMS = null;
        this._isMilestone = null;
    }

    get endDateMS() {
        const me = this;

        if (me._endDateMS == null) {
            me._endDateMS = me.endDate && me.endDate.getTime();
        }

        return me._endDateMS;
    }

    get startDateMS() {
        const me = this;

        if (me._startDateMS == null) {
            me._startDateMS = me.startDate && me.startDate.getTime();
        }

        return me._startDateMS;
    }

    get isMilestone() {
        const me = this;

        if (me._isMilestone == null) {
            me._isMilestone = me.durationMS === 0;
        }

        return me._isMilestone;
    }

    inSetNormalize(field) {
        if (typeof field !== 'string') {
            // If user is updating multiple properties in one go using an object, we help out
            // by filling out missing schedule related data
            field = Object.assign({}, field);

            if ('duration' in field) {
                if (field.startDate && !field.endDate) {
                    field.endDate = DateHelper.add(field.startDate, field.duration, field.durationUnit || this.durationUnit, true, true);
                }

                if (!field.startDate && field.endDate) {
                    field.startDate = DateHelper.add(field.endDate, -field.duration, field.durationUnit || this.durationUnit, true, true);
                }
            }
            else if (field.startDate && field.endDate) {
                field.duration = DateHelper.diff(field.startDate, field.endDate, field.durationUnit || this.durationUnit, true);
            }
            return field;
        }
    }

    inSet(field, value, silent, fromRelationUpdate) {
        this.clearCachedValues();
        field = this.inSetNormalize(field) || field;
        return super.inSet(field, value, silent, fromRelationUpdate);
    }

    //endregion

    //region Iteration

    /**
     * Iterates over the {@link #property-dates}
     * @param {Function} func The function to call for each date
     * @param {Object} thisObj `this` reference for the function
     */
    forEachDate(func, thisObj) {
        return this.dates.forEach(func.bind(thisObj));
    }

    //endregion

    /**
     * Checks if the range record has both start and end dates set and start <= end
     *
     * @return {Boolean}
     */
    get isScheduled() {
        const me = this;
        return Boolean(me.startDate && me.endDate && me.hasValidDates);
    }

    // Simple check if end date is greater than start date
    get isValid() {
        const
            me = this;
        let result = true; //super.isValid(),

        if (result) {
            const start = me.startDate,
                end   = me.endDate;
            result = !start || !end || (end - start >= 0);
        }

        return result;
    }

    // Simple check if just end date is greater than start date
    get hasValidDates() {
        const me    = this,
            start = me.startDateMS,
            end   = me.endDateMS;

        return !start || !end || (end - start >= 0);
    }

    /**
     * Shift the dates for the date range by the passed amount and unit
     * @param {String} unit The unit to shift by, see {@Core.helper.DateHelper} for more information on valid formats.
     * @param {Number} amount The amount to shift
     */
    shift(amount, unit = this.durationUnit) {
        // TODO REMOVE FOR 2.0
        if (typeof amount === 'string') {
            const u = amount;

            amount = unit;
            unit = u;
        }

        this.setStartDate(DateHelper.add(this.startDate, amount, unit, true), true);
    }

    /**
     * Returns the WBS code of this model (only relevant when it's part of a tree store).
     * @return {String} The WBS code string
     * @private
     */
    get wbsCode() {
        return this.indexPath.join('.');
    }

    fullCopy() {
        //NOT PORTED

        return this.copy.apply(this, arguments);
    }

    intersects(timeSpan) {
        return this.intersectsRange(timeSpan.startDate, timeSpan.endDate);
    }

    intersectsRange(start, end) {
        const myStart = this.startDate,
            myEnd   = this.endDate;

        return myStart && myEnd && DateHelper.intersectSpans(myStart, myEnd, start, end);
    }

    /**
     * Splits this event into two pieces at the desired position.
     *
     * @param {Number} splitPoint A number greater than 0 and less than 1, indicating how this event will be split. 0.5 means cut it in half
     * @return {Scheduler.model.TimeSpan} The newly created split section of the timespan
     */
    split(splitPoint = 0.5) {
        const me              = this,
            clone           = this.copy(),
            eventStore      = me.firstStore,
            assignmentStore = eventStore && eventStore.assignmentStore,
            ownNewDuration  = me.duration * splitPoint,
            cloneDuration   = me.duration - ownNewDuration;

        if (splitPoint <= 0 || splitPoint >= 1) {
            throw new Error('Split point must be > 0 and < 1');
        }

        me.duration = ownNewDuration;
        clone.startDate = me.endDate;
        clone.duration = cloneDuration;

        if (eventStore) {
            eventStore.add(clone);
        }

        if (assignmentStore) {
            assignmentStore.add(
                me.assignments.map((assignment) => {
                    const clonedData = Object.assign({}, assignment.data, { eventId : clone.id });
                    delete clonedData.id;

                    return clonedData;
                })
            );
        }

        return clone;
    }
}
TimeSpan._$name = 'TimeSpan';

/**
 * @module Scheduler/data/Calendar
 */

/**
 * A class representing a customizable calendar with weekends, holidays and availability information for any day.
 * Internally, it's just a subclass of the AjaxStore class which should be loaded with a collection
 * of {@link Scheduler.model.CalendarDayModel} instances. Additionally, calendars may have parent-child relations,
 * allowing "child" calendars to "inherit" all special dates from its "parent" and add its own.
 * See {@link #property-parent} property for details.
 *
 * A calendar can be instantiated like this:
 * ```
 * let calendar = new Scheduler.data.Calendar({
 *     data : [
 *         {
 *             date            : new Date(2010, 0, 13),
 *             cls             : 'national-holiday'
 *         },
 *         {
 *             date            : new Date(2010, 1, 1),
 *             cls             : 'company-holiday'
 *         },
 *         {
 *             date            : new Date(2010, 0, 16),
 *             isWorkingDay    : true
 *         }
 *     ]
 * });
 * ```
 * Please refer to the {@link Scheduler.model.CalendarDayModel} class to learn the data model used for the calendar.
 */
class Calendar extends AjaxStore {
    static get defaultConfig() {
        return {
            modelClass : CalendarDayModel,

            /**
             * Number of days per month. Will be used when converting the big duration units like month/year to days.
             *
             * @config {Number}
             * @default
             */
            daysPerMonth : 30,

            /**
             * Number of days per week. Will be used when converting the duration in weeks to days.
             *
             * @config {Number}
             * @default
             */
            daysPerWeek : 7,

            /**
             * Number of hours per day. Will be used when converting the duration in days to hours.
             *
             * **Please note**, that this config is used for duration conversion and not anything else. If you need to change
             * the number of working hours in the day, update the {@link #config-defaultAvailability}
             *
             * @config {Number}
             * @default
             */
            hoursPerDay : 24,

            unitsInMs : null,

            defaultNonWorkingTimeCssCls : 'b-nonworkingtime',

            /**
             * Setting this option to `true` will treat *all* days as working days. Default value is `false`.
             * @config {Boolean}
             * @default
             */
            weekendsAreWorkdays : false,

            /**
             * The index of the first day in a weekend, 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on. '
             * Default value is 6 - Saturday
             * @config {Number}
             * @default
             */
            weekendFirstDay : 6,

            /**
             * The index of the second day in weekend, 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on.
             * Default value is 0 - Sunday
             * @config {Number}
             * @default
             */
            weekendSecondDay : 0,

            holidaysCache              : null,
            availabilityIntervalsCache : null,
            daysIndex                  : null,

            // a "cached" array of WEEKDAY days
            weekAvailability : null,

            // the "very default" availability array, calculated based on `defaultAvailability` property
            defaultWeekAvailability : null,

            nonStandardWeeksByStartDate : null,
            nonStandardWeeksStartDates  : null,

            /**
             * The unique id for the calendar. Providing a `calendarId` will register this calendar in the calendars
             * registry and it can be retrieved later with {@link #function-getCalendar-static}. Generally only required if want to use
             * {@link #property-parent parent-child relations} between the calendars, or assign this calendar to a particular
             * task or resource.
             *
             * @config {String}
             */
            calendarId : null,

            /**
             * The parent calendar. Can be provided as the calendar id or calendar instance itself. If this property is
             * provided or set with {@link #property-parent} property, this calendar becomes a "child" of the specified
             * calendar. This means that it will "inherit" all day overrides, week days and week day overrides from its
             * "parent". In the same time, special days, defined in this calendar take priority over the ones from the
             * "parent".
             *
             * You can use this feature if you'd like to create a single "main" calendar for the whole project, and then
             * allow some task or resource to have slightly different calendar (with an additional day off for example).
             * You will not have to re-create all special days in the calendar of such task/resource - just set the
             * "main" calendar as a "parent" for it.
             *
             * @config {String|Scheduler.data.Calendar}
             */
            parent : null,

            /**
             * The array of default availability intervals (in the format of the
             * `Availability` field in the {@link Scheduler.model.CalendarDayModel}) for each working weekday (Monday-Friday). Defaults
             * to whole day (00-24) for backward compatibility.
             * @config {String[]}
             * @default
             */
            defaultAvailability : ['00:00-24:00'],

            /**
             * The name of this calendar
             * @config {String}
             */
            name : null,

            suspendCacheUpdate : 0,

            /**
             * Maximum number of days to search for calendar availability intervals.
             * Used in various calculations requiring to respect working time.
             * In these cases the system iterates through the working time day by day. This option determines the maximum distance
             * to iterate. Prevents against infinite loop in case of wrong calendar configuration.
             * @config {Number}
             * @default
             */
            availabilitySearchLimit : 1825 //5*365
        };
    }

    /**
     * Returns an array of all registered calendars.
     *
     * @return {Scheduler.data.Calendar[]}
     */
    static get allCalendars() {
        return (Store.stores || []).filter(store => store instanceof Calendar);
    }

    /**
     * Get/set the calendarId of the current calendar, also registers it in the calendar registry.
     * @property {String}
     */
    get calendarId() {
        return this._calendarId;
    }

    /**
     * Sets the {@link #property-parent} for this calendar. Pass `null` to remove the parent.
     *
     * @param {String|Scheduler.data.Calendar} parentOrId String with {@link #config-calendarId} value or calendar instance itself.
     */
    set parent(parentOrId) {
        const me     = this,
            parent = Calendar.getCalendar(parentOrId);

        if (parentOrId && !parent) throw new Error('Invalid parent specified for the calendar');

        if (me.parent != parent) {
            const listeners = {
                calendarchange : me.clearCache,
                destroy        : me.onParentDestroy,
                thisObj        : me
            };

            const oldParent = me.parent;

            if (oldParent) oldParent.un(listeners);

            me._parent = parent;

            if (parent) parent.on(listeners);

            me.params = Object.assign(me.params || {}, { parentId : parent ? parent.calendarId : null });

            me.clearCache();

            /**
             * Triggered when a calender is assigned to a new parent calendar.
             * @event parentChange
             *
             * @param {Scheduler.data.Calendar} source The calendar which parent has changed
             * @param {Scheduler.data.Calendar} newParent The new parent of this calendar (can be `null` if parent is being removed)
             * @param {Scheduler.data.Calendar} oldParent The old parent of this calendar (can be `null` if there was no parent)
             */
            me.trigger('parentChange', { newParent : parent, oldParent });
        }
    }

    construct(config) {
        const me = this;

        super.construct(config);

        // TODO: This will be from static get properties() when https://app.assembla.com/spaces/bryntum/tickets/5165 is done
        me.unitsInMs = {
            MILLI   : 1,
            SECOND  : 1000,
            MINUTE  : 60 * 1000,
            HOUR    : 60 * 60 * 1000,
            DAY     : me.hoursPerDay * 60 * 60 * 1000,
            WEEK    : me.daysPerWeek * me.hoursPerDay * 60 * 60 * 1000,
            MONTH   : me.daysPerMonth * me.hoursPerDay * 60 * 60 * 1000,
            QUARTER : 3 * me.daysPerMonth * 24 * 60 * 60 * 1000,
            YEAR    : 4 * 3 * me.daysPerMonth * 24 * 60 * 60 * 1000
        };

        me.defaultWeekAvailability = me.getDefaultWeekAvailability();

        // traditional "on-demand" caching seems to be not so efficient for calendar (in theory)
        // calculating any cached property, like, "weekAvailability" or "nonStandardWeeksStartDates" will require full calendar scan each time
        // so we update ALL cached values on any CRUD operations
        me.on({
            // TODO ignore changes of "name/cls" field?
            change  : me.clearCache,
            thisObj : me
        });

        me.clearCache();
    }

    /**
     * Returns the registered calendar with the given id.
     *
     * @param {String} id The calendar id
     * @return {Scheduler.data.Calendar}
     */
    static getCalendar(id) {
        if (id instanceof Calendar) return id;

        return Store.getStore(id);
    }

    set calendarId(id) {
        const me = this;

        me._calendarId = id;

        if (id != null) {
            me.storeId = 'GNT_CALENDAR:' + id;
        }
        else {
            me.storeId = null;
        }

        me.params = Object.assign(me.params || {}, { calendarId : id });
    }

    getDefaultWeekAvailability() {
        let availability     = this.defaultAvailability,
            weekendFirstDay  = this.weekendFirstDay,
            weekendSecondDay = this.weekendSecondDay,
            res              = [];

        for (let i = 0; i < 7; i++) {
            res.push(
                this.weekendsAreWorkdays || i != weekendFirstDay && i != weekendSecondDay
                    ? new this.modelClass({
                        type         : 'WEEKDAY',
                        weekday      : i,
                        availability : availability && availability.slice() || [],
                        isWorkingDay : true
                    })
                    :                    new this.modelClass({ type : 'WEEKDAY', weekday : i, availability : [] })
            );
        }

        return res;
    }

    /**
     * Destroys all registered calendars.
     *
     * @return {Scheduler.data.Calendar[]}
     */
    removeAll() {
        Calendar.allCalendars.forEach(calendar => {
            calendar.storeId = null; //unregisters from Store map
            calendar.destroy();
        });
    }

    /**
     * Returns `true` or `false` depending whether the given time span intersects with one of the defined week day overrides.
     *
     * @param {Date} startDate The start date of the time span
     * @param {Date} endDate The end date of the time span
     *
     * @return {Boolean}
     */
    intersectsWithCurrentWeeks(startDate, endDate) {
        let result = false;

        this.forEachNonStandardWeek(week => {
            const weekStartDate = week.startDate,
                weekEndDate   = week.endDate;

            if (weekStartDate <= startDate && startDate < weekEndDate || weekStartDate < endDate && endDate <= weekEndDate) {
                result = true;

                // stop the iteration
                return false;
            }
        });

        return result;
    }

    // will scan through all calendar days in the store and save references to special ones to the properties, for speedup
    clearCache() {
        const me = this;

        if (me.suspendCacheUpdate > 0) return;

        me.holidaysCache              = {};
        me.availabilityIntervalsCache = {};

        const daysIndex = me.daysIndex = {},
            weekAvailability = me.weekAvailability = [],
            nonStandardWeeksStartDates = me.nonStandardWeeksStartDates = [],
            nonStandardWeeksByStartDate = me.nonStandardWeeksByStartDate = {};

        me.forEach(function(calendarDay) {
            // backward compat
            let id            = calendarDay.id,
                overrideMatch = /^(\d)-(\d\d\d\d\/\d\d\/\d\d)-(\d\d\d\d\/\d\d\/\d\d)$/.exec(id),
                weekDayMatch  = /^WEEKDAY:(\d+)$/.exec(id),
                type          = calendarDay.type,
                weekDay       = calendarDay.weekday;

            if (type == 'WEEKDAYOVERRIDE' || overrideMatch) {
                let startDate, endDate;

                if (type == 'WEEKDAYOVERRIDE') {
                    startDate = calendarDay.overrideStartDate;
                    endDate   = calendarDay.overrideEndDate;
                }

                // backward compat
                if (overrideMatch) {
                    startDate = DateHelper.parse(overrideMatch[2], 'YYYY/MM/DD');
                    endDate   = DateHelper.parse(overrideMatch[3], 'YYYY/MM/DD');
                    weekDay   = overrideMatch[1];
                }

                // allow partially defined days - they will not be included in calculations
                if (startDate && endDate && weekDay != null) {
                    const startDateNum = startDate - 0;

                    if (!nonStandardWeeksByStartDate[startDateNum]) {
                        nonStandardWeeksByStartDate[startDateNum] = {
                            startDate        : new Date(startDate),
                            endDate          : new Date(endDate),
                            name             : calendarDay.getName(),
                            weekAvailability : [],
                            // main day representing the week override itself - for example for overrides w/o any re-defined availability
                            mainDay          : null
                        };

                        nonStandardWeeksStartDates.push(startDateNum);
                    }

                    if (weekDay >= 0) {
                        nonStandardWeeksByStartDate[startDateNum].weekAvailability[weekDay] = calendarDay;
                    }
                    else {
                        nonStandardWeeksByStartDate[startDateNum].mainDay = calendarDay;
                    }
                }
            }
            else if (type == 'WEEKDAY' || weekDayMatch) {
                if (weekDayMatch) weekDay = weekDayMatch[1];

                // again - only fully defined records will be taken into account
                if (weekDay != null) {
                    if (weekDay < 0 || weekDay > 6) {
                        throw new Error('Incorrect week day index');
                    }

                    weekAvailability[weekDay] = calendarDay;
                }
            }
            else {
                const date = calendarDay.date;

                if (date) daysIndex[date - 0] = calendarDay;
            }
        });

        // Numeric sort, can't use default JS sort which is string based
        nonStandardWeeksStartDates.sort((a, b) => a - b);

        /**
         * Triggered on changes to the calendar.
         * @event calendarChange
         * @param {Scheduler.data.Calendar} source
         */
        me.trigger('calendarChange');
    }

    /**
     * Adds a week day override ("non-standard" week) to the calendar. As a reminder, week day override consists from up to 7 days,
     * that re-defines the default week days availability only within certain time span.
     *
     * @param {Date} startDate The start date of the time span
     * @param {Date} endDate The end date of the time span
     * @param {Scheduler.model.CalendarDayModel[]|String[]} weekAvailability The array indexed from 0 to 7, containing items for week days.
     * Index 0 corresponds to Sunday, 1 to Monday, etc. Some items can be not defined or set to `null`, indicating that override does not
     * change this week day. Item can be - an instance of {@link Scheduler.model.CalendarDayModel} (only `Availability` field needs to be set), or
     * an array of strings, defining the availability (see the description of the `Availability` field in the {@link Scheduler.model.CalendarDayModel}).
     * @param {String} name The name of this week day override
     */
    addNonStandardWeek(startDate, endDate, weekAvailability, name) {
        startDate = DateHelper.clearTime(startDate);
        endDate   = DateHelper.clearTime(endDate);

        if (this.intersectsWithCurrentWeeks(startDate, endDate)) {
            throw new Error('Can not add intersecting week');
        }

        const DayModel = this.modelClass,
            days     = [];

        weekAvailability.forEach((day, index) => {
            if (day instanceof CalendarDayModel) {
                day.type              = 'WEEKDAYOVERRIDE';
                day.overrideStartDate = startDate;
                day.overrideEndDate   = endDate;
                day.weekday           = index;
                day.name              = name || 'Week override';

                days.push(day);
            }
            else if (Array.isArray(day)) {
                const newDay = new DayModel();

                newDay.type              = 'WEEKDAYOVERRIDE';
                newDay.overrideStartDate = startDate;
                newDay.overrideEndDate   = endDate;
                newDay.weekday           = index;
                newDay.name              = name || 'Week override';
                newDay.setAvailability(day);

                days.push(newDay);
            }
        });

        const mainDay = new DayModel();

        mainDay.type              = 'WEEKDAYOVERRIDE';
        mainDay.overrideStartDate = startDate;
        mainDay.overrideEndDate   = endDate;
        mainDay.weekday           = -1;
        mainDay.name              = name || 'Week override';

        days.push(mainDay);

        this.add(days);
    }

    /**
     * Returns an object describing a week day override ("non-standard" week), that starts at the given date or `null` if there's no any.
     *
     * @param {Date} startDate The start date of the week day override
     *
     * @return {Object} An object with the following properties
     * @return {Object} return.name A "Name" field of the week days in the override
     * @return {Date} return.startDate An "OverrideStartDate" field of the week days in the override
     * @return {Date} return.endDate An "OverrideEndDate" field of the week days in the override
     * @return {Scheduler.model.CalendarDayModel[]} return.weekAvailability An array with the week days, defined by this override. May be filled only partially if
     * week day override does not contain all days.
     * @return {Scheduler.model.CalendarDayModel} return.mainDay A "main" day instance for this override
     */
    getNonStandardWeekByStartDate(startDate) {
        return this.nonStandardWeeksByStartDate[DateHelper.clearTime(startDate) - 0] || null;
    }

    /**
     * Removes all calendar day instances, that forms a week day override ("non-standard" week) with the given start date.
     *
     * @param {Date} startDate The start date of the week day override
     */
    removeNonStandardWeek(startDate) {
        startDate = DateHelper.clearTime(startDate) - 0;

        const week = this.getNonStandardWeekByStartDate(startDate);

        if (!week) return;

        this.remove(ArrayHelper.clean(week.weekAvailability).concat(week.mainDay));
    }

    /**
     * Returns an object describing a week day override ("non-standard" week), that contains the given date or `null` if there's no any.
     *
     * @param {Date} timeDate The date that falls within some of the week day overrides
     *
     * @return {Object} An object describing week day override. See {@link #function-getNonStandardWeekByStartDate} method for details.
     */
    getNonStandardWeekByDate(timeDate) {
        timeDate = DateHelper.clearTime(timeDate) - 0;

        const nonStandardWeeksStartDates  = this.nonStandardWeeksStartDates,
            nonStandardWeeksByStartDate = this.nonStandardWeeksByStartDate;

        for (let i = 0; i < nonStandardWeeksStartDates.length; i++) {
            const week = nonStandardWeeksByStartDate[nonStandardWeeksStartDates[i]];

            // since `nonStandardWeeksStartDates` are sorted inc and week overrides do not intersect
            // we can shorcut in this case
            if (week.startDate > timeDate) break;

            if (week.startDate <= timeDate && timeDate <= week.endDate) {
                return week;
            }
        }

        return null;
    }

    /**
     * Updates the default availability information based on the value provided.
     *
     * @param {Boolean} value true if weekends should be regarded as working time.
     */
    setWeekendsAreWorkDays(value) {
        const me = this;

        if (value !== me.weekendsAreWorkdays) {
            me.weekendsAreWorkdays = value;

            // Must generate new defaultWeekAvailability
            me.defaultWeekAvailability = me.getDefaultWeekAvailability();

            me.clearCache();
        }
    }

    /**
     * Returns true if weekends are regarded as working time.
     *
     * @return {Boolean} true if weekends should be regarded as working time.
     */
    areWeekendsWorkDays() {
        return this.weekendsAreWorkdays;
    }

    /**
     * Iterator for each week day override, defined in this calendar.
     *
     * @param {Function} func The function to call for each override. It will receive a single argument - object, describing the override.
     * See {@link #function-getNonStandardWeekByStartDate} for details. Returning `false` from the function stops the iterator.
     * @param {Object} thisObj `this` reference for the function
     *
     * @return {Boolean} `false` if any of the function calls have returned `false`
     */
    forEachNonStandardWeek(func, thisObj) {
        const me                          = this,
            nonStandardWeeksStartDates  = this.nonStandardWeeksStartDates,
            nonStandardWeeksByStartDate = this.nonStandardWeeksByStartDate;

        for (let i = 0; i < nonStandardWeeksStartDates.length; i++) {
            if (func.call(thisObj || me, nonStandardWeeksByStartDate[nonStandardWeeksStartDates[i]]) === false) return false;
        }
    }

    /**
     * Returns a corresponding {@link Scheduler.model.CalendarDayModel} instance for the given date. First, this method checks for {@link #function-getOverrideDay day overrides}
     * (either in this or parent calendars), then for week days (again, in this or parent calendars) and finally fallbacks to the
     * calendar day with the {@link #config-defaultAvailability} availability.
     *
     * @param {Date} timeDate A date (can contain time portion which will be ignored)
     *
     * @return {Scheduler.model.CalendarDayModel}
     */
    getCalendarDay(timeDate) {
        timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;

        return this.getOverrideDay(timeDate) || this.getWeekDay(timeDate.getDay(), timeDate) || this.getDefaultCalendarDay(timeDate.getDay());
    }

    /**
     * Returns a day override corresponding to the given date (possibly found in the parent calendars) or `null` if the given date
     * has no overrides in this calendar and all its parents.
     *
     * @param {Date} timeDate The date to check for day overrides for
     * @return {Scheduler.model.CalendarDayModel}
     */
    getOverrideDay(timeDate) {
        return this.getOwnCalendarDay(timeDate) || this.parent && this.parent.getOverrideDay(timeDate) || null;
    }

    /**
     * Returns an "own" day override corresponding to the given date. That is - day override defined in the current calendar only.
     *
     * @param {Date} timeDate The date to check for day overrides for
     * @return {Scheduler.model.CalendarDayModel}
     */
    getOwnCalendarDay(timeDate) {
        timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;

        return this.daysIndex[DateHelper.clearTime(timeDate) - 0];
    }

    /**
     * Returns a "special" week day corresponding to the given date. Under "special" week day we mean a calendar day with the `Type = WEEKDAY` or `WEEKDAYOVERRIDE`.
     * See the {@link Scheduler.model.CalendarDayModel} class for details. If the concrete date is given as 2nd argument, this method will
     * first check for any week overrides passing on it.
     *
     * If not found in current calendar, this method will consult parent. If no "special" week day found neither in this calendar, no parents - it returns `null`.
     *
     * @param {Number} weekDayIndex The index of the week day to retrieve (0-Sunday, 1-Monday, etc)
     * @param {Date} [timeDate] The date for which the week day is being retrieved.
     * @return {Scheduler.model.CalendarDayModel}
     */
    getWeekDay(weekDayIndex, timeDate) {
        // if 2nd argument is provided then try to search in non-standard weeks first
        if (timeDate) {
            const week = this.getNonStandardWeekByDate(timeDate);

            if (week && week.weekAvailability[weekDayIndex]) return week.weekAvailability[weekDayIndex];
        }

        return this.weekAvailability[weekDayIndex] || this.parent && this.parent.getWeekDay(weekDayIndex, timeDate) || null;
    }

    /**
     * Returns a boolean indicating whether a passed date falls on the weekend or holiday.
     *
     * @param {Date} timeDate A given date (can contain time portion)
     *
     * @return {Boolean}
     */
    isHoliday(timeDate) {
        const secondsSinceEpoch = timeDate - 0,
            holidaysCache     = this.holidaysCache;

        if (holidaysCache[secondsSinceEpoch] != null) {
            return holidaysCache[secondsSinceEpoch];
        }

        timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;

        const day = this.getCalendarDay(timeDate);

        if (!day) throw new Error("Can't find day for " + timeDate);

        return holidaysCache[secondsSinceEpoch] = !day.isWorkingDay;
    }

    /**
     * Returns a "default" calendar day instance, corresponding to the one, generated from {@link #config-defaultAvailability}. By default all working days in the week
     * corresponds to the day with {@link #config-defaultAvailability} set in the `Availability` field and non-working days has empty `Availability`.
     *
     * @param {Number} weekDayIndex The index of the "default" week day to retrieve (0-Sunday, 1-Monday, etc)
     * @return {Scheduler.model.CalendarDayModel}
     */
    getDefaultCalendarDay(weekDayIndex) {
        if (!this.hasOwnProperty('defaultAvailability') && !this.hasOwnProperty('weekendsAreWorkdays') && this.parent) {
            return this.parent.getDefaultCalendarDay(weekDayIndex);
        }

        return this.defaultWeekAvailability[weekDayIndex];
    }

    /**
     * Returns a boolean indicating whether a passed date is a working day.
     *
     * @param {Date} date A given date (can contain time portion which will be ignored)
     *
     * @return {Boolean}
     */
    isWorkingDay(date) {
        return !this.isHoliday(date);
    }

    /**
     * Returns `true` if given date passes on the weekend and `false` otherwise. Weekend days can be re-defined with the {@link #config-weekendFirstDay} and {@link #config-weekendSecondDay} options.
     *
     * @param {Date} timeDate The date to check
     * @return {Boolean}
     */
    isWeekend(timeDate) {
        const dayIndex = timeDate.getDay();
        return dayIndex === this.weekendFirstDay || dayIndex === this.weekendSecondDay;
    }

    /**
     * Convert the duration given in milliseconds to a given unit. Uses the {@link #config-daysPerMonth} configuration option.
     *
     * @param {Number} durationInMs Duration in milliseconds
     * @param {String} unit Duration unit to which the duration should be converted
     *
     * @return {Number} converted value
     */
    convertMSDurationToUnit(durationInMs, unit) {
        return durationInMs / this.unitsInMs[DateHelper.getUnitByName(unit)];
    }

    /**
     * Convert the duration given in some unit to milliseconds. Uses the {@link #config-daysPerMonth} configuration option.
     *
     * @param {Number} durationInMs
     * @param {String} unit
     *
     * @return {Number} converted value
     */
    convertDurationToMs(duration, unit) {
        return duration * this.unitsInMs[DateHelper.getUnitByName(unit)];
    }

    /**
     * This an iterator that passes through the all availability intervals (working time intervals) in the given date range.
     *
     * For example if the default availability in this calendar is [ '09:00-13:00', '14:00-18:00' ] and this function is called, like this:
     *
     *      calendar.forEachAvailabilityInterval(
     *           //             midnight  Friday                 midnight Tuesday
     *          { startDate : new Date(2013, 1, 8), endDate : new Date(2013, 1, 12) },
     *          function (startDate, endDate) { ... }
     *      )
     * then the provided function will be called 4 times with the following arguments:
     *
     *      startDate : new Date(2013, 1, 8, 9),    endDate : new Date(2013, 1, 8, 13)
     *      startDate : new Date(2013, 1, 8, 14),   endDate : new Date(2013, 1, 8, 18)
     *      startDate : new Date(2013, 1, 11, 9),   endDate : new Date(2013, 1, 11, 13)
     *      startDate : new Date(2013, 1, 11, 14),  endDate : new Date(2013, 1, 11, 18)
     *
     *
     * @param {Object} options An object with the following properties:
     * @param {Date} options.startDate A start date of the date range. Can be omitted, if `isForward` flag is set to `false`. In this case iterator
     * will not stop until the call to `func` will return `false`.
     * @param {Date} options.endDate An end date of the date range. Can be omitted, if `isForward` flag is set to `true`. In this case iterator
     * will not stop until the call to `func` will return `false`.
     * @param {Boolean} [options.isForward=true] A flag, defining the direction, this iterator advances in. If set to `true` iterations
     * will start from the `startDate` option and will advance in date increasing direction. If set to `false` iterations will start from the `endDate`
     * option and will advance in date decreasing direction.
     * @param {Function} func A function to call for each availability interval, in the given date range. It receives 2 arguments - the start date
     * of the availability interval and the end date.
     * @param {Object} thisObj `this` reference for the function
     *
     * @return {Boolean} `false` if any of the calls to `func` has returned `false`
     */
    forEachAvailabilityInterval(options, func, thisObj) {
        thisObj         = thisObj || this;
        let me        = this,
            startDate = options.startDate,
            endDate   = options.endDate,

            // isForward by default
            isForward = options.isForward !== false;

        if (isForward ? !startDate : !endDate) {
            throw new Error('At least `startDate` or `endDate` is required, depending from the `isForward` option');
        }

        let cursorDate = new Date(isForward ? startDate : endDate),
            DATE       = DateHelper;

        // if no boundary we still have to specify some limit
        if (isForward) {
            if (!endDate) {
                endDate = DATE.add(startDate, options.availabilitySearchLimit || me.availabilitySearchLimit || 5 * 365, 'day');
            }
        }
        else {
            if (!startDate) {
                startDate = DATE.add(endDate, -(options.availabilitySearchLimit || me.availabilitySearchLimit || 5 * 365), 'day');
            }
        }

        // the clearTime() method is called a lot during this method (like 200k times for 2k tasks project)
        // sometimes w/o real need for it since we always advance to the next day's boundary
        // this optimization brings it down to ~10k, ~10% speed up
        let noNeedToClearTime = false;

        while (isForward ? cursorDate < endDate : cursorDate > startDate) {
            // - 1 for backward direction ensures that we are checking correct day,
            // since the endDate is not inclusive - 02/10/2012 means the end of 02/09/2012
            // for backward direction we always clear time, because intervals are cached by the beginning of the day
            let intervals = me.getAvailabilityIntervalsFor(cursorDate - (isForward ? 0 : 1), isForward ? noNeedToClearTime : false);

            // the order of processing is different for forward / backward processing
            for (let i = isForward ? 0 : intervals.length - 1; isForward ? i < intervals.length : i >= 0; isForward ? i++ : i--) {
                let interval          = intervals[i],
                    intervalStartDate = interval.startDate,
                    intervalEndDate   = interval.endDate;

                // availability interval is out of [ startDate, endDate )
                if (intervalStartDate >= endDate || intervalEndDate <= startDate) continue;

                let countingFrom = intervalStartDate < startDate ? startDate : intervalStartDate,
                    countingTill = intervalEndDate > endDate ? endDate : intervalEndDate;

                if (func.call(thisObj, countingFrom, countingTill) === false) return false;
            }

            cursorDate = isForward ? DATE.getStartOfNextDay(cursorDate, false, noNeedToClearTime) : DATE.getEndOfPreviousDay(cursorDate, noNeedToClearTime);

            noNeedToClearTime = true;
        }
    }

    /**
     * Calculate the duration in the given `unit` between 2 dates, taking into account the availability/holidays information (non-working time will be excluded from the duration).
     *
     * @param {Date} startDate The start date
     * @param {Date} endDate The end date
     * @param {String} unit One of the units used by DateHelper
     *
     * @return {Number} Working time duration between given dates.
     */
    calculateDuration(startDate, endDate, unit) {
        let duration = 0;

        this.forEachAvailabilityInterval({
            startDate : startDate,
            endDate   : endDate
        }, (intervalStartDate, intervalEndDate) => {
            let dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();

            duration += intervalEndDate - intervalStartDate + dstDiff * 60 * 1000;
        });

        return this.convertMSDurationToUnit(duration, unit);
    }

    /**
     * Returns an array of ranges for non-working days between `startDate` and `endDate`. For example normally, given a
     * full month, it will return an array of 4 `Scheduler.model.TimeSpan` instances, containing ranges for the
     * weekends. If a holiday lasts for several days and all {@link Scheduler.model.CalendarDayModel} instances have
     * the same `cls` value then all days will be combined into a single range.
     *
     * @param {Date} startDate - A start date of the timeframe to extract the holidays from
     * @param {Date} endDate - An end date of the timeframe to extract the holidays from
     *
     * @return {Scheduler.model.TimeSpan[]}
     */
    getHolidaysRanges(startDate, endDate, includeWeekends) {
        if (startDate > endDate) {
            throw new Error("startDate can't be bigger than endDate");
        }

        startDate = DateHelper.clearTime(startDate);
        endDate   = DateHelper.clearTime(endDate);

        let ranges = [],
            currentRange,
            date;

        for (date = startDate; date < endDate; date = DateHelper.getNext(date, 'day', 1)) {
            if (this.isHoliday(date) || (this.weekendsAreWorkdays && includeWeekends && this.isWeekend(date))) {
                const day      = this.getCalendarDay(date),
                    cssClass = day && day.cls || this.defaultNonWorkingTimeCssCls,
                    nextDate = DateHelper.getNext(date, 'day', 1);

                // starts new range
                if (!currentRange) {
                    currentRange = new TimeSpan({
                        startDate : date,
                        endDate   : nextDate,
                        cls       : cssClass
                    });
                }
                else {
                    // checks if the range is still the same
                    if (currentRange.cls.isEqual(cssClass)) {
                        currentRange.endDate = nextDate;
                    }
                    else {
                        ranges.push(currentRange);

                        currentRange = new TimeSpan({
                            startDate : date,
                            endDate   : nextDate,
                            cls       : cssClass
                        });
                    }
                }
            }
            else {
                if (currentRange) {
                    ranges.push(currentRange);
                    currentRange = null;
                }
            }
        }

        if (currentRange) {
            ranges.push(currentRange);
        }

        return ranges;
    }

    /**
     * Calculate the end date for the given start date and duration, taking into account the availability/holidays information (non-working time will not be counted as duration).
     *
     * @param {Date} startDate The start date
     * @param {Number} duration The "pure" duration (w/o any non-working time).
     * @param {String} unit One of the units of the {@link Core.helper.DateHelper} class.
     *
     * @return {Date} The end date
     */
    calculateEndDate(startDate, duration, unit) {
        // if duration is 0 - return the same date
        if (!duration) {
            return new Date(startDate);
        }

        let DATE = DateHelper,
            endDate;

        duration = this.convertDurationToMs(duration, unit);

        let startFrom =
                // milestone case, which we don't want to re-schedule to the next business days
                // milestones should start/end in the same day as its incoming dependency
                duration === 0 && DATE.clearTime(startDate, true) - startDate === 0

                    ? DATE.add(startDate, -1, 'day')
                    :                    startDate;

        this.forEachAvailabilityInterval({ startDate : startFrom }, function(intervalStartDate, intervalEndDate) {
            let diff    = intervalEndDate - intervalStartDate,
                dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();

            if (diff >= duration) {
                endDate = new Date(intervalStartDate - 0 + duration);

                return false;
            }
            else {
                duration -= diff + dstDiff * 60 * 1000;
            }
        });

        return endDate;
    }

    /**
     * This method starts from the given `date` and moves forward/backward in time (depending from the `isForward` flag) skiping the non-working time.
     * It returns the nearest edge of the first working time interval it encounters. If the given `date` falls on the working time, then `date` itself is returned.
     *
     * For example, if this function is called with some Saturday as `date` and `isForward` flag is set, it will return the earliest working hours on following Monday.
     * If `isForward` flag will be set to `false` - it will return the latest working hours on previous Friday.
     *
     * @param {Date} date A date (presumably falling on the non-working time).
     * @param {Boolean} isForward Pass `true` to skip the non-working time in forward direction, `false` - in backward
     *
     * @return {Date} Nearest working date.
     */
    skipNonWorkingTime(date, isForward) {
        let found = false;
        // reseting the date to the earliest availability interval
        this.forEachAvailabilityInterval(
            isForward ? { startDate : date } : { endDate : date, isForward : false },

            (intervalStartDate, intervalEndDate) => {
                date  = isForward ? intervalStartDate : intervalEndDate;
                found = true;

                return false;
            }
        );

        if (!found) throw new Error('skipNonWorkingTime: Cannot skip non-working time, please ensure that this calendar has any working period of time specified');

        return new Date(date);
    }

    /**
     * Calculate the start date for the given end date and duration, taking into account the availability/holidays information (non-working time will not be counted as duration).
     *
     * @param {Date} endDate The end date
     * @param {Number} duration The "pure" duration (w/o any non-working time).
     * @param {String} unit One of the units of the {@link Core.helper.DateHelper} class.
     *
     * @return {Date} The start date
     */
    calculateStartDate(endDate, duration, unit) {
        // if duration is 0 - return the same date
        if (!duration) {
            return new Date(endDate);
        }

        let startDate;

        duration = this.convertDurationToMs(duration, unit);

        this.forEachAvailabilityInterval({
            endDate   : endDate,
            isForward : false
        }, (intervalStartDate, intervalEndDate) => {
            const diff = intervalEndDate - intervalStartDate;

            if (diff >= duration) {
                startDate = new Date(intervalEndDate - duration);

                return false;
            }
            else {
                duration -= diff;
            }
        });

        return startDate;
    }

    /**
     * This method starts from the given `date` and moves forward/backward in time (depending from the `duration` argument).
     * It stops as soon as it skips the amount of *working* time defined by the `duration` and `unit` arguments. Skipped non-working time simply will not
     * be counted.
     *
     * **Note** that this method behaves differently from the {@link #function-skipNonWorkingTime} - that method stops as soon as it encounters the non-working time.
     * This method stops as soon as it accumulate enough skipped working time.
     *
     * @param {Date} date A starting point
     * @param {Number} duration The duration of the working time. To skip working time in backward direction pass a negative value.
     * @param {String} unit One of the units of the {@link Core.helper.DateHelper} class.
     *
     * @return {Date}
     */
    skipWorkingTime(date, duration, unit) {
        return duration >= 0 ? this.calculateEndDate(date, duration, unit) : this.calculateStartDate(date, -duration, unit);
    }

    isChildOf(calendar) {
        let parent = this,
            found  = false;

        while (parent && !found) {
            found  = parent === calendar;
            parent = parent.parent;
        }

        return found;
    }

    getParentableCalendars() {
        const me        = this,
            calendars = Calendar.getAllCalendars();

        return calendars.reduce((result, calendar) => {
            if (calendar !== me && !calendar.isChildOf(me)) {
                result.push({ id : calendar.calendarId, name : calendar.name || calendar.calendarId });
            }
            return result;
        }, []);
    }

    get parent() {
        return this._parent;
    }

    /**
     * Returns the availability intervals of a specific day. Potentially can consult a parent calendar.
     *
     * @param {Date|Number} timeDate A date or timestamp
     * @return {Object[]} Array of objects, like:

     {
         startDate       : new Date(...),
         endDate         : new Date(...)
     }
     */
    getAvailabilityIntervalsFor(timeDate, noNeedToClearTime) {
        if (noNeedToClearTime) {
            timeDate = (timeDate).valueOf();
        }
        else if (timeDate instanceof Date) {
            timeDate = (new Date(timeDate.getFullYear(), timeDate.getMonth(), timeDate.getDate())).valueOf();
        }
        else {
            timeDate = DateHelper.clearTime(new Date(timeDate)).valueOf();
        }

        return this.availabilityIntervalsCache[timeDate] = (this.availabilityIntervalsCache[timeDate] || this.getCalendarDay(timeDate).getAvailabilityIntervalsFor(timeDate));
    }

    onParentDestroy() {
        this.parent = null;
    }

    isAvailabilityIntersected(withCalendar, startDate, endDate) {
        let ownWeekDay, ownAvailability,
            testWeekDay, testAvailability;

        // first let's try to find overlapping of weeks (check daily intervals)
        // loop over week days
        for (let i = 0; i < 7; i++) {
            ownWeekDay  = this.getWeekDay(i) || this.getDefaultCalendarDay(i);
            testWeekDay = withCalendar.getWeekDay(i) || withCalendar.getDefaultCalendarDay(i);

            if (!ownWeekDay || !testWeekDay) continue;

            // get daily intervals
            ownAvailability  = ownWeekDay.getAvailability();
            testAvailability = testWeekDay.getAvailability();

            // loop over intervals to find overlapping
            for (let j = 0, l = ownAvailability.length; j < l; j++) {
                for (let k = 0, ll = testAvailability.length; k < ll; k++) {
                    if (testAvailability[k].startTime < ownAvailability[j].endTime && testAvailability[k].endTime > ownAvailability[j].startTime) {
                        return true;
                    }
                }
            }
        }

        let result = false;

        this.forEachNonStandardWeek(week => {
            if (week.startDate >= endDate) return false;

            if (startDate < week.endDate) {
                result = true;
                // stop the iteration
                return false;
            }
        });

        return result;
    }
}
Calendar._$name = 'Calendar';

/**
 * @module Scheduler/data/mixin/ResourceStoreMixin
 */

/**
 * This is a mixin for the ResourceStore functionality. It is consumed by the {@link Scheduler.data.ResourceStore}.
 *
 * @mixin
 */
var ResourceStoreMixin = Target => class ResourceStoreMixin extends (Target || Base) {
    /**
     * Get/set the associated event store instance
     *
     * @property {Scheduler.data.EventStore}
     */
    get eventStore() {
        return this._eventStore;
    }

    set eventStore(eventStore) {
        const me = this;

        if (me._eventStore !== eventStore) {
            const oldStore = me._eventStore;
            me._eventStore = eventStore || null;

            if (eventStore && !eventStore.resourceStore) {
                eventStore.resourceStore = me;
            }

            /**
             * Fires when new event store is set via {@link #property-eventStore} method.
             * @event eventstorechange
             * @param {Scheduler.data.ResourceStore}   this
             * @param {Scheduler.data.EventStore} newEventStore
             * @param {Scheduler.data.EventStore} oldEventStore
             */
            me.trigger('eventStoreChange', { newEventStore : eventStore, oldEventStore : oldStore });
        }
    }

    getScheduledEventsInTimeSpan(start, end, eventStore = this.eventStore) {
        // TODO: PORT check if correct
        return this.reduce((events, resource) => {
            events.concat(eventStore.getEventsForResource(resource).reduce((events, event) => {
                if (event.intersectsRange(start, end)) events.push(event);
            }));
        });
    }
};

/**
 * @module Scheduler/model/ResourceModel
 */

/**
 * This class represent a single Resource in the scheduler chart. It's a subclass of  {@link Core.data.Model}.
 * Please refer to the documentation for that class to become familiar with the base interface of the resource.
 *
 * A Resource has only 2 mandatory fields - `id` and `name`. If you want to add more fields with meta data describing your resources then you should subclass this class:
 *
 * ```javascript
 * class MyResource extends ResourceModel {
 *
 *   static get fields() {
 *     [
 *       // `Id` and `Name` fields are already provided by the superclass
 *       { name: 'company', type : 'string' }
 *     ];
 *   }
 *
 *   getCompany() {
 *     return this.company;
 *   }
 *   ...
 * });
 * ```
 * If you want to use other names in your data for the id and name fields you can configure them as seen below:
 * ```javascript
 * class MyResource extends ResourceModel {
 *
 *   static get fields() {
 *     return [
 *        { name: 'name', dataSource: 'userName' }
 *     ];
 *   },
 *   ...
 * });
 * ```
 * Please refer to {@link Core.data.Model} for details.
 *
 * @extends Grid/data/GridRowModel
 */
class ResourceModel extends GridRowModel {
    //region Fields

    static get fields() {
        return [
            /**
             * Unique identifier
             * @field {String|Number} id
             */

            /**
             * Get or set resource name
             * @field {String} name
             */
            { name : 'name', type : 'string', persist : true },

            /**
             * Controls the primary color used for events assigned to this resource. Can be overridden per event using
             * EventModels {@link Scheduler/model/EventModel#field-eventColor eventColor config}. See Schedulers
             * {@link Scheduler.view.mixin.TimelineEventRendering#config-eventColor eventColor config} for available
             * colors.
             * @field {String} eventColor
             */
            'eventColor',

            /**
             * Controls the style used for events assigned to this resource. Can be overridden per event using
             * EventModels {@link Scheduler/model/EventModel#field-eventStyle eventStyle config}. See Schedulers
             * {@link Scheduler.view.mixin.TimelineEventRendering#config-eventStyle eventStyle config} for available
             * options.
             * @field {String} eventStyle
             */
            'eventStyle',

            /**
             * Fully qualified image URL, used by `ResourceInfoColumn` and vertical modes `ResourceHeader` to display a miniature image
             * for the resource.
             * @field {String} imageUrl
             */
            'imageUrl',

            /**
             * Image name relative to {@link Scheduler/view/mixin/SchedulerEventRendering#config-resourceImagePath},
             * used by `ResourceInfoColumn` and vertical modes `ResourceHeader` to display a miniature image
             * for the resource.
             * @field {String} image
             */
            'image'
        ];
    }

    // ResoureModel#assignments is created by a relation defined in AssignmentModel
    /**
     * Returns all assignments for the resource. Resource must be part of the store for this method to work.
     * @member {Scheduler.model.AssignmentModel[]} assignments
     */

    //endregion

    //region Stores

    /**
     * Returns a resource store this resource is part of. Resource must be part
     * of a resource store to be able to retrieve resource store.
     *
     * @return {Scheduler.data.ResourceStore}
     * @readonly
     */
    get resourceStore() {
        return this.stores && this.stores[0];
    }

    /**
     * Returns an event store this resource uses as default. Resource must be part
     * of a resource store to be able to retrieve event store.
     *
     * @return {Scheduler.data.EventStore}
     * @readonly
     */
    get eventStore() {
        const resourceStore = this.resourceStore;
        // TODO: this.parentNode... is not ported
        return resourceStore && resourceStore.eventStore || this.parentNode && this.parentNode.eventStore;
    }

    /**
     * Returns as assignment store this resources uses as default. Resource must be part
     * of a resource store to be able to retrieve default assignment store.
     *
     * @return {Scheduler.data.AssignmentStore}
     * @readonly
     */
    get assignmentStore() {
        const eventStore = this.eventStore;
        return eventStore && eventStore.assignmentStore;
    }

    //endregion

    //region Getters

    /**
     * Get associated events
     * @returns {Scheduler.model.EventModel[]}
     * @readonly
     */
    get events() {
        // Cannot use relation here, since it wont work in mult assignment
        // TODO: Investigate making relations handle many-to-many using intermediate store? To have it cached
        return this.eventStore && this.eventStore.getEventsForResource(this);
    }

    // /**
    //  * Returns all assignments for the resource. Resource must be part of the store for this method to work.
    //  *
    //  * @return {Scheduler.model.AssignmentModel[]}
    //  * @readonly
    //  */
    // get assignments() {
    //     const me         = this,
    //         eventStore = me.eventStore;
    //
    //     return eventStore && eventStore.getAssignmentsForResource(me);
    // }

    /**
     * Returns an array of events, associated with this resource
     *
     * @param {Scheduler.data.EventStore} eventStore (optional) The event store to get events for (if a resource is bound to multiple stores)
     * @return {Scheduler.model.TimeSpan[]}
     */
    // TODO: Needed?
    getEvents(eventStore = this.eventStore) {
        return eventStore && eventStore.getEventsForResource(this) || [];
    }

    /**
     * Returns true if the Resource can be persisted.
     * In a flat store resource is always considered to be persistable, in a tree store resource is considered to
     * be persitable if it's parent node is persistable.
     *
     * @return {Boolean} true if this model can be persisted to server.
     * @readonly
     */
    get isPersistable() {
        const parent = this.parentNode;
        // TODO: not ported yet
        return !parent || !parent.phantom || (parent.isRoot && parent.isRoot());
    }

    //endregion

    /**
     * Returns true if this resource model is above the passed resource model
     * @param {Scheduler.model.ResourceModel} otherResource
     * @returns {Boolean}
     */
    isAbove(otherResource) {
        let me     = this,
            store  = me.resourceStore,
            current, myAncestors, otherAncestors, commonAncestorsLength, lastCommonAncestor;

        

        if (me === otherResource) return false;

        if (store.tree) {
            //TODO: not ported

            // Getting self ancestors this node including
            current = me;
            myAncestors = [];
            while (current) {
                myAncestors.push(current);
                current = current.parentNode;
            }

            // Getting other ancestors other node including
            current = otherResource;
            otherAncestors = [];
            while (current) {
                otherAncestors.push(current);
                current = current.parentNode;
            }

            // Getting common ancestors sequence length
            commonAncestorsLength = 0;
            while (
                commonAncestorsLength < myAncestors.length - 1 &&
            commonAncestorsLength < otherAncestors.length - 1 &&
            myAncestors[commonAncestorsLength] == otherAncestors[commonAncestorsLength]
            ) {
                ++commonAncestorsLength;
            }

            // Getting last common ancesstor
            lastCommonAncestor = myAncestors[commonAncestorsLength];

            // Here the next ancestor in myAncestors and next ancesstor in otherAncestors are siblings and
            // thus designate which node is above
            me = myAncestors[commonAncestorsLength + 1];
            otherResource = otherAncestors[commonAncestorsLength + 1];

            return lastCommonAncestor.indexOf(me) < lastCommonAncestor.indexOf(otherResource);
        }

        return store.indexOf(me) < store.indexOf(otherResource);
    }

    /**
     * Unassigns this Resource from all its Events
     */
    unassignAll(removingResource) {
        this.events && this.events.slice().forEach(event => event.unassign(this, removingResource));
    }
}

ResourceModel.exposeProperties();
ResourceModel._$name = 'ResourceModel';

/**
 * @module Scheduler/data/ResourceStore
 */

/**
 * This is a class holding the collection the {@link Scheduler.model.ResourceModel resources} to be rendered into a
 * {@link Scheduler.view.Scheduler scheduler}.
 *
 * @mixes Scheduler/data/mixin/ResourceStoreMixin
 * @extends Core/data/AjaxStore
 */
class ResourceStore extends ResourceStoreMixin(AjaxStore) {
    static get defaultConfig() {
        return {
            /**
             * CrudManager must load stores in the correct order. Lowest first.
             * @private
             */
            loadPriority : 200,
            /**
             * CrudManager must sync stores in the correct order. Lowest first.
             * @private
             */
            syncPriority : 100,
            modelClass   : ResourceModel,
            storeId      : 'resources',
            autoTree     : true
        };
    }

    construct(config) {
        super.construct(config);

        if (this.modelClass !== ResourceModel && !(this.modelClass.prototype instanceof ResourceModel)) {
            throw new Error('Model for ResourceStore must subclass ResourceModel');
        }
    }

    remove(recordsOrIds) {
        recordsOrIds      = Array.isArray(recordsOrIds) ? recordsOrIds : [recordsOrIds];

        for (let r of recordsOrIds) {
            const record = this.getById(r);
            // Unassign flagged as part of removal, to let UI make intelligent (?) decisions about what to update
            record.unassignAll(true);
        }

        super.remove(recordsOrIds);
    }

    removeAll() {
        this.traverse(resourceRecord => resourceRecord.unassignAll(true));

        super.removeAll();
    }
}
ResourceStore._$name = 'ResourceStore';

/**
 * @module Scheduler/data/util/ModelPersistencyManager
 */

/**
 * This class manages model persistency, it listens to model stores' beforesync event and removes all non persistable
 * records from sync operation. The logic has meaning only for CRUD-less sync operations.
 *
 * @private
 */
class ModelPersistencyManager extends Base {
    // region Event attachers

    set eventStore(newEventStore) {
        const me = this;

        me.eventStoreDetacher && me.eventStoreDetacher();
        me._eventStore = newEventStore;

        if (newEventStore && newEventStore.autoCommit) {
            me.eventStoreDetacher = newEventStore.on({
                beforecommit : me.onEventStoreBeforeSync,
                thisObj      : me,
                detachable   : true,
                // Just in case
                prio         : 100
            });
        }
    }

    get eventStore() {
        return this._eventStore;
    }

    set resourceStore(newResourceStore) {
        const me = this;

        me.resourceStoreDetacher && me.resourceStoreDetacher();
        me._resourceStore = newResourceStore;

        if (newResourceStore && newResourceStore.autoCommit) {
            me.resourceStoreDetacher = newResourceStore.on({
                beforecommit : me.onResourceStoreBeforeSync,
                thisObj      : me,
                detachable   : true,
                // Just in case
                prio         : 100
            });
        }
    }

    get resourceStore() {
        return this._resourceStore;
    }

    set assignmentStore(newAssignmentStore) {
        const me = this;

        me.assignmentStoreDetacher && me.assignmentStoreDetacher();
        me._assignmentStore = newAssignmentStore;

        if (newAssignmentStore && newAssignmentStore.autoSync) {
            me.assignmentStoreDetacher = newAssignmentStore.on({
                beforecommit : me.onAssignmentStoreBeforeSync,
                thisObj      : me,
                detachable   : true,
                // Just in case
                prio         : 100
            });
        }
    }

    get assignmentStore() {
        return this._assignmentStore;
    }

    set dependencyStore(newDependencyStore) {
        const me = this;

        me.dependencyStoreDetacher && me.dependencyStoreDetacher();
        me._dependencyStore = newDependencyStore;

        if (newDependencyStore && newDependencyStore.autoSync) {
            me.dependencyStoreDetacher = newDependencyStore.on({
                beforecommit : me.onDependencyStoreBeforeSync,
                thisObj      : me,
                detachable   : true,
                // Just in case
                prio         : 100
            });
        }
    }

    get dependencyStore() {
        return this._dependencyStore;
    }

    // endregion

    // region Event handlers

    onEventStoreBeforeSync({changes}) {
        const me = this;
        me.removeNonPersistableRecordsToCreate(changes);
        return me.shallContinueSync(changes);
    }

    onResourceStoreBeforeSync({changes}) {
        const me = this;
        me.removeNonPersistableRecordsToCreate(changes);
        return me.shallContinueSync(changes);
    }

    onAssignmentStoreBeforeSync({changes}) {
        const me = this;
        me.removeNonPersistableRecordsToCreate(changes);
        return me.shallContinueSync(changes);
    }

    onDependencyStoreBeforeSync({changes}) {
        const me = this;
        me.removeNonPersistableRecordsToCreate(changes);
        return me.shallContinueSync(changes);
    }

    // endregion

    // region Management rules

    removeNonPersistableRecordsToCreate(changes) {
        let recordsToCreate = changes.added || [],
            r, i;

        // We remove from the array we iterate thus we iterate from end to start
        for (i = recordsToCreate.length - 1; i >= 0; --i) {
            r = recordsToCreate[i];
            if (!r.isPersistable) {
                recordsToCreate.splice(recordsToCreate.indexOf(r), 1);
            }
        }

        // Prevent empty create request
        if (recordsToCreate.length === 0) {
            changes.added.length = 0;
        }
    }

    shallContinueSync(options) {
        return Boolean((options.added && options.added.length > 0) ||
            (options.modified && options.modified.length > 0) ||
            (options.removed && options.removed.length > 0));
    }

    // endregion
}
ModelPersistencyManager._$name = 'ModelPersistencyManager';

// TODO: PORT Make getters/setters?

/**
 * @module Scheduler/data/mixin/EventStoreMixin
 */

/**
 * This is a mixin, containing functionality related to managing events.
 *
 * It is consumed by the regular {@link Scheduler.data.EventStore} class and the Gantt `TaskStore` classes
 * to allow data sharing between a Gantt chart and a Scheduler.
 *
 * @mixin
 */
var EventStoreMixin = Target => class EventStoreMixin extends (Target || Base) {
    //region Connected stores (Resource, Assigment & Dependency)

    /**
     * Get/set the resource store for this store
     * @property {Scheduler.data.ResourceStore}
     */
    get resourceStore() {
        return this._resourceStore;
    }

    set resourceStore(resourceStore) {
        const
            me       = this,
            oldStore = me._resourceStore;

        if (oldStore) {
            oldStore.eventStore = null;
            if (me.modelPersistencyManager) me.modelPersistencyManager.resourceStore = null;
        }

        me._resourceStore = resourceStore || null;

        if (resourceStore) {
            if (me.modelPersistencyManager) me.modelPersistencyManager.resourceStore = me._resourceStore;
            resourceStore.eventStore = me;
        }

        // If store is assigned after configuration we need to init relations
        if (!me.isConfiguring) {
            me.initRelations(true);
        }

        if ((oldStore || resourceStore) && oldStore !== resourceStore) {
            /**
             * Fires when new resource store is set via {@link #property-resourceStore} setter.
             * @event resourcestorechange
             * @param {Scheduler.data.EventStore}         this
             * @param {Scheduler.data.ResourceStore} newResourceStore
             * @param {Scheduler.data.ResourceStore} oldResourceStore
             */
            me.trigger('resourceStoreChange', { newResourceStore : resourceStore, oldResourceStore : oldStore });
        }
    }

    /**
     * Get/set assignment store this event store is using by default
     * @property {Scheduler.data.AssignmentStore}
     */
    get assignmentStore() {
        return this._assignmentStore;
    }

    set assignmentStore(assignmentStore) {
        const
            me       = this,
            oldStore = me._assignmentStore;

        if (oldStore) {
            oldStore.eventStore = null;
            if (me.modelPersistencyManager) me.modelPersistencyManager.assignmentStore = null;
        }

        me._assignmentStore = assignmentStore || null;

        if (assignmentStore) {
            if (me.modelPersistencyManager) me.modelPersistencyManager.assignmentStore = me._assignmentStore;
            assignmentStore.eventStore = me;
        }

        // If store is assigned after configuration we need to init relations
        if (!me.isConfiguring) {
            me.initRelations(true);
        }

        if ((oldStore || assignmentStore) && oldStore !== assignmentStore) {
            /**
             * Fires when new assignment store is set via {@link #property-assignmentStore} setter.
             * @event assignmentStoreChange
             * @param {Scheduler.data.EventStore}           this
             * @param {Scheduler.data.AssignmentStore} newAssignmentStore
             * @param {Scheduler.data.AssignmentStore} oldAssignmentStore
             */
            me.trigger('assignmentStoreChange',  { newAssignmentStore : assignmentStore, oldAssignmentStore : oldStore });
        }
    }

    /**
     * Get/set a dependecy store instance this event store is associated with
     * Get/set a dependecy store instance this event store is associated with
     * @property {Scheduler.data.DependencyStore}
     */
    get dependencyStore() {
        return this._dependencyStore;
    }

    set dependencyStore(dependencyStore) {
        const
            me       = this,
            oldStore = me._dependencyStore;

        if (oldStore) {
            oldStore.eventStore = null;
            if (me.modelPersistencyManager) me.modelPersistencyManager.dependencyStore = null;
        }

        me._dependencyStore = dependencyStore || null;

        if (me._dependencyStore) {
            if (me.modelPersistencyManager) me.modelPersistencyManager.dependencyStore = me._dependencyStore;
            me._dependencyStore.eventStore = me;
        }

        if ((oldStore || dependencyStore) && oldStore !== dependencyStore) {
            /**
             * Fires when new dependency store is set via {@link #property-dependencyStore} setter.
             * @event dependencystorechange
             * @param {Scheduler.data.EventStore}           this
             * @param {Scheduler.data.DependencyStore} newDependencyStore
             * @param {Scheduler.data.DependencyStore} oldDependencyStore
             */
            me.trigger('dependencyStoreChange',  { newDependencyStore : dependencyStore, oldDependencyStore : oldStore });
        }
    }

    /**
     * Provide assignment store to enable multiple connections between events and resources
     * @config {Scheduler.data.AssignmentStore} assignmentStore
     */

    //endregion

    //region Init & destroy

    construct(config) {
        const me = this;

        super.construct(config);

        Object.assign(me, {
            isEventStore            : true,
            autoTree                : true,
            modelPersistencyManager : me.createModelPersistencyManager()
        });
    }

    /**
     * Creates and returns model persistency manager
     *
     * @return {Scheduler.data.util.ModelPersistencyManager}
     * @internal
     */
    createModelPersistencyManager() {
        const me = this;
        return new ModelPersistencyManager({
            eventStore      : me,
            resourceStore   : me.resourceStore,
            assignmentStore : me.assignmentStore,
            dependencyStore : me.dependencyStore
        });
    }

    //endregion

    //region Events records, iteration etc.

    /**
     * Returns events between the supplied start and end date
     * @param {Date} start The start date
     * @param {Date} end The end date
     * @param {Boolean} allowPartial false to only include events that start and end inside of the span
     * @param {Boolean} onlyAssigned true to only include events that are assigned to a resource
     * @return {Scheduler.model.EventModel[]} the events
     * @category Events
     */
    getEventsInTimeSpan(start, end, allowPartial = true, onlyAssigned = false) {
        const events = [];

        this.forEachScheduledEvent((event, eventStart, eventEnd) => {
            if (
                (allowPartial && DateHelper.intersectSpans(eventStart, eventEnd, start, end)) ||
                (!allowPartial && eventStart - start >= 0 && end - eventEnd >= 0)
            ) {
                if (!onlyAssigned || event.resources.length > 0) {
                    events.push(event);
                }
            }
        });

        return events;
    }

    /**
     * Returns all events that starts on the specified day.
     * @param start Start date
     * @returns {Scheduler.model.EventModel[]} Events starting on specified day
     * @category Events
     */
    getEventsByStartDate(start) {
        const events = [];

        this.forEachScheduledEvent((event, eventStart, eventEnd) => {
            if (DateHelper.isEqual(eventStart, start, 'day')) {
                events.push(event);
            }
        });

        return events;
    }

    /**
     * Calls the supplied iterator function once for every scheduled event, providing these arguments
     * - event : the event record
     * - startDate : the event start date
     * - endDate : the event end date
     *
     * Returning false cancels the iteration.
     *
     * @param {Function} fn iterator function
     * @param {Object} thisObj `this` reference for the function
     * @category Events
     */
    forEachScheduledEvent(fn, thisObj = this) {
        this.forEach(event => {
            const
                eventStart = event.startDate,
                eventEnd   = event.endDate;

            if (eventStart && eventEnd) return fn.call(thisObj, event, eventStart, eventEnd);
        });
    }

    /**
     * Returns an object defining the earliest start date and the latest end date of all the events in the store.
     *
     * @return {Object} An object with 'start' and 'end' Date properties (or null values if data is missing).
     * @category Events
     */
    getTotalTimeSpan() {
        let earliest = new Date(9999, 0, 1),
            latest   = new Date(0);

        this.forEach(r => {
            if (r.startDate) earliest = DateHelper.min(r.startDate, earliest);
            if (r.endDate) latest = DateHelper.max(r.endDate, latest);
        });

        // TODO: this will fail in programs designed to work with events in the past (after Jan 1, 1970)
        earliest = earliest < new Date(9999, 0, 1) ? earliest : null;
        latest   = latest > new Date(0) ? latest : null;

        // keep last calculated value to be able to track total timespan changes
        return (this.lastTotalTimeSpan = {
            startDate : earliest || null,
            endDate   : latest || earliest || null
        });
    }

    /**
     * Checks if given event record is persistable.
     * In case assignment store is used to assign events to resources and vise versa event is considered to be always
     * persistable. Otherwise backward compatible logic is used, i.e. event is considered to be persistable when
     * resources it's assigned to are not phantom.
     *
     * @param {Scheduler.model.EventModel} event
     * @return {Boolean}
     * @category Events
     */
    isEventPersistable(event) {
        let result = true;

        if (!this.assignmentStore) {
            const
                store       = event.stores[0],
                crudManager = store && store.crudManager;

            if (store) {
                // if crud manager is used it can deal with phantom resource since it persists all records in one batch
                // if no crud manager used we have to wait till resource is persisted
                result = crudManager || !event.resource || !event.resource.hasGeneratedId;
            }
            // if we remove the record
            else {
                result = true;
            }
        }

        return result;
    }

    //endregion

    //region Resource

    /**
     * Checks if a date range is allocated or not for a given resource.
     * @param {Date} start The start date
     * @param {Date} end The end date
     * @param {Scheduler.model.EventModel} excludeEvent An event to exclude from the check (or null)
     * @param {Scheduler.model.ResourceModel} resource The resource
     * @return {Boolean} True if the timespan is available for the resource
     * @category Resource
     */
    isDateRangeAvailable(start, end, excludeEvent, resource) {
        if (excludeEvent instanceof AssignmentModel) {
            const
                currentEvent = excludeEvent.event,
                resources    = currentEvent.resources,
                allEvents    = new Set(resource.events);

            resources.forEach(resource => {
                resource.events.forEach(e => allEvents.add(e));
            });

            allEvents.delete(currentEvent);

            return !Array.from(allEvents).some(ev => DateHelper.intersectSpans(start, end, ev.startDate, ev.endDate));
        }
        return !this.getEventsForResource(resource).some(ev =>
            !(excludeEvent === ev || !DateHelper.intersectSpans(start, end, ev.startDate, ev.endDate))
        );
    }

    /**
     * Filters the events associated with a resource, based on the function provided. An array will be returned for those
     * events where the passed function returns true.
     * @param {Scheduler.model.ResourceModel} resource
     * @param {Function} fn The function
     * @param {Object} [thisObj] `this` reference for the function
     * @return {Scheduler.model.EventModel[]} the events in the time span
     * @private
     * @category Resource
     */
    filterEventsForResource(resource, fn, thisObj = this) {
        // `getEvents` method of the resource will use either `indexByResource` or perform a full scan of the event store
        return resource.getEvents(this).filter(fn.bind(thisObj));
    }

    // This method provides a way for the store to append a new record, and the consuming class has to implement it
    // since Store and TreeStore don't share the add API.
    //append(record) {
    //    throw 'Must be implemented by consuming class';
    //}

    /**
     * Returns all resources assigned to an event.
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @return {Scheduler.model.ResourceModel[]}
     * @category Resource
     */
    getResourcesForEvent(event) {
        if (this.assignmentStore) {
            return this.assignmentStore.getResourcesForEvent(event);
        }

        event = this.getById(event);

        return event.resource && !event.resource.placeHolder ? [event.resource] : [];
    }

    /**
     * Returns all events assigned to a resource
     *
     * @param {Scheduler.model.ResourceModel|String|Number} resource Resource or resource id
     * @return {Scheduler.model.EventModel[]}
     * @category Resource
     */
    getEventsForResource(resource) {
        if (this.assignmentStore) {
            return this.assignmentStore.getEventsForResource(resource);
        }

        resource = Model.asId(resource);

        // Could be changed to use resource.events, but that would require getting model by id. This way is a bit faster
        const cache = this.relationCache.resource && this.relationCache.resource[resource];
        // Slice to be safe from outside manipulation of the array
        return cache ? cache.slice() : [];
    }

    //endregion

    //region Assignment

    /**
     * Returns all assignments for a given event.
     * Works only if {@link #property-assignmentStore} is defined, otherwise returns an empty array.
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @return {Scheduler.model.AssignmentModel[]}
     * @category Assignment
     */
    getAssignmentsForEvent(event) {
        return this.assignmentStore && this.assignmentStore.getAssignmentsForEvent(event) || [];
    }

    /**
     * Returns all assignments for a given resource.
     * Works only if {@link #property-assignmentStore} is defined, otherwise returns an empty array.
     *
     * @param {Scheduler.model.ResourceModel|String|Number} resource
     * @return {Scheduler.model.AssignmentModel[]}
     * @category Assignment
     */
    getAssignmentsForResource(resource) {
        return this.assignmentStore && this.assignmentStore.getAssignmentsForResource(resource) || [];
    }

    /**
     * Creates and adds assignment record for a given event and a resource.
     *
     * @param {Scheduler.model.EventModel|String|number} event
     * @param {Scheduler.model.ResourceModel|String|number|Scheduler.model.ResourceModel[]|String[]|number[]} resource The resource(s) to assign to the event
     * @privateparam {Boolean} [removeExistingAssignments] true to first remove existing assignments
     * @category Assignment
     */
    assignEventToResource(event, resource, removeExistingAssignments = false) {
        if (this.assignmentStore) {
            this.assignmentStore.assignEventToResource(event, resource, undefined, removeExistingAssignments);
        }
        else {
            event    = this.getById(event);

            if (Array.isArray(resource)) {
                resource = resource[0];
            }

            if (event) {
                event.resourceId = Model.asId(resource);
            }
        }
    }

    /**
     * Removes assignment record for a given event and a resource.
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @param {Scheduler.model.ResourceModel|String|Number} resource
     * @category Assignment
     */
    unassignEventFromResource(event, resource) {
        if (this.assignmentStore) {
            this.assignmentStore.unassignEventFromResource(event, resource);
        }
        else {
            event    = this.getById(event);
            resource = Model.asId(resource);
            if (event && event.resourceId == resource) {
                event.resourceId = null;
            }
        }
    }

    /**
     * Reassigns an event from an old resource to a new resource
     *
     * @param {Scheduler.model.EventModel}    event    An event or id of the event to reassign
     * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]} oldResource A resource or id to unassign from
     * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]} newResource A resource or id to assign to
     * @category Assignment
     */
    reassignEventFromResourceToResource(event, oldResource, newResource) {
        const
            me                  = this,
            { assignmentStore } = me,
            newResourceId       = Model.asId(newResource),
            oldResourceId       = Model.asId(oldResource);

        if (assignmentStore) {
            const assignment = assignmentStore.getAssignmentForEventAndResource(event, oldResource);

            if (assignment) {
                assignment.resourceId = newResourceId;
            }
            else {
                assignmentStore.assignEventToResource(event, newResource);
            }
        }
        else {
            event = me.getById(event);
            if (event.resourceId == oldResourceId) {
                event.resourceId = newResourceId;
            }
        }
    }

    /**
     * Checks whether an event is assigned to a resource.
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @param {Scheduler.model.ResourceModel|String|Number} resource
     * @return {Boolean}
     * @category Assignment
     */
    isEventAssignedToResource(event, resource) {
        if (this.assignmentStore) {
            return this.assignmentStore.isEventAssignedToResource(event, resource);
        }

        event    = this.getById(event);
        resource = Model.asId(resource);
        return event && (event.resourceId == resource) || false;
    }

    /**
     * Removes all assignments for given event
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @category Assignment
     */
    removeAssignmentsForEvent(event) {
        if (this.assignmentStore) {
            this.assignmentStore.removeAssignmentsForEvent(event);
        }
        else {
            event = this.getById(event);
            if (event) {
                // This will update resource events cache via 'update' event
                event.resourceId = null;
            }
        }
    }

    /**
     * Removes all assignments for given resource
     *
     * @param {Scheduler.model.ResourceModel|String|Number} resource
     * @category Assignment
     */
    removeAssignmentsForResource(resource) {
        const { assignmentStore, resourceStore } = this;

        if (assignmentStore) {
            assignmentStore.removeAssignmentsForResource(resource);
        }
        else if (resourceStore) {
            resource = resourceStore.getById(resource);

            // TODO: change to use model cache
            //resource && me.resourceEventsCache.get(resource).forEach(event => {
            //    event.resourceId = null; // This will update resource events cache via 'update' event
            //});
        }
        else {
            resource = Model.asId(resource); // resource id might be 0 thus we use ? operator
            this.forEach(event =>
                event.resourceId == resource && (event.resourceId = null)
            );
        }
    }

    //endregion
};

/**
 * @module Scheduler/data/util/DelayedCallsManager
 */

/**
 * This class delays a function call in the same way {@link Core.helper.FunctionHelper#function-createBuffered-static createBuffered} does, plus it:
 *
 * - accepts a function call as a configuration object
 * - collects arguments of the wrapped function calls
 * - provides a hook that allows to process/combine the collected call arguments
 * - triggers wrapping `delayed${Id}Start`, `delayed${Id}End` events (where `${Id}` is capitalized `id` of the delayed call).
 *
 * @private
 */
class DelayedCallsManager extends Delayable(Events()) {

    get delayedCallTimeout() {
        return !isNaN(this._delayedCallTimeout) ? this._delayedCallTimeout : 100;
    }

    set delayedCallTimeout(value) {
        this._delayedCallTimeout = value;
    }

    cancel(...callIds) {
        const { delayedCalls } = this;

        if (delayedCalls) {
            const ids = callIds.length ? callIds : Object.keys(delayedCalls);

            for (let i = ids.length - 1; i >= 0; i--) {
                const id        = ids[i],
                    delayedCall = delayedCalls[id];

                if (delayedCall && delayedCall.timer) {
                    this.clearTimeout(delayedCall.timer);
                    delayedCall.timer = null;
                }
            }
        }
    }

    invoke(delayedCall) {
        const { id, scope, beforeFn } = delayedCall,
            Id = StringHelper.capitalizeFirstLetter(id);

        this.trigger(`delayed${Id}Start`, delayedCall);

        beforeFn && beforeFn.call(scope, delayedCall);

        // get entries after beforeFn call (it could be processed by the call)
        const { afterFn, fn, entries } = delayedCall;

        let args, result = [];

        while ((args = entries.shift())) {
            result.push(fn.call(scope, delayedCall, ...args));
        }

        afterFn && afterFn.call(scope, delayedCall);

        this.trigger(`delayed${Id}End`, delayedCall);

        delayedCall.delete();

        return result;
    }

    /**
     * Schedules a delayed call.
     * @param {Object}   config Call configuration object:
     * @param {String}   config.id Call identifier. This is used as part of triggered `delayed${Id}Start`, `delayed${Id}End` events
     * @param {Function} config.fn Function that should be called
     * @param {Object[]} config.args `fn` function arguments
     * @param {Object}   config.scope `this` object for `fn` function call
     * @param {Function} config.beforeFn Function that should be called before real invoking of the `fn` function
     * @param {Object}   config.beforeFn.delayedCall Object containing the delayed call config plus additional property:
     * @param {Array[]}  config.beforeFn.delayedCall.entries Array of collected call arguments
     * @returns {Promise}
     */
    execute(config = {}) {
        return new Promise((resolve, reject) => {
            const me = this;

            me.delayedCalls = me.delayedCalls || {};

            const { id, args, timeout } = config;

            // get this specific group of delayed calls
            if (!me.delayedCalls[id]) {
                me.delayedCalls[id] = Object.assign({
                    delete  : () => delete me.delayedCalls[id],
                    entries : [],
                    scope   : this,
                    id
                }, config);

                delete me.delayedCalls[id].args;
            }

            const delayedCall = me.delayedCalls[id];

            // reset previously set timer (if any)
            me.cancel(id);

            // record this call into entries array
            delayedCall.entries.push(args || []);

            // Setup timer to delay the call
            delayedCall.timer = me.setTimeout(() => {
                delayedCall.results = me.invoke(delayedCall);
                resolve(delayedCall);
            }, timeout || me.delayedCallTimeout);
        });
    }
}
DelayedCallsManager._$name = 'DelayedCallsManager';

class DailyRecurrenceIterator extends AbstractRecurrenceIterator {

    static get frequency() {
        return 'DAILY';
    }

    static forEachDate(config) {
        const
            me         = this,
            { recurrence, fn, scope = me } = config,
            { timeSpan, endDate : until, interval } = recurrence,
            timeSpanStart = timeSpan.startDate;

        let startDate  = config.startDate || timeSpanStart,
            endDate    = config.endDate || until,
            count      = recurrence.count,
            counter    = 0;

        if (until && endDate && endDate > until) {
            endDate = until;
        }

        // iteration should not start before the event starts
        if (timeSpanStart > startDate) {
            startDate = timeSpanStart;
        }

        const
            delay            = startDate - timeSpanStart,
            // recurrence interval duration in ms (86400000 is a single day duration in ms)
            intervalDuration = interval * 86400000,
            delayInIntervals = Math.floor(delay / intervalDuration);

        if (!endDate && !count) {
            count = me.MAX_OCCURRENCES_COUNT;
        }

        let date = DateHelper.add(timeSpanStart, delayInIntervals, 'day');

        while (!endDate || date <= endDate) {

            counter++;

            if (date >= startDate &&
                ((endDate && date > endDate) || fn.call(scope, date, counter) === false || (count && counter >= count))
            ) {
                break;
            }

            // shift to the next day
            date = DateHelper.add(date, interval, 'day');
        }
    }
}
DailyRecurrenceIterator._$name = 'DailyRecurrenceIterator';

const dayParseRegExp = /^([+-]?[0-9])?(SU|MO|TU|WE|TH|FR|SA)$/;

const days = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];

class RecurrenceDayRuleEncoder extends Base {

    static decodeDay(rawDay) {
        let parsedDay,
            result;

        if ((parsedDay = dayParseRegExp.exec(rawDay))) {

            result = [days.indexOf(parsedDay[2])];

            // optional position number
            if (parsedDay[1]) {
                parsedDay[1] = parseInt(parsedDay[1], 10);
                result.push(parsedDay[1]);
            }
        }

        return result;
    }

    static encodeDay(day) {
        let position;

        // support decodeDay() result format
        if (Array.isArray(day)) {
            [day, position] = day;
        }

        return (position ? position.toString() : '') + days[day];
    }

    // Turns days values provided as an array of strings (like [`-1MO`, `SU`, `+3FR`])
    // into an array of [ dayIndex, position ] elements, where:
    //
    // - `dayIndex` - zero-based week day index value (0 - Sunday, 1 - Monday, 2 - Tuesday, etc.)
    // - `position` - (optional) 1-based position of the day (integer value (can be both positive and negative))
    static decode(rawDays) {
        let result = [],
            parsedDay;

        if (rawDays) {
            for (let i = 0; i < rawDays.length; i++) {
                if ((parsedDay = this.decodeDay(rawDays[i]))) {
                    result.push(parsedDay);
                }
            }
        }

        return result;
    }

    static encode(days) {
        let result = [],
            day;

        if (days) {
            for (let i = 0; i < days.length; i++) {
                if ((day = this.encodeDay(days[i]))) {
                    result.push(day);
                }
            }
        }

        return result;
    }
}RecurrenceDayRuleEncoder._$name = 'RecurrenceDayRuleEncoder';

class WeeklyRecurrenceIterator extends AbstractRecurrenceIterator {

    static get frequency() {
        return 'WEEKLY';
    }

    static forEachDate(config) {
        const
            me         = this,
            { fn, recurrence, scope = me } = config,
            {
                timeSpan,
                interval,
                days,
                endDate : until
            } = recurrence,
            timeSpanStart = timeSpan.startDate;

        let counter    = 0,
            startDate  = config.startDate || timeSpanStart,
            endDate    = config.endDate || until,
            { count }  = recurrence,
            weekDays   = RecurrenceDayRuleEncoder.decode(days),
            weekStartDate, date;

        if (until && endDate && endDate > until) {
            endDate = until;
        }

        // days could be provided in any order so it's important to sort them
        if (weekDays && weekDays.length) {
            weekDays.sort((a, b) => a[0] - b[0]);
        }
        // "Days" might be skipped then we use the event start day
        else {
            weekDays = [[ timeSpanStart.getDay() ]];
        }

        // iteration should not start before the event starts
        if (timeSpanStart > startDate) {
            startDate = timeSpanStart;
        }

        // if the recurrence is limited w/ "Count"
        // we need to 1st count passed occurrences so we always start iteration from the event start date
        weekStartDate = DateHelper.getNext(count ? timeSpanStart : startDate, 'week', 0, 0);

        if (!endDate && !count) {
            count = me.MAX_OCCURRENCES_COUNT;
        }

        while (!endDate || weekStartDate <= endDate) {

            for (let i = 0; i < weekDays.length; i++) {

                date = DateHelper.copyTimeValues(DateHelper.add(weekStartDate, weekDays[i][0], 'day'), timeSpanStart);

                if (date >= timeSpanStart) {
                    counter++;

                    if (date >= startDate &&
                        ((endDate && date > endDate) ||
                        (fn.call(scope, date, counter) === false) ||
                        (count && counter >= count))
                    ) {
                        return;
                    }
                }
            }

            // get next week start
            weekStartDate = DateHelper.getNext(weekStartDate, 'week', interval, 0);
        }
    }

}
WeeklyRecurrenceIterator._$name = 'WeeklyRecurrenceIterator';

class MonthlyRecurrenceIterator extends AbstractRecurrenceIterator {

    static get frequency() {
        return 'MONTHLY';
    }

    static getNthDayOfMonth(date, dayNum) {
        const daysInMonth = DateHelper.daysInMonth(date);
        let result = null;

        if (dayNum && Math.abs(dayNum) <= daysInMonth) {
            result = new Date(date.getFullYear(), date.getMonth(), dayNum < 0 ? daysInMonth + dayNum + 1 : dayNum);
        }

        return result;
    }

    static isValidPosition(position) {
        return position && Math.abs(position) > 0 && Math.abs(position) <= 31;
    }

    static forEachDate(config) {
        const
            me             = this,
            { fn, recurrence, scope = me } = config,
            {
                timeSpan,
                interval,
                days,
                endDate : until,
                count,
                positions
            } = recurrence,
            eventStart     = timeSpan.startDate,
            weekDays       = RecurrenceDayRuleEncoder.decode(days),
            hasPositions   = positions && positions.length,
            processedDate  = {};

        let
            startDate      = config.startDate || eventStart,
            endDate        = config.endDate || until,
            { monthDays }  = recurrence,
            counter        = 0,
            weekDayPosition,
            monthStartDate, monthEndDate,
            dates, date, i;

        if (until && endDate && endDate > until) {
            endDate = until;
        }

        // iteration should not start before the event starts
        if (eventStart > startDate) {
            startDate = eventStart;
        }

        // if the recurrence is limited w/ "Count"
        // we need to 1st count passed occurrences so we always start iteration from the event start date
        monthStartDate = DateHelper.startOf(count ? eventStart : startDate, 'month');
        monthEndDate   = new Date(DateHelper.getNext(monthStartDate, 'month', 1) - 1);

        // if no month days nor week days are provided let's use event start date month day
        if (!(monthDays && monthDays.length) && !(weekDays && weekDays.length)) {
            monthDays = [eventStart.getDate()];
        }

        if (weekDays && weekDays.length) {
            // Collect hash of positions indexed by week days
            weekDays.forEach(day => {
                if (day[1]) {
                    weekDayPosition         = weekDayPosition || {};
                    weekDayPosition[day[0]] = day[1];
                }
            });
        }

        while ((!endDate || endDate >= monthStartDate) && (!count || counter < count)) {

            dates = [];

            if (weekDays && weekDays.length) {

                weekDays.forEach(day => {
                    const weekDay = day[0];

                    let from    = 1,
                        till    = 53;

                    // if position provided
                    if (day[1]) {
                        from = till = day[1];
                    }

                    for (i = from; i <= till; i++) {
                        if ((date = me.getNthDayInPeriod(monthStartDate, monthEndDate, weekDay, i))) {
                            date = DateHelper.copyTimeValues(date, eventStart);

                            if (!processedDate[date.getTime()]) {
                                // remember we processed the date
                                processedDate[date.getTime()] = true;

                                dates.push(date);
                            }
                        }
                    }
                });

                dates.sort((a, b) => a - b);

                if (!hasPositions) {
                    for (i = 0; i < dates.length; i++) {
                        date = dates[i];

                        if (date >= eventStart) {
                            counter++;

                            if (date >= startDate &&
                                ((endDate && date > endDate) || (fn.call(scope, date, counter) === false) || (count && counter >= count))
                            ) {
                                return false;
                            }
                        }
                    }
                }

            }
            else {
                const sortedMonthDates = [];

                for (i = 0; i < monthDays.length; i++) {
                    // check if the date wasn't iterated over yet
                    if ((date = me.getNthDayOfMonth(monthStartDate, monthDays[i])) && !processedDate[date.getTime()]) {
                        processedDate[date.getTime()] = true;
                        sortedMonthDates.push(date);
                    }
                }

                // it's important to sort the dates to iterate over them in the proper order
                sortedMonthDates.sort((a, b) => a - b);

                for (i = 0; i < sortedMonthDates.length; i++) {
                    date = DateHelper.copyTimeValues(sortedMonthDates[i], eventStart);

                    if (hasPositions) {
                        dates.push(date);
                    }
                    else if (date >= eventStart) {
                        counter++;

                        if (date >= startDate &&
                            // eslint-disable-next-line no-labels
                            ((endDate && date > endDate) || (fn.call(scope, date, counter) === false) || (count && counter >= count))
                        ) {
                            return;
                        }
                    }
                }
            }

            if (hasPositions && dates.length) {
                me.forEachDateAtPositions(dates, positions, date => {
                    if (date >= eventStart) {
                        counter++;
                        // Ignore dates outside of the [startDate, endDate] range
                        if (date >= startDate && (!endDate || date <= endDate) &&
                            // return false if it's time to stop recurring
                            (fn.call(scope, date, counter) === false || (count && counter >= count))
                        ) {
                            return false;
                        }
                    }
                });
            }

            // get next month start
            monthStartDate = DateHelper.getNext(monthStartDate, 'month', interval);
            monthEndDate   = new Date(DateHelper.getNext(monthStartDate, 'month', 1) - 1);
        }

    }

}
MonthlyRecurrenceIterator._$name = 'MonthlyRecurrenceIterator';

class YearlyRecurrenceIterator extends AbstractRecurrenceIterator {

    static get frequency() {
        return 'YEARLY';
    }

    static forEachDate(config) {
        const
            me           = this,
            { fn, recurrence, scope = me } = config,
            {
                timeSpan,
                interval,
                days,
                count,
                positions,
                endDate : until
            } = recurrence,
            timeSpanStart  = timeSpan.startDate,
            weekDays       = RecurrenceDayRuleEncoder.decode(days),
            hasPositions   = positions && positions.length,
            processedDate  = {};

        let
            startDate      = config.startDate || timeSpanStart,
            endDate        = config.endDate || until,
            { months }     = recurrence,
            counter        = 0,
            i, date, dates, yearStartDate, yearEndDate,
            weekDayPosition;

        if (until && endDate && endDate > until) {
            endDate = until;
        }

        // iteration should not start before the event starts
        if (timeSpanStart > startDate) {
            startDate = timeSpanStart;
        }

        // if the recurrence is limited w/ "Count"
        // we need to 1st count passed occurrences so we always start iteration from the event start date
        yearStartDate = DateHelper.startOf(count ? timeSpanStart : startDate, 'year');
        yearEndDate   = new Date(DateHelper.getNext(yearStartDate, 'year', 1) - 1);

        months && months.sort((a, b) => a - b);

        // if no months provided let's use the event month
        if (!(months && months.length) && !(weekDays && weekDays.length)) {
            months = [ timeSpanStart.getMonth() + 1 ];
        }

        if (weekDays && weekDays.length) {
            // Collect hash of positions indexed by week days
            weekDays.forEach(day => {
                if (day[1]) {
                    weekDayPosition         = weekDayPosition || {};
                    weekDayPosition[day[0]] = day[1];
                }
            });
        }

        while ((!endDate || endDate >= yearStartDate) && (!count || counter < count)) {

            dates = [];

            if (weekDays && weekDays.length) {

                weekDays.forEach(day => {
                    let weekDay = day[0],
                        from    = 1,
                        till    = 53;

                    // if position provided
                    if (day[1]) {
                        from = till = day[1];
                    }

                    for (i = from; i <= till; i++) {
                        if ((date = me.getNthDayInPeriod(yearStartDate, yearEndDate, weekDay, i))) {
                            date = DateHelper.copyTimeValues(date, timeSpanStart);

                            if (!processedDate[date.getTime()]) {
                                // remember we processed the date
                                processedDate[date.getTime()] = true;

                                dates.push(date);
                            }
                        }
                    }
                });

                dates.sort((a, b) => a - b);

                if (!hasPositions) {
                    for (i = 0; i < dates.length; i++) {
                        date = dates[i];

                        if (date >= timeSpanStart) {
                            counter++;

                            if (date >= startDate &&
                                ((endDate && date > endDate) ||
                                (fn.call(scope, date, counter) === false) ||
                                (count && counter >= count))
                            ) {
                                return;
                            }
                        }
                    }
                }

            }
            else {
                for (i = 0; i < months.length; i++) {

                    if ((date = me.buildDate(yearStartDate.getFullYear(), months[i] - 1, timeSpanStart.getDate()))) {
                        date = DateHelper.copyTimeValues(date, timeSpanStart);

                        // check if the date wasn't iterated over yet
                        if (!processedDate[date.getTime()]) {
                            processedDate[date.getTime()] = true;

                            if (hasPositions) {
                                dates.push(date);
                            }
                            else if (date >= timeSpanStart) {
                                counter++;

                                if (date >= startDate &&
                                    ((endDate && date > endDate) ||
                                    (fn.call(scope, date, counter) === false) ||
                                    (count && counter >= count))
                                ) {
                                    return;
                                }
                            }
                        }
                    }
                }
            }

            if (hasPositions && dates.length) {
                me.forEachDateAtPositions(dates, positions, date => {
                    if (date >= timeSpanStart) {
                        counter++;
                        // Ignore dates outside of the [startDate, endDate] range
                        if (date >= startDate && (!endDate || date <= endDate)) {
                            // return false if it's time to stop recurring
                            if (fn.call(scope, date, counter) === false || (count && counter >= count)) {
                                return false;
                            }
                        }
                    }
                });
            }

            // get next month start
            yearStartDate = DateHelper.getNext(yearStartDate, 'year', interval);
            yearEndDate   = new Date(DateHelper.getNext(yearStartDate, 'year', 1) - 1);
        }

    }
}
YearlyRecurrenceIterator._$name = 'YearlyRecurrenceIterator';

/**
 * @module Scheduler/data/mixin/RecurringTimeSpansMixin
 */

/**
 * This mixin class provides recurring timespans functionality to a store of {@link Scheduler.model.TimeSpan} models.
 * @mixin
 */
var RecurringTimeSpansMixin = Target => class RecurringTimeSpansMixin extends (Target || Base) {

    static get $name() {
        return 'RecurringTimeSpansMixin';
    }

    /**
     * Indicates that the store supports recurring timespans.
     * @default true
     * @property {Boolean}
     * @readonly
     */
    get supportsRecurringTimeSpans() {
        return true;
    }

    /**
     * Timeout in milliseconds during which to collect calls for generating occurrences related methods.
     * @property {Number}
     * @default 100
     */
    get delayedCallTimeout() {
        return !isNaN(this._delayedCallTimeout) ? this._delayedCallTimeout : 100;
    }

    set delayedCallTimeout(value) {
        this._delayedCallTimeout = value;
    }

    /**
     * Returns delayed calls manager
     *
     * @return {Scheduler.data.util.DelayedCallsManager}
     * @internal
     */
    get delayedCallsManager() {
        this._delayedCallsManager = this._delayedCallsManager || new DelayedCallsManager({
            delayedCallTimeout : this.delayedCallTimeout
        });

        return this._delayedCallsManager;
    }

    setupRecurringTimeSpans() {
        const me = this;

        me.recurrenceIterators = me.recurrenceIterators || [];

        me.addRecurrenceIterators(
            DailyRecurrenceIterator,
            WeeklyRecurrenceIterator,
            MonthlyRecurrenceIterator,
            YearlyRecurrenceIterator
        );

        me.relayEvents(
            me.delayedCallsManager,
            [
                'delayedRegenerateOccurrencesStart',
                'delayedRegenerateOccurrencesEnd',
                'delayedGenerateOccurrencesStart',
                'delayedGenerateOccurrencesEnd'
            ]
        );

        me.delayedCallsManager.on({
            'delayedRegenerateOccurrencesEnd' : me.onDelayedRegenerateOccurrencesFinish,
            'delayedGenerateOccurrencesEnd'   : me.onDelayedGenerateOccurrencesFinish,

            thisObj : me
        });
    }

    doDestroy() {
        this.delayedCallsManager.destroy();
    }

    addRecurrenceIterators(...iterators) {
        iterators.forEach(iterator => this.recurrenceIterators[iterator.frequency] = iterator);
    }

    getRecurrenceIteratorForTimeSpan(timeSpan) {
        return this.recurrenceIterators[timeSpan.recurrence.frequency];
    }

    /**
     * Builds the provided timespan occurrences for the provided timespan.
     * @private
     */
    buildOccurrencesForTimeSpan(timeSpan, startDate, endDate, skipExisting) {
        const occurrences = [];

        // is recurring
        if (timeSpan.isRecurring && timeSpan.startDate) {
            const
                me         = this,
                recurrence = timeSpan.recurrence,
                iterator   = me.getRecurrenceIteratorForTimeSpan(timeSpan);

            

            const hasExceptionOnDate = timeSpan.exceptionDates ? timeSpan.exceptionDates.reduce((map, date) => {
                map[date.getTime()] = true;
                return map;
            }, {}) : {};

            iterator.forEachDate({
                recurrence,
                startDate,
                endDate,
                fn(date) {
                    // when it's told we don't generate occurrences if we already have ones on the calculated dates
                    if (!hasExceptionOnDate[date.getTime()] && (!skipExisting || !timeSpan.getOccurrenceByStartDate(date))) {
                        occurrences.push(timeSpan.buildOccurrence(date));
                    }
                }
            });
        }

        return occurrences;
    }

    mergeDelayedCallEntries(delayedCall) {
        let entries = delayedCall.entries,
            byTimeSpanId = {},
            startDate,
            endDate,
            timeSpans,
            timeSpan,
            args;

        // first get the largest range for each requested timeSpan
        for (let i = 0; i < entries.length; i++) {
            args      = entries[i];
            [timeSpans, startDate, endDate] = args;

            // Go over the timeSpans and merge this call and other ones arguments
            // so start date will be the minimal start date requested
            // and the end date the maximal end date requested
            // TODO: need to handle cases when ranges don't intersect
            for (let j = 0; j < timeSpans.length; j++) {
                timeSpan = timeSpans[j];

                const savedArgs = byTimeSpanId[timeSpan.id];

                // if we already met this timeSpan -> adjust its start/end date arguments
                if (savedArgs) {
                    if (savedArgs[1] > startDate) savedArgs[1] = startDate;
                    if (savedArgs[2] < endDate) savedArgs[2] = endDate;
                }
                // Arguments are:
                // 1) array of timeSpans
                // 2) start date
                // 3) end date
                // ...
                else {
                    byTimeSpanId[timeSpan.id] = [[timeSpan], ...args.slice(1)];
                }
            }

        }

        // ranges are grouped by timeSpan id
        entries = Object.values(byTimeSpanId);

        // let's try to combine calls having the same ranges
        const combinedEntries = {};

        for (let i = 0; i < entries.length; i++) {
            args      = entries[i];

            [timeSpan, startDate, endDate] = args;

            const key = (startDate ? startDate.getTime() : '') + '-' + (endDate ? endDate.getTime() : '');

            // if this range is already met
            if (combinedEntries[key]) {
                // add timeSpan to the first argument
                combinedEntries[key][0] = combinedEntries[key][0].concat(timeSpan);

            // if this range isn't met yet
            // remember we met it using that call arguments
            }
            else {
                combinedEntries[key] = args;
            }
        }

        // use combined entries
        delayedCall.entries = Object.values(combinedEntries);
    }

    /**
     * Schedules regenerating (removing and building back) the occurrences of the provided recurring timespans in the provided time interval.
     * The method waits for {@link #property-delayedCallTimeout} milliseconds timeout during which it collects repeating calls.
     * Every further call restarts the timeout. After the timeout the method processes the collected calls trying to merge startDate/endDate ranges
     * to reduce the number of calls and then generates new occurrences and removes the previous ones.
     * @param   {Scheduler.model.TimeSpan[]} timeSpans Timespans to build occurrences for.
     * @param   {Date}                       startDate Time interval start.
     * @param   {Date}                       endDate   Time interval end.
     * @returns {Promise}
     * @async
     */
    regenerateOccurrencesForTimeSpansBuffered(timeSpans, startDate, endDate) {
        const me = this;

        if (!Array.isArray(timeSpans)) {
            timeSpans = [timeSpans];
        }

        // make sure we deal w/ recurring timeSpans only
        timeSpans = timeSpans.filter(timeSpan => timeSpan.isRecurring);

        if (timeSpans.length) {
            return new Promise(async(resolve, reject) => {
                const delayedCall = await me.delayedCallsManager.execute({
                    id       : 'regenerateOccurrences',
                    beforeFn : me.mergeDelayedCallEntries,
                    args     : [timeSpans, startDate, endDate],
                    fn(delayedCall, timeSpans, startDate, endDate) {
                        // Collect old occurrences we'll remove them later by using a single store.remove() call
                        const toRemove = delayedCall.toRemove = delayedCall.toRemove || [];

                        toRemove.push(...me.getOccurrencesForTimeSpans(timeSpans));

                        // add new occurrences
                        delayedCall.added = me.generateOccurrencesForTimeSpans(timeSpans, startDate, endDate, false);
                    },
                    // remove previous occurrences (if we have any)
                    afterFn(delayedCall) {
                        const { toRemove } = delayedCall;
                        if (toRemove.length) {
                            delayedCall.removed = me.remove(toRemove);
                        }
                    }
                });

                resolve({
                    added   : delayedCall.added,
                    removed : delayedCall.removed
                });
            });
        }

        return Promise.resolve();
    }

    /**
     * Schedules generating the occurrences of the provided recurring timespans in the provided time interval.
     * The method waits for {@link #property-delayedCallTimeout} milliseconds timeout during which it collects repeating calls.
     * Every further call restarts the timeout. After the timeout the method processes the collected calls trying to merge startDate/endDate ranges
     * to reduce the number of calls and then generates occurrences.
     * @param   {Scheduler.model.TimeSpan[]} timeSpans          Timespans to build occurrences for.
     * @param   {Date}                       startDate          Time interval start.
     * @param   {Date}                       endDate            Time interval end.
     * @param   {Boolean}                    [preserveExisting] `false` to generate occurrences even if there is already an existing one on a calculated date.
     * @returns {Promise}
     * @async
     */
    generateOccurrencesForTimeSpansBuffered(timeSpans, startDate, endDate, preserveExisting = true) {
        const me = this;

        if (!Array.isArray(timeSpans)) {
            timeSpans = [timeSpans];
        }

        // make sure we deal w/ recurring timeSpans only
        timeSpans = timeSpans.filter(timeSpan => timeSpan.isRecurring);

        if (timeSpans.length) {
            return new Promise(async(resolve) => {
                const delayedCall = await me.delayedCallsManager.execute({
                    id       : 'generateOccurrences',
                    beforeFn : me.mergeDelayedCallEntries,
                    args     : [timeSpans, startDate, endDate, preserveExisting],
                    fn(delayedCall, ...args) {
                        // add new occurrences
                        delayedCall.added = me.generateOccurrencesForTimeSpans(...args);
                    }
                });

                resolve({
                    added : delayedCall.added
                });
            });
        }

        return Promise.resolve();
    }

    /**
     * Generates occurrences of the provided recurring timespans in the provided time interval.
     * @param  {Scheduler.model.TimeSpan[]} timeSpans          Timespans to build occurrences for.
     * @param  {Date}                       startDate          Time interval start.
     * @param  {Date}                       endDate            Time interval end.
     * @param  {Boolean}                    [preserveExisting] `false` to generate occurrences even if there is already an existing one on a calculated date.
     * @private
     */
    generateOccurrencesForTimeSpans(timeSpans, startDate, endDate, preserveExisting = true) {
        const allOccurrences = [];

        if (timeSpans) {
            const me = this;

            let occurrences = [];

            if (!Array.isArray(timeSpans)) {
                timeSpans = [timeSpans];
            }

            if (timeSpans.length) {

                for (let i = 0; i < timeSpans.length; i++) {

                    let timeSpan = timeSpans[i],
                        firstOccurrenceStartDate,
                        firstOccurrence,
                        eventStartDate;

                    if ((occurrences = me.buildOccurrencesForTimeSpan(timeSpan, startDate, endDate, preserveExisting))) {

                        eventStartDate = timeSpan.startDate;

                        // If requested [startDate, endDate] range starts before or matches the timespan starts
                        // we treat the first built occurrence as the timespan itself
                        // and if the occurrence start doesn't match the timespan start
                        // we move the timespan accordingly
                        if (startDate <= eventStartDate) {
                            // get 1st occurrence
                            if ((firstOccurrence = occurrences.shift())) {
                                firstOccurrenceStartDate = firstOccurrence.startDate;
                                // compare its start date with the event one and shift the event if needed
                                if (firstOccurrenceStartDate - eventStartDate) {
                                    timeSpan.setStartEndDate(firstOccurrenceStartDate, firstOccurrence.endDate);
                                    // Since we've changed the event start date the recurrence "Days"/"MonthDays"/"Months"
                                    // might get redundant in case the event start date matches the fields values
                                    // Calling recurrence sanitize() will clean the fields in this case.
                                    timeSpan.recurrence.sanitize();
                                }
                            }
                        }

                        allOccurrences.push(...occurrences);
                    }
                }

                if (allOccurrences.length) {
                    me.add(allOccurrences);
                }
            }
        }

        return allOccurrences;
    }

    /**
     * Generates occurrences for all the existing recurring timespans in the provided time interval.
     * @param  {Date}    startDate          Time interval start.
     * @param  {Date}    endDate            Time interval end.
     * @param  {Boolean} [preserveExisting] `true` to not generate occurrences if there are already existing ones on the calculated dates.
     * @private
     */
    generateOccurrencesForAll(startDate, endDate, preserveExisting = false) {
        const me   = this,
            timeSpans = me.getRecurringTimeSpans();

        let result = [];

        if (timeSpans.length) {
            me.trigger('generateOccurrencesAllStart', { timeSpans, startDate, endDate, preserveExisting });

            result = me.generateOccurrencesForTimeSpans(timeSpans, startDate, endDate, preserveExisting);

            me.trigger('generateOccurrencesAllEnd', { timeSpans, startDate, endDate, preserveExisting });
        }

        return result;
    }

    /**
     * Returns all the recurring timespans.
     * @return {Scheduler.model.TimeSpan[]} Array of recurring events.
     */
    getRecurringTimeSpans() {
        return this.query(record => record.supportsRecurring && record.isRecurring);
    }

    /**
     * Returns occurrences of the provided recurring timespans.
     * @param  {Scheduler.model.TimeSpan|Scheduler.model.TimeSpan[]} records Recurring timespans which occurrences should be retrieved.
     * @return {Scheduler.model.TimeSpan[]} Array of the provided timespans occurrences.
     */
    getOccurrencesForTimeSpans(records) {
        const result = [];

        if (!Array.isArray(records)) {
            records = [records];
        }

        if (records.length) {
            for (let i = 0; i < records.length; i++) {
                const recordId = records[i].id;

                // TODO: cache
                result.push(...this.query(record => record.supportsRecurring && record.recurringTimeSpanId == recordId));
            }
        }

        return result;
    }

    /**
     * Returns occurrences of all the existing recurring timespans.
     * @return {Scheduler.model.TimeSpan[]} Array of the occurrences.
     */
    getOccurrencesForAll() {
        return this.query(record => record.supportsRecurring && record.isOccurrence);
    }

    /**
     * Removes occurrences of the provided recurring timespans.
     * @param {Scheduler.model.TimeSpan|Scheduler.model.TimeSpan[]} timeSpans Recurring timespans which occurrences should be removed.
     */
    removeOccurrencesForTimeSpans(timeSpans) {
        return this.remove(this.getOccurrencesForTimeSpans(timeSpans));
    }

    /**
     * Removes occurrences of all the existing recurring events.
     */
    removeOccurrencesForAll() {
        return this.remove(this.getOccurrencesForAll());
    }

    onDelayedRegenerateOccurrencesFinish() {
        /**
         * Fires when occurrences building is done. This happens:
         *
         * - after panel got rendered;
         * - on timespans store `refresh`, `add`, `update` and `remove` events;
         * - on visible timespan change.
         * @event occurrencesReady
         * @param {Core.data.Store} source Timespans store.
         */
        this.trigger('occurrencesReady');
    }

    onDelayedGenerateOccurrencesFinish() {
        this.trigger('occurrencesReady');
    }

};

/**
 * @module Scheduler/data/mixin/RecurringEventsMixin
 */

/**
 * This mixin class provides recurring events functionality to the {@link Scheduler.data.EventStore event store}.
 * @extends Scheduler/data/mixin/RecurringTimeSpansMixin
 * @mixin
 */
var RecurringEventsMixin = Target => class RecurringEventsMixin extends RecurringTimeSpansMixin(Target || Base) {

    static get $name() {
        return 'RecurringEventsMixin';
    }

    /**
     * Indicates that the store supports recurring events.
     * @default true
     * @property {Boolean}
     * @readonly
     */
    get supportsRecurringEvents() {
        return true;
    }

    setupRecurringEvents(...args) {
        return this.setupRecurringTimeSpans(...args);
    }

    generateOccurrencesForEvents(...args) {
        return this.generateOccurrencesForTimeSpans(...args);
    }

    /**
     * Schedules generating the occurrences of the provided recurring events in the provided time interval.
     * The method waits for {@link Scheduler.data.mixin.RecurringTimeSpansMixin#property-delayedCallTimeout} milliseconds timeout during which it collects repeating calls.
     * Every further call restarts the timeout. After the timeout the method processes the collected calls trying to merge startDate/endDate ranges
     * to reduce the number of calls and then launches occurrences generation.
     * @param  {Scheduler.model.EventModel[]} events        Events to build occurrences for.
     * @param  {Date}              startDate                Time interval start.
     * @param  {Date}              endDate                  Time interval end.
     * @param  {Boolean}           [preserveExisting=true]  `false` to generate occurrences even if there is already an existing one on a calculated date.
     * @returns {Promise}
     * @async
     */
    generateOccurrencesForEventsBuffered(...args) {
        return this.generateOccurrencesForTimeSpansBuffered(...args);
    }

    regenerateOccurrencesForEvents(...args) {
        return this.regenerateOccurrencesForTimeSpans(...args);
    }

    /**
     * Schedules regenerating (removing and building back) the occurrences of the provided recurring events in the provided time interval.
     * The method waits for {@link Scheduler.data.mixin.RecurringTimeSpansMixin#property-delayedCallTimeout} milliseconds timeout during which it collects repeating calls.
     * Every further call restarts the timeout. After the timeout the method processes the collected calls trying to merge startDate/endDate ranges
     * to reduce the number of calls and then launches new occurrences generation and removes the previous ones.
     * @param  {Scheduler.model.EventModel[]} events    Events to build occurrences for.
     * @param  {Date}                         startDate Time interval start.
     * @param  {Date}                         endDate   Time interval end.
     * @returns {Promise}
     * @async
     */
    regenerateOccurrencesForEventsBuffered(...args) {
        return this.regenerateOccurrencesForTimeSpansBuffered(...args);
    }

    /**
     * Returns all the recurring events.
     *
     * **An alias for ** {@link Scheduler.data.mixin.RecurringTimeSpansMixin#function-getRecurringTimeSpans} method.
     *
     * @return {Scheduler.model.EventModel[]} Array of recurring events.
     */
    getRecurringEvents() {
        return this.getRecurringTimeSpans();
    }

    /**
     * Returns occurrences of the provided recurring events.
     *
     * **An alias for ** {@link Scheduler.data.mixin.RecurringTimeSpansMixin#function-getOccurrencesForTimeSpans} method.
     *
     * @param  {Scheduler.model.EventModel|Scheduler.model.EventModel[]} events Recurring events which occurrences should be retrieved.
     * @return {Scheduler.model.EventModel[]} Array of the provided events occurrences.
     */
    getOccurrencesForEvents(events) {
        return this.getOccurrencesForTimeSpans(events);
    }

    /**
     * Removes occurrences of the provided recurring events.
     *
     * **An alias for ** {@link Scheduler.data.mixin.RecurringTimeSpansMixin#function-removeOccurrencesForTimeSpans} method.
     *
     * @param {Scheduler.model.EventModel|Scheduler.model.EventModel[]} events Recurring events which occurrences should be removed.
     */
    removeOccurrencesForEvents(events) {
        return this.removeOccurrencesForTimeSpans(events);
    }

    isEventPersistable(event) {
        // occurrences are not persistable
        return super.isEventPersistable(event) && (!event.supportsRecurring || !event.isOccurrence);
    }
};

/**
 * @module Scheduler/model/RecurrenceModel
 */

function convertStringOfIntegerItemsValue(value) {
    if (value) {
        if (typeof value == 'string') {
            value = value.split(',').map(item => parseInt(item, 10));
        }
    }
    else {
        value = null;
    }

    return value;
}

function convertStringOfItemsValue(value) {
    if (value) {
        if (typeof value == 'string') {
            value = value.split(',');
        }
    }
    else {
        value = null;
    }

    return value;
}

function isEqualAsString(value1, value2) {
    return String(value1) === String(value2);
}

function convertInteger(value) {
    if (this.defaultValue && value === undefined) {
        return this.defaultValue;
    }

    if (this.allowNull && value == null) {
        return null;
    }

    value = parseInt(value);

    if (isNaN(value)) value = undefined;

    return value;
}

/**
 * This class represents a timespan recurrence settings.
 * It is a subclass of {@link Core.data.Model} class.
 * Please refer to the documentation for that class to become familiar with the base interface of this class.
 *
 * The data source for these fields can be customized by subclassing this class.
 *
 * @extends Core/data/Model
 */
class RecurrenceModel extends Model {
    /**
     * Indicates that this is a `RecurrenceModel` class instance
     * (allows to avoid using `instanceof`).
     * @property {Boolean} [isRecurrenceModel=true]
     * @readonly
     */
    get isRecurrenceModel() {
        return true;
    }

    //region Fields
    static get fields() {
        return [
            /**
             * Field defines the recurrence frequency. Supported values are: `DAILY`, `WEEKLY`, `MONTHLY`, `YEARLY`.
             * @field {String} frequency
             */
            { name : 'frequency', defaultValue : 'DAILY' },
            /**
             * Field defines how often the recurrence repeats.
             * For example, if the recurrence is weekly its interval is 2, then the timespan repeats every two weeks.
             * @field {number} interval
             */
            { name : 'interval', defaultValue : 1, convert : convertInteger },
            /**
             * End date of the recurrence. Specifies when the recurrence ends.
             * The value is optional, the recurrence can as well be stopped using {@link #field-count} field value.
             * @field {Date} endDate
             */
            { name : 'endDate', type : 'date' },
            /**
             * Specifies the number of occurrences after which the recurrence ends.
             * The value includes the associated timespan itself so values less than 2 make no sense.
             * The field is optional, the recurrence as well can be stopped using {@link #field-endDate} field value.
             * @field {number} count
             */
            { name : 'count', allowNull : true, convert : convertInteger },
            /**
             * Specifies days of the week on which the timespan should occur.
             * An array of string values `SU`, `MO`, `TU`, `WE`, `TH`, `FR`, `SA`
             * corresponding to Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, and Saturday days of the week.
             * Each value can also be preceded by a positive (+n) or negative (-n) integer.
             * If present, this indicates the nth occurrence of a specific day within the monthly or yearly recurrence.
             *
             * **Not applicable** for daily {@link #field-frequency}.
             * @field {String[]} days
             */
            {
                name    : 'days',
                convert : convertStringOfItemsValue,
                isEqual : isEqualAsString
            },
            /**
             * Specifies days of the month on which the timespan should occur.
             * An array of integer values (-31..-1 - +1..+31, negative values mean counting backwards from the month end).
             * **Applicable only** for monthly {@link #field-frequency}.
             * @field {number[]} monthDays
             */
            {
                name    : 'monthDays',
                convert : convertStringOfIntegerItemsValue,
                isEqual : isEqualAsString
            },
            /**
             * Specifies months of the year on which the timespan should occur.
             * An array of integer values (1 - 12).
             * **Applicable only** for yearly {@link #field-frequency}.
             * @field {number[]} months
             */
            {
                name    : 'months',
                convert : convertStringOfIntegerItemsValue,
                isEqual : isEqualAsString
            },
            /**
             * The positions to include in the recurrence. The values operate on a set of recurrence instances **in one interval** of the recurrence rule.
             * An array of integer values (valid values are 1 to 366 or -366 to -1, negative values mean counting backwards from the end of the built list of occurrences).
             * **Not applicable** for daily {@link #field-frequency}.
             * @field {number} positions
             */
            {
                name    : 'positions',
                convert : convertStringOfIntegerItemsValue,
                isEqual : isEqualAsString
            }
        ];
    }

    get dateFormat() {
        return this._dateFormat || 'YYYYMMDDTHHmmss';
    }

    set dateFormat(format) {
        this._dateFormat = format;
    }

    /**
     * The timespan this recurrence is associated with.
     */
    get timeSpan() {
        return this._timeSpan;
    }

    set timeSpan(value) {
        this._timeSpan = value;
    }

    /**
     * The recurrence rule. A string in [RFC-5545](https://tools.ietf.org/html/rfc5545#section-3.3.10) described format ("RRULE" expression).
     */
    get rule() {
        const me   = this,
            result = [];

        if (me.frequency) {
            result.push(`FREQ=${me.frequency}`);

            if (me.interval > 1) {
                result.push(`INTERVAL=${me.interval}`);
            }
            if (me.days && me.days.length) {
                result.push('BYDAY=' + me.days.join(','));
            }
            if (me.monthDays && me.monthDays.length) {
                result.push('BYMONTHDAY=' + me.monthDays.join(','));
            }
            if (me.months && me.months.length) {
                result.push('BYMONTH=' + me.months.join(','));
            }
            if (me.count) {
                result.push(`COUNT=${me.count}`);
            }
            if (me.endDate) {
                result.push('UNTIL=' + DateHelper.format(me.endDate, me.dateFormat));
            }
            if (me.positions && me.positions.length) {
                result.push('BYSETPOS=' + me.positions.join(','));
            }
        }

        return result.join(';');
    }

    set rule(rule) {
        const me = this;

        me.beginBatch();

        if (rule) {
            const parts = rule.split(';');

            for (let i = 0, len = parts.length; i < len; i++) {
                const
                    part = parts[i].split('='),
                    value  = part[1];

                switch (part[0]) {
                    case 'FREQ':
                        me.frequency = value;
                        break;
                    case 'INTERVAL':
                        me.interval = value;
                        break;
                    case 'COUNT':
                        me.count = value;
                        me.until = null;
                        break;
                    case 'UNTIL':
                        if (value) {
                            me.endDate = DateHelper.parse(value, me.dateFormat);
                        }
                        else {
                            me.endDate = null;
                        }
                        me.count = null;
                        break;
                    case 'BYDAY':
                        me.days = value;
                        break;
                    case 'BYMONTHDAY':
                        me.monthDays = value;
                        break;
                    case 'BYMONTH':
                        me.months = value;
                        break;
                    case 'BYSETPOS':
                        me.positions = value;
                        break;
                }
            }

            me.sanitize();
        }
        else {
            me.set({
                frequency : null,
                interval  : null,
                count     : null,
                endDate   : null,
                days      : null,
                monthDays : null,
                months    : null,
                positions : null
            });
        }

        me.endBatch();
    }

    construct(data = {}) {
        const
            me                 = this,
            { rule, timeSpan } = data;

        me._suspendedTimeSpanNotifying = 0;

        delete data.timeSpan;
        delete data.rule;

        super.construct(...arguments);

        if (rule) {
            me.suspendTimeSpanNotifying();
            me.rule = rule;
            me.resumeTimeSpanNotifying();
        }

        me.timeSpan = timeSpan;
    }

    /**
     * Cleans up fields that do not makes sense for the current {@link #field-frequency} value.
     * @private
     */
    sanitize() {
        const
            me                = this,
            timeSpan          = me.timeSpan,
            timeSpanStartDate = timeSpan && timeSpan.startDate;

        me.beginBatch();

        me.isSanitizing = true;

        switch (me.frequency) {
            case 'DAILY' :
                me.positions    = null;
                me.days         = null;
                me.monthDays    = null;
                me.months       = null;
                break;

            case 'WEEKLY' :
                me.positions    = null;
                me.monthDays    = null;
                me.months       = null;

                const days = me.days;

                if (timeSpanStartDate && days && days.length == 1 && days[0] == RecurrenceDayRuleEncoder.encodeDay(timeSpanStartDate.getDay())) {
                    me.days = null;
                }
                break;

            case 'MONTHLY' :
                if (me.monthDays && me.monthDays.length) {
                    me.positions = null;
                    me.days      = null;
                }

                me.months = null;

                const monthDays = me.monthDays;

                if (timeSpanStartDate && monthDays && monthDays.length == 1 && monthDays[0] == timeSpanStartDate.getDate()) {
                    me.monthDays = null;
                }
                break;

            case 'YEARLY' :
                me.monthDays = null;

                const months = me.months;

                if (timeSpanStartDate && months && months.length == 1 && months[0] == timeSpanStartDate.getMonth() + 1) {
                    me.months = null;
                }
                break;
        }

        me.isSanitizing = false;

        me.endBatch();
    }

    copy(...args) {
        const result = super.copy(...args);

        result.dateFormat = this.dateFormat;
        result.timeSpan   = this.timeSpan;

        return result;
    }

    afterChange(toSet, wasSet, silent) {
        const result = super.afterChange(toSet, wasSet, silent);

        if (!this.isSanitizing) {
            // cleanup data to match the chosen frequency
            this.sanitize();
        }

        const { timeSpan } = this;

        if (timeSpan && !this.isTimeSpanNotifyingSuspended) {
            timeSpan.onRecurrenceChanged();
        }

        return result;
    }

    get count() {
        return this.get('count');
    }

    set count(value) {
        if (value) this.endDate = null;
        this.set('count', value);
    }

    get endDate() {
        return this.get('endDate');
    }

    set endDate(value) {
        if (value) this.count = null;
        this.set('endDate', value);
    }

    get isTimeSpanNotifyingSuspended() {
        return Boolean(this._suspendedTimeSpanNotifying);
    }

    suspendTimeSpanNotifying() {
        this._suspendedTimeSpanNotifying++;
    }

    resumeTimeSpanNotifying() {
        if (this._suspendedTimeSpanNotifying) this._suspendedTimeSpanNotifying--;
    }
}
RecurrenceModel._$name = 'RecurrenceModel';

function convertExceptionDatesValue(value) {
    if (value) {
        const dateFormat = this.dateFormat;

        value = typeof value == 'string' ? value.split(',') : value;

        value = value.map(item => {
            if (typeof item == 'string') {
                item = DateHelper.parse(item, dateFormat);
            }

            return item;
        });
    }

    return value;
}

/**
 * @module Scheduler/model/mixin/RecurringTimeSpan
 */

/**
 * This mixin class provides recurrence related fields and methods to a {@link Scheduler.model.TimeSpan timespan model}.
 *
 * The mixin introduces two types of timespans: __recurring timespan__ and its __occurrences__.
 * __Recurring timespan__ is a timespan having {@link #field-recurrenceRule recurrence rule} specified and its __occurrences__ are "fake" dynamically generated timespans.
 * Their set depends on the scheduler visible timespan and changes upon the timespan change.
 *
 * There are few methods allowing to distinguish a recurring event and an occurrence: {@link #property-isRecurring}, {@link #property-isOccurrence}
 * and {@link #property-recurringTimeSpan} (returns the event this record is an occurrence of).
 *
 * The {@link #field-recurrenceRule recurrence rule} defined for the event is parsed and
 * represented with {@link Scheduler.model.RecurrenceModel} class (can be changed by setting {@link #property-recurrenceModel} property) instance.
 * See: {@link #property-recurrence} property.
 * @mixin
 */
var RecurringTimeSpan = Target => class RecurringTimeSpan extends (Target || TimeSpan) {

    /**
     * Returns `true` indicating the timespan supports recurring.
     * @property {Boolean} true
     */
    get supportsRecurring() {
        return true;
    }

    static get fields() {
        return [
            /**
             * Identifier of the "main" timespan this model is an occurrence of.
             * **Applicable to occurrences only.**
             * @field {String|Number} recurringTimeSpanId
             */
            { name : 'recurringTimeSpanId' },
            /**
             * The timespan recurrence rule. A string in [RFC-5545](https://tools.ietf.org/html/rfc5545#section-3.3.10) described format ("RRULE" expression).
             * @field {String} recurrenceRule
             */
            { name : 'recurrenceRule' },
            /**
             * The timespan exception dates. The dates that must be skipped when generating occurrences for a repeating timespan.
             * This is used to modify only individual occurrences of the timespan so the further regenerations
             * won't create another copy of this occurrence again.
             * Use {@link #function-addExceptionDate} method to add an individual entry to the dates array:
             *
             * ```javascript
             * // let the main timespan know that this date should be skipped when regenerating the occurrences
             * occurrence.recurringTimeSpan.addExceptionDate( occurrence.startDate );
             *
             * // cut the main event cord
             * occurrence.recurringTimeSpanId = null;
             *
             * // now the occurrence is an individual record that can be changed & persisted freely
             * occurrence.setStartEndDate(new Date(2018, 6, 2), new Date(2018, 6, 3));
             * ```
             * **Note:** The dates in this field get automatically removed when the event changes its {@link Scheduler.model.TimeSpan#field-startDate start date}.
             *
             * @field {Date[]} exceptionDates
             */
            { name : 'exceptionDates', convert : convertExceptionDatesValue }
        ];
    }

    /**
     * Name of the class representing the recurrence model.
     * @property {String} [recurrenceModel=Scheduler.model.RecurrenceModel]
     */
    get recurrenceModel() {
        return this._recurrenceModel || RecurrenceModel;
    }

    set recurrenceModel(model) {
        this._recurrenceModel = model;
    }

    /**
     * Sets a recurrence for the timespan with a given frequency, interval, and end.
     * @param {String|Object|Scheduler.model.RecurrenceModel} frequency The frequency of the recurrence, configuration object or the recurrence model. The frequency can be `DAILY`, `WEEKLY`, `MONTHLY`, or `YEARLY`.
     *
     * ```javascript
     * // repeat the event every other week till Jan 2 2039
     * event.setRecurrence("WEEKLY", 2, new Date(2039, 0, 2));
     * ```
     *
     * Also a {@link Scheduler.model.RecurrenceModel recurrence model} can be provided as the only argument for this method:
     *
     * ```javascript
     * const recurrence = new RecurrenceModel({ frequency : 'DAILY', interval : 5 });
     *
     * event.setRecurrence(recurrence);
     * ```
     *
     * @param {Number} [interval] The interval between occurrences (instances of this recurrence). For example, a daily recurrence with an interval of 2 occurs every other day. Must be greater than 0.
     * @param {Number|Date} [recurrenceEnd] The end of the recurrence. The value can be specified by a date or by a maximum count of occurrences (has to greater than 1, since 1 means the event itself).
     */
    setRecurrence(frequency, interval, recurrenceEnd) {
        const me = this;

        let recurrence,
            recurrenceRule;

        if (frequency) {
            if (frequency.isRecurrenceModel) {
                recurrence = frequency;
            }
            else if (typeof frequency == 'string') {
                recurrence = new this.recurrenceModel();

                recurrence.frequency = frequency;
                if (interval) {
                    recurrence.interval = interval;
                }

                // if the recurrence is limited
                if (recurrenceEnd) {
                    if (recurrenceEnd instanceof Date) {
                        recurrence.endDate = recurrenceEnd;
                    }
                    else {
                        recurrence.count = recurrenceEnd;
                    }
                }
            }
            else {
                recurrence = new this.recurrenceModel(frequency);
            }

            recurrence.timeSpan = me;

            recurrenceRule = recurrence.rule;
        }

        me.recurrence     = recurrence;
        me.recurrenceRule = recurrenceRule;
    }

    /**
     * The recurrence model used for the timespan.
     * @property {Scheduler.model.RecurrenceModel}
     */
    get recurrence() {
        const
            me = this,
            rule = me.recurrenceRule;

        if (!me._recurrence && rule) {
            me._recurrence = new me.recurrenceModel({ rule, timeSpan : me });
        }

        return me._recurrence;
    }

    set recurrence(recurrence) {
        const me = this;

        let previousRecurrence;

        // If this is an occurrence - turn it into an event first
        if (me.isOccurrence) {
            const recurringTimeSpan = me.recurringTimeSpan;
            previousRecurrence      = recurringTimeSpan && recurringTimeSpan.recurrence;
            me.recurringTimeSpanId  = null;
        }

        if (recurrence) {
            // if we set recurrence on an occurrence model
            // we stop previous main recurrence
            if (previousRecurrence) {
                previousRecurrence.endDate = new Date(me.startDate - 1);
            }
        }

        me._recurrence = recurrence;

        if (recurrence) {
            // bind recurrence instance to the model
            recurrence.timeSpan = me;
            me.recurrenceRule   = recurrence.rule;
        }
        else {
            me.recurrenceRule = null;
        }
    }

    /**
     * Indicates if the timespan is recurring.
     * @property {Boolean}
     * @readonly
     */
    get isRecurring() {
        return this.recurrence && !this.isOccurrence;
    }

    /**
     * Indicates if the timespan is an occurrence of another recurring timespan.
     * @property {Boolean}
     * @readonly
     */
    get isOccurrence() {
        return Boolean(this.recurringTimeSpanId);
    }

    /**
     * The "main" timespan this model is an occurrence of. For non-occurrences returns `null`.
     * @property {Scheduler.model.TimeSpan}
     * @readonly
     */
    get recurringTimeSpan() {
        const masterEventId = this.recurringTimeSpanId,
            store           = this.stores[0];

        return masterEventId && store && store.getById(masterEventId);
    }

    getOccurrenceByStartDate(startDate) {
        let result, occurrences;

        if (startDate) {
            occurrences = this.occurrences;

            for (let i = 0; i < occurrences.length; i++) {
                if (occurrences[i].startDate - startDate === 0) {
                    result = occurrences[i];
                    break;
                }
            }
        }

        return result;
    }

    /**
     * List of this recurring timespan occurrences or `null` if the timespan is not recurring.
     * @property {Scheduler.model.TimeSpan[]}
     * @readonly
     */
    get occurrences() {
        const store = this.stores[0];

        return store && store.getOccurrencesForTimeSpans && store.getOccurrencesForTimeSpans(this);
    }

    /**
     * Removes this recurring timespan occurrences.
     */
    removeOccurrences() {
        const store = this.stores[0];

        return store && store.removeOccurrencesForTimeSpans && store.removeOccurrencesForTimeSpans(this);
    }

    /**
     * The method is triggered when the timespan recurrence settings get changed.
     * It updates the {@link #field-recurrenceRule} field in this case.
     * @protected
     */
    onRecurrenceChanged() {
        this.recurrenceRule = this.recurrence && this.recurrence.rule || null;
    }

    /**
     * Builds this record occurrence by cloning the timespan data.
     * The method is used internally by the __recurring events__ feature.
     * Override it if you need to customize the generated occurrences.
     * @param  {Date} startDate The occurrence start date.
     * @return {Scheduler.model.TimeSpan} The occurrence.
     * @protected
     */
    buildOccurrence(startDate) {
        const copy = this.copy(null);

        copy.beginBatch();
        copy.setStartDate(startDate);
        copy.recurringTimeSpanId = this.id;
        copy.endBatch();

        return copy;
    }

    afterChange(toSet, wasSet, silent, ...args) {
        // reset cached recurrence instance in case "recurrenceRule" is changed
        if ('recurrenceRule' in wasSet) {
            this._recurrence = null;
        }

        return super.afterChange(toSet, wasSet, silent, ...args);
    }

    /**
     * Adds an exception date that should be skipped when generating occurrences for the timespan.
     * The methods adds an entry to the array kept in {@link #field-exceptionDates} field.
     * @param {Date} date Exception date.
     */
    addExceptionDate(date) {
        const me  = this,
            dates = me.exceptionDates || [];

        if (date) {
            me.exceptionDates = dates.concat(date);
        }
    }

    beforeStartDateChange() {
        this._startDateValue = this.startDate;
    }

    afterStartDateChange() {
        if (this._startDateValue - this.startDate && this.exceptionDates) {
            this.exceptionDates = null;
        }
    }

};

/**
 * @module Scheduler/model/EventModel
 */

/**
 * This class represent a single event in your schedule. It is a subclass of the {@link Scheduler.model.TimeSpan}, which is in turn subclass of {@link Core.data.Model}.
 * Please refer to documentation of that class to become familiar with the base interface of the event.
 *
 * The Event model has a few predefined fields as seen below. If you want to add new fields or change the options for the existing fields,
 * you can do that by subclassing this class (see example below).
 *
 * Subclassing the Event model class
 * --------------------
 * ```
 * class MyEvent extends EventModel {
 *
 *     static get fields() {
 *         return [
 *            // Add new field
 *            { name: 'myField', type : 'number', defaultValue : 0 }
 *         ];
 *     },
 *
 *     myCheckMethod() {
 *         return this.myField > 0
 *     },
 *
 *     ...
 * });
 * ```
 * If you in your data want to use other names for the startDate, endDate, resourceId and name fields you can configure
 * them as seen below:
 * ```
 * class MyEvent extends EventModel {
 *
 *     static get fields() {
 *         return [
 *            { name: 'startDate', dataSource 'taskStart', type: 'date', format: 'YYYY-MM-DD' },
 *            { name: 'endDate', dataSource 'taskEnd', type: 'date', format: 'YYYY-MM-DD' },
 *            { name: 'resourceId', dataSource 'userId' },
 *            { name: 'name', dataSource 'taskTitle' },
 *         ];
 *     },
 *     ...
 * });
 * ```
 * Please refer to {@link Core.data.Model} for additional details.
 *
 * @extends Scheduler/model/TimeSpan
 * @mixes Scheduler/model/mixin/RecurringTimeSpan
 */
class EventModel extends RecurringTimeSpan() {
    //region Fields

    // TODO: handle persist? defaultValue?
    static get fields() {
        return [
            /**
             * The unique identifier of a task (mandatory)
             * @field {String|Number} id
             */

            /**
             * Id of the resource this event is associated with (only usable for single assignments)
             * @field {String|Number} resourceId
             */
            { name : 'resourceId' },

            /**
             * Specify false to prevent the event from being dragged (if EventDrag feature is used)
             * @field {Boolean} draggable
             * @default true
             */
            { name : 'draggable', type : 'boolean', persist : false, defaultValue : true },   // true or false

            /**
             * Specify false to prevent the event from being resized (if EventResize feature is used). You can also
             * specify 'start' or 'end' to only allow resizing in one direction
             * @field {boolean|String} resizable
             * @default true
             */
            { name : 'resizable', persist : false, defaultValue : true },                    // true, false, 'start' or 'end'

            /**
             * Controls this events appearance, see Schedulers
             * {@link Scheduler.view.mixin.TimelineEventRendering#config-eventStyle eventStyle config} for
             * available options.
             * @field {String} eventStyle
             */
            'eventStyle',

            /**
             * Controls the primary color of the event, see Schedulers
             * {@link Scheduler.view.mixin.TimelineEventRendering#config-eventColor eventColor config} for
             * available colors.
             * @field {String} eventColor
             */
            'eventColor',

            /**
             * Width (in px) to use for this milestone when using Scheduler#milestoneLayoutMode 'data'.
             * @field {Number} milestoneWidth
             */
            'milestoneWidth'
        ];
    }

    // EventModel#assignments is created by a relation defined in AssignmentModel
    /**
     * Returns all assignments for the event. Event must be part of the store for this method to work.
     * @member {Scheduler.model.AssignmentModel[]} assignments
     */

    /**
     * Returns the assigned resource. Only valid when not using an AssignmentStore (single assignment)
     * @member {Scheduler.model.ResourceModel} resource
     */

    static get relationConfig() {
        return [
            { relationName : 'resource', fieldName : 'resourceId', store : 'resourceStore', collectionName : 'events' }
        ];
    }

    //endregion

    //region Stores

    /**
     * Returns the event store this event is part of.
     *
     * @return {Scheduler.data.EventStore}
     * @readonly
     */
    get eventStore() {
        const me = this;

        if (!me._eventStore) {
            me._eventStore = me.stores && me.stores.find(s => s.isEventStore);
        }
        return me._eventStore;
    }

    /**
     * Returns the resource store this event uses as its default resource store. Event must be part
     * of an event store to be able to retrieve default resource store.
     *
     * @return {Scheduler.data.ResourceStore}
     * @readonly
     */
    get resourceStore() {
        const eventStore = this.eventStore;
        return eventStore && eventStore.resourceStore;
    }

    /**
     * Returns the assigment store this event uses as its default assignment store. Event must be part
     * of an event store to be able to retrieve default assignment store.
     *
     * @return {Scheduler.data.AssignmentStore}
     * @readonly
     */
    get assignmentStore() {
        const eventStore = this.eventStore;
        return eventStore && eventStore.assignmentStore;
    }

    //endregion

    //region Resources

    /**
     * Returns all resources assigned to an event.
     *
     * @return {Scheduler.model.ResourceModel[]}
     * @readonly
     */
    get resources() {
        return this.eventStore && this.eventStore.getResourcesForEvent(this) || [];
    }

    /**
     * Iterate over all associated resources
     * @private
     */
    forEachResource(fn, thisObj = this) {
        for (let resource of this.resources) {
            if (fn.call(thisObj, resource) === false) return;
        }
    }

    /**
     * Returns either the resource associated with this event (when called w/o `resourceId`) or resource
     * with specified id.
     *
     * @param {String} resourceId (optional)
     * @return {Scheduler.model.ResourceModel}
     */
    getResource(resourceId = this.resourceId) {
        let me            = this,
            eventStore    = me.eventStore,
            resourceStore = eventStore && eventStore.resourceStore;

        if (eventStore && resourceId) {
            let result = eventStore.getResourcesForEvent(me);

            if (result.length == 1) return result[0];

            if (result.length > 1) throw new Error('Event::getResource() is not applicable for events with multiple assignments, please use Event::resources instead.');

            return null;
        }

        if (resourceStore) return resourceStore ? resourceStore.getById(resourceId) : null;
    }

    /**
     * Sets the resource which the event should belong to.
     *
     * @param {Scheduler.model.ResourceModel|String|Number} resource The new resource
     */
    // set resource(resource) {
    //     const me         = this,
    //           eventStore = me.eventStore;
    //
    //     eventStore && eventStore.removeAssignmentsForEvent(me);
    //
    //     me.assign(resource);
    // }

    //endregion

    //region Is

    // Used internally to differentiate between Event and ResourceTimeRange
    get isEvent() {
        return true;
    }

    /**
     * Returns true if event can be drag and dropped
     * @return {Boolean} The draggable state for the event.
     * @readonly
     */
    get isDraggable() {
        return this.draggable;
    }

    /**
     * Returns true if event can be resized, but can additionally return 'start' or 'end' indicating how this event can be resized.
     * @return {*} true, false, 'start' or 'end'
     * @readonly
     */
    get isResizable() {
        return !this.isMilestone && this.resizable;
    }

    /**
     * Returns false if a linked resource is a phantom record, i.e. it's not persisted in the database.
     *
     * @return {Boolean} true if persistable
     * @readonly
     */
    get isPersistable() {
        const me         = this,
            eventStore = me.eventStore;
        return eventStore && eventStore.isEventPersistable(me);
    }

    //endregion

    //region Assignment

    /**'
     * Assigns this event to the specified resource.
     *
     * @param {Scheduler.model.ResourceModel|String|Number} resource A new resource for this event, either as a full Resource record or an id (or an array of such).
     */
    assign(resource) {
        const me         = this,
            eventStore = me.eventStore;

        resource = Model.asId(resource);

        if (eventStore) {
            eventStore.assignEventToResource(me, resource);
        }
        else {
            me.resourceId = resource;
        }
    }

    /**
     * Unassigns this event from the specified resource
     *
     * @param {Scheduler.model.ResourceModel|String|Number|Array} [resource] The resource to unassign from.
     */
    unassign(resource, removingResource) {
        const me         = this,
            eventStore = me.eventStore;

        resource = Model.asId(resource);

        // If unassigned is caused by removing the resource the UI should be able to find out to not do extra redraws etc.
        me.meta.removingResource = removingResource;

        if (eventStore) {
            eventStore.unassignEventFromResource(me, resource);
        }
        else if (me.resourceId == resource) {
            me.resourceId = null;
        }

        me.meta.removingResource = null;
    }

    /**
     * Reassigns an event from an old resource to a new resource
     *
     * @param {Scheduler.model.ResourceModel|String|Number} oldResourceId A resource to unassign from or its id
     * @param {Scheduler.model.ResourceModel|String|Number} newResourceId A resource to assign to or its id
     */
    reassign(oldResourceId, newResourceId) {
        const me         = this,
            eventStore = me.eventStore;

        oldResourceId = Model.asId(oldResourceId);
        newResourceId = Model.asId(newResourceId);

        if (eventStore) {
            eventStore.reassignEventFromResourceToResource(me, oldResourceId, newResourceId);
        }
        else {
            me.resourceId = newResourceId;
        }
    }

    /**
     * Returns true if this event is assigned to a certain resource.
     *
     * @param {Scheduler.model.ResourceModel|String|Number} resource The resource to query for
     * @return {Boolean}
     */
    isAssignedTo(resource) {
        let me         = this,
            eventStore = me.eventStore;

        resource = Model.asId(resource);

        if (eventStore) return eventStore.isEventAssignedToResource(me, resource);

        return me.resourceId == resource;
    }

    //endregion

    /**
     * The "main" event this model is an occurrence of.
     * Returns `null` for non-occurrences.
     * @property {Scheduler.model.EventModel}
     * @alias #property-recurringTimeSpan
     * @readonly
     */
    get recurringEvent() {
        return this.recurringTimeSpan;
    }

}

EventModel.exposeProperties();
EventModel._$name = 'EventModel';

/**
 * @module Scheduler/data/EventStore
 */

/**
 * This is a class holding all the {@link Scheduler.model.EventModel events} to be rendered into a {@link Scheduler.view.Scheduler Scheduler}.
 * This class only accepts a model class inheriting from {@link Scheduler.model.EventModel}.
 *
 * @mixes Scheduler/data/mixin/EventStoreMixin
 * @extends Core/data/AjaxStore
 */
class EventStore extends RecurringEventsMixin(EventStoreMixin(AjaxStore)) {
    static get defaultConfig() {
        return {
            /**
             * CrudManager must load stores in the correct order. Lowest first.
             * @private
             */
            loadPriority : 100,
            /**
             * CrudManager must sync stores in the correct order. Lowest first.
             * @private
             */
            syncPriority : 200,
            /**
             * Class used to represent records
             * @config {Scheduler.model.EventModel}
             * @default
             * @category Common
             * @typings { new(data: object): EventModel }
             */
            modelClass   : EventModel,
            storeId      : 'events'
        };
    }

    /**
     * Class used to represent records. Defaults to class EventModel.
     * @property {Scheduler.model.EventModel}
     * @category Records
     * @typings { new(data: object): EventModel }
     * @name modelClass
     */

    construct(config) {
        super.construct(config, true);

        this.setupRecurringEvents();

        if (this.modelClass !== EventModel && !(this.modelClass.prototype instanceof EventModel)) {
            throw new Error('The model for the EventStore must subclass EventModel');
        }
    }

    /**
     * Appends a new record to the store
     * @param {Scheduler.model.EventModel} record The record to append to the store
     */
    append(record) {
        this.add(record);
    }
}
EventStore._$name = 'EventStore';

/**
 * @module Scheduler/model/DependencyBaseModel
 */

const canonicalDependencyTypes = [
    'SS',
    'SF',
    'FS',
    'FF'
];

/**
 * Base class used for both Ext Scheduler and Ext Gantt. Not intended to be used directly
 *
 * @extends Core/data/Model
 */
class DependencyBaseModel extends Model {
    //region Fields

    /**
     * An enumerable object, containing names for the dependency types integer constants.
     * - 0 StartToStart
     * - 1 StartToEnd
     * - 2 EndToStart
     * - 3 EndToEnd
     * @property {Object}
     * @readonly
     */
    static get Type() {
        return {
            StartToStart : 0,
            StartToEnd   : 1,
            EndToStart   : 2,
            EndToEnd     : 3
        };
    }

    static get fields() {
        return [
            // 3 mandatory fields

            /**
             * From event, id of source event
             * @field {String|number} from
             */
            { name : 'from' },

            /**
             * To event, id of target event
             * @field {String|number} to
             */
            { name : 'to' },

            /**
             * Dependency type, see static property Type
             * @field {Number} type
             * @default 2
             */
            { name : 'type', type : 'int', defaultValue : 2 },

            /**
             * CSS class to apply to lines drawn for the dependency
             * @field {String} cls
             */
            { name : 'cls', defaultValue : '' },

            /**
             * Bidirectional, drawn with arrows in both directions
             * @field {Boolean} bidirectional
             */
            { name : 'bidirectional', type : 'boolean' },

            /**
             * Start side on source (top, left, bottom, right)
             * @field {String} fromSide
             */
            { name : 'fromSide', type : 'string' },

            /**
             * End side on target (top, left, bottom, right)
             * @field {String} toSide
             */
            { name : 'toSide', type : 'string' },

            /**
             * The magnitude of this dependency's lag (the number of units).
             * @field {Number} lag
             */
            { name : 'lag', type : 'number', allowNull : true, defaultValue : 0 },

            /**
             * The units of this dependency's lag, defaults to "d" (days). Valid values are:
             *
             * - "ms" (milliseconds)
             * - "s" (seconds)
             * - "m" (minutes)
             * - "h" (hours)
             * - "d" (days)
             * - "w" (weeks)
             * - "M" (months)
             * - "y" (years)
             *
             * This field is readonly after creation, to change lagUnit use #setlag().
             * @field {String} lagUnit
             */
            {
                name         : 'lagUnit',
                type         : 'string',
                defaultValue : 'd'
            }

            //{ name : 'highlighted', type : 'string', persist : false }
        ];
    }

    static get relationConfig() {
        return [
            { relationName : 'sourceEvent', fieldName : 'from', store : 'eventStore', collectionName : 'successors' },
            { relationName : 'targetEvent', fieldName : 'to', store : 'eventStore', collectionName : 'predecessors' }
        ];
    }

    //endregion

    //region Init

    construct(data) {
        super.construct(...arguments);

        if (data) {
            // Allow passing in event instances too
            if (data.from && data.from instanceof TimeSpan) {
                this.setSourceEvent(data.from);
                delete data.from;
            }

            if (data.to && data.to instanceof TimeSpan) {
                this.setTargetEvent(data.to);
                delete data.to;
            }
        }
    }

    //endregion

    get eventStore() {
        const { stores, unjoinedStores } = this;
        return stores[0] && stores[0].eventStore || unjoinedStores[0] && unjoinedStores[0].eventStore;
    }

    /**
     * Alias to dependency type, but when set resets {@link #field-fromSide} {@link #field-toSide} to null as well.
     *
     * @property {Number}
     */
    get hardType() {
        return this.getHardType();
    }

    set hardType(type) {
        this.setHardType(type);
    }

    /**
     * Returns dependency hard type, see {@link #property-hardType}.
     *
     * @return {Number}
     */
    getHardType() {
        return this.get('type');
    }

    /**
     * Sets dependency {@link #field-type} and resets {@link #field-fromSide} and {@link #field-toSide} to null.
     *
     * @param {Number} type
     */
    setHardType(type) {
        let result;

        if (type !== this.getHardType()) {
            result = this.set({
                type,
                fromSide : null,
                toSide   : null
            });
        }

        return result;
    }

    get lag() {
        return this.get('lag');
    }

    set lag(lag) {
        if (typeof lag === 'number') {
            this.set({
                lag
            });
        }
        else {
            this.setLag(lag);
        }
    }

    /**
     * Sets lag and lagUnit in one go. Only allowed way to change lagUnit, the lagUnit field is
     * readonly after creation
     * @param {Number|String|Object} lag The lag value. May be just a numeric magnitude, or a full string descriptor eg '1d'
     * @param {String} [lagUnit] Unit for numeric lag value, see {@link #field-lagUnit} for valid values
     */
    setLag(lag, lagUnit) {
        // Either they're only setting the magnitude
        // or, if it's a string, parse the full duration.
        if (arguments.length === 1) {
            if (typeof lag === 'number') {
                this.lag = lag;
            }
            else {
                
                lag = DateHelper.parseDuration(lag);
                this.set({
                    lag     : lag.magnitude,
                    lagUnit : lag.unit
                });
            }
            return;
        }

        // Must be a number
        lag = parseFloat(lag);

        this.set({
            lag,
            lagUnit
        });
    }

    getLag() {
        if (this.lag) {
            return `${this.lag < 0 ? '-' : '+'}${Math.abs(this.lag)}${DateHelper.getShortNameOfUnit(this.lagUnit)}`;
        }
        return '';
    }

    /**
     * Property which encapsulates the lag's magnitude and units.
     * An object which contains two properties:
     * - magnitude : [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number) The magnitude of the duration.
     * - unit : [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) The unit in which the duration is measured, eg `'d'` for days.
     * @property {Object}
     */
    get fullLag() {
        return {
            unit      : this.lagUnit,
            magnitude : this.lag
        };
    }

    set fullLag(lag) {
        if (typeof lag === 'string') {
            this.setLag(lag);
        }
        else {
            this.setLag(lag.magnitude, lag.unit);
        }
    }

    /**
     * Gets/sets the source event of the dependency
     *
     * @property {Scheduler.model.EventModel}
     */
    set sourceEvent(event) {
        this.from = event.id;
    }

    /**
     * Gets/sets the target event of the dependency
     *
     * @property {Scheduler.model.EventModel}
     */
    set targetEvent(event) {
        this.to = event.id;
    }

    /**
     * Returns true if the linked events have been persisted (e.g. neither of them are 'phantoms')
     *
     * @property {Boolean}
     * @readonly
     */
    get isPersistable() {
        const
            me = this,
            { stores, unjoinedStores } = me;

        let store = stores[0],
            result;

        if (store) {
            const source    = me.getSourceEvent(),
                target      = me.getTargetEvent(),
                crudManager = store.crudManager;

            // if crud manager is used it can deal with phantom source/target since it persists all records in one batch
            // if no crud manager used we have to wait till source/target are persisted
            result = source && (crudManager || !source.hasGeneratedId) && target && (crudManager || !target.hasGeneratedId);
        }
        else {
            result = Boolean(unjoinedStores[0]);
        }

        return result;
    }

    /**
     * Returns the source event of the dependency
     *
     * @return {Scheduler.model.EventModel} The source event of this dependency
     */
    getSourceEvent(eventStore = this.eventStore) {
        if (!eventStore && this.unjoinedStores.length) {
            eventStore = this.leftProjectEventStore;
        }

        return eventStore && eventStore.getById(this.from);
    }

    /**
     * Gets/sets the dependency type
     *
     * @property {Number}
     */

    /**
     * Gets/sets the name of field holding the CSS class for each rendered dependency element
     *
     * @property {String} cls
     */

    /**
     * Returns the target event of the dependency
     *
     * @return {Scheduler.model.EventModel} The target event of this dependency
     */
    getTargetEvent(eventStore = this.eventStore) {
        if (!eventStore && this.unjoinedStores.length) {
            eventStore = this.leftProjectEventStore;
        }

        return eventStore && eventStore.getById(this.to);
    }

    getDateRange(doNotNormalize = false) {
        const sourceTask = this.sourceEvent,
            targetTask = this.targetEvent;

        if (sourceTask && targetTask && sourceTask.isScheduled && targetTask.isScheduled) {
            let Type = DependencyBaseModel.Type,
                sourceDate,
                targetDate;

            switch (this.type) {
                case Type.StartToStart:
                    sourceDate = sourceTask.startDate;
                    targetDate = targetTask.startDate;
                    break;

                case Type.StartToEnd:
                    sourceDate = sourceTask.startDate;
                    targetDate = targetTask.endDate;
                    break;

                case Type.EndToEnd:
                    sourceDate = sourceTask.endDate;
                    targetDate = targetTask.endDate;
                    break;

                case Type.EndToStart:
                    sourceDate = sourceTask.endDate;
                    targetDate = targetTask.startDate;
                    break;
            }

            return {
                start : doNotNormalize ? sourceDate : DateHelper.min(sourceDate, targetDate),
                end   : doNotNormalize ? targetDate : DateHelper.max(sourceDate, targetDate)
            };
        }

        return null;
    }

    /**
     * Applies given CSS class to dependency, the value doesn't persist
     *
     * @param {String} cls
     */
    highlight(cls) {
        const me = this,
            h  = me.highlighted ? me.highlighted.split(' ') : [];

        if (!h.includes(cls)) me.highlighted = h.concat(cls).join(' ');
    }

    /**
     * Removes given CSS class from dependency if applied, the value doesn't persist
     *
     * @param {String} cls
     */
    unhighlight(cls) {
        const me        = this,
            highlighted = me.highlighted;

        if (highlighted) {
            const h = highlighted.split(' '),
                idx = h.findIndex(i => i === cls);

            if (idx >= 0) {
                h.splice(idx, 1);
                me.highlighted = h.join(' ');
            }
        }
    }

    /**
     * Checks if the given CSS class is applied to dependency.
     *
     * @param {String} cls
     * @return {Boolean}
     */
    isHighlightedWith(cls) {
        const me        = this,
            highlighted = me.highlighted;

        return highlighted && highlighted.split(' ').includes(cls);
    }

    getConnectorString(raw) {
        const rawValue = canonicalDependencyTypes[this.type];

        if (raw) {
            return rawValue;
        }

        // FS => empty string; it's the default
        if (this.type === DependencyBaseModel.Type.EndToStart) {
            return '';
        }

        const locale = LocaleManagerSingelton.locale;

        // See if there is a local version of SS, SF or FF
        if (locale) {
            const localized = locale.Scheduler && locale.Scheduler[rawValue];
            if (localized) {
                return localized;
            }
        }

        return rawValue;
    }

    toString() {
        return `${this.from}${this.getConnectorString()}${this.getLag()}`;
    }

    /**
     * Returns `true` if the dependency is valid. Has valid type and both source and target ids set and not links to itself.
     *
     * @return {Boolean}
     * @typings ignore
     */
    isValid(taskStore) {
        const { from, to, type } = this;

        return typeof type === 'number' && from && from !== '' && to != null && to !== '' && from !== to;
    }
}

DependencyBaseModel.exposeProperties();
DependencyBaseModel._$name = 'DependencyBaseModel';

/**
 * @module Scheduler/model/DependencyModel
 */

/**
 * This class represents a single Dependency between two events. It is a subclass of the {@link Scheduler.model.DependencyBaseModel}
 * class, which in its turn subclasses {@link Core.data.Model}.
 * Please refer to documentation of those classes to become familiar with the base interface of this class.
 *
 * A Dependency has the following fields:
 *
 * - `id` - The id of the dependency itself
 * - `from` - The id of the event at which the dependency starts
 * - `to` - The id of the event at which the dependency ends
 * - `cls` - A CSS class that will be applied to each rendered dependency DOM element
 * - `type` - An integer constant representing the type of the dependency:
 *   - 0 - start-to-start dependency
 *   - 1 - start-to-end dependency
 *   - 2 - end-to-start dependency
 *   - 3 - end-to-end dependency
 * - `bidirectional` - A boolean indicating if a dependency goes both directions (default false)
 *
 * Subclassing the Dependency class
 * --------------------
 *
 * The name of any fields data source can be customized in the subclass, see the example below. Please also refer to {@link Core.data.Model}
 * for details.
 * @example
 * class MyDependency extends DependencyModel {
 *       static get fields() {
 *           return [
 *               { name: 'to', dataSource: 'targetId' },
 *               { name: 'from', dataSource: 'sourceId' }
 *           ]);
 *       }
 *
 *       ...
 *  }
 *
 * @extends Scheduler/model/DependencyBaseModel
 */
class DependencyModel extends DependencyBaseModel {
    // Determines the type of dependency based on fromSide and toSide
    // TODO: Check with vertical orientation
    getTypeFromSides(fromSide, toSide, rtl) {
        const types     = DependencyBaseModel.Type,
            startSide = rtl ? 'right' : 'left',
            endSide   = rtl ? 'left' : 'right';

        if (fromSide === startSide) {
            return (toSide === startSide) ? types.StartToStart : types.StartToEnd;
        }

        return (toSide === endSide) ? types.EndToEnd : types.EndToStart;
    }
}

DependencyModel.exposeProperties();
DependencyModel._$name = 'DependencyModel';

// @tag dependencies

/**
 * @module Scheduler/data/DependencyStore
 */

/**
 * A class representing a collection of dependencies between events in the {@link Scheduler.data.EventStore}.
 * Contains a collection of {@link Scheduler.model.DependencyModel} records.
 *
 * @extends Core/data/AjaxStore
 */
class DependencyStore extends AjaxStore {
    static get defaultConfig() {
        return {
            /**
             * CrudManager must load stores in the correct order. Lowest first.
             * @private
             */
            loadPriority : 400,
            /**
             * CrudManager must sync stores in the correct order. Lowest first.
             * @private
             */
            syncPriority : 400,
            modelClass   : DependencyModel,
            storeId      : 'dependencies'
        };
    }

    //region Init & destroy

    doDestroy() {
        const me = this;
        me.eventStoreDetacher && me.eventStoreDetacher();
        super.doDestroy();
    }

    //endregion

    //region Stores

    /**
     * Get/set the associated event store instance.
     *
     * @property {Scheduler.data.EventStore}
     */
    get eventStore() {
        return this._eventStore;
    }

    set eventStore(eventStore) {
        const me       = this,
            oldStore = me._eventStore;

        me._eventStore = eventStore;

        if (eventStore) {
            me.attachToEventStore(eventStore);

            // If store is assigned after configuration we need to init relations
            if (!me.isConfiguring) {
                me.initRelations(true);
            }
        }

        if ((oldStore || eventStore) && oldStore !== eventStore) {
            /**
             * Fires when a new event store is set via the {@link #property-eventStore} property.
             * @event eventstorechange
             * @param {Scheduler.data.DependencyStore} this
             * @param {Scheduler.data.EventStore} newEventStore
             * @param {Scheduler.data.EventStore} oldEventStore
             */
            me.trigger('eventStoreChange', { newEventStore : eventStore, oldEventStore : oldStore });
        }
    }

    attachToEventStore(eventStore) {
        const me = this;

        me.eventStoreDetacher && me.eventStoreDetacher();

        me.eventStoreDetacher = eventStore.on({
            'remove'   : me.onEventRemove,
            thisObj    : me,
            detachable : true
        });
    }

    //endregion

    onEventRemove({ records, isMove = false, isCollapse = false }) {
        if (!isMove && !isCollapse) {
            records.forEach(record => {
                // traversing in a flat structure will only call fn on self, no need to handle tree case differently
                record.traverse(eventRecord => this.removeEventDependencies(eventRecord, false));
            });
        }
    }

    // TODO: document
    reduceEventDependencies(event, reduceFn, result, flat = true, depsGetterFn) {
        // const me       = this,
        //     relation = me.relationCache;

        depsGetterFn = depsGetterFn || (event => {
            return  this.getEventDependencies(event);

            // const eventId      = DependencyModel.asId(event),
            //     sourceEvents = (relation.sourceEvent && relation.sourceEvent[eventId]) || [],
            //     targetEvents = (relation.targetEvent && relation.targetEvent[eventId]) || [];
            //
            // return sourceEvents.concat(targetEvents);

            // return me.eventDependencyCache.get(event, () =>
            //     // Full scan, but cache makes everything possible to avoid it
            //     me.records.filter(dependency =>
            //         dependency.to == eventId || dependency.from == eventId
            //     )
            // );
        });

        event = Array.isArray(event) ? event : [event];

        event.reduce((result, event) => {
            if (event.children && !flat) {
                event.traverse(evt => {
                    result = depsGetterFn(evt).reduce(reduceFn, result);
                });
            }
            else {
                result = depsGetterFn(event).reduce(reduceFn, result);
            }
        }, result);

        return result;
    }

    // TODO: document
    reduceEventPredecessors(event, reduceFn, result, flat) {
        const me = this;

        return me.reduceEventDependencies(event, reduceFn, result, flat, evt => {
            // const eventId = Model.asId(evt);
            // return me.eventDependencyCache.getPredecessors(evt, () =>
            //     // Full scan, but cache makes everything possible to avoid it
            //     me.records.filter(dependency =>
            //         dependency.to == eventId
            //     )
            // );
        });
    }

    // TODO: document
    reduceEventSuccessors(event, reduceFn, result, flat) {
        const me = this;

        return me.reduceEventDependencies(event, reduceFn, result, flat, evt => {
            // const eventId = Model.asId(evt);
            // return me.eventDependencyCache.getSuccessors(evt, () =>
            //     // Full scan, but cache makes everything possible to avoid it
            //     me.records.filter(dependency =>
            //         dependency.getSourceId() == eventId
            //     )
            // );
        });
    }

    // TODO: document
    mapEventDependencies(event, fn, filterFn, flat, depsGetterFn) {
        return this.reduceEventDependencies(event, (result, dependency) => {
            filterFn(dependency) && result.push(dependency);
            return result;
        }, [], flat, depsGetterFn);
    }

    // TODO: document
    mapEventPredecessors(event, fn, filterFn, flat) {
        return this.reduceEventPredecessors(event, (result, dependency) => {
            filterFn(dependency) && result.push(dependency);
            return result;
        }, [], flat);
    }

    // TODO: document
    mapEventSuccessors(event, fn, filterFn, flat) {
        return this.reduceEventSuccessors(event, (result, dependency) => {
            filterFn(dependency) && result.push(dependency);
            return result;
        }, [], flat);
    }

    /**
     * Returns all dependencies for a certain event (both incoming and outgoing)
     *
     * @param {Scheduler.model.EventModel} event
     * @param {Boolean} [flat]
     * @return {Scheduler.model.DependencyModel[]}
     */
    getEventDependencies(event, flat = false) {
        return [].concat(event.predecessors || [], event.successors || []);
    }

    /**
     * Returns all incoming dependencies of the given event
     *
     * @param {Scheduler.model.EventModel} event
     * @param {Boolean} [flat]
     * @return {Scheduler.model.DependencyModel[]}
     */
    getEventPredecessors(event, flat = false) {
        //return this.mapEventPredecessors(event, o => o, o => true, flat);
        return event.predecessors;
    }

    /**
     * Returns all outcoming dependencies of a event
     *
     * @param {Scheduler.model.EventModel} event
     * @param {Boolean} [flat]
     * @return {Scheduler.model.DependencyModel[]}
     */
    getEventSuccessors(event, flat = false) {
        //return this.mapEventSuccessors(event, o => o, o => true, flat);
        return event.successors;
    }

    getUnique(array) {
        return [...new Set(array)];
    }

    // TODO: document
    removeEventDependencies(event, flat) {
        const me           = this,
            dependencies = me.getEventDependencies(event, flat);

        dependencies.length && me.remove(me.getUnique(dependencies));
    }

    // TODO: document
    removeEventPredecessors(event, flat) {
        const me           = this,
            dependencies = me.getEventPredecessors(event, flat);

        dependencies.length && me.remove(me.getUnique(dependencies));
    }

    // TODO: document
    removeEventSuccessors(event, flat) {
        const me           = this,
            dependencies = me.getEventSuccessors(event, flat);

        dependencies.length && me.remove(me.getUnique(dependencies));
    }

    getBySourceTargetId(key) {
        //TODO: in original code this uses a keymap
        return this.records.find(r =>
            key == DependencyStore.makeDependencySourceTargetCompositeKey(r.from, r.to)
        );
    }

    /**
     * Returns dependency model instance linking tasks with given ids. The dependency can be forward (from 1st
     * task to 2nd) or backward (from 2nd to 1st).
     *
     * @param {Scheduler.model.EventModel|String} sourceEvent 1st event
     * @param {Scheduler.model.EventModel|String} targetEvent 2nd event
     * @return {Scheduler.model.DependencyModel}
     */
    getDependencyForSourceAndTargetEvents(sourceEvent, targetEvent) {
        // NOTE: In case this will not work switch to cache get and linear search
        const me = this;

        sourceEvent = Model.asId(sourceEvent);
        targetEvent = Model.asId(targetEvent);

        return me.getBySourceTargetId(DependencyStore.makeDependencySourceTargetCompositeKey(sourceEvent, targetEvent));
    }

    /**
     * Returns a dependency model instance linking given events if such dependency exists in the store.
     * The dependency can be forward (from 1st event to 2nd) or backward (from 2nd to 1st).
     *
     * @param {Scheduler.model.EventModel|String} sourceEvent
     * @param {Scheduler.model.EventModel|String} targetEvent
     * @return {Scheduler.model.DependencyModel}
     */
    getEventsLinkingDependency(sourceEvent, targetEvent) {
        const me = this;
        return me.getDependencyForSourceAndTargetEvents(sourceEvent, targetEvent) ||
            me.getDependencyForSourceAndTargetEvents(targetEvent, sourceEvent);
    }

    /**
     * Validation method used to validate a dependency. Override and return `true` to indicate that an
     * existing dependency between two tasks is valid. For a new dependency being created please see
     * {@link #function-isValidDependencyToCreate}.
     *
     * @param {Scheduler.model.DependencyModel|Number|String} dependencyOrFromId The dependency model or from event id
     * @param {Number|String} [toId] To event id if the first parameter is not a dependency model instance
     * @param {Number} [type] Dependency {@link Scheduler.model.DependencyBaseModel#property-Type-static}  if the first parameter is not a dependency model instance.
     * @return {Boolean}
     */
    isValidDependency(dependencyOrFromId, toId, type) {
        if (arguments.length === 1) {
            type = dependencyOrFromId.type;
            toId = dependencyOrFromId.to;
            dependencyOrFromId = dependencyOrFromId.from;
        }

        return dependencyOrFromId != null && toId != null && dependencyOrFromId !== toId;
    }

    /**
     * Validation method used to validate a dependency while creating. Override and return `true` to indicate that
     * a new dependency is valid to be created.
     *
     * @param {Number|String} fromId `From` event id
     * @param {Number|String} toId `To` event id
     * @param {Number} type Dependency {@link Scheduler.model.DependencyBaseModel#property-Type-static}
     * @return {Boolean}
     */
    isValidDependencyToCreate(fromId, toId, type) {
        return this.isValidDependency(fromId, toId, type);
    }

    /**
     * Returns all dependencies highlighted with the given CSS class
     *
     * @param {String} cls
     * @return {Scheduler.model.DependencyBaseModel[]}
     */
    getHighlightedDependencies(cls) {
        return this.records.reduce((result, dep) => {
            if (dep.isHighlightedWith(cls)) result.push(dep);
            return result;
        }, []);
    }

    static makeDependencySourceTargetCompositeKey(from, to) {
        return `source(${from})-target(${to})`;
    }

    //region Product neutral

    getTimeSpanDependencies(record) {
        return this.getEventDependencies(record);
    }

    //endregion
}
DependencyStore._$name = 'DependencyStore';

/**
 * @module Scheduler/data/CrudManager
 */

/**
 * The Crud Manager (or "CM") is a class implementing centralized loading and saving of data in multiple stores.
 * Loading the stores and saving all changes is done using one ajax request. This class uses AJAX as a transport
 * mechanism and JSON as the data encoding format.
 *
 * ## Scheduler stores
 *
 * The class supports Scheduler specific stores (namely: resource, event and assignment stores).
 * For these stores, the CM has separate configs ({@link #config-resourceStore}, {@link #config-eventStore},
 * {@link #config-assignmentStore}) to register them. The class can also grab them from the task store (this behavior
 * can be changed using {@link #config-addRelatedStores} config).
 *
 * ```javascript
 * let crudManager = new CrudManager({
 *   autoLoad        : true,
 *   resourceStore   : resourceStore,
 *   eventStore      : eventStore,
 *   assignmentStore : assignmentStore,
 *   transport       : {
 *     load    : {
 *       url     : 'php/read.php'
 *     },
 *     sync    : {
 *       url     : 'php/save.php'
 *     }
 *   }
 * });
 * ```
 *
 * ## AJAX request configuration
 *
 * To configure AJAX request parameters please take a look at the
 * {@link Scheduler.crud.transport.AjaxTransport AjaxTransport} docs.
 *
 * ```javascript
 * const crudManager = new CrudManager({
 *     autoLoad        : true,
 *     resourceStore   : resourceStore,
 *     eventStore      : eventStore,
 *     assignmentStore : assignmentStore,
 *     transport       : {
 *         load    : {
 *             url         : 'php/read.php',
 *             // use GET request
 *             method      : 'GET',
 *             // pass request JSON in "rq" parameter
 *             paramName   : 'rq',
 *             // extra HTTP request parameters
 *             params      : {
 *                 foo     : 'bar'
 *             },
 *             requestConfig : {
 *                 fetchOptions : {
 *                     credentials: 'include'
 *                 }
 *             }
 *         },
 *         sync    : {
 *             url     : 'php/save.php'
 *         }
 *     }
 * });
 * ```
 *
 * ## Load order
 *
 * The CM is aware of the proper load order for Scheduler specific stores so you don't need to worry about it.
 * If you provide any extra stores (using {@link Scheduler.crud.AbstractCrudManager#config-stores} config) they will be
 * added to the start of collection before the Scheduler specific stores.
 * If you a different load order, you should use {@link Scheduler.crud.AbstractCrudManager#function-addStore} method to
 * register your store:
 *
 * ```javascript
 * const crudManager = new CrudManager({
 *     resourceStore   : resourceStore,
 *     eventStore      : eventStore,
 *     assignmentStore : assignmentStore,
 *     // extra user defined stores will get to the start of collection
 *     // so they will be loaded first
 *     stores          : [ store1, store2 ],
 *     transport       : {
 *         load    : {
 *             url     : 'php/read.php'
 *         },
 *         sync    : {
 *             url     : 'php/save.php'
 *         }
 *     }
 * });
 *
 * // append store3 to the end so it will be loaded last
 * crudManager.addStore(store3);
 *
 * // now when we registered all the stores let's load them
 * crudManager.load();
 * ```
 *
 * ## Features
 * The Crud Manager can automatically add Scheduler feature stores to the tracked collection.
 * For example, it tracks TimeRanges {@link Scheduler.feature.TimeRanges#config-store}.
 * You can receive a tracked store by its id:
 * ```javascript
 * let timeRangesStore = crudManager.getStore('timeRanges');
 * ```
 *
 * @mixes Scheduler/crud/encoder/JsonEncoder
 * @mixes Scheduler/crud/transport/AjaxTransport
 * @extends Scheduler/crud/AbstractCrudManager
 */

class CrudManager extends JsonEncoder(AjaxTransport(AbstractCrudManager)) {

    //region Config

    static get defaultConfig() {
        return {
            resourceStoreClass   : ResourceStore,
            eventStoreClass      : EventStore,
            assignmentStoreClass : AssignmentStore,
            dependencyStoreClass : DependencyStore,

            /**
             * A store with resources (or its descriptor).
             * @config {Scheduler.data.ResourceStore|Object}
             */
            resourceStore : {},

            /**
             * A store with events (or its descriptor).
             *
             * ```
             * crudManager : {
             *      eventStore {
             *          storeClass : MyEventStore
             *      }
             * }
             * ```
             * @config {Scheduler.data.EventStore|Object}
             */
            eventStore : {},

            /**
             * A store with assignments (or its descriptor).
             * @config {Scheduler.data.AssignmentStore|Object}
             */
            assignmentStore : null,

            /**
             * A store with dependencies (or its descriptor).
             * @config {Scheduler.data.DependencyStore|Object}
             */
            dependencyStore : null,

            /**
             * When set to `true` this class will try to get the {@link #config-resourceStore} and {@link #config-assignmentStore} stores from
             * the specified {@link #config-eventStore} instance.
             * @config {Boolean}
             */
            addRelatedStores : true
        };
    }

    //endregion

    construct(config = {}) {
        if (config.scheduler) {
            this.scheduler = config.scheduler;

            // The effects of this class's initialization are so wide ranging that they may need to
            // access the Scheduler's CrudManager, so ensure it's available immediately.
            this.scheduler._crudManager = this;
        }

        super.construct(config);
    }

    afterConstruct() {
        const me = this,
            scheduler = me.scheduler;

        if (scheduler) {
            // Inject the scheduler stores into the Scheduler.
            // The resourceStore becomes the primary store.
            if (scheduler.isVertical || scheduler.isHorizontal && !scheduler.store) {
                scheduler.resourceStore = me.resourceStore;
                scheduler.eventStore = me.eventStore;
            }

            // Features self initialize if not already initialized.
            // This must be done after the _crudManager is assigned because it may access this.crudManager
            // to get its eventStore.
            const { dependencies, timeRanges, resourceTimeRanges } = scheduler.features;

            // Special handling of dependency store
            if (dependencies) {
                me.dependencyStore = dependencies.dependencyStore;
            }

            if (timeRanges) {
                me.addCrudStore(timeRanges.store);
                me._timeRangesStore = timeRanges.store;
            }

            if (resourceTimeRanges) {
                me.addCrudStore(resourceTimeRanges.store);
                me._resourceTimeRangesStore = resourceTimeRanges.store;
            }
        }

        super.afterConstruct();
    }

    //region Stores

    /**
     * Returns store associated with timeRanges feature, if feature is enabled.
     * @property {Core.data.Store}
     * @readonly
     */
    get timeRangesStore() {
        return this._timeRangesStore;
    }

    // Adds configured scheduler stores to the store collection ensuring correct order
    // unless they're already registered.
    addFeaturedStore(store) {
        this.addPrioritizedStore(store);
    }

    static getEventStoreInfo(eventStore, config) {
        if (!(eventStore instanceof EventStore)) {
            if (typeof eventStore === 'string') {
                eventStore = Store.getStore(eventStore);
            }
            else {
                eventStore = eventStore.store;
            }
        }
        let result          = {},
            assignmentStore = config.assignmentStore,
            resourceStore   = config.resourceStore,
            dependencyStore = config.dependencyStore;

        !assignmentStore && (result.assignmentStore = eventStore.assignmentStore);
        !resourceStore && (result.resourceStore = eventStore.resourceStore);
        !dependencyStore && (result.dependencyStore = eventStore.dependencyStore);

        return result;
    }

    /**
     * Get/set the resource store bound to the CRUD manager.
     * @property {Scheduler.data.ResourceStore}
     */
    get resourceStore() {
        return this._resourceStore && this._resourceStore.store;
    }

    set resourceStore(store) {
        const me = this;

        me.setFeaturedStore('_resourceStore', store, me.resourceStoreClass);

        me.eventStore.resourceStore = me._resourceStore && me._resourceStore.store;
    }

    /**
     * Get/set the event store bound to the CRUD manager.
     * @property {Scheduler.data.EventStore}
     */
    get eventStore() {
        return this._eventStore && this._eventStore.store;
    }

    set eventStore(store) {
        const me = this;

        me.setFeaturedStore('_eventStore', store, me.eventStoreClass);

        store = me._eventStore && me._eventStore.store;

        // If we're configuring, retrieve stores registered on the provided taskStore
        if (me.isConfiguring && store && me.addRelatedStores !== false) {
            let extracted = CrudManager.getEventStoreInfo(store, me.initialConfig),
                assignmentStore = extracted.assignmentStore,
                resourceStore = extracted.resourceStore,
                dependencyStore = extracted.dependencyStore;

            if (assignmentStore) {
                me.assignmentStore = assignmentStore;
            }
            if (resourceStore) {
                me.resourceStore = resourceStore;
            }
            if (dependencyStore) {
                me.dependencyStore = dependencyStore;
            }
        }
    }

    /**
     * Get/set the assignment store bound to the CRUD manager.
     * @property {Scheduler.data.AssignmentStore}
     */
    get assignmentStore() {
        return this._assignmentStore && this._assignmentStore.store;
    }

    set assignmentStore(store) {
        this.setFeaturedStore('_assignmentStore', store, this.assignmentStoreClass);
    }

    /**
     * Get/set the dependency store bound to the CRUD manager.
     * @property {Scheduler.data.DependencyStore}
     */
    get dependencyStore() {
        return this._dependencyStore && this._dependencyStore.store;
    }

    set dependencyStore(store) {
        this.setFeaturedStore('_dependencyStore', store, this.dependencyStoreClass);
    }

    setFeaturedStore(property, store, storeClass) {
        const me = this,
            oldStore = me[property];

        store = Store.getStore(store, store && store.storeClass || storeClass);

        if (oldStore) {
            me.removeStore(oldStore);
        }

        me[property] = store && { store } || null;

        me.addFeaturedStore(me[property]);

        return me[property];
    }

    //endregion
}CrudManager._$name = 'CrudManager';

/**
 * @module Scheduler/data/util/recurrence/RecurrenceLegend
 */

/**
 * A static class allowing to get a human readable description of the provided recurrence.
 *
 * ```javascript
 * const event = new EventModel({ startDate : new Date(2018, 6, 3), endDate : new Date(2018, 6, 4) });
 * const recurrence = new RecurrenceModel({ frequency : 'WEEKLY', days : ['MO', 'TU', 'WE'] });
 * event.recurrence = recurrence;
 * // "Weekly on  Mon, Tue and Wed"
 * RecurrenceLegend.getLegend(recurrence);
 * ```
 * @mixes Core/localization/Localizable
 */
class RecurrenceLegend extends Localizable() {

    static get $name() {
        return 'RecurrenceLegend';
    }

    static get allDaysValue() {
        return 'SU,MO,TU,WE,TH,FR,SA';
    }

    static get workingDaysValue() {
        return 'MO,TU,WE,TH,FR';
    }

    static get nonWorkingDaysValue() {
        return 'SU,SA';
    }

    /**
     * Returns the provided recurrence description. The recurrence might be assigned to a timespan model,
     * in this case the timespan start date should be provided in the second argument.
     * @param  {Scheduler.model.RecurrenceModel} recurrence         Recurrence model.
     * @param  {Date}                           [timeSpanStartDate] The recurring timespan start date. Can be omitted if the recurrence is assigned to a timespan model
     *                                                              (and the timespan has {@link Scheduler.model.TimeSpan#field-startDate} filled).
     *                                                              Then start date will be retrieved from the model.
     * @return {String}                                             The recurrence description.
     */
    static getLegend(recurrence, timeSpanStartDate) {
        const
            me = this,
            { timeSpan, interval, days, monthDays, months, positions } = recurrence,
            startDate = timeSpanStartDate || timeSpan.startDate,
            tplData   = { interval };

        let fn;

        switch (recurrence.frequency) {
            case 'DAILY':
                return interval == 1 ? me.L('Daily') : me.L('Every {0} days', tplData);

            case 'WEEKLY':
                if (days && days.length) {
                    tplData.days = me.getDaysLegend(days);
                }
                else if (startDate) {
                    tplData.days = DateHelper.getDayName(startDate.getDay());
                }

                return me.L(interval == 1 ? 'Weekly on {1}' : 'Every {0} weeks on {1}', tplData);

            case 'MONTHLY':
                if (days && days.length && positions && positions.length) {
                    tplData.days = me.getDaysLegend(days, positions);
                }
                else if (monthDays && monthDays.length) {
                    // sort dates to output in a proper order
                    monthDays.sort((a, b) => a - b);

                    tplData.days = me.arrayToText(monthDays);
                }
                else if (startDate) {
                    tplData.days = startDate.getDate();
                }

                return me.L(interval == 1 ? 'Monthly on {1}' : 'Every {0} months on {1}', tplData);

            case 'YEARLY':

                if (days && days.length && positions && positions.length) {
                    tplData.days = me.getDaysLegend(days, positions);
                }
                else {
                    tplData.days = startDate.getDate();
                }

                if (months && months.length) {
                    // sort months to output in a proper order
                    months.sort((a, b) => a - b);

                    if (months.length > 2) {
                        fn = month => DateHelper.getMonthShortName(month - 1);
                    }
                    else {
                        fn = month => DateHelper.getMonthName(month - 1);
                    }

                    tplData.months = me.arrayToText(months, fn);
                }
                else {
                    tplData.months = DateHelper.getMonthName(startDate.getMonth());
                }

                return me.L(interval == 1 ? 'Yearly on {1} of {2}' : 'Every {0} years on {1} of {2}', tplData);
        }
    }

    static getDaysLegend(days, positions) {
        const me = this;

        let tplData = { position : '' },
            fn;

        if (positions && positions.length) {
            // the following lines are added to satisfy the 904_unused localization test
            // to let it know that these locales are used:
            // me.L('position1')
            // me.L('position2')
            // me.L('position3')
            // me.L('position4')
            // me.L('position5')
            // me.L('position-1')
            tplData.position = me.arrayToText(positions, position => me.L(`position${position}`));
        }

        if (days.length) {
            days.sort((a, b) => RecurrenceDayRuleEncoder.decodeDay(a)[0] - RecurrenceDayRuleEncoder.decodeDay(b)[0]);

            switch (days.join(',')) {
                case me.allDaysValue :
                    tplData.days = me.L('day');
                    break;

                case me.workingDaysValue :
                    tplData.days = me.L('weekday');
                    break;

                case me.nonWorkingDaysValue :
                    tplData.days = me.L('weekend day');
                    break;

                default :
                    if (days.length > 2) {
                        fn = day => DateHelper.getDayShortName(RecurrenceDayRuleEncoder.decodeDay(day)[0]);
                    }
                    else {
                        fn = day => DateHelper.getDayName(RecurrenceDayRuleEncoder.decodeDay(day)[0]);
                    }

                    tplData.days = me.arrayToText(days, fn);
            }
        }

        return me.L('daysFormat', tplData);
    }

    // Converts array of items to a human readable list.
    // For example: [1,2,3,4]
    // to: "1, 2, 3 and 4"
    static arrayToText(array, fn) {
        if (fn) {
            array = array.map(fn);
        }

        return array.join(', ').replace(/,(?=[^,]*$)/, this.L(' and '));
    }

}
RecurrenceLegend._$name = 'RecurrenceLegend';

/**
 * @module Scheduler/model/ResourceTimeRangeModel
 */

/**
 * This class represent a single resource time range in your schedule. To style
 * the rendered elements, use the {@link Scheduler.model.TimeSpan#field-cls cls} field of the `TimeSpan` class, or use the {@link #field-timeRangeColor} field.
 *
 * @extends Scheduler/model/TimeSpan
 */
class ResourceTimeRangeModel extends TimeSpan {
    //region Fields

    static get fields() {
        return [
            /**
             * Id of the resource this time range is associated with
             * @field {String|Number} resourceId
             */
            'resourceId',

            /**
             * Controls this time ranges primary color, defaults to using current themes default time range color.
             * @field {String} timeRangeColor
             */
            'timeRangeColor'
        ];
    }

    static get relationConfig() {
        return [
            /**
             * The associated resource, retrieved using a relation to a ResourceStore determined by the value assigned
             * to `resourceId`. The relation also lets you access all time ranges on a resource through
             * `ResourceModel#timeRanges`.
             * @property {Scheduler.model.ResourceModel} resource
             */
            { relationName : 'resource', fieldName : 'resourceId', store : 'resourceStore', collectionName : 'timeRanges', nullFieldOnRemove : true }
        ];
    }

    //endregion

    // Used internally to differentiate between Event and ResourceTimeRange
    get isResourceTimeRange() {
        return true;
    }

    // To match EventModel API
    get resources() {
        return [this.resource];
    }
}
ResourceTimeRangeModel._$name = 'ResourceTimeRangeModel';

/**
 * @module Scheduler/data/ResourceTimeRangeStore
 */

/**
 * A class representing a collection of resource time ranges.
 * Contains a collection of {@link Scheduler.model.ResourceTimeRangeModel} records.
 *
 * @extends Core/data/AjaxStore
 */
class ResourceTimeRangeStore extends AjaxStore {
    static get defaultConfig() {
        return {
            /**
             * CrudManager must load stores in the correct order. Lowest first.
             * @private
             */
            loadPriority : 500,

            /**
             * CrudManager must sync stores in the correct order. Lowest first.
             * @private
             */
            syncPriority : 500,

            /**
             * This store should be linked to a ResourceStore to link the time ranges to resources
             * @config {Scheduler.data.ResourceStore}
             */
            resourceStore : null,

            modelClass : ResourceTimeRangeModel,
            storeId    : 'resourceTimeRanges'
        };
    }

    set resourceStore(store) {
        this._resourceStore = store;

        // If store is assigned after configuration we need to init relations
        if (!this.isConfiguring) {
            this.initRelations(true);
        }
    }

    get resourceStore() {
        return this._resourceStore;
    }

    // Matching signature in EventStore to allow reusage of SchedulerStores#onInternalEventStoreChange()
    getResourcesForEvent(resourceTimeRange) {
        return [resourceTimeRange.resource];
    }
}
ResourceTimeRangeStore._$name = 'ResourceTimeRangeStore';

/**
 * @module Scheduler/preset/ViewPreset
 */

/**
 * A ViewPreset is a record of {@link Scheduler.preset.PresetStore PresetStore} which describes the granularity
 * of the timeline view of a {@link Scheduler.view.Scheduler Scheduler} and the layout and subdivisions of the timeline header.
 *
 * You can create a new instance by specifying all fields:
 * ```javascript
 * const myViewPreset = new ViewPreset({
 *     id   : 'myPreset',              // Unique id value provided to recognize your view preset. Not required, but having it you can simply set new view preset by id: scheduler.viewPreset = 'myPreset'
 *
 *     name : 'My view preset',        // A human-readable name provided to be used in GUI, e.i. preset picker, etc.
 *
 *     tickWidth  : 24,                // Time column width in horizontal mode
 *     tickHeight : 50,                // Time column height in vertical mode
 *     displayDateFormat : 'HH:mm',    // Controls how dates will be displayed in tooltips etc
 *
 *     shiftIncrement : 1,             // Controls how much time to skip when calling shiftNext and shiftPrevious.
 *     shiftUnit      : 'day',         // Valid values are 'millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'.
 *     defaultSpan    : 12,            // By default, if no end date is supplied to a view it will show 12 hours
 *
 *     timeResolution : {              // Dates will be snapped to this resolution
 *         unit      : 'minute',       // Valid values are 'millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'.
 *         increment : 15
 *     },
 *
 *     headers : [                     // This defines your header rows from top to bottom
 *         {                           // For each row you can define 'unit', 'increment', 'dateFormat', 'renderer', 'align', and 'thisObj'
 *             unit       : 'day',
 *             dateFormat : 'ddd DD/MM'
 *         },
 *         {
 *             unit       : 'hour',
 *             dateFormat : 'HH:mm'
 *         }
 *     ],
 *
 *     columnLinesFor : 1              // Defines header level column lines will be drawn for. Defaults to the last level.
 * });
 * ```
 *
 * Or you can extend one of view presets registered in {@link Scheduler.preset.PresetManager PresetManager}:
 *
 * ```javascript
 * const myViewPreset2 = new ViewPreset({
 *     id   : 'myPreset',                  // Unique id value provided to recognize your view preset. Not required, but having it you can simply set new view preset by id: scheduler.viewPreset = 'myPreset'
 *     name : 'My view preset',            // A human-readable name provided to be used in GUI, e.i. preset picker, etc.
 *     base : 'hourAndDay',                // Extends 'hourAndDay' view preset provided by PresetManager. You can pick out any of PresetManager's view presets: PresetManager.records
 *
 *     timeResolution : {                  // Override time resolution
 *         unit      : 'minute',
 *         increment : 15                  // Make it increment every 15 mins
 *     },
 *
 *     headers : [                         // Override headers
 *         {
 *             unit       : 'day',
 *             dateFormat : 'DD.MM.YYYY'   // Use different date format for top header 01.10.2020
 *         },
 *         {
 *             unit       : 'hour',
 *             dateFormat : 'LT'
 *         }
 *     ]
 * });
 * ```
 *
 * See {@link Scheduler.preset.PresetManager PresetManager} for the list of base presets. You may add your own
 * presets to this global list:
 *
 * ```javascript
 * PresetManager.add(myViewPreset);     // Adds new preset to the global scope. All newly created scheduler instances will have it too.
 *
 * const scheduler = new Scheduler({
 *     viewPreset : 'myPreset'
 *     // other configs...
 * });
 * ```
 *
 * Or add them on an individual basis to Scheduler instances:
 *
 * ```javascript
 * const scheduler = new Scheduler({...});
 *
 * scheduler.presets.add(myViewPreset); // Adds new preset to the scheduler instance only. All newly created scheduler instances will **not** have it.
 *
 * scheduler.viewPreset = 'myPreset';
 * ```
 *
 * @extends Core/data/Model
 */
class ViewPreset extends Model {
    static get fields() {
        return [
            /**
             * The name of the view preset
             * @field {String} name
             */
            { name : 'name', type : 'string' },

            /**
             * The height of the row in horizontal orientation
             * @field {Number} rowHeight
             * @default
             */
            {
                name         : 'rowHeight',
                defaultValue : 24
            },

            /**
             * The width of the time tick column in horizontal orientation
             * @field {Number} tickWidth
             * @default
             */
            {
                name         : 'tickWidth',
                defaultValue : 50
            },

            /**
             * The height of the time tick column in vertical orientation
             * @field {Number} tickHeight
             * @default
             */
            {
                name         : 'tickHeight',
                defaultValue : 50
            },

            /**
             * Defines how dates will be formatted in tooltips etc
             * @field {String} displayDateFormat
             * @default
             */
            {
                name         : 'displayDateFormat',
                defaultValue : 'HH:mm'
            },

            /**
             * The unit to shift when calling shiftNext/shiftPrevious to navigate in the chart.
             * Valid values are "millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year".
             * @field {String} shiftUnit
             * @default
             */
            {
                name         : 'shiftUnit',
                defaultValue : 'hour'
            },

            /**
             * The amount to shift (in shiftUnits)
             * @field {Number} shiftIncrement
             * @default
             */
            {
                name         : 'shiftIncrement',
                defaultValue : 1
            },

            /**
             * The amount of time to show by default in a view (in the unit defined by the middle header)
             * @field {Number} defaultSpan
             * @default
             */
            {
                name         : 'defaultSpan',
                defaultValue : 12
            },

            /**
             * An object containing a unit identifier and an increment variable. This value means minimal task duration you can create using UI.
             * For example when you drag create a task or drag & drop a task, if increment is 5 and unit is 'minute'
             * that means that you can create a 5 min long task, or move it 5 min forward/backward. This config maps to
             * scheduler's {@link Scheduler.view.mixin.TimelineDateMapper#property-timeResolution timeResolution} config.
             *
             * ```javascript
             * timeResolution : {
             *   unit      : 'minute',  //Valid values are "millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year".
             *   increment : 5
             * }
             * ```
             *
             * @field {Object} timeResolution
             */
            'timeResolution',

            /**
             * An array containing one or more {@link Scheduler.preset.ViewPresetHeaderRow} config objects, each of which defines a level of headers for the scheduler.
             * The 'main' unit will be the last header's unit, but this can be changed using the `mainHeaderLevel` field.
             * @field {Object} headers
             */
            'headers',

            /**
             * Defines which {@link #field-headers header} level defines the 'main' header. Defaults to the bottom header.
             * @field {Number} mainHeaderLevel
             */
            'mainHeaderLevel',

            /**
             * Defines which {@link #field-headers header} level the column lines will be drawn for. See {@link Scheduler.feature.ColumnLines}.
             * Defaults to the bottom header.
             * @field {Number} columnLinesFor
             */
            'columnLinesFor'
        ];
    }

    construct(data) {
        super.construct(...arguments);
        this.normalizeUnits();
    }

    static processData(data, ...args) {
        // Process legacy headerConfig config into a headers array.
        // TODO: remove deprecated compatibility layer in V4
        if (data.headerConfig) {
            VersionHelper.deprecate('Scheduler', '4.0.0', 'ViewPreset headerConfig config replaced by headers config. See https://www.bryntum.com/docs/scheduler/#guides/upgrades/3.0.md');
            data = ObjectHelper.assign({}, data);
            this.normalizeHeaderConfig(data);
        }

        return super.processData(data, ...args);
    }

    generateId(owner) {
        const
            me          = this,
            {
                headers
            }           = me,
            parts       = [];

        // If we were subclassed from a base, use that id as the basis of oure.
        let result = Object.getPrototypeOf(me.data).id;

        if (!result) {
            for (let { length } = headers, i = length - 1; i >= 0; i--) {
                parts.push(i ? headers[i].unit : StringHelper.capitalizeFirstLetter(headers[i].unit));
            }

            // Use upwards header units at so eg "monthAndYear"
            result = parts.join('And');
        }

        // If duplicate, make it "hourAndDay-50by80"
        if (owner.includes(result)) {
            result += `-${me.tickWidth}by${me.tickHeight || me.tickWidth}`;
            // If still duplicate use increment
            if (owner.includes(result)) {
                result += `-${me.bottomHeader.increment}`;
                // And if STILL duplicate, make it unique with a suffix
                if (owner.includes(result)) {
                    result = IdHelper.generateId(`${result}-`);
                }
            }
        }

        return result;
    }

    normalizeUnits() {
        const
            me                          = this,
            { timeResolution, headers } = me;

        // Make sure date "unit" constant specified in the preset are resolved
        for (let i = 0, { length } = headers; i < length; i++) {
            const header = headers[i];

            header.unit = DateHelper.normalizeUnit(header.unit);
            if (header.splitUnit) {
                header.splitUnit = DateHelper.normalizeUnit(header.splitUnit);
            }
            if (!('increment' in header)) {
                headers[i] = Object.assign({
                    increment : 1
                }, header);
            }
        }

        if (timeResolution) {
            timeResolution.unit = DateHelper.normalizeUnit(timeResolution.unit);
        }

        if (me.shiftUnit) {
            me.shiftUnit = DateHelper.normalizeUnit(me.shiftUnit);
        }
    }

    // Process legacy columnLines config into a headers array.
    static normalizeHeaderConfig(data) {
        const
            { headerConfig, columnLinesFor, mainHeaderLevel } = data,
            headers = data.headers           = [];

        if (headerConfig.top) {
            if (columnLinesFor == 'top') {
                data.columnLinesFor = 0;
            }
            if (mainHeaderLevel == 'top') {
                data.mainHeaderLevel = 0;
            }
            headers[0] = headerConfig.top;
        }
        if (headerConfig.middle) {
            if (columnLinesFor == 'middle') {
                data.columnLinesFor = headers.length;
            }
            if (mainHeaderLevel == 'middle') {
                data.mainHeaderLevel = headers.length;
            }
            headers.push(headerConfig.middle);
        }
        else {
            throw new Error('ViewPreset.headerConfig must be configured with a middle');
        }
        if (headerConfig.bottom) {
            // Main level is middle when using headerConfig object.
            data.mainHeaderLevel = headers.length - 1;

            // There *must* be a middle above this bottom header
            // so that is the columnLines one by default.
            if (columnLinesFor == null) {
                data.columnLinesFor = headers.length - 1;
            }
            else if (columnLinesFor == 'bottom') {
                data.columnLinesFor = headers.length;
            }

            // There *must* be a middle above this bottom header
            // so that is the main one by default.
            if (mainHeaderLevel == null) {
                data.mainHeaderLevel = headers.length - 1;
            }
            if (mainHeaderLevel == 'bottom') {
                data.mainHeaderLevel = headers.length;
            }

            headers.push(headerConfig.bottom);
        }
    }

    // These are read-only once configured.
    set() {}
    inSet() {}

    get columnLinesFor() {
        return ('columnLinesFor' in this.data) ? this.data.columnLinesFor : this.headers.length - 1;
    }

    get tickSize() {
        return this._tickSize || this.tickWidth;
    }

    get tickWidth() {
        return ('tickWidth' in this.data) ? this.data.tickWidth : 50;
    }

    get tickHeight() {
        return ('tickHeight' in this.data) ? this.data.tickHeight : 50;
    }

    get headerConfig() {
        // Configured in the legacy manner, just return the configured value.
        if (this.data.headerConfig) {
            return this.data.headerConfig;
        }

        // Rebuild the object based upon the configured headers array.
        const
            result = {},
            { headers } = this,
            { length } = headers;

        switch (length) {
            case 1 :
                result.middle = headers[0];
                break;
            case 2:
                if (this.mainHeaderLevel === 0) {
                    result.middle = headers[0];
                    result.bottom = headers[1];
                }
                else {
                    result.top = headers[0];
                    result.middle = headers[1];
                }
                break;
            case 3:
                result.top = headers[0];
                result.middle = headers[1];
                result.bottom = headers[2];
                break;
            default:
                throw new Error('headerConfig object not supported for >3 header levels');
        }

        return result;
    }

    set mainHeaderLevel(mainHeaderLevel) {
        this.data.mainHeaderLevel = mainHeaderLevel;
    }

    get mainHeaderLevel() {
        if ('mainHeaderLevel' in this.data) {
            return this.data.mainHeaderLevel;
        }

        // 3 headers, then it's the middle
        if (this.data.headers.length === 3) {
            return 1;
        }
        // Assume it goes top, middle.
        // If it's middle, top, use mainHeaderLevel : 0
        return this.headers.length - 1;
    }

    get mainHeader() {
        return this.headers[this.mainHeaderLevel];
    }

    get bottomHeader() {
        return this.headers[this.headers.length - 1];
    }

    get leafUnit() {
        return this.bottomHeader.unit;
    }

    get mainUnit() {
        return this.mainHeader;
    }

    get msPerPixel() {
        const { bottomHeader } = this;

        return Math.round(DateHelper.asMilliseconds(bottomHeader.increment || 1, bottomHeader.unit) / this.tickWidth);
    }

    get isValid() {
        const me = this;

        let valid = true;

        // Make sure all date "unit" constants are valid
        for (const header of me.headers) {
            valid = valid && Boolean(DateHelper.normalizeUnit(header.unit));
        }

        if (me.timeResolution) {
            valid = valid && DateHelper.normalizeUnit(me.timeResolution.unit);
        }

        if (me.shiftUnit) {
            valid = valid && DateHelper.normalizeUnit(me.shiftUnit);
        }

        return valid;
    }
}
ViewPreset._$name = 'ViewPreset';

// eslint-disable-next-line import/no-named-default

/**
 * @module Scheduler/preset/PresetStore
 */

/**
 * A special Store subclass which holds {@link Scheduler.preset.ViewPreset ViewPresets}.
 * Each ViewPreset in this store represents a zoom level. The store data is sorted in special
 * zoom order. That is zoomed out to zoomed in. The first Preset will produce the narrowest event bars
 * the last one will produce the widest event bars.
 *
 * To specify view presets (zoom levels) please provide set of view presets to the scheduler:
 *
 * ```javascript
 * const myScheduler = new Scheduler({
 *     presets : [
 *         {
 *             base : 'hourAndDay',
 *             id   : 'MyHourAndDay',
 *             // other preset configs....
 *         },
 *         {
 *             base : 'weekAndMonth',
 *             id   : 'MyWeekAndMonth',
 *             // other preset configs....
 *         }
 *     ],
 *     viewPreset : 'MyHourAndDay',
 *     // other scheduler configs....
 *     });
 * ```
 *
 * @extends Core/data/Store
 */
class PresetStore extends Localizable(Store) {
    static get defaultConfig() {
        return {
            useRawData : true,

            modelClass : ViewPreset,

            /**
             * Specifies the sort order of the presets in the store.
             * By default they are in zoomed out to zoomed in order. That is
             * presets which will create widest event bars to presets
             * which will produce narrowest event bars.
             *
             * Configure this as `-1` to reverse this order.
             * @config {Number}
             * @default
             */
            zoomOrder : 1
        };
    }

    set storage(storage) {
        super.storage = storage;

        // Maintained in order automatically while adding.
        this.storage.addSorter((lhs, rhs) => {
            const
                leftBottomHeader  = lhs.bottomHeader,
                rightBottomHeader = rhs.bottomHeader;

            // Sort order:
            //  Milliseconds per pixel.
            //  Tick size.
            //  Unit magnitude.
            //  Increment size.
            const
                order = rhs.msPerPixel - lhs.msPerPixel ||
                unitMagnitudes[leftBottomHeader.unit] - unitMagnitudes[rightBottomHeader.unit] ||
                leftBottomHeader.increment - rightBottomHeader.increment;

            return order * this.zoomOrder;
        });
    }

    get storage() {
        return super.storage;
    }

    createRecord(data) {
        // TODO: remove deprecated compatibility layer in V4
        if (data.preset && !data.base) {
            VersionHelper.deprecate('Scheduler', '4.0.0', 'ViewPreset preset config replaced by base config. See https://www.bryntum.com/docs/scheduler/#guides/upgrades/3.0.md');
            data.base = data.preset;
        }

        if (data.base) {
            const base = this.getById(data.base) || pm.getById(data.base);

            data = Object.setPrototypeOf(data, base.data);
        }
        return super.createRecord(...arguments);
    }

    updateLocalization() {
        super.updateLocalization();

        this.forEach((preset) => {
            const locale = this.L(preset.id);

            if (locale) {
                locale.displayDateFormat && (preset.displayDateFormat = locale.displayDateFormat);
                locale.middleDateFormat  && preset.headerConfig.middle && (preset.headerConfig.middle.dateFormat = locale.middleDateFormat);
                locale.topDateFormat     && preset.headerConfig.top    && (preset.headerConfig.top.dateFormat    = locale.topDateFormat);
                locale.bottomDateFormat  && preset.headerConfig.bottom && (preset.headerConfig.bottom.dateFormat = locale.bottomDateFormat);
            }
        });
    }
}
PresetStore._$name = 'PresetStore';

// No module tag here. That stops the singleton from being included by the docs.

/**
 * This is a global Store of {@link Scheduler.preset.ViewPreset ViewPresets}, required to supply initial data to
 * Scheduler's {@link Scheduler.view.mixin.TimelineViewPresets#config-presets presets}.
 *
 * You can provide new view presets globally or for a specific scheduler.
 * **NOTE:** All changes provided to PresetManager store are not reflected to PresetStore of schedulers that already exist!
 *
 * ```javascript
 * const scheduler = new Scheduler({...});
 *
 * const newGlobalPresets = PresetManager.add({
 *     id              : 'myNewPreset',
 *     base            : 'hourAndDay', // Based on an existing preset
 *     columnLinesFor  : 0,
 *     headers : [                         // Override headers
 *         {
 *             unit       : 'day',
 *             dateFormat : 'DD.MM.YYYY'   // Use different date format for top header 01.10.2020
 *         },
 *         {
 *             unit       : 'hour',
 *             dateFormat : 'LT'
 *         }
 *     ]
 * });
 *
 * scheduler.presets.add(newGlobalPresets); // Add new presets to the scheduler that has been created before changes to PresetManager are applied
 * ```
 *
 * Predefined presets are:
 *
 * - `secondAndMinute` - creates 2 level header - minute and seconds within it:
 * {@inlineexample scheduler/viewpresets/secondAndMinute.js}
 * - `minuteAndHour` - creates 2 level header - hour and minutes within it:
 * {@inlineexample scheduler/viewpresets/minuteAndHour.js}
 * - `hourAndDay` - creates 2 level header - day and hours within it:
 * {@inlineexample scheduler/viewpresets/hourAndDay.js}
 * - `dayAndWeek` - creates 2 level header - week and days within it:
 * {@inlineexample scheduler/viewpresets/dayAndWeek.js}
 * - `weekAndDay` - just like `dayAndWeek` but with different formatting:
 * {@inlineexample scheduler/viewpresets/weekAndDay.js}
 * - `weekAndDayLetter` - creates 2 level header - with weeks and day letters within it:
 * {@inlineexample scheduler/viewpresets/weekAndDayLetter.js}
 * - `weekAndMonth` - creates 2 level header - month and weeks within it:
 * {@inlineexample scheduler/viewpresets/weekAndMonth.js}
 * - `weekDateAndMonth` - creates 2 level header - month and weeks within it (weeks shown by first day only):
 * {@inlineexample scheduler/viewpresets/weekDateAndMonth.js}
 * - `monthAndYear` - creates 2 level header - year and months within it:
 * {@inlineexample scheduler/viewpresets/monthAndYear.js}
 * - `year` - creates 2 level header - year and quarters within it:
 * {@inlineexample scheduler/viewpresets/year.js}
 * - `manyYears` - creates 2 level header - 5-years and year within it:
 * {@inlineexample scheduler/viewpresets/manyYears.js}
 *
 * See the {@link Scheduler.preset.ViewPreset} and {@link Scheduler.preset.ViewPresetHeaderRow} classes for a description of the view preset properties.
 *
 * @singleton
 * @extends Scheduler/preset/PresetStore
 */
class PresetManager extends PresetStore {
    static get defaultConfig() {
        return {
            // To not break CSP demo
            preventSubClassingModel : true,

            basePresets : {
                secondAndMinute : {
                    name              : 'Seconds',
                    tickWidth         : 30,   // Time column width
                    tickHeight        : 40,
                    displayDateFormat : 'll LTS', // Controls how dates will be displayed in tooltips etc
                    shiftIncrement    : 10,     // Controls how much time to skip when calling shiftNext and shiftPrevious.
                    shiftUnit         : 'minute', // Valid values are "millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year".
                    defaultSpan       : 24,    // By default, if no end date is supplied to a view it will show 24 hours
                    timeResolution    : {      // Dates will be snapped to this resolution
                        unit      : 'second',  // Valid values are "millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year".
                        increment : 5
                    },
                    // This defines your header rows.
                    // For each row you can define "unit", "increment", "dateFormat", "renderer", "align", and "thisObj"
                    headers : [
                        {
                            unit       : 'minute',
                            dateFormat : 'llll'
                        },
                        {
                            unit       : 'second',
                            increment  : 10,
                            dateFormat : 'ss'
                        }
                    ]
                },
                minuteAndHour : {
                    name              : 'Minutes',
                    tickWidth         : 60,    // Time column width
                    tickHeight        : 60,
                    displayDateFormat : 'll LT', // Controls how dates will be displayed in tooltips etc
                    shiftIncrement    : 1,     // Controls how much time to skip when calling shiftNext and shiftPrevious.
                    shiftUnit         : 'hour', // Valid values are "MILLI", "SECOND", "minute", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
                    defaultSpan       : 24,    // By default, if no end date is supplied to a view it will show 24 hours
                    timeResolution    : {      // Dates will be snapped to this resolution
                        unit      : 'minute',  // Valid values are "MILLI", "SECOND", "minute", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
                        increment : 30
                    },
                    headers : [
                        {
                            unit       : 'hour',
                            dateFormat : 'ddd MM/DD, hA'
                        },
                        {
                            unit       : 'minute',
                            increment  : 30,
                            dateFormat : 'mm'
                        }
                    ]
                },
                hourAndDay : {
                    name              : 'Hours',
                    tickWidth         : 70,
                    tickHeight        : 40,
                    displayDateFormat : 'll LT',
                    shiftIncrement    : 1,
                    shiftUnit         : 'day',
                    defaultSpan       : 24,
                    timeResolution    : {
                        unit      : 'minute',
                        increment : 30
                    },
                    headers : [
                        {
                            unit       : 'day',
                            dateFormat : 'ddd DD/MM' //Mon 01/10
                        },
                        {
                            unit       : 'hour',
                            dateFormat : 'LT'
                        }
                    ]
                },
                day : {
                    name              : 'Hours 2',
                    displayDateFormat : 'LT',
                    shiftIncrement    : 1,
                    shiftUnit         : 'day',
                    defaultSpan       : 1,
                    timeResolution    : {
                        unit      : 'minute',
                        increment : 30
                    },
                    mainHeaderLevel : 0,
                    headers         : [
                        {
                            unit       : 'day',
                            dateFormat : 'ddd DD/MM', // Mon 01/02
                            splitUnit  : 'day'
                        },
                        {
                            unit : 'hour',
                            renderer(value) {
                                return `
                                    <div class="b-sch-calendarcolumn-ct"><span class="b-sch-calendarcolumn-hours">${DateHelper.format(value, 'HH')}</span>
                                    <span class="b-sch-calendarcolumn-minutes">${DateHelper.format(value, 'mm')}</span></div>
                                `;
                            }
                        }
                    ]
                },
                week : {
                    name              : 'Week/hours',
                    displayDateFormat : 'LT',
                    shiftIncrement    : 1,
                    shiftUnit         : 'week',
                    defaultSpan       : 24,
                    timeResolution    : {
                        unit      : 'minute',
                        increment : 30
                    },
                    mainHeaderLevel : 0,
                    headers         : [
                        {
                            unit       : 'week',
                            dateFormat : 'D d',
                            splitUnit  : 'day'
                        },
                        {
                            unit       : 'hour',
                            dateFormat : 'LT',    // will be overridden by renderer
                            renderer(value) {
                                return `
                                    <div class="sch-calendarcolumn-ct">
                                    <span class="sch-calendarcolumn-hours">${DateHelper.format(value, 'HH')}</span>
                                    <span class="sch-calendarcolumn-minutes">${DateHelper.format(value, 'mm')}</span>
                                    </div>
                                `;
                            }
                        }
                    ]
                },
                dayAndWeek : {
                    name              : 'Days 2',
                    tickWidth         : 100,
                    tickHeight        : 80,
                    displayDateFormat : 'll LT',
                    shiftUnit         : 'day',
                    shiftIncrement    : 1,
                    defaultSpan       : 5,
                    timeResolution    : {
                        unit      : 'hour',
                        increment : 1
                    },
                    headers : [
                        {
                            unit : 'week',
                            renderer(start) {
                                return DateHelper.getShortNameOfUnit('week') + '.' + DateHelper.format(start, 'WW MMM YYYY');
                            }
                        },
                        {
                            unit       : 'day',
                            dateFormat : 'dd DD'
                        }
                    ]
                },
                weekAndDay : {
                    name              : 'Days',
                    tickWidth         : 100,
                    tickHeight        : 80,
                    displayDateFormat : 'll hh:mm A',
                    shiftUnit         : 'week',
                    shiftIncrement    : 1,
                    defaultSpan       : 1,
                    timeResolution    : {
                        unit      : 'day',
                        increment : 1
                    },
                    mainHeaderLevel : 0,
                    headers         : [
                        {
                            unit       : 'week',
                            dateFormat : 'YYYY MMMM DD' // 2017 January 01
                        },
                        {
                            unit       : 'day',
                            increment  : 1,
                            dateFormat : 'DD MMM'
                        }
                    ]
                },
                weekAndMonth : {
                    name              : 'Weeks',
                    tickWidth         : 100,
                    tickHeight        : 105,
                    displayDateFormat : 'll',
                    shiftUnit         : 'week',
                    shiftIncrement    : 5,
                    defaultSpan       : 6,
                    timeResolution    : {
                        unit      : 'day',
                        increment : 1
                    },
                    headers : [
                        {
                            unit       : 'month',
                            dateFormat : 'MMM YYYY' //Jan 2017
                        },
                        {
                            unit       : 'week',
                            dateFormat : 'DD MMM'
                        }
                    ]
                },
                weekAndDayLetter : {
                    name              : 'Weeks 2',
                    tickWidth         : 20,
                    tickHeight        : 50,
                    displayDateFormat : 'll',
                    shiftUnit         : 'week',
                    shiftIncrement    : 1,
                    defaultSpan       : 10,
                    timeResolution    : {
                        unit      : 'day',
                        increment : 1
                    },
                    mainHeaderLevel : 0,
                    headers         : [
                        {
                            unit                : 'week',
                            dateFormat          : 'ddd DD MMM YYYY',
                            verticalColumnWidth : 115
                        },
                        {
                            unit                : 'day',
                            dateFormat          : 'd1',
                            verticalColumnWidth : 25
                        }
                    ]
                },
                weekDateAndMonth : {
                    name              : 'Weeks 3',
                    tickWidth         : 30,
                    tickHeight        : 40,
                    displayDateFormat : 'll',
                    shiftUnit         : 'week',
                    shiftIncrement    : 1,
                    defaultSpan       : 10,
                    timeResolution    : {
                        unit      : 'day',
                        increment : 1
                    },
                    headers : [
                        {
                            unit       : 'month',
                            dateFormat : 'YYYY MMMM'
                        },
                        {
                            unit       : 'week',
                            dateFormat : 'DD'
                        }
                    ]
                },
                monthAndYear : {
                    name              : 'Months',
                    tickWidth         : 110,
                    tickHeight        : 110,
                    displayDateFormat : 'll',
                    shiftIncrement    : 3,
                    shiftUnit         : 'month',
                    defaultSpan       : 12,
                    timeResolution    : {
                        unit      : 'day',
                        increment : 1
                    },
                    headers : [
                        {
                            unit       : 'year',
                            dateFormat : 'YYYY' //2017
                        },
                        {
                            unit       : 'month',
                            dateFormat : 'MMM YYYY' //Jan 2017
                        }
                    ]
                },
                year : {
                    name                : 'Years',
                    tickWidth           : 100,
                    tickHeight          : 100,
                    resourceColumnWidth : 100,
                    displayDateFormat   : 'll',
                    shiftUnit           : 'year',
                    shiftIncrement      : 1,
                    defaultSpan         : 1,
                    timeResolution      : {
                        unit      : 'month',
                        increment : 1
                    },
                    headers : [
                        {
                            unit       : 'year',
                            dateFormat : 'YYYY'
                        },
                        {
                            unit : 'quarter',
                            renderer(start, end, cfg) {
                                return DateHelper.getShortNameOfUnit('quarter').toUpperCase() + (Math.floor(start.getMonth() / 3) + 1);
                            }
                        }
                    ]
                },
                manyYears : {
                    name              : 'Years 2',
                    tickWidth         : 40,
                    tickHeight        : 50,
                    displayDateFormat : 'll',
                    shiftUnit         : 'year',
                    shiftIncrement    : 1,
                    defaultSpan       : 1,
                    timeResolution    : {
                        unit      : 'year',
                        increment : 1
                    },
                    mainHeaderLevel : 0,
                    headers         : [
                        {
                            unit       : 'year',
                            dateFormat : 'YYYY',
                            increment  : 5
                        },
                        {
                            unit       : 'year',
                            dateFormat : 'YY',
                            increment  : 1
                        }
                    ]
                }
            },

            // This is a list of bryntum-supplied preset adjustments used to create the Scheduler's
            // default initial set of ViewPresets.
            defaultPresets : [
                // Years over years
                'manyYears',
                { width : 80, increment : 1, resolution : 1, preset : 'manyYears', resolutionUnit : 'YEAR' },

                // Years over quarters
                'year',
                { width : 30,  increment : 1, resolution : 1, preset : 'year', resolutionUnit : 'MONTH' },
                { width : 50,  increment : 1, resolution : 1, preset : 'year', resolutionUnit : 'MONTH' },
                { width : 200, increment : 1, resolution : 1, preset : 'year', resolutionUnit : 'MONTH' },

                // Years over months
                'monthAndYear',

                // Months over weeks
                'weekDateAndMonth',

                // Months over weeks
                'weekAndMonth',

                // Months over weeks
                'weekAndDayLetter',

                // Weeks over days
                'weekAndDay',
                { width : 54, increment : 1, resolution : 1, preset : 'weekAndDay', resolutionUnit : 'HOUR' },

                // Days over hours
                'hourAndDay',
                { width : 64,  increment : 6, resolution : 30, preset : 'hourAndDay', resolutionUnit : 'MINUTE' },
                { width : 100, increment : 6, resolution : 30, preset : 'hourAndDay', resolutionUnit : 'MINUTE' },
                { width : 64,  increment : 2, resolution : 30, preset : 'hourAndDay', resolutionUnit : 'MINUTE' },

                // Hours over minutes
                'minuteAndHour',
                { width : 30,  increment : 15, resolution : 5, preset : 'minuteAndHour' },
                { width : 130, increment : 15, resolution : 5, preset : 'minuteAndHour' },
                { width : 60,  increment : 5,  resolution : 5, preset : 'minuteAndHour' },
                { width : 100, increment : 5,  resolution : 5, preset : 'minuteAndHour' },

                // Minutes over seconds
                'secondAndMinute',
                { width : 60,  increment : 10, resolution : 5, preset : 'secondAndMinute' },
                { width : 130, increment : 5,  resolution : 5, preset : 'secondAndMinute' }
            ],

            listeners : {
                locale : 'updateLocalization'
            }
        };
    }

    set basePresets(basePresets) {
        const presetCache = this._basePresets = {};

        for (const id in basePresets) {
            basePresets[id].id = id;
            presetCache[id] = this.createRecord(basePresets[id]);
        }
    }

    get basePresets() {
        return this._basePresets;
    }

    set defaultPresets(defaultPresets) {
        for (let i = 0, { length } = defaultPresets; i < length; i++) {
            const
                presetAdjustment   = defaultPresets[i],
                isBase             = typeof presetAdjustment === 'string',
                baseType           = isBase ? presetAdjustment : presetAdjustment.preset;

            let preset;

            // The default was just a string, so it's an unmodified instance of a base type.
            if (isBase) {
                preset = this.basePresets[baseType];
            }
            // If it's an object, it's an adjustment to a base tyope
            else {
                const
                    config             = Object.setPrototypeOf(ObjectHelper.clone(this.basePresets[baseType].data), { id : baseType }),
                    { timeResolution } = config,
                    bottomHeader       = config.headers[config.headers.length - 1];

                config.id = undefined;
                if ('width' in presetAdjustment) {
                    config.tickWidth = presetAdjustment.width;
                }
                if ('height' in presetAdjustment) {
                    config.tickHeight = presetAdjustment.height;
                }
                if ('increment' in presetAdjustment) {
                    bottomHeader.increment = presetAdjustment.increment;
                }
                if ('resolution' in presetAdjustment) {
                    timeResolution.increment = presetAdjustment.resolution;
                }
                if ('resolutionUnit' in presetAdjustment) {
                    timeResolution.unit = DateHelper.getUnitByName(presetAdjustment.resolutionUnit);
                }

                preset = this.createRecord(config);
            }
            this.add(preset);
        }
    }

    getById(id) {
        // Look first in the default set, and if it's one of the base types that is not imported into the
        // default set, then look at the bases.
        return super.getById(id) || this.basePresets[id];
    }

    /**
     * Registers a new view preset base to be used by any scheduler grid or tree on the page.
     * @param {String} id The unique identifier for this preset
     * @param {Object} config The configuration properties of the view preset (see {@link Scheduler.preset.ViewPreset} for more information)
     * @returns {Scheduler.preset.ViewPreset} A new ViewPreset based upon the passed configuration.
     */
    registerPreset(id, config) {
        const
            preset = this.createRecord(Object.assign({
                id
            }, config)),
            existingDuplicate = this.find(p => p.equals(preset));

        if (existingDuplicate) {
            return existingDuplicate;
        }

        if (preset.isValid) {
            this.add(preset);
        }
        else {
            throw new Error('Invalid preset, please check your configuration');
        }

        return preset;
    }

    getPreset(preset) {
        if (typeof preset === 'number') {
            preset = this.getAt(preset);
        }
        if (typeof preset === 'string') {
            preset = this.getById(preset);
        }
        else if (!(preset instanceof ViewPreset)) {
            preset = this.createRecord(preset);
        }
        return preset;
    }

    /**
     * Applies preset customizations or fetches a preset view preset using its name.
     * @param {String|Object} presetOrId Id of a predefined preset or a preset config object
     * @returns {Scheduler.preset.ViewPreset} Resulting ViewPreset instance
     */
    normalizePreset(preset) {
        let me = this;

        if (!(preset instanceof ViewPreset)) {
            if (typeof preset === 'string') {
                preset = me.getPreset(preset);
                if (!preset) {
                    throw new Error('You must define a valid view preset. See PresetManager for reference');
                }
            }
            else if (typeof preset === 'object') {
                // Look up any existing ViewPreset that it is based upon.
                if (preset.base) {
                    const base = this.getById(preset.base);

                    if (!base) {
                        throw new Error(`ViewPreset base '${preset.base}' does not exist`);
                    }
                    // The config is based upon the base's data with the new config object merged in.
                    preset = ObjectHelper.merge(ObjectHelper.clone(base.data), preset);
                }

                // Ensure the new ViewPreset has a legible, logical id which does not already
                // exxist in our store.
                if (preset.id) {
                    preset = me.createRecord(preset);
                }
                else {
                    preset = me.createRecord(ObjectHelper.assign({}, preset));
                    preset.id = preset.generateId(preset);
                }
            }
        }

        return preset;
    }

    /**
     * Deletes a view preset
     * @param {String} id The id of the preset, or the preset instance.
     */
    deletePreset(presetOrId) {
        if (typeof presetOrId === 'string') {
            presetOrId = this.getById(presetOrId);
        }
        else if (typeof presetOrId === 'number') {
            presetOrId = this.getAt(presetOrId);
        }

        if (presetOrId) {
            this.remove(presetOrId);

            // ALso remove it from our base list
            delete this.basePresets[presetOrId.id];
        }
    }
}

const pm = new PresetManager();

/**
 * @module Scheduler/data/TimeAxis
 */

/**
 * A class representing the time axis of the scheduler. The scheduler timescale is based on the ticks generated by this class.
 * This is a pure "data" (model) representation of the time axis and has no UI elements.
 *
 * The time axis can be {@link #config-continuous} or not. In continuous mode, each timespan starts where the previous ended, and in non-continuous mode
 * there can be gaps between the ticks.
 * A non-continuous time axis can be used when want to filter out certain periods of time (like weekends) from the time axis.
 *
 * To create a non-continuos time axis you have 2 options. First, you can create a time axis containing only the time spans of interest.
 * To do that, subclass this class and override the {@link #function-generateTicks} method.
 *
 * The other alternative is to call the {@link #function-filterBy} method, passing a function to it which should return `false` if the time tick should be filtered out.
 * Calling {@link Core.data.mixin.StoreFilter#function-clearFilters} will return you to a full time axis.
 *
 * @extends Core/data/Store
 */
class TimeAxis extends Store {
    //region Events

    /**
     * Fires before the timeaxis is about to be reconfigured (e.g. new start/end date or unit/increment). Return false to abort the operation.
     * @event beforereconfigure
     * @param {Scheduler.data.TimeAxis} source The time axis instance
     * @param {Date} startDate The new time axis start date
     * @param {Date} endDate The new time axis end date
     */

    /**
     * Event that is triggered when we end reconfiguring and everything UI-related should be done
     * @event endreconfigure
     * @private
     */

    /**
     * Fires when the timeaxis has been reconfigured (e.g. new start/end date or unit/increment)
     * @event reconfigure
     * @param {Scheduler.data.TimeAxis} source The time axis instance
     */

    /**
     * Fires if all the ticks in the timeaxis are filtered out. After firing the filter is cleared to return the time
     * axis to a valid state.
     * @event invalidFilter
     * @param {Scheduler.data.TimeAxis} source The time axis instance
     */

    //endregion

    //region Default config

    static get defaultConfig() {
        return {
            modelClass : TimeSpan,

            /**
             * Set to false if the timeline is not continuous, e.g. the next timespan does not start where the previous ended (for example skipping weekends etc).
             * @config {Boolean}
             * @default
             */
            continuous : true,

            originalContinuous : null,

            /**
             * Include only certain hours or days in the time axis (makes it `continuous : false`). Accepts and object
             * with `day` and `hour` properties:
             * ```
             * const scheduler = new Scheduler({
             *     timeAxis : {
             *         include : {
             *              // Do not display hours after 17 or before 9 (only display 9 - 17). The `to´ value is not
             *              // included in the time axis
             *              hour : {
             *                  from : 9,
             *                  to   : 17
             *              },
             *              // Do not display sunday or saturday
             *              day : [0, 6]
             *         }
             *     }
             * }
             * ```
             * In most cases we recommend that you use Scheduler's workingTime config instead. It is easier to use and
             * makes sure all parts of the Scheduler gets updated.
             * @config {Object}
             */
            include : null,

            /**
             * Automatically adjust the timespan when generating ticks with {@link #function-generateTicks} according to
             * the `viewPreset` configuration. Setting this to false may lead to shifting time/date of ticks.
             * @config {Boolean}
             * @default
             */
            autoAdjust : true,

            unit                : null,
            increment           : null,
            resolutionUnit      : null,
            resolutionIncrement : null,

            weekStartDay : null,

            mainUnit  : null,
            shiftUnit : null,

            shiftIncrement : 1,

            //isConfigured : false,

            // in case of `autoAdjust : false`, the 1st and last ticks can be truncated, containing only part of the normal tick
            // these dates will contain adjusted start/end (like if the tick has not been truncated)
            adjustedStart    : null,
            adjustedEnd      : null,
            // the visible position in the first tick, can actually be > 1 because the adjustment is done by the `mainUnit`
            visibleTickStart : null,
            // the visible position in the first tick, is always ticks count - 1 < value <= ticks count, in case of autoAdjust, always = ticks count
            visibleTickEnd   : null,

            defaultSpan : 1,

            tickCache : {},

            viewPreset : null
        };
    }

    //endregion

    //region Init

    // private
    construct(config) {
        const me = this;

        // TODO: maybe not needed
        me.generateTicksValidatorFn = () => true;

        super.construct(config);

        me.originalContinuous = me.continuous;

        me.on({
            change : ({ action }) => {
                // If the change was due to filtering, there will be a refresh event
                // arriving next, so do not reconfigure
                if (action !== 'filter') {
                    me.trigger('reconfigure', { supressRefresh : false });
                }
            },
            refresh        : () => me.trigger('reconfigure', { supressRefresh : false }),
            endreconfigure : event => me.trigger('reconfigure', event)
        });

        if (me.startDate) {
            me.internalOnReconfigure();
            me.trigger('reconfigure');
        }
        else if (me.viewPreset) {
            const range = me.getAdjustedDates(new Date());
            me.startDate = range.startDate;
            me.endDate = range.endDate;
        }
    }

    get isTimeAxis() {
        return true;
    }

    //endregion

    //region Configuration (reconfigure & consumePreset)

    /**
     * Reconfigures the time axis based on the config object supplied and generates the new 'ticks'.
     * @param {Object} config
     * @param {Boolean} [suppressRefresh]
     * @private
     */
    reconfigure(config, suppressRefresh = false, preventThrow = false) {
        const me         = this,
            normalized = me.getAdjustedDates(config.startDate, config.endDate);

        if (me.trigger('beforeReconfigure', { startDate : normalized.startDate, endDate : normalized.endDate, config }) !== false) {
            me.trigger('beginReconfigure');

            me._configuredStartDate = config.startDate;
            me._configuredEndDate = config.endDate;

            Object.assign(me, config);

            if (me.internalOnReconfigure(preventThrow) === false) {
                return false;
            }

            me.trigger('endReconfigure', { suppressRefresh, config });
        }
    }

    internalOnReconfigure(preventThrow = false) {
        const me = this;

        me.isConfigured = true;

        const adjusted = me.getAdjustedDates(me.startDate, me.endDate, true),
            normalized = me.getAdjustedDates(me.startDate, me.endDate),
            start      = normalized.startDate,
            end        = normalized.endDate;

        if (start >= end) {
            throw new Error(`Invalid start/end dates. Start date must less than end date. Start date: ${start}. End date: ${end}.`);
        }

        const unit     = me.unit,
            increment  = me.increment || 1,
            ticks      = me.generateTicks(start, end, unit, increment);

        // Suspending to be able to detect an invalid filter
        me.suspendEvents();
        me.data = ticks;

        const { count } = me;

        if (count === 0) {
            if (preventThrow) {
                me.resumeEvents();
                return false;
            }
            throw new Error('Invalid time axis configuration or filter, please check your input data.');
        }

        // start date is cached, update it to fill after generated ticks
        me.startDate = me.first.startDate;

        me.resumeEvents();

        let checkEnd = me.last.endDate;

        if (me.isContinuous) {
            me.adjustedStart = adjusted.startDate;
            me.adjustedEnd = DateHelper.getNext(count > 1 ? ticks[count - 1].startDate : adjusted.startDate, unit, increment, me.weekStartDay);
        }
        else {
            me.adjustedStart = me.startDate;
            me.adjustedEnd = checkEnd;
        }

        // if visibleTickStart > 1 this means some tick is fully outside of the view - we are not interested in it and want to
        // drop it and adjust "adjustedStart" accordingly
        do {
            // TODO this has to use more sophisticated formula to take into account that months for example can be expressed in ms consistenly
            me.visibleTickStart = (me.startDate - me.adjustedStart) / (DateHelper.asMilliseconds(unit) * increment);

            // TODO: Changed from round to floor which seems to work, but this is not needed in ExtScheduler. Need to step and see what is different
            if (me.autoAdjust) me.visibleTickStart = Math.floor(me.visibleTickStart);

            if (me.visibleTickStart >= 1) me.adjustedStart = DateHelper.getNext(me.adjustedStart, unit, increment, me.weekStartDay);
        } while (me.visibleTickStart >= 1);

        do {
            me.visibleTickEnd = count - (me.adjustedEnd - checkEnd) / (DateHelper.asMilliseconds(unit) * increment);

            if (count - me.visibleTickEnd >= 1) me.adjustedEnd = DateHelper.getNext(me.adjustedEnd, unit, -1, me.weekStartDay);
        } while (count - me.visibleTickEnd >= 1);

        me.updateTickCache(true);
    }

    /**
     * Get/set currently used preset
     * @property {Scheduler.preset.ViewPreset}
     */
    get viewPreset() {
        return this._viewPreset;
    }

    set viewPreset(preset) {
        const me = this;

        preset = pm.getPreset(preset);

        if (!(preset instanceof ViewPreset)) {
            throw new Error('TimeAxis must be configured with the ViewPreset instance that the Scheduler is using');
        }

        me._viewPreset = preset;

        Object.assign(me, {
            unit      : preset.bottomHeader.unit,
            increment : preset.bottomHeader.increment || 1,

            resolutionUnit      : preset.timeResolution.unit,
            resolutionIncrement : preset.timeResolution.increment,

            mainUnit       : preset.mainHeader.unit,
            shiftUnit      : preset.shiftUnit,
            shiftIncrement : preset.shiftIncrement || 1,

            defaultSpan : preset.defaultSpan || 1,
            presetName  : preset.id,

            // Weekview columns are updated upon 'datachanged' event on this object.
            // We have to pass headers in order to render them correctly (timeAxisViewModel is incorrect in required time)
            headers : preset.headers
        });
    }

    //endregion

    //region Getters & setters

    set weekStartDay(day) {
        this._weekStartDay = day;
    }

    get weekStartDay() {
        if (this._weekStartDay == null) {
            return DateHelper.weekStartDay;
        }

        return this._weekStartDay;
    }

    // private
    get resolution() {
        return {
            unit      : this.resolutionUnit,
            increment : this.resolutionIncrement
        };
    }

    // private
    set resolution(resolution) {
        this.resolutionUnit = resolution.unit;
        this.resolutionIncrement = resolution.increment;
    }

    get resolutionUnit() {
        return this._resolutionUnit;
    }

    set resolutionUnit(resolutionUnit) {
        this._resolutionUnit = resolutionUnit;
    }

    get resolutionIncrement() {
        return this._resolutionIncrement;
    }

    set resolutionIncrement(resolutionIncrement) {
        this._resolutionIncrement = resolutionIncrement || 1;
    }

    set mainUnit(mainUnit) {
        this._mainUnit = mainUnit;
    }

    get mainUnit() {
        return this._mainUnit;
    }

    set shiftUnit(shiftUnit) {
        this._shiftUnit = shiftUnit;
    }

    // private
    get shiftUnit() {
        return this._shiftUnit || this._mainUnit;
    }

    set shiftIncrement(shiftIncrement) {
        this._shiftIncrement = shiftIncrement;
    }

    // private
    get shiftIncrement() {
        return this._shiftIncrement || 1;
    }

    set unit(unit) {
        this._unit = unit;
    }

    // private
    get unit() {
        return this._unit;
    }

    set increment(increment) {
        this._increment = increment;
    }

    // private
    get increment() {
        return this._increment;
    }

    get defaultSpan() {
        return this._defaultSpan;
    }

    set defaultSpan(defaultSpan) {
        this._defaultSpan = defaultSpan;
    }

    //endregion

    //region Timespan & resolution

    /**
     * Changes the time axis timespan to the supplied start and end dates.
     * @param {Date} newStartDate The new start date
     * @param {Date} newEndDate The new end date
     */
    setTimeSpan(newStartDate, newEndDate, preventThrow = false) {
        const me             = this,
            { startDate, endDate } = me.getAdjustedDates(newStartDate, newEndDate);

        if (me.startDate - startDate !== 0 || me.endDate - endDate !== 0) {
            return me.reconfigure({
                startDate,
                endDate
            }, false, preventThrow);
        }
    }

    /**
     * Moves the time axis by the passed amount and unit.
     *
     * NOTE: When using a filtered TimeAxis the result of `shift()` cannot be guaranteed, it might shift into a
     * filtered out span. It tries to be smart about it by shifting from unfiltered start and end dates.
     * If that solution does not work for your filtering setup, please call {@link #function-setTimeSpan} directly
     * instead.
     *
     * @param {Number} amount The number of units to jump
     * @param {String} [unit] The unit (Day, Week etc)
     */
    shift(amount, unit = this.shiftUnit) {
        const me = this;

        let { startDate, endDate } = me;

        // Use unfiltered start and end dates when shifting a filtered time axis, to lessen risk of messing it up.
        // Still not guaranteed to work though
        if (me.isFiltered) {
            startDate = me.allRecords[0].startDate;
            endDate = me.allRecords[me.allCount - 1].endDate;
        }

        // Hack for filtered time axis, for example if weekend is filtered out and you shiftPrev() day from monday
        let tries = 0;
        do {
            startDate = DateHelper.add(startDate, amount, unit);
            endDate = DateHelper.add(endDate, amount, unit);
        } while (tries++ < 100 && me.setTimeSpan(startDate, endDate, true) === false);
    }

    /**
     * Moves the time axis forward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement`
     * config of the current view preset.
     *
     * NOTE: When using a filtered TimeAxis the result of `shiftNext()` cannot be guaranteed, it might shift into a
     * filtered out span. It tries to be smart about it by shifting from unfiltered start and end dates.
     * If that solution does not work for your filtering setup, please call {@link #function-setTimeSpan} directly
     * instead.

     *
     * @param {Number} [amount] The number of units to jump forward
     */
    shiftNext(amount = this.shiftIncrement) {
        this.shift(amount);
    }

    /**
     * Moves the time axis backward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement` config of the current view preset.
     *
     * NOTE: When using a filtered TimeAxis the result of `shiftPrev()` cannot be guaranteed, it might shift into a
     * filtered out span. It tries to be smart about it by shifting from unfiltered start and end dates.
     * If that solution does not work for your filtering setup, please call {@link #function-setTimeSpan} directly
     * instead.

     *
     * @param {Number} [amount] The number of units to jump backward
     */
    shiftPrevious(amount = this.shiftIncrement) {
        this.shift(-amount);
    }

    //endregion

    //region Filter & continous

    /**
     * Filter the time axis by a function. The passed function will be called with each tick in time axis.
     * If the function returns true, the 'tick' is included otherwise it is filtered. If all ticks are filtered out
     * the time axis is considered invalid, triggering `invalidFilter` and then removing the filter.
     * @param {Function} fn The function to be called, it will receive an object with startDate/endDate properties, and 'index' of the tick.
     * @param {Object} [thisObj] `this` reference for the function
     */
    filterBy(fn, thisObj = this) {
        const me = this;

        me.filters.clear();

        super.filterBy((tick, index) => fn.call(thisObj, tick.data, index));

        if (me.count === 0) {
            me.trigger('invalidFilter');
            me.clearFilters();
        }
    }

    triggerFilterEvent(event) {
        const me = this;

        if (!event.filters.count) {
            me.continuous = me.originalContinuous;
        }
        else {
            me.continuous = false;
        }

        // Filters has been applied (or cleared) but listeners are not informed yet, update tick cache to have start and
        // end dates correct when later redrawing events & header
        me.updateTickCache();

        super.triggerFilterEvent(event);
    }

    /**
     * Returns `true` if the time axis is continuous (will return `false` when filtered)
     * @return {Boolean}
     */
    get isContinuous() {
        return this.continuous !== false && !this.filtered;
    }

    //endregion

    //region Dates

    getAdjustedDates(startDate, endDate, forceAdjust = false) {
        const me = this;

        startDate = startDate || me.startDate;
        endDate = endDate || DateHelper.add(startDate, me.defaultSpan, me.mainUnit);

        return me.autoAdjust || forceAdjust ? {
            startDate : me.floorDate(startDate, false, me.autoAdjust ? me.mainUnit : me.unit, 1),
            endDate   : me.ceilDate(endDate, false, me.autoAdjust ? me.mainUnit : me.unit, 1)
        } : {
            startDate : startDate,
            endDate   : endDate
        };
    }

    /**
     * Method to get the current start date of the time axis.
     * @property {Date}
     */
    get startDate() {
        // TODO: added _start as caching, might mess something up when reconfiguring? change here if tests fail
        return this._start || (this.first ? new Date(this.first.startDate) : null);
    }

    set startDate(start) {
        this._start = DateHelper.parse(start);
    }

    /**
     * Method to get a the current end date of the time axis
     * @property {Date}
     */
    get endDate() {
        return this._end || (this.last ? new Date(this.last.endDate) : null);
    }

    set endDate(end) {
        if (end) this._end = DateHelper.parse(end);
    }

    // used in performance critical code for comparisons
    get startMS() {
        return this._startMS;
    }

    // used in performance critical code for comparisons
    get endMS() {
        return this._endMS;
    }

    // Floors a date and optionally snaps it to one of the following resolutions:
    // 1. 'resolutionUnit'. If param 'resolutionUnit' is passed, the date will simply be floored to this unit.
    // 2. If resolutionUnit is not passed: If date should be snapped relative to the timeaxis start date,
    // the resolutionUnit of the timeAxis will be used, or the timeAxis 'mainUnit' will be used to snap the date
    //
    // returns a copy of the original date
    // private
    floorDate(date, relativeToStart, resolutionUnit, incr) {
        relativeToStart = relativeToStart !== false;

        const
            me         = this,
            relativeTo = relativeToStart ? DateHelper.clone(me.startDate) : null,
            increment  = incr || me.resolutionIncrement,
            unit       = resolutionUnit || (relativeToStart ? me.resolutionUnit : me.mainUnit),
            snap       = (value, increment) => Math.floor(value / increment) * increment;

        if (relativeToStart) {
            const snappedDuration = snap(DateHelper.diff(relativeTo, date, unit), increment);
            // TODO: used to be small unit multipled with factor (minute = seconds, minutes * 60)
            return DateHelper.add(relativeTo, snappedDuration, unit);
        }

        let dt = DateHelper.clone(date);

        if (unit === 'week') {
            let day      = dt.getDay() || 7,
                startDay = me.weekStartDay || 7;

            dt = DateHelper.add(DateHelper.startOf(dt, 'day'), day >= startDay ? startDay - day : -(7 - startDay + day), 'day');

            // Watch out for Brazil DST craziness (see test 028_timeaxis_dst.t.js)
            if (dt.getDay() !== startDay && dt.getHours() === 23) {
                dt = DateHelper.add(dt, 1, 'hour');
            }
        }
        else {
            // removes "smaller" units from date (for example minutes; removes seconds and milliseconds)
            dt = DateHelper.startOf(dt, unit);

            // day and year are 1-based so need to make additional adjustments
            let modifier     = ['day', 'year'].includes(unit) ? 1 : 0,
                useUnit      = unit === 'day' ? 'date' : unit,
                snappedValue = snap(DateHelper.get(dt, useUnit) - modifier, increment) + modifier;

            dt = DateHelper.set(dt, useUnit, snappedValue);
        }

        return dt;
    }

    /**
     * Rounds the date to nearest unit increment
     * @private
     */
    roundDate(date, relativeTo) {
        const
            me        = this,
            dt        = DateHelper.clone(date),
            increment = me.resolutionIncrement || 1;

        relativeTo = DateHelper.clone(relativeTo || me.startDate);

        switch (me.resolutionUnit) {
            case 'week':
                DateHelper.startOf(dt, 'day');

                let distanceToWeekStartDay = dt.getDay() - me.weekStartDay,
                    toAdd;

                if (distanceToWeekStartDay < 0) {
                    distanceToWeekStartDay = 7 + distanceToWeekStartDay;
                }

                if (Math.round(distanceToWeekStartDay / 7) === 1) {
                    toAdd = 7 - distanceToWeekStartDay;
                }
                else {
                    toAdd = -distanceToWeekStartDay;
                }

                return DateHelper.add(dt, toAdd, 'day');

            case 'month':
                const
                    nbrMonths     = DateHelper.diff(relativeTo, dt, 'month') + DateHelper.as('month', dt.getDay() / DateHelper.daysInMonth(dt)), //*/DH.as('month', DH.diff(relativeTo, dt)) + (dt.getDay() / DH.daysInMonth(dt)),
                    snappedMonths = Math.round(nbrMonths / increment) * increment;
                return DateHelper.add(relativeTo, snappedMonths, 'month');

            case 'quarter':
                DateHelper.startOf(dt, 'month');
                return DateHelper.add(dt, 'month', 3 - (dt.getMonth() % 3));

            default:
                const
                    duration        = DateHelper.as(me.resolutionUnit, DateHelper.diff(relativeTo, dt)),
                    // Need to find the difference of timezone offsets between relativeTo and original dates. 0 if timezone offsets are the same.
                    offset          = DateHelper.as(me.resolutionUnit, relativeTo.getTimezoneOffset() - dt.getTimezoneOffset(), 'minute'),
                    // Need to add the offset to the whole duration, so the divided value will take DST into account
                    snappedDuration = Math.round((duration + offset) / increment) * increment;

                // TODO: used to add one res unit lower * factor, minutes = add seconds, minutes * 60
                // Now when the round is done, we need to subtract the offset, so the result also will take DST into account
                return DateHelper.add(relativeTo, snappedDuration - offset, me.resolutionUnit);
        }
    }

    // private
    ceilDate(date, relativeToStart, resolutionUnit, increment) {
        const me = this;

        relativeToStart = relativeToStart !== false;
        increment = increment || (relativeToStart ? this.resolutionIncrement : 1);

        let dt     = DateHelper.clone(date),
            doCall = false,
            unit   = resolutionUnit || (relativeToStart ? me.resolutionUnit : me.mainUnit);

        switch (unit) {
            case 'minute':
                doCall = !DateHelper.isStartOf(dt, 'minute');
                break;
            case 'hour':
                doCall = !DateHelper.isStartOf(dt, 'hour');
                break;

            case 'day':
            case 'date':
                doCall = !DateHelper.isStartOf(dt, 'day');
                break;

            case 'week':
                dt = DateHelper.startOf(dt, 'day');
                doCall = (dt.getDay() !== me.weekStartDay || !DateHelper.isEqual(dt, date));
                break;

            case 'month':
                dt = DateHelper.startOf(dt, 'day');
                doCall = (dt.getDate() !== 1 || !DateHelper.isEqual(dt, date));
                break;

            case 'quarter':
                dt = DateHelper.startOf(dt, 'day');
                doCall = (dt.getMonth() % 3 !== 0 || dt.getDate() !== 1 || !DateHelper.isEqual(dt, date));
                break;

            case 'year':
                dt = DateHelper.startOf(dt, 'day');
                doCall = (dt.getMonth() !== 0 || dt.getDate() !== 1 || !DateHelper.isEqual(dt, date));
                break;
        }

        if (doCall) return DateHelper.getNext(dt, unit, increment, me.weekStartDay);

        return dt;
    }

    //endregion

    //region Ticks

    get include() {
        return this._include;
    }

    set include(include) {
        const me = this;

        me._include = include;
        me.continuous = !include;

        if (!me.isConfiguring) {
            me.startDate = me._configuredStartDate;
            me.endDate = me._configuredEndDate;
            me.internalOnReconfigure();
            me.trigger('includeChange');
        }
    }

    // Check if a certain date is included based on timeAxis.include rules
    processExclusion(startDate, endDate, unit) {
        const { include } = this;

        if (include) {
            return Object.entries(include).some(([includeUnit, rule]) => {

                if (!rule) {
                    return false;
                }

                const { from, to } = rule;

                // Including the closest smaller unit with a { from, to} rule should affect start & end of the
                // generated tick. Currently only works for days or smaller.
                if (DateHelper.compareUnits('day', unit) >= 0 && DateHelper.getLargerUnit(includeUnit) === unit) {
                    if (from) {
                        DateHelper.set(startDate, includeUnit, from);
                    }

                    if (to) {
                        let stepUnit = unit;
                        // Stepping back base on date, not day
                        if (unit === 'day') {
                            stepUnit = 'date';
                        }
                        // Since endDate is not inclusive it points to the next day etc.
                        // Turns for example 2019-01-10T00:00 -> 2019-01-09T18:00
                        DateHelper.set(endDate, {
                            [stepUnit]    : DateHelper.get(endDate, stepUnit) - 1,
                            [includeUnit] : to
                        });
                    }
                }

                // "Greater" unit being included? Then we need to care about it
                // (for example excluding day will also affect hour, minute etc)
                if (DateHelper.compareUnits(includeUnit, unit) >= 0) {
                    const datePart = (includeUnit === 'day' ? startDate.getDay() : DateHelper.get(startDate, includeUnit));

                    if ((from && datePart < from) || (to && datePart >= to)) {
                        return true;
                    }
                }
            });
        }

        return false;
    }

    // Calculate constants used for exclusion when scaling within larger ticks
    initExclusion() {
        Object.entries(this.include).forEach(([unit, rule]) => {
            if (rule) {
                const { from, to } = rule;

                // For example for hour:
                // 1. Get the next bigger unit -> day, get ratio -> 24
                // 2. to 20 - from 8 = 12 hours visible each day. lengthFactor 24 / 12 = 2 means that each hour used
                // needs to represent 2 hours when drawn (to stretch)
                // |    ████    | -> |  ████████  |
                rule.lengthFactor = DateHelper.getUnitToBaseUnitRatio(unit, DateHelper.getLargerUnit(unit)) / (to - from);
                // TODO: Since `to` is exclusive this should be the correct one... but cannot get it to work throughout
                rule.lengthFactorExcl = DateHelper.getUnitToBaseUnitRatio(unit, DateHelper.getLargerUnit(unit)) / (to - from - 1);

                // Calculate weighted center to stretch around |   ██x█ |
                rule.center = from + from / (rule.lengthFactor - 1);
            }
        });
    }

    /**
     * Method generating the ticks for this time axis. Should return an array of ticks. Each tick is an object of the following structure:
     * ```
     * {
     *    startDate : ..., // start date
     *    endDate   : ...  // end date
     * }
     * ```
     * Take notice, that this function either has to be called with `start`/`end` parameters, or create those variables.
     *
     * To see it in action please check out our [TimeAxis](https://bryntum.com/examples/scheduler/timeaxis/) example and navigate to "Compressed non-working time" tab.
     *
     * @param {Date} axisStartDate The start date of the interval
     * @param {Date} axisEndDate The end date of the interval
     * @param {String} unit The unit of the time axis
     * @param {Number} increment The increment for the unit specified.
     * @return {Array} ticks The ticks representing the time axis
     */
    generateTicks(axisStartDate, axisEndDate, unit = this.unit, increment = this.increment) {
        const me          = this,
            ticks         = [],
            usesExclusion = Boolean(me.include);

        let intervalEnd,
            tickEnd,
            isExcluded,
            dstDiff        = 0,
            { startDate, endDate } = me.getAdjustedDates(axisStartDate, axisEndDate);

        me.tickCache = {};

        if (usesExclusion) {
            me.initExclusion();
        }

        while (startDate < endDate) {
            intervalEnd = DateHelper.getNext(startDate, unit, increment, me.weekStartDay);

            if (!me.autoAdjust && intervalEnd > endDate) {
                intervalEnd = endDate;
            }

            // Handle hourly increments crossing DST boundaries to keep the timescale looking correct
            // Only do this for HOUR resolution currently, and only handle it once per tick generation.
            if (unit === 'hour' && increment > 1 && ticks.length > 0 && dstDiff === 0) {
                const prev = ticks[ticks.length - 1];

                dstDiff = ((prev.startDate.getHours() + increment) % 24) - prev.endDate.getHours();

                if (dstDiff !== 0) {
                    // A DST boundary was crossed in previous tick, adjust this tick to keep timeaxis "symmetric".
                    intervalEnd = DateHelper.add(intervalEnd, dstDiff, 'hour');
                }
            }

            isExcluded = false;

            if (usesExclusion) {
                tickEnd = new Date(intervalEnd.getTime());
                isExcluded = me.processExclusion(startDate, intervalEnd, unit);
            }
            else {
                tickEnd = intervalEnd;
            }

            if (me.generateTicksValidatorFn(startDate) && !isExcluded) {
                ticks.push({
                    id      : (ticks.length + 1),
                    startDate,
                    endDate : intervalEnd
                });
                me.tickCache[startDate.getTime()] = ticks.length - 1;
            }

            startDate = tickEnd;
        }

        return ticks;
    }

    get visibleTickTimeSpan() {
        const me = this;
        return me.isContinuous ? me.visibleTickEnd - me.visibleTickStart : me.count;
    }

    /**
     * Gets a tick "coordinate" representing the date position on the time scale. Returns -1 if the date is not part of the time axis.
     * @param {Date} date the date
     * @return {Number} the tick position on the scale or -1 if the date is not part of the time axis
     */
    getTickFromDate(date) {
        const me = this,
            ticks = me.records;

        let begin = 0,
            end = ticks.length - 1,
            middle, tick, tickStart, tickEnd;

        // Quickly eliminate out of range dates or if we have not been set up with a time range yet
        if (!ticks.length || date < ticks[0].startDate || date > ticks[end].endDate) {
            return -1;
        }
        if (me.isContinuous) {
            // TODO: This is the code from ExtScheduler, it is a calculation without iteration so it should perform better,
            //  we should consider using it...
            // if (date - ticks[0].startDate === 0) return this.visibleTickStart;
            // if (date - ticks[end].endDate === 0) return this.visibleTickEnd;
            //
            // const { adjustedStart, adjustedEnd }     = this;
            //
            // let tickIndex       = Math.floor(ticks.length * (date - adjustedStart) / (adjustedEnd - adjustedStart));
            //
            // // for the date == adjustedEnd case
            // if (tickIndex > end) {
            //     tickIndex = end;
            // }
            //
            // const tickStart           = tickIndex === 0 ? adjustedStart : ticks[tickIndex].startDate;
            // const tickEnd             = tickIndex === end ? adjustedEnd : ticks[tickIndex].endDate;
            //
            // tick                = tickIndex + (date - tickStart) / (tickEnd - tickStart);
            //
            // // in case of `autoAdjust : false` the actual visible timespan starts not from 0 tick coordinate, but
            // // from `visibleTickStart` coordinate, this check generally repeats the "quick bailout" check in the begining of the method,
            // // but still
            // if (tick < this.visibleTickStart || tick > this.visibleTickEnd) {
            //     return -1;
            // }
            //
            // return tick;
            // Chop tick cache in half until we find a match
            while (begin < end) {
                middle = (begin + end + 1) >> 1;
                if (date > ticks[middle].endDate) {
                    begin = middle + 1;
                }
                else if (date < ticks[middle].startDate) {
                    end = middle - 1;
                }
                else {
                    begin = middle;
                }
            }
            tick = ticks[begin];
            tickStart = tick.startDate;
            tickEnd = tick.endDate;

            // Part way though, calculate the fraction
            if (date > tickStart) {
                begin += (date - tickStart) / (tickEnd - tickStart);
            }
            return Math.min(Math.max(begin, me.visibleTickStart), me.visibleTickEnd);
        }
        else {
            for (let i = 0; i <= end; i++) {
                tickEnd         = ticks[i].endDate;

                if (date <= tickEnd) {
                    tickStart   = ticks[i].startDate;

                    // date < tickStart can occur in filtered case
                    tick = i + (date > tickStart ? (date - tickStart) / (tickEnd - tickStart) : 0);

                    return tick;
                }
            }
        }

    }

    /**
     * Gets the time represented by a tick "coordinate".
     * @param {Number} tick the tick "coordinate"
     * @param {String} [roundingMethod] The rounding method to use
     * @return {Date} The date to represented by the tick "coordinate", or null if invalid.
     */
    getDateFromTick(tick, roundingMethod) {
        const me = this;

        if (tick === me.visibleTickEnd) {
            return me.endDate;
        }

        const wholeTick = Math.floor(tick),
            fraction  = tick - wholeTick,
            t         = me.getAt(wholeTick);

        if (!t) {
            return null;
        }

        let start = wholeTick === 0 ? me.adjustedStart : t.startDate,
            // if we've filtered timeaxis using filterBy, then we cannot trust to adjustedEnd property and should use tick end
            end   = (wholeTick === me.count - 1) && me.isContinuous ? me.adjustedEnd : t.endDate,
            date  = DateHelper.add(start, fraction * (end - start), 'millisecond');

        if (roundingMethod) {
            date = me[roundingMethod + 'Date'](date);
        }

        return date;
    }

    /**
     * Returns the ticks of the timeaxis in an array of objects with a "start" and "end" date.
     * @return {Object[]} the ticks on the scale
     */
    get ticks() {
        return this.records;
    }

    /**
     * Caches ticks and start/end dates for faster processing during rendering of events.
     * @private
     */
    updateTickCache(onlyStartEnd = false) {
        const me = this;

        if (me.count) {
            me._start = me.first.startDate;
            me._end = me.last.endDate;
            me._startMS = me.startDate.getTime();
            me._endMS = me.endDate.getTime();
        }
        else {
            me._start = me._end = me._startMs = me._endMS = null;
        }

        // onlyStartEnd is true prior to clearing filters, to get start and end dates correctly during that process.
        // No point in filling tickCache yet in that case, it will be done after the filters are cleared
        if (!onlyStartEnd) {
            me.tickCache = {};
            me.forEach((tick, i) => me.tickCache[tick.startDate.getTime()] = i);
        }
    }

    //endregion

    //region Axis

    /**
     * Returns true if the passed date is inside the span of the current time axis.
     * @param {Date} date The date to query for
     * @return {Boolean} true if the date is part of the timeaxis
     */
    dateInAxis(date, inclusiveEnd = false) {
        const me        = this,
            axisStart = me.startDate,
            axisEnd   = me.endDate;

        // Date is between axis start/end and axis is not continuous - need to perform better lookup
        if (me.isContinuous) {
            return inclusiveEnd ? DateHelper.betweenLesserEqual(date, axisStart, axisEnd) : DateHelper.betweenLesser(date, axisStart, axisEnd);
        }
        else {
            let length = me.getCount(), tickStart, tickEnd, tick;

            for (let i = 0; i < length; i++) {
                tick = me.getAt(i);
                tickStart = tick.startDate;
                tickEnd = tick.endDate;

                if ((inclusiveEnd && date <= tickEnd) || (!inclusiveEnd && date < tickEnd)) {
                    return date >= tickStart;
                }
            }
        }

        return false;
    }

    /**
     * Returns true if the passed timespan is part of the current time axis (in whole or partially).
     * @param {Date} start The start date
     * @param {Date} end The end date
     * @return {Boolean} true if the timespan is part of the timeaxis
     */
    timeSpanInAxis(start, end) {
        const me = this;

        if (end.getTime() === start.getTime()) {
            return this.dateInAxis(start, true);
        }

        if (me.isContinuous) {
            return DateHelper.intersectSpans(start, end, me.startDate, me.endDate);
        }

        return (start < me.startDate && end > me.endDate) || me.getTickFromDate(start) !== me.getTickFromDate(end);
    }

    // Accepts a TimeSpan model (uses its cached MS values to be a bit faster during rendering)
    isTimeSpanInAxis(timeSpan) {
        const me    = this,
            startMS = timeSpan.startDateMS,
            endMS   = timeSpan.endDateMS;

        // only consider fully scheduled ranges
        if (!startMS || !endMS) return false;

        if (endMS === startMS) {
            return this.dateInAxis(timeSpan.startDate, true);
        }

        if (me.isContinuous) {
            return endMS > me.startMS && startMS < me.endMS;
        }

        return (startMS < me.startMS && endMS > me.endMS) || me.getTickFromDate(timeSpan.startDate) !== me.getTickFromDate(timeSpan.endDate);
    }

    //endregion

    //region Iteration

    /**
     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
     * @internal
     * @param {String} unit The unit to use when iterating over the timespan
     * @param {Number} increment The increment to use when iterating over the timespan
     * @param {Function} iteratorFn The function to call
     * @param {Object} [thisObj] `this` reference for the function
     */
    forEachAuxInterval(unit, increment = 1, iteratorFn, thisObj = this) {
        let end = this.endDate,
            dt  = this.startDate,
            i   = 0,
            intervalEnd;

        if (dt > end) throw new Error('Invalid time axis configuration');

        while (dt < end) {
            intervalEnd = DateHelper.min(DateHelper.getNext(dt, unit, increment, this.weekStartDay), end);
            iteratorFn.call(thisObj, dt, intervalEnd, i);
            dt = intervalEnd;
            i++;
        }
    }

    //endregion
}
TimeAxis._$name = 'TimeAxis';

/**
 * @module Scheduler/feature/ColumnLines
 */

/**
 * Displays column lines for ticks, with a different styling for major ticks (by default they are darker). If this
 * feature is disabled, no lines are shown. If it's enabled, line are shown for the tick level which is set in current
 * ViewPreset. Please see {@link Scheduler.preset.ViewPreset#field-columnLinesFor} config for details.
 *
 * The lines are drawn to a canvas, converted to an image and used as background in the schedulers background canvas.
 * In certain scenarios, major column lines are drawn as divs.
 *
 * The color and style of the lines are determined by extracting the values for `border-left-color` and
 * `border-left-style` (solid, dashed or dotted are supported) from the css rules for `.b-column-line` and
 * `.b-column-line-major`.
 *
 * This feature is **enabled** by default
 *
 * @extends Core/mixin/InstancePlugin
 * @demo Scheduler/basic
 * @externalexample scheduler/ColumnLines.js
 */
class ColumnLines extends InstancePlugin {
    //region Config

    static get $name() {
        return 'ColumnLines';
    }

    static get properties() {
        return {
            tickColor      : '#e6e6e6',
            majorTickColor : '#999',
            tickStyle      : 'solid',
            majorTickStyle : 'solid'
        };
    }

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            after : ['render', 'updateCanvasSize']
        };
    }

    //endregion

    //region Init & destroy

    construct(client, config) {
        const me = this;

        client.useBackgroundCanvas = true;

        super.construct(client, config);

        me.timeAxisViewModel = client.timeAxisViewModel;

        client.on({
            theme   : 'onThemeChange',
            thisObj : me
        });
    }

    doDestroy() {
        this.timeAxisViewModelDetatcher && this.timeAxisViewModelDetatcher();
        super.doDestroy();
    }

    doDisable(disable) {
        if (!this.isConfiguring) {
            if (disable) {
                DomHelper.removeEachSelector(this.client.backgroundCanvas, '.b-column-line-major');
                this.client.backgroundCanvas.style.backgroundImage = 'none';
            }
            else {
                this.drawLines();
            }
        }

        super.doDisable(disable);
    }

    //endregion

    //region Draw

    /**
     * Reads lines colors from temporary element
     * @private
     */
    getColorsFromCSS() {
        const me = this;

        // Create two fake column lines. But only do it once per app.
        if (!me.GotColors) {
            const element      = DomHelper.createElement({
                    style  : 'position: absolute; visibility: hidden',
                    html   : '<div class="b-column-line"></div><div class="b-column-line-major"></div>',
                    parent : document.body
                }),
                tickColor      = DomHelper.getStyleValue(element.firstElementChild, 'border-left-color'),
                majorColor     = DomHelper.getStyleValue(element.lastElementChild, 'border-left-color'),
                tickStyle      = DomHelper.getStyleValue(element.firstElementChild, 'border-left-style'),
                majorTickStyle = DomHelper.getStyleValue(element.lastElementChild, 'border-left-style');

            if (tickColor) {
                me.tickColor = tickColor;
            }

            if (majorColor) {
                me.majorTickColor = majorColor;
            }

            if (tickStyle) {
                me.tickStyle = tickStyle;
            }

            if (majorTickStyle) {
                me.majorTickStyle = majorTickStyle;
            }

            element.remove();
            me.GotColors = true;
        }
    }

    onThemeChange() {
        this.GotColors = false;
        this.render();
    }

    /**
     * Draw lines when scheduler/gantt is rendered.
     * @private
     */
    render() {
        this.getColorsFromCSS();
        this.drawLines();
    }

    /**
     * Draw column lines to a offscreen canvas, convert to base64 and use as background image.
     * @private
     */
    drawLines() {
        // Early bailout for timeaxis without start date
        if (!this.client.timeAxis.startDate) {
            return;
        }

        // We cannot rely on timeAxisViewModel because rendered header may not include full top header.
        // This means we should generate whole top level tick and then iterate over ticks, calculating lines position
        // depending on header config
        const
            me            = this,
            { client }    = me,
            { timeAxis }  = client,
            axisStart     = timeAxis.startDate,
            viewModel     = client.timeAxisViewModel,
            tickSize      = viewModel.tickSize,
            element       = client.backgroundCanvas,
            canvas         = document.createElement('canvas'),
            ctx            = canvas.getContext('2d'),
            linesForLevel = viewModel.columnLinesFor,
            // header to draw lines for
            targetHeader  = viewModel.headers[linesForLevel],
            headers       = viewModel.headers,
            // header which is used to draw major lines
            upperHeader   = headers[headers.indexOf(targetHeader) - 1] || headers[0],
            // header defining ticks
            lowerHeader   = headers[headers.length - 1],
            // when unit is year we should use 1 as increment
            startDate     = timeAxis.floorDate(axisStart, false, upperHeader.unit, upperHeader.unit === 'year' ? 1 : upperHeader.increment || 1),
            endDate       = DateHelper.getNext(startDate, upperHeader.unit, upperHeader.increment || 1, timeAxis.weekStartDay),
            // we rendered one upper header and need to calculate how many ticks fit in it
            ticksInHeader  = Math.round(DateHelper.getDurationInUnit(startDate, endDate, lowerHeader.unit)) / (lowerHeader.increment || 1),
            nbrLinesToDraw = Math.round(DateHelper.getDurationInUnit(startDate, endDate, targetHeader.unit)) / (targetHeader.increment || 1),
            // shows how many ticks should we skip before drawing next line
            ratio          = ticksInHeader / nbrLinesToDraw;

        if (client.isHorizontal) {
            if (axisStart) {
                const
                    doUnitsAlign   = headers.length > 1 && DateHelper.doesUnitsAlign(upperHeader.unit, targetHeader.unit),
                    offsetDate     = doUnitsAlign ? startDate : timeAxis.floorDate(axisStart, false, targetHeader.unit, targetHeader.increment),
                    // TODO: isContinuous check solved the issue I was seeing but not very generic
                    offset         = !timeAxis.isContinuous ? 0 : DateHelper.getDurationInUnit(offsetDate, axisStart, lowerHeader.unit, true) / timeAxis.increment * tickSize,
                    // this is position from left side of the canvas to draw first line, otherwi
                    startPos       = 10,
                    height         = 20;

                DomHelper.removeEachSelector(element, '.b-column-line-major');

                let isMajor = false,
                    majorHeaderIsRegular = true;

                if (targetHeader !== upperHeader && doUnitsAlign && lowerHeader.unit === 'day' &&
                    DateHelper.compareUnits(upperHeader.unit, 'month') !== -1) {
                    // This condition means, that major lines are irregular, e.g. when lower level is days and upper is
                    // months. Since months have different duration, we cannot safely repeat images
                    majorHeaderIsRegular = false;
                    timeAxis.forEachAuxInterval(upperHeader.unit, upperHeader.increment, (start, end) => {
                        DomHelper.append(element, {
                            tag       : 'div',
                            className : 'b-column-line-major',
                            style     : `left:${viewModel.getPositionFromDate(end) - 1}px;`
                        });
                    });
                }

                // hack for FF to not crash when trying to create too wide canvas.
                canvas.width = Math.min(ticksInHeader * 2 * tickSize, 32767);
                canvas.height = height;
                ctx.translate(-0.5, -0.5);
                ctx.lineWidth = 2;

                for (let i = 0; i < nbrLinesToDraw; i++) {
                    // Only first interval may be major
                    if (i === 0) {
                        // Filtered time axis should not have any major lines
                        isMajor = upperHeader !== targetHeader && doUnitsAlign && majorHeaderIsRegular && timeAxis.isContinuous;
                    }
                    else {
                        isMajor = false;
                    }

                    const tickStyle = (isMajor && me.majorTickStyle) || (!isMajor && me.tickStyle);
                    if (tickStyle !== 'solid') {
                        switch (tickStyle) {
                            case 'dashed':
                                ctx.setLineDash([6, 4]);
                                break;
                            case 'dotted':
                                ctx.setLineDash([2, 3]);
                                break;
                        }
                    }

                    ctx.beginPath();
                    ctx.strokeStyle = isMajor ? me.majorTickColor : me.tickColor;

                    // draw ticks
                    ctx.moveTo(i * ratio * tickSize * 2 + startPos - 1, 0);
                    ctx.lineTo(i * ratio * tickSize * 2 + startPos - 1, height + 2);
                    ctx.stroke();
                }

                // use as background image
                element.style.backgroundImage = `url(${canvas.toDataURL()})`;
                element.style.backgroundSize = `${canvas.width / 2}px`;
                element.style.backgroundPositionX = `${-(startPos / 2 + offset)}px`;
            }
        }
        else {
            // hack for FF to not crash when trying to create too wide canvas.
            canvas.width = client.timeAxisColumn.resourceColumns.columnWidth * 2;
            canvas.height = 2;
            ctx.translate(-0.5, -0.5);
            ctx.lineWidth = 2;

            if (axisStart) {

                DomHelper.removeEachSelector(element, '.b-column-line-major');

                // Major lines always as divs to not get so large image
                if (targetHeader !== upperHeader) {
                    timeAxis.forEachAuxInterval(upperHeader.unit, upperHeader.increment, (start, end) => {
                        DomHelper.append(element, {
                            tag       : 'div',
                            className : 'b-column-line-major',
                            style     : `top:${viewModel.getPositionFromDate(end) - 1}px;`
                        });
                    });
                }

                if (me.tickStyle !== 'solid') {
                    switch (me.tickStyle) {
                        case 'dashed':
                            ctx.setLineDash([6, 4]);
                            break;
                        case 'dotted':
                            ctx.setLineDash([2, 3]);
                            break;
                    }
                }

                const height = ratio * tickSize * 2;

                canvas.height = height;

                ctx.beginPath();
                ctx.strokeStyle = me.tickColor;
                ctx.lineWidth = 2;

                // draw ticks
                ctx.moveTo(0,                height - 1);
                ctx.lineTo(canvas.width + 2, height - 1);
                ctx.stroke();
            }

            ctx.beginPath();
            ctx.strokeStyle = me.tickColor;

            // draw ticks
            ctx.moveTo(canvas.width - 1, 0);
            ctx.lineTo(canvas.width - 1, canvas.height + 2);
            ctx.stroke();

            // use as background image
            element.style.backgroundImage = `url(${canvas.toDataURL()})`;
            element.style.backgroundSize = `${canvas.width / 2}px`;
            element.style.backgroundPositionX = '0';
        }
    }

    //endregion

    //region Events

    /**
     * Redraw lines when time axis changes.
     * @private
     */
    updateCanvasSize() {
        if (!this.disabled) {
            this.drawLines();
        }
    }

    //endregion
}

ColumnLines._$name = 'ColumnLines'; GridFeatureManager.registerFeature(ColumnLines, true, ['Scheduler', 'Gantt']);

/**
 * @module Scheduler/feature/mixin/DependencyCreation
 */

// TODO: refactor this class using StateChart utility to be implemented in Core/util/StateChart.js or XState library if allowed to be used
/**
 * Mixin for Dependencies feature that handles dependency creation (drag & drop from terminals which are shown on hover).
 * Requires {@link Core.mixin.Delayable}, {@link Scheduler.data.api.DataAPI} to be mixed in alongside.
 *
 * @mixin
 */
var DependencyCreation = Target => class DependencyCreation extends (Target || Base) {
    //region Config

    static get defaultConfig() {
        return {
            /**
             * `false` to not show a tooltip while creating a dependency
             * @config {Boolean}
             * @default
             */
            showCreationTooltip : true,

            /**
             * A tooltip config object that will be applied to the dependency creation tooltip
             * @config {Object}
             */
            creationTooltip : null,

            /**
             * CSS class used for terminals
             * @config {String}
             * @default
             */
            terminalCls : 'b-sch-terminal',

            /**
             * Where (at events borders) to display terminals
             * @config {String[]}
             * @default
             */
            terminalSides : ['left', 'top', 'right', 'bottom'],

            /**
             * Set to `false` to not allow creating dependencies
             * @config {Boolean}
             * @default
             */
            allowCreate : true
        };
    }

    //endregion

    //region Init & destroy

    construct(view, config) {
        super.construct(view, config);

        const me = this;

        me.view = view;
        me.eventName = view.scheduledEventName;

        me.view.on('readOnly', () => me.updateCreateListeners());

        me.updateCreateListeners();
    }

    doDestroy() {
        const me = this;

        me.detachListeners('view');

        me.creationData = null;

        me.mouseDetacher && me.mouseDetacher();
        me.creationTooltip && me.creationTooltip.destroy();

        super.doDestroy();
    }

    updateCreateListeners() {
        const me = this;

        if (!me.view) {
            return;
        }

        me.detachListeners('view');

        if (me.isCreateAllowed) {
            me.view.on({
                name                          : 'view',
                [`${me.eventName}mouseenter`] : 'onTimeSpanMouseEnter',
                [`${me.eventName}mouseleave`] : 'onTimeSpanMouseLeave',
                thisObj                       : me
            });
        }
    }

    set allowCreate(value) {
        this._allowCreate = value;

        this.updateCreateListeners();
    }

    get allowCreate() {
        return this._allowCreate;
    }

    get isCreateAllowed() {
        return this.allowCreate && !this.view.readOnly && !this.disabled;
    }
    //endregion

    //region Events

    /**
     * Show terminals when mouse enters event/task element
     * @private
     */
    onTimeSpanMouseEnter(event) {
        const
            record  = event[`${this.eventName}Record`],
            element = event[`${this.eventName}Element`];
        this.showTerminals(record, DomHelper.down(element, event.source.eventInnerSelector));
    }

    /**
     * Hide terminals when mouse leaves event/task element
     * @private
     */
    onTimeSpanMouseLeave(event) {
        const
            me      = this,
            element = event[`${me.eventName}Element`];

        if (!me.creationData || !DomHelper.isDescendant(element, me.creationData.sourceTerminal.parentElement)) {
            me.hideTerminals(element);
        }
    }

    /**
     * Remove hover styling when mouse leaves terminal. Also hides terminals when mouse leaves one it and not creating a dependency.
     * @private
     */
    onTerminalMouseOut(event) {
        const me = this,
            el = DomHelper.up(event.target, me.view.eventSelector);

        if (!DomHelper.isDescendant(el, me.showingTerminalsFor) && (!me.creationData || el !== me.creationData.sourceTerminal.parentElement)) {
            me.hideTerminals(el);
            me.view.unhover(event);
        }
    }

    /**
     * Start creating a dependency when mouse is pressed over terminal
     * @private
     */
    onTerminalMouseDown(event) {
        const me = this;

        // ignore non-left button clicks
        if (event.button === 0 && !me.creationData) {
            const
                view                   = me.view,
                timeAxisSubGridElement = view.timeAxisSubGridElement,
                terminal               = event.target,
                element                = terminal.parentElement.closest(view.eventSelector),
                viewBounds             = Rectangle.from(view.element, document.body);

            event.preventDefault();
            event.stopPropagation();

            me.creationData = {
                source         : view.resolveTimeSpanRecord(element),
                sourceTerminal : terminal,
                startPoint     : Rectangle.from(terminal, timeAxisSubGridElement).center,
                startX         : event.pageX - viewBounds.x + view.scrollLeft,
                startY         : event.pageY - viewBounds.y + view.scrollTop,
                valid          : false
            };

            if (view.resolveResourceRecord) {
                me.creationData.sourceResource = view.resolveResourceRecord(element);
            }

            me.mouseDetacher = EventHelper.on({
                mouseup : {
                    element : document.body,
                    handler : 'onMouseUp'
                },
                mousemove : {
                    element : timeAxisSubGridElement,
                    handler : 'onMouseMove'
                },
                thisObj : me
            });
        }
    }

    /**
     * Update connector line showing dependency between source and target when mouse moves. Also check if mouse is over a valid
     * target terminal
     * @private
     */
    onMouseMove(event) {
        const
            me                            = this,
            { view, creationData : data } = me,
            viewBounds                    = Rectangle.from(view.element, document.body),
            deltaX                        = (event.pageX - viewBounds.x + view.scrollLeft) - data.startX,
            deltaY                        = (event.pageY - viewBounds.y + view.scrollTop) - data.startY,
            length                        = Math.round(Math.sqrt(deltaX * deltaX + deltaY * deltaY)) - 3,
            angle                         = Math.atan2(deltaY, deltaX);

        let { connector } = me;

        if (!connector) {
            if (this.onRequestDragCreate() === false) {
                return;
            }
            connector = me.connector;
        }

        connector.style.width     = `${length}px`;
        connector.style.transform = `rotate(${angle}rad)`;

        me.lastMouseMoveEvent = event;
    }

    onRequestDragCreate() {
        const
            me                            = this,
            { view, creationData : data } = me;

        /**
         * Fired on the owning Scheduler/Gantt before a dependency creation drag operation starts. Return false to prevent it
         * @event beforeDependencyCreateDrag
         * @param {Object} data
         * @param {Scheduler.model.TimeSpan} data.source The source task
         */
        if (view.trigger('beforeDependencyCreateDrag', { data }) === false) {
            me.abort();
            return false;
        }

        view.element.classList.add('b-creating-dependency');

        me.connector = me.createConnector(data.startPoint.x, data.startPoint.y);

        /**
         * Fired on the owning Scheduler/Gantt when a dependency creation drag operation starts
         * @event dependencyCreateDragStart
         * @param {Object} data
         */
        view.trigger('dependencyCreateDragStart', { data });

        if (me.showCreationTooltip) {
            me.creationTooltip = me.creationTooltip || me.createDragTooltip();

            me.creationTooltip.disabled = false;
            me.creationTooltip.show();
        }

        view.scrollManager.startMonitoring({
            element  : view.timeAxisSubGridElement,
            callback : () => me.lastMouseMoveEvent && me.onMouseMove(me.lastMouseMoveEvent),
            thisObj  : me
        });
    }

    onOverTargetTerminal(event) {
        const
            me     = this,
            { target } = event,
            { view, creationData : data } = me;

        const { connector } = me;

        if (!(data.valid instanceof Promise)) {
            if (target !== data.sourceTerminal) {
                if (target !== data.targetTerminal) {
                    data.targetTerminal = target;
                    data.target = view.resolveTimeSpanRecord(target);

                    if (view.resolveResourceRecord) {
                        data.targetResource = view.resolveResourceRecord(target);
                    }

                    const
                        fromSide = data.sourceTerminal.dataset.side,
                        toSide = data.targetTerminal.dataset.side,
                        updateValidity = valid => {
                            if (!me.isDestroyed) {
                                data.valid = valid;
                                target.classList.add(valid ? 'b-valid' : 'b-invalid');
                                connector.classList.add(valid ? 'b-valid' : 'b-invalid');

                                /**
                                 * Fired on the owning Scheduler/Gantt when asynchronous dependency validation completes
                                 * @event dependencyValidationComplete
                                 * @param {Object} data
                                 */
                                view.trigger('dependencyValidationComplete', { data });
                            }
                        };

                    let type;

                    // NOTE: Top/Bottom sides are not taken into account due to
                    //       scheduler doesn't check for type value anyway, whereas
                    //       gantt will reject any other dependency types undefined in
                    //       DependencyBaseModel.Type enumeration.
                    switch (true) {
                        case fromSide === 'left' && toSide === 'left':
                            type = DependencyBaseModel.Type.StartToStart;
                            break;
                        case fromSide === 'left' && toSide === 'right':
                            type = DependencyBaseModel.Type.StartToEnd;
                            break;
                        case fromSide === 'right' && toSide === 'left':
                            type = DependencyBaseModel.Type.EndToStart;
                            break;
                        case fromSide === 'right' && toSide === 'right':
                            type = DependencyBaseModel.Type.EndToEnd;
                            break;
                    }

                    /**
                     * Fired on the owning Scheduler/Gantt when asynchronous dependency validation starts
                     * @event dependencyValidationStart
                     * @param {Object} data
                     */
                    view.trigger('dependencyValidationStart', { data });

                    data.valid = me.dataApi.isValidDependencyToCreate({
                        type,
                        sourceEvent     : data.source,
                        targetEvent     : data.target,
                        dependencyStore : me.dependencyStore
                    });

                    // Promise is returned when using the engine
                    if (data.valid instanceof Promise) {
                        data.valid.then(updateValidity);
                    }
                    else {
                        updateValidity(data.valid);
                    }
                }
            }
            else {
                connector.classList.remove('b-valid');
                connector.classList.remove('b-invalid');
            }
        }
    }

    /**
     * Create a new dependency if mouse release over valid terminal. Hides connector
     * @private
     */
    onMouseUp(event) {
        const
            me     = this,
            data   = me.creationData,
            target = event.target;

        me.abort();

        const doDependencyDrop = async() => {
            data.targetTerminal = event.target;

            const result = me.createDependency(data);

            if (result instanceof Promise) {
                await result;
            }

            //data.valid = true; // TODO: remove this line if tests are fine

            /**
             * Fired on the owning Scheduler/Gantt when a dependency drag creation operation succeeds
             * @event dependencyCreateDrop
             * @param {Object} data
             */
            me.view.trigger('dependencyCreateDrop', { data });
        };

        const doAfterDependencyDrop = (data) => {
            /**
             * Fired on the owning Scheduler/Gantt after a dependency drag creation operation finished, no matter to outcome
             * @event afterDependencyCreateDrop
             * @param {Object} data
             */
            me.view.trigger('afterDependencyCreateDrop', { data });
        };

        // TODO: should call finalize and allow user to hook it (as in EventDrag, EventResize)
        if (data.valid && target.matches(`.${me.terminalCls}`)) {

            if (data.valid instanceof Promise) {

                data.valid.then((valid) => {

                    data.valid = valid;

                    if (valid) {
                        doDependencyDrop().then(() => doAfterDependencyDrop(data));
                    }
                    else {
                        doAfterDependencyDrop(data);
                    }

                });
            }
            else {
                doDependencyDrop().then(() => doAfterDependencyDrop(data));
            }
        }
        else {
            data.valid = false;
            doAfterDependencyDrop(data);
        }
    }

    /**
     * Aborts dependency creation, removes proxy and cleans up listeners
     */
    abort() {
        const me     = this,
            { view, creationData } = me;

        // Remove terminals from source and target events.
        if (creationData) {
            const { source, sourceResource, target, targetResource } = creationData;

            if (source) {
                const el = view.getElementFromEventRecord(source, sourceResource);
                if (el) {
                    me.hideTerminals(el);
                }
            }
            if (target) {
                const el = view.getElementFromEventRecord(target, targetResource);
                if (el) {
                    me.hideTerminals(el);
                }
            }
        }

        if (me.creationTooltip) {
            me.creationTooltip.disabled = true;
        }

        me.creationData = me.lastMouseMoveEvent = null;

        me.mouseDetacher && me.mouseDetacher();

        me.removeConnector();
    }

    //endregion

    //region Connector

    /**
     * Creates a connector line that visualizes dependency source & target
     * @private
     */
    createConnector(x, y) {
        const me = this,
            view = me.view;

        me.connector = DomHelper.createElement({
            parent    : view.timeAxisSubGridElement,
            className : `${me.baseCls}-connector`,
            style     : `left:${x}px;top:${y}px`
        });

        view.element.classList.add('b-creating-dependency');

        return me.connector;
    }

    createDragTooltip() {
        const
            me   = this,
            view = me.view;

        return me.creationTooltip = new Tooltip(Object.assign({
            id                     : `${view.id}-dependency-drag-tip`,
            cls                    : 'b-sch-dependency-creation-tooltip',
            loadingMsg             : '',
            autoShow               : true,
            anchorToTarget         : false,
            // Keep tip visible until drag drop operation is finalized
            forSelector            : '.b-sch-terminal',
            trackMouse             : true,
            // Do not constrain at all, want it to be able to go outside of the viewport to not get in the way
            constrainTo            : null,
            getHtml                : ({ tip, event }) => {
                if (me.creationData) {
                    event && me.onOverTargetTerminal(event);

                    return me.generateTooltipContent(tip, me.creationData);
                }
            },
            header                 : {
                dock : 'right'
            },

            listeners : {
                pointerout : ({ source : tip }) => {
                    const data = me.creationData;

                    data.target = data.targetTerminal = null;
                    data.valid = false;

                    tip.html = tip.getHtml({ tip });
                    return false;
                },

                show : ({ source : tip }) => {
                    // Show initial content immediately
                    tip.html = tip.getHtml({ tip });
                }
            }
        }, me.creationTooltip || {}));
    }

    /**
     * Remove connector
     * @private
     */
    removeConnector(callback) {
        const me = this,
            { connector, view } = me;

        if (connector) {
            connector.classList.add('b-removing');
            connector.style.width = '0';
            me.setTimeout(() => {
                connector.remove();
                me.connector = null;
                if (callback) {
                    callback.call(me);
                }
            }, 200);
        }

        view.element.classList.remove('b-creating-dependency');
        me.creationTooltip && me.creationTooltip.hide();

        view.scrollManager.stopMonitoring(view.timeAxisSubGridElement);
    }

    //endregion

    //region Terminals

    /**
     * Show terminals for specified event at sides defined in #terminalSides.
     * @param {Scheduler.model.TimeSpan} timeSpanRecord Event/task to show terminals for
     * @param {HTMLElement} element Event/task element
     */
    showTerminals(timeSpanRecord, element) {
        const me  = this;

        if (!me.isCreateAllowed) {
            return;
        }

        const
            cls = me.terminalCls,
            terminalsVisibleCls = `${cls}s-visible`;

        // We operate on the event bar, not the wrap
        element = DomHelper.down(element, me.view.eventInnerSelector);

        // bail out if terminals already shown or if view is readonly
        // do not draw new terminals if we are resizing event
        if (!element.classList.contains(terminalsVisibleCls) && !this.view.element.classList.contains('b-resizing-event') && !me.view.readOnly) {

            // create terminals for desired sides
            me.terminalSides.forEach(side => {
                const terminal = DomHelper.createElement({
                    parent    : element,
                    className : `${cls} ${cls}-${side}`,
                    dataset   : {
                        side,
                        feature : true
                    }
                });

                terminal.detacher = EventHelper.on({
                    element   : terminal,
                    mouseout  : 'onTerminalMouseOut',
                    mousedown : {
                        handler : 'onTerminalMouseDown',
                        capture : true
                    },
                    thisObj : me
                });
            });

            element.classList.add(terminalsVisibleCls);
            timeSpanRecord.cls.add(terminalsVisibleCls);

            me.showingTerminalsFor = element;
        }
    }

    /**
     * Hide terminals for specified event
     * @param {HTMLElement} eventElement Event element
     */
    hideTerminals(eventElement) {
        // remove all terminals
        const
            me                  = this,
            eventParams         = me.client.getTimeSpanMouseEventParams(eventElement),
            timeSpanRecord      = eventParams[`${this.eventName}Record`],
            terminalsVisibleCls = `${me.terminalCls}s-visible`;

        DomHelper.forEachSelector(eventElement, `.${me.terminalCls}`, terminal => {
            terminal.detacher && terminal.detacher();
            terminal.remove();
        });

        DomHelper.down(eventElement, me.view.eventInnerSelector).classList.remove(terminalsVisibleCls);
        timeSpanRecord.cls.remove(terminalsVisibleCls);

        me.showingTerminalsFor = null;
    }

    //endregion

    //region Dependency creation

    /**
     * Create a new dependency from source terminal to target terminal
     * @internal
     */
    createDependency(data) {
        const
            source   = data.source,
            target   = data.target,
            fromSide = data.sourceTerminal.dataset.side,
            toSide   = data.targetTerminal.dataset.side,
            type     = (fromSide === 'left' ? 0 : 2) + (toSide === 'right' ? 1 : 0);

        return this.dataApi.createDependency({
            sourceEvent     : source,
            targetEvent     : target,
            dependencyStore : this.dependencyStore,
            type,
            fromSide,
            toSide
        });
    }

    //endregion

    //region Tooltip

    /**
     * Update dependency creation tooltip
     * @private
     */
    generateTooltipContent(tip, data) {
        const me      = this;
        let { valid } = data;

        Object.assign(data, {
            fromText : data.source.name,
            toText   : data.target ? data.target.name : '',
            fromSide : data.sourceTerminal.dataset.side,
            toSide   : data.targetTerminal ? data.targetTerminal.dataset.side : ''
        });

        let tipTitleIconClsSuffix,
            tipTitleText;

        // Promise, when using engine
        if (valid instanceof Promise) {
            tip.element.classList.remove('b-invalid');
            tip.element.classList.add('b-checking');
            tipTitleIconClsSuffix = 'checking';
            tipTitleText          = me.L('Checking');

            return new Promise(resolve => valid.then(valid => {
                    data.valid = valid;

                    if (!tip.isDestroyed) {
                        resolve(me.generateTooltipContent(tip, data));
                    }
                })
            );
        }
        // Valid
        else if (valid === true) {
            tip.element.classList.remove('b-invalid');
            tip.element.classList.remove('b-checking');
            tipTitleIconClsSuffix = 'valid';
            tipTitleText = me.L('valid');
        }
        // Invalid
        else {
            tip.element.classList.remove('b-checking');
            tip.element.classList.add('b-invalid');
            tipTitleIconClsSuffix = 'invalid';
            tipTitleText          = me.L('invalid');
        }

        tip.titleElement.innerHTML = `<i class="b-icon b-icon-${tipTitleIconClsSuffix}"></i>${tipTitleText}`;

        return `<table class="b-sch-dependency-creation-tooltip">
                        <tr><td>${me.L('from')}: </td><td>${data.fromText}</td><td><div class="b-sch-box b-${data.fromSide}"></div></td></tr>
                        <tr><td>${me.L('to')}: </td><td>${data.toText}</td><td><div class="b-sch-box b-${data.toSide}"></div></td></tr>
                    </table>`;
    }

    //endregion
};

/**
 * @module Scheduler/util/RectangularPathFinder
 */

/**
 * Class which finds rectangular path, i.e. path with 90 degrees turns, between two boxes.
 * @private
 */
class RectangularPathFinder extends Base {
    static get defaultConfig() {
        return {
            /**
             * Default start connection side: 'left', 'right', 'top', 'bottom'
             * @config {String|Boolean}
             * @default
             */
            startSide : 'right',

            /**
             * Default start arrow size in pixels
             * @config {Number}
             * @default
             */
            startArrowSize : 0,

            /**
             * Default start arrow staff size in pixels
             * @config {Number}
             * @default
             */
            startArrowMargin : 12,

            /**
             * Default starting connection point shift from box's arrow pointing side middle point
             * @config {Number}
             * @default
             */
            startShift : 0,

            /**
             * Default end arrow pointing direction, possible values are: 'left', 'right', 'top', 'bottom'
             * @config {String|Boolean}
             * @default
             */
            endSide : 'left',

            /**
             * Default end arrow size in pixels
             * @config {Number}
             * @default
             */
            endArrowSize : 0,

            /**
             * Default end arrow staff size in pixels
             * @config {Number}
             * @default
             */
            endArrowMargin : 12,

            /**
             * Default ending connection point shift from box's arrow pointing side middle point
             * @config {Number}
             * @default
             */
            endShift : 0,

            /**
             * Start / End box vertical margin, the amount of pixels from top and bottom line of a box where drawing
             * is prohibited
             * @config {Number}
             * @default
             */
            verticalMargin : 2,

            /**
             * Start / End box horizontal margin, the amount of pixels from left and right line of a box where drawing
             * @config {Number}
             * @default
             */
            horizontalMargin : 5,

            /**
             * Other rectangular areas (obstacles) to search path through
             * @config {Object[]}
             * @default
             */
            otherBoxes : null
        };
    }

    /**
     * Returns list of horizontal and vertical segments connecting two boxes
     * <pre>
     *    |    | |  |    |       |
     *  --+----+----+----*-------*---
     *  --+=>Start  +----*-------*--
     *  --+----+----+----*-------*--
     *    |    | |  |    |       |
     *    |    | |  |    |       |
     *  --*----*-+-------+-------+--
     *  --*----*-+         End <=+--
     *  --*----*-+-------+-------+--
     *    |    | |  |    |       |
     * </pre>
     * Path goes by lines (-=) and turns at intersections (+), boxes depicted are adjusted by horizontal/vertical
     * margin and arrow margin, original boxes are smaller (path can't go at original box borders). Algorithm finds
     * the shortest path with minimum amount of turns. In short it's mix of "Lee" and "Dijkstra pathfinding"
     * with turns amount taken into account for distance calculation.
     *
     * The algorithm is not very performant though, it's O(N^2), where N is amount of
     * points in the grid, but since the maximum amount of points in the grid might be up to 34 (not 36 since
     * two box middle points are not permitted) that might be ok for now.
     *
     * @param {Object} lineDef An object containing any of the class configuration option overrides as well
     *                         as `startBox`, `endBox`, `startHorizontalMargin`, `startVerticalMargin`,
     *                         `endHorizontalMargin`, `endVerticalMargin` properties
     * @param {Object} lineDef.startBox An object containing `start`, `end`, `top`, `bottom` properties
     * @param {Object} lineDef.endBox   An object containing `start`, `end`, `top`, `bottom` properties
     * @param {Number} lineDef.startHorizontalMargin Horizontal margin override for start box
     * @param {Number} lineDef.startVerticalMargin   Vertical margin override for start box
     * @param {Number} lineDef.endHorizontalMargin   Horizontal margin override for end box
     * @param {Number} lineDef.endVerticalMargin     Vertical margin override for end box
     *
     *
     * @return {Object[]|Boolean} Array of line segments or false if path cannot be found
     * @return {Number} return.x1
     * @return {Number} return.y1
     * @return {Number} return.x2
     * @return {Number} return.y2
     */
    //
    //@ignore
    //@privateparam {Function[]|Function} noPathFallbackFn
    //     A function or array of functions which will be tried in case a path can't be found
    //     Each function will be given a line definition it might try to adjust somehow and return.
    //     The new line definition returned will be tried to find a path.
    //     If a function returns false, then next function will be called if any.
    //
    findPath(lineDef, noPathFallbackFn) {
        let me = this,

            lineDefFull,
            startBox,
            endBox,
            startShift,
            endShift,
            startSide,
            endSide,
            startArrowSize,
            endArrowSize,
            startArrowMargin,
            endArrowMargin,
            horizontalMargin,
            verticalMargin,
            startHorizontalMargin,
            startVerticalMargin,
            endHorizontalMargin,
            endVerticalMargin,
            otherHorizontalMargin,
            otherVerticalMargin,
            otherBoxes,

            connStartPoint, connEndPoint,
            pathStartPoint, pathEndPoint,
            gridStartPoint, gridEndPoint,
            startGridBox, endGridBox,
            grid, path, tryNum;

        if (noPathFallbackFn && !Array.isArray(noPathFallbackFn)) {
            noPathFallbackFn = [noPathFallbackFn];
        }

        for (tryNum = 0; lineDef && !path;) {
            lineDefFull = Object.assign(me.config, lineDef);

            startBox              = lineDefFull.startBox;
            endBox                = lineDefFull.endBox;
            startShift            = lineDefFull.startShift;
            endShift              = lineDefFull.endShift;
            startSide             = lineDefFull.startSide;
            endSide               = lineDefFull.endSide;
            startArrowSize        = lineDefFull.startArrowSize;
            endArrowSize          = lineDefFull.endArrowSize;
            startArrowMargin      = lineDefFull.startArrowMargin;
            endArrowMargin        = lineDefFull.endArrowMargin;
            horizontalMargin      = lineDefFull.horizontalMargin;
            verticalMargin        = lineDefFull.verticalMargin;
            startHorizontalMargin = lineDefFull.hasOwnProperty('startHorizontalMargin') ? lineDefFull.startHorizontalMargin : horizontalMargin;
            startVerticalMargin   = lineDefFull.hasOwnProperty('startVerticalMargin') ? lineDefFull.startVerticalMargin : verticalMargin;
            endHorizontalMargin   = lineDefFull.hasOwnProperty('endHorizontalMargin') ? lineDefFull.endHorizontalMargin : horizontalMargin;
            endVerticalMargin     = lineDefFull.hasOwnProperty('endVerticalMargin') ? lineDefFull.endVerticalMargin : verticalMargin;
            otherHorizontalMargin = lineDefFull.hasOwnProperty('otherHorizontalMargin') ? lineDefFull.otherHorizontalMargin : horizontalMargin;
            otherVerticalMargin   = lineDefFull.hasOwnProperty('otherVerticalMargin') ? lineDefFull.otherVerticalMargin : verticalMargin;
            otherBoxes            = lineDefFull.otherBoxes;

            startSide = me.normalizeSide(startSide);
            endSide   = me.normalizeSide(endSide);

            connStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startBox, startSide, startShift);
            connEndPoint   = me.getConnectionCoordinatesFromBoxSideShift(endBox, endSide, endShift);

            startGridBox   = me.calcGridBaseBoxFromBoxAndDrawParams(startBox, startSide, startArrowSize, startArrowMargin, startHorizontalMargin, startVerticalMargin);
            endGridBox     = me.calcGridBaseBoxFromBoxAndDrawParams(endBox, endSide, endArrowSize, endArrowMargin, endHorizontalMargin, endVerticalMargin);
            otherBoxes     = otherBoxes && otherBoxes.map(box =>
                me.calcGridBaseBoxFromBoxAndDrawParams(box, false, 0, 0, otherHorizontalMargin, otherVerticalMargin)
            );
            pathStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startGridBox, startSide, startShift);
            pathEndPoint   = me.getConnectionCoordinatesFromBoxSideShift(endGridBox, endSide, endShift);
            grid           = me.buildPathGrid(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherBoxes);
            gridStartPoint = me.convertDecartPointToGridPoint(grid, pathStartPoint);
            gridEndPoint   = me.convertDecartPointToGridPoint(grid, pathEndPoint);
            path           = me.findPathOnGrid(grid, gridStartPoint, gridEndPoint, startSide, endSide);

            

            // Loop if
            // - path is still not found
            // - have no next line definition (which should be obtained from call to one of the functions from noPathFallbackFn array
            // - have noPathFallBackFn array
            // - current try number is less then noPathFallBackFn array length
            for (lineDef = false; !path && !lineDef && noPathFallbackFn && tryNum < noPathFallbackFn.length; tryNum++) {
                lineDef = (noPathFallbackFn[tryNum])(lineDefFull);
            }
        }

        if (path) {
            path = me.prependPathWithArrowStaffSegment(path, connStartPoint, startArrowSize, startSide);
            path = me.appendPathWithArrowStaffSegment(path, connEndPoint, endArrowSize, endSide);
            path = me.optimizePath(path);
        }

        return path;
    }

    getConnectionCoordinatesFromBoxSideShift(box, side, shift) {
        let coords;

        switch (side) {
            case 'left':
                coords = {
                    x : box.start,
                    y : (box.top + box.bottom) / 2 + shift
                };
                break;
            case 'right':
                coords = {
                    x : box.end,
                    y : (box.top + box.bottom) / 2 + shift
                };
                break;
            case 'top':
                coords = {
                    x : (box.start + box.end) / 2 + shift,
                    y : box.top
                };
                break;
            case 'bottom':
                coords = {
                    x : (box.start + box.end) / 2 + shift,
                    y : box.bottom
                };
                break;
        }

        return coords;
    }

    calcGridBaseBoxFromBoxAndDrawParams(box, side, arrowSize, arrowMargin, horizontalMargin, verticalMargin) {
        let gridBox;

        switch (side) {
            case 'left':
                gridBox = {
                    start  : box.start - Math.max(arrowSize + arrowMargin, horizontalMargin),
                    end    : box.end + horizontalMargin,
                    top    : box.top - verticalMargin,
                    bottom : box.bottom + verticalMargin
                };
                break;
            case 'right':
                gridBox = {
                    start  : box.start - horizontalMargin,
                    end    : box.end + Math.max(arrowSize + arrowMargin, horizontalMargin),
                    top    : box.top - verticalMargin,
                    bottom : box.bottom + verticalMargin
                };
                break;
            case 'top':
                gridBox = {
                    start  : box.start - horizontalMargin,
                    end    : box.end + horizontalMargin,
                    top    : box.top - Math.max(arrowSize + arrowMargin, verticalMargin),
                    bottom : box.bottom + verticalMargin
                };
                break;
            case 'bottom':
                gridBox = {
                    start  : box.start - horizontalMargin,
                    end    : box.end + horizontalMargin,
                    top    : box.top - verticalMargin,
                    bottom : box.bottom + Math.max(arrowSize + arrowMargin, verticalMargin)
                };
                break;
            default:
                gridBox = {
                    start  : box.start - horizontalMargin,
                    end    : box.end + horizontalMargin,
                    top    : box.top - verticalMargin,
                    bottom : box.bottom + verticalMargin
                };
        }

        return gridBox;
    }

    buildPathGrid(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherGridBoxes) {
        let xs, ys,
            y, x, ix, iy, xslen, yslen, ib, blen, box, permitted, point,
            points       = {},
            linearPoints = [];

        xs = [
            startGridBox.start,
            (startSide === 'left' || startSide === 'right') ? (startGridBox.start + startGridBox.end) / 2 : pathStartPoint.x,
            startGridBox.end,
            endGridBox.start,
            (endSide === 'left' || endSide === 'right') ? (endGridBox.start + endGridBox.end) / 2 : pathEndPoint.x,
            endGridBox.end
        ];
        ys = [
            startGridBox.top,
            (startSide === 'top' || startSide === 'bottom') ? (startGridBox.top + startGridBox.bottom) / 2 : pathStartPoint.y,
            startGridBox.bottom,
            endGridBox.top,
            (endSide === 'top' || endSide === 'bottom') ? (endGridBox.top + endGridBox.bottom) / 2 : pathEndPoint.y,
            endGridBox.bottom
        ];

        if (otherGridBoxes) {
            otherGridBoxes.forEach(box => {
                xs.push(box.start, (box.start + box.end) / 2, box.end);
                ys.push(box.top, (box.top + box.bottom) / 2, box.bottom);
            });
        }

        xs = [...new Set(xs.sort((a, b) => a - b))];
        ys = [...new Set(ys.sort((a, b) => a - b))];

        // TODO: fastest way to make unique, Set is slower
        // for ( let i = 0, I = array.length; i < I; i++ ) {
        //     if ( ~array.indexOf( array[ i ], i + 1 ) ) {
        //         array.splice( i, 1 );
        //         i--;
        //         I--;
        //     }
        // }

        for (iy = 0, yslen = ys.length; iy < yslen; ++iy) {
            points[iy] = points[iy] || {};
            y          = ys[iy];
            for (ix = 0, xslen = xs.length; ix < xslen; ++ix) {
                x = xs[ix];

                permitted = (
                    (x <= startGridBox.start || x >= startGridBox.end || y <= startGridBox.top || y >= startGridBox.bottom) &&
                    (x <= endGridBox.start || x >= endGridBox.end || y <= endGridBox.top || y >= endGridBox.bottom)
                );

                if (otherGridBoxes) {
                    for (ib = 0, blen = otherGridBoxes.length; permitted && ib < blen; ++ib) {
                        box       = otherGridBoxes[ib];
                        permitted = (x <= box.start || x >= box.end || y <= box.top || y >= box.bottom) ||
                            // Allow point if it is a path start/end even if point is inside any box
                            (x === pathStartPoint.x && y === pathStartPoint.y) ||
                            (x === pathEndPoint.x && y === pathEndPoint.y);
                    }
                }

                point = {
                    distance  : Math.pow(2, 53) - 1, // Number.MAX_SAFE_INTEGER (not supported in Opera/IE)
                    permitted : permitted,
                    x         : x,
                    y         : y,
                    ix        : ix,
                    iy        : iy
                };

                points[iy][ix] = point;
                linearPoints.push(point);
            }
        }

        return {
            width        : xs.length,
            height       : ys.length,
            xs           : xs,
            ys           : ys,
            points       : points,
            linearPoints : linearPoints
        };
    }

    convertDecartPointToGridPoint(grid, point) {
        let x = grid.xs.indexOf(point.x),
            y = grid.ys.indexOf(point.y);

        return grid.points[y][x];
    }

    findPathOnGrid(grid, gridStartPoint, gridEndPoint, startSide, endSide) {
        let me   = this,
            path = false;

        if (gridStartPoint.permitted && gridEndPoint.permitted) {
            grid = me.waveForward(grid, gridStartPoint, 0);
            path = me.collectPath(grid, gridEndPoint, endSide);
        }

        return path;
    }

    // Returns neighbors from Von Neiman ambit (see Lee pathfinding algorithm description)
    getGridPointNeighbors(grid, gridPoint, predicateFn) {
        let ix     = gridPoint.ix,
            iy     = gridPoint.iy,
            result = [],
            neighbor;

        // NOTE:
        // It's important to push bottom neighbors first since this method is used
        // in collectPath(), which reversively collects path from end to start node
        // and if bottom neighbors are pushed first in result array then collectPath()
        // will produce a line which is more suitable (pleasant looking) for our purposes.
        if (iy < grid.height - 1) {
            neighbor = grid.points[iy + 1][ix];
            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
        }
        if (iy > 0) {
            neighbor = grid.points[iy - 1][ix];
            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
        }
        if (ix < grid.width - 1) {
            neighbor = grid.points[iy][ix + 1];
            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
        }
        if (ix > 0) {
            neighbor = grid.points[iy][ix - 1];
            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
        }

        return result;
    }

    waveForward(grid, gridStartPoint, distance) {
        const me = this;

        // I use the WalkHelper here because a point on a grid and it's neighbors might be considered as a hierarchy.
        // The point is the parent node, and it's neighbors are the children nodes. Thus the grid here is hierarchical
        // data structure which can be walked. WalkHelper walks non-recursivelly which is exactly what I need as well.
        WalkHelper.preWalkUnordered(
            // Walk starting point - a node is a grid point and it's distance from the starting point
            [gridStartPoint, distance],
            // Children query function
            // NOTE: It's important to fix neighbor distance first, before waving to a neighbor, otherwise waving might
            //       get through a neighbor point setting it's distance to a value more then (distance + 1) whereas we,
            //       at the children quering moment in time, already know that the possibly optimal distance is (distance + 1)
            ([point, distance]) => me.getGridPointNeighbors(
                grid,
                point,
                neighborPoint => neighborPoint.permitted && (neighborPoint.distance > distance + 1)
            ).map(
                neighborPoint => [neighborPoint, distance + 1] // Neighbor distance fixation
            ),
            // Walk step iterator function
            ([point, distance]) => point.distance = distance // Neighbor distance applying
        );

        return grid;
    }

    collectPath(grid, gridEndPoint, endSide) {
        let me        = this,
            pathFound = true,
            neighbors,
            lowestDistanceNeighbor,
            xDiff, yDiff,
            path      = [];

        while (pathFound && gridEndPoint.distance) {
            neighbors = me.getGridPointNeighbors(grid, gridEndPoint, point =>
                point.permitted && (point.distance == gridEndPoint.distance - 1)
            );

            pathFound = neighbors.length > 0;

            if (pathFound) {
                // Prefer turnless neighbors first
                neighbors = neighbors.sort((a, b) => {
                    let xDiff, yDiff;

                    xDiff = a.ix - gridEndPoint.ix;
                    yDiff = a.iy - gridEndPoint.iy;

                    let resultA = (
                        ((endSide === 'left' || endSide === 'right') && yDiff === 0) ||
                                       ((endSide === 'top' || endSide === 'bottom') && xDiff === 0)
                    ) ? -1 : 1;

                    xDiff = b.ix - gridEndPoint.ix;
                    yDiff = b.iy - gridEndPoint.iy;

                    let resultB = (
                        ((endSide === 'left' || endSide === 'right') && yDiff === 0) ||
                                       ((endSide === 'top' || endSide === 'bottom') && xDiff === 0)
                    ) ? -1 : 1;

                    if (resultA > resultB) return 1;
                    if (resultA < resultB) return -1;
                    // apply additional sorting to be sure to pick bottom path in IE
                    if (resultA === resultB) return a.y > b.y ? -1 : 1;
                });

                lowestDistanceNeighbor = neighbors[0];

                path.push({
                    x1 : lowestDistanceNeighbor.x,
                    y1 : lowestDistanceNeighbor.y,
                    x2 : gridEndPoint.x,
                    y2 : gridEndPoint.y
                });

                // Detecting new side, either xDiff or yDiff must be 0 (but not both)
                xDiff = lowestDistanceNeighbor.ix - gridEndPoint.ix;
                yDiff = lowestDistanceNeighbor.iy - gridEndPoint.iy;

                switch (true) {
                    case !yDiff && xDiff > 0:
                        endSide = 'left';
                        break;
                    case !yDiff && xDiff < 0:
                        endSide = 'right';
                        break;
                    case !xDiff && yDiff > 0:
                        endSide = 'top';
                        break;
                    case !xDiff && yDiff < 0:
                        endSide = 'bottom';
                        break;
                }

                gridEndPoint = lowestDistanceNeighbor;
            }
        }

        return pathFound && path.reverse() || false;
    }

    prependPathWithArrowStaffSegment(path, connStartPoint, startArrowSize, startSide) {
        let prependSegment,
            firstSegment;

        if (path.length > 0) {
            firstSegment   = path[0];
            prependSegment = {
                x2 : firstSegment.x1,
                y2 : firstSegment.y1
            };

            switch (startSide) {
                case 'left':
                    prependSegment.x1 = connStartPoint.x - startArrowSize;
                    prependSegment.y1 = firstSegment.y1;
                    break;
                case 'right':
                    prependSegment.x1 = connStartPoint.x + startArrowSize;
                    prependSegment.y1 = firstSegment.y1;
                    break;
                case 'top':
                    prependSegment.x1 = firstSegment.x1;
                    prependSegment.y1 = connStartPoint.y - startArrowSize;
                    break;
                case 'bottom':
                    prependSegment.x1 = firstSegment.x1;
                    prependSegment.y1 = connStartPoint.y + startArrowSize;
                    break;
            }

            path.unshift(prependSegment);
        }

        return path;
    }

    appendPathWithArrowStaffSegment(path, connEndPoint, endArrowSize, endSide) {
        let appendSegment,
            lastSegment;

        if (path.length > 0) {
            lastSegment   = path[path.length - 1];
            appendSegment = {
                x1 : lastSegment.x2,
                y1 : lastSegment.y2
            };

            switch (endSide) {
                case 'left':
                    appendSegment.x2 = connEndPoint.x - endArrowSize;
                    appendSegment.y2 = lastSegment.y2;
                    break;
                case 'right':
                    appendSegment.x2 = connEndPoint.x + endArrowSize;
                    appendSegment.y2 = lastSegment.y2;
                    break;
                case 'top':
                    appendSegment.x2 = lastSegment.x2;
                    appendSegment.y2 = connEndPoint.y - endArrowSize;
                    break;
                case 'bottom':
                    appendSegment.x2 = lastSegment.x2;
                    appendSegment.y2 = connEndPoint.y + endArrowSize;
                    break;
            }

            path.push(appendSegment);
        }

        return path;
    }

    optimizePath(path) {
        let optPath = [],
            prevSegment,
            curSegment;

        if (path.length > 0) {
            prevSegment = path.shift();
            optPath.push(prevSegment);

            while (path.length > 0) {
                curSegment = path.shift();

                // both segments are equal
                if (prevSegment.x1 == curSegment.x1 && prevSegment.y1 == curSegment.y1 && prevSegment.x2 == curSegment.x2 && prevSegment.y2 == curSegment.y2) {
                    prevSegment = curSegment;
                }
                // both segments are horizontal
                else if (
                    (prevSegment.y1 - prevSegment.y2 === 0) && (curSegment.y1 - curSegment.y2 === 0)
                ) {
                    prevSegment.x2 = curSegment.x2;
                }
                // both segments are vertical
                else if (
                    (prevSegment.x1 - prevSegment.x2 === 0) && (curSegment.x1 - curSegment.x2 === 0)
                ) {
                    prevSegment.y2 = curSegment.y2;
                }
                // segments has different orientation (path turn)
                else {
                    optPath.push(curSegment);
                    prevSegment = curSegment;
                }
            }
        }

        return optPath;
    }

    normalizeSide(side) {
        return RectangularPathFinder.sideToSide[side] || side;
    }

    static get sideToSide() {
        return {
            'l' : 'left',
            'r' : 'right',
            't' : 'top',
            'b' : 'bottom'
        };
    }
}


RectangularPathFinder._$name = 'RectangularPathFinder';

/**
 * @module Grid/feature/mixin/GridFeatureDataLayer
 */

/**
 * Mixin handling common feature data layer facility.
 *
 * The mixin is designed for grid feature to consume. Since it's impossible to predict what store a feature might need the mixin provides a way
 * to obtain a custom store via minimized yet useful set of template methods with default implementation provided.
 *
 * There are several phases during a feature lifetime the mixin methods should/might be invoked:
 *
 * 1. Construction/configuration
 * 2. Component destruction
 * 3. Component lifetime
 *
 * 1. Construction/configuration time
 * ----------------------------------
 * At construction time the mixin relies on {@link #function-configDataLayer} to inject configuration properties into the mixin config object.
 * The method iterates over {@link #config-dataLayerStores} array and checks if corresponding config option is already set
 * in the provided feature configuration object. If there's no such option present then mixin calls obtain*() method where * represents
 * a store name from {@link #config-dataLayerStores} array with the first letter capitalized.
 *
 * The mixin will also create store accessors if ones do not exist at this time.
 *
 * 2. Grid destruction time
 * ------------------------
 * At this time the mixin will do the usual cleanup. Detach stores event listeners if those were provided via calls to get*ListenersConfig()
 * methods, where * represents a store name from {@link #config-dataLayerStores} array with the first letter capitalized. Set previously obtained
 * store references to null.
 *
 * 3. Component lifetime
 * ---------------------
 * It might be that the stores the feature is needed are available only after the client component has been already rendered. To obtain such stores
 * one should call mixin's {@link #function-attachToDataLayer} method. The method will iterate over {@link #config-dataLayerStores} configuration
 * option and try to obtain any store, which hasn't been yet obtained, via call to obtain*() method, where * represents a store name
 * from {@link #config-dataLayerStores} array with the first letter capitalized. The difference between calls to obtain*() method at construction/configuration
 * time and component lifetime is that for the second case the obtain*() methods will be called without the second argument.
 *
 * During a component lifetime store accessors might be called as well as {@link #function-attachToDataLayer} method. If store reference set
 * via an accessors is different from the one the mixing already has then the previous store event listeners will be detached
 * and new listeners configuration will be requested via call to get*ListenersConfig(), where * represents a store name
 * from the {@link #config-dataLayerStores} array with the first letter capitalized.
 *
 * @mixin
 * @private
 */
var GridFeatureDataLayer = Target => class GridFeatureDataLayer extends (Target || Base) {

    static get defaultConfig() {
        return {
            /**
             * List of data layer store names the mixin will take to obtain store instances, create corresponding store accessors and
             * attach listeners to.
             *
             * @config {String[]}
             */
            dataLayerStores : ['store']
        };
    }

    startConfigure(config) {
        this.configDataLayer(this.client, config);
        super.startConfigure(config);
    }

    doDestroy() {
        (this.dataLayerStores || []).forEach(s => {
            if (s === 'columns') {
                s = 'columnStore';
            }
            this[s] = null;
        });

        return super.doDestroy();
    }

    /**
     *
     * @param {Grid.view.Grid} client
     * @param {Object} config
     * @returns {Object}
     * @internal
     */
    configDataLayer(client, config) {
        return (config.dataLayerStores || []).reduce((config, s) => {
            if (s === 'columnStore' || s === 'columns') {
                s = 'columnStore';
                config.columnStore = config.columnStore || config.columns || this.obtainColumnStore(client, config);
            }
            else {
                const
                    obtainFnName = `obtain${StringHelper.capitalizeFirstLetter(s)}`,
                    obtainFn = this[obtainFnName];

                config[s] = config[s] || (obtainFn && obtainFn.call(this, client, config));
            }

            if (!Reflect.has(this, s) && Object.isExtensible(this) && !Object.isSealed(this) && !Object.isFrozen(this)) {
                Object.defineProperty(this, s, {
                    get : function() {
                        return this[`_${s}`];
                    },
                    set : function(store) {
                        this.setDataLayerStore(s, store);
                    }
                });
            }

            return config;
        }, config);
    }

    /**
     * Call this method to obtain stores not yet obtained.
     */
    attachToDataLayer(force = false) {
        (this.dataLayerStores || []).forEach(s => {
            if (s === 'columns') {
                s = 'columnStore';
            }

            const
                obtainFnName = `obtain${StringHelper.capitalizeFirstLetter(s)}`,
                obtainFn = this[obtainFnName];

            if ((!this[s] || force) && obtainFn) {
                this[s] = obtainFn.call(this, this.client);
            }
        });
    }

    setDataLayerStore(propName, store) {
        const
            privPropName = `_${propName}`,
            detacherName = `_${propName}Detacher`,
            onChangeTplMethodName = `on${StringHelper.capitalizeFirstLetter(propName)}Change`,
            listenersGetterName = `get${StringHelper.capitalizeFirstLetter(propName)}ListenersConfig`;

        if (this[privPropName] !== store) {

            if (this[detacherName]) {
                this[detacherName]();
                this[detacherName] = null;
            }

            if (this[onChangeTplMethodName]) {
                this[onChangeTplMethodName](store, this[privPropName]);
            }

            this[privPropName] = store;

            if (store && this[listenersGetterName]) {
                const listeners = this[listenersGetterName]();

                if (listeners) {
                    this[detacherName] = store.on(Object.assign({ thisObj : this, detachable : true }, listeners));
                }
            }
        }
    }

    obtainStore(client, config) {
        return client.store;
    }

    obtainColumnStore(client, config) {
        return client.columns;
    }
};

/**
 * @module Scheduler/feature/mixin/SchedulerFeatureDataLayer
 */

/**
 * Scheduler feature data layer mixin, provides methods and properties
 * to get scheduler stores, attach to their events and react gracefully on their change.
 *
 * @mixin
 * @private
 */
var SchedulerFeatureDataLayer = Target => class SchedulerFeatureDataLayer extends GridFeatureDataLayer(Target || Base) {

    static get defaultConfig() {
        return {
            dataLayerStores : ['resourceStore', 'dependencyStore', 'assignmentStore', 'eventStore']
        };
    }

    obtainResourceStore(scheduler, config) {
        return scheduler.store;
    }

    obtainDependencyStore(scheduler, config) {
        return scheduler.dependencyStore;
    }

    obtainAssignmentStore(scheduler, config) {
        return scheduler.assignmentStore;
    }

    obtainEventStore(scheduler, config) {
        return scheduler.eventStore;
    }
};

/**
 * @module Scheduler/data/api/EventAPI
 */

/**
 * Event model data API mixin
 *
 * The mixin should be mixed alongside with other API mixins, because it might rely on them.
 *
 * @mixin
 */
var EventAPI = Target => class EventAPI extends (Target || Base) {

    addEventToResource({ event, resource, eventStore, assignmentStore }) {
        event = eventStore.add(event)[0];

        const { assignment } = this.addAssignment({ event, resource, assignmentStore });

        return {
            event,
            assignment : assignment !== event ? assignment : null
        };
    }

    getEventDependencies({ event, dependencyStore }) {
        return dependencyStore.getEventDependencies(event);
    }

    getEventAssignments({ event, assignmentStore }) {
        return event.assignments || [];
    }

    getEventResource({ event, resourceStore }) {
        return event.resource;
    }

    isEventAssignedToResource({ event, resource, resourceStore, assignmentStore }) {
        let result = false;

        if (!assignmentStore) {
            result = event.resource === resource;
        }
        else {
            result = this.getEventAssignments({ event, assignmentStore }).some(assignment => this.isAssignmentForResource({ assignment, resource, resourceStore }));
        }

        return result;
    }

    assignEventToResource({ event, resource, assignmentStore }) {
        let assignment;

        if (assignmentStore) {
            assignment = assignmentStore.add({ eventId : event.id, resourceId : resource.id })[0];
        }
        else {
            event.resourceId = resource.id;
        }

        return assignment || event;
    }
};

/**
 * @module Scheduler/data/api/AssignmentAPI
 */

/**
 * Assignment model data API mixin
 *
 * The mixin should be mixed alongside with other API mixins, because it might rely on them.
 *
 * @mixin
 */
var AssignmentAPI = Target => class AssignmentAPI extends (Target || Base) {

    isAssignmentEventAssigned({ assignment }) {
        return !!assignment.event;
    }

    isAssignmentResourceAssigned({ assignment }) {
        return !!assignment.resource;
    }

    isAssignmentAssigned({ assignment }) {
        return !!assignment.event && !!assignment.resource;
    }

    isAssignmentForResource({ assignment, resource, resourceStore }) {
        return assignment.resource === resource;
    }

    getAssignmentResource({ assignment, resourceStore }) {
        return assignment.resource;
    }

    getAssignmentEvent({ assignment, eventStore }) {
        return assignment.event;
    }

    getAssignmentDependencies({ assignment, dependencyStore }) {
        const event = assignment.event;
        return event ? this.getEventDependencies({ event, dependencyStore }) : [];
    }

    addAssignment({ event, resource, assignmentStore, assignmentConfig }) {
        return {
            assignment : assignmentStore.add(Object.assign({}, assignmentConfig, {
                eventId    : event.id,
                resourceId : resource.id
            }))[0]
        };
    }
};

/**
 * @module Scheduler/data/api/DependencyAPI
 */

/**
 * Dependency model data API mixin
 *
 * The mixin should be mixed alongside with other API mixins, because it might rely on them.
 *
 * @mixin
 */
var DependencyAPI = Target => class DependencyAPI extends (Target || Base) {

    getDependencySourceEvent({ dependency, eventStore }) {
        return dependency.sourceEvent;
    }

    getDependencyTargetEvent({ dependency, eventStore }) {
        return dependency.targetEvent;
    }

    getDependencySourceAssignments({ dependency, assignmentStore }) {
        const event = dependency.sourceEvent;
        return event ? this.getEventAssignments({ event, assignmentStore }) : [];
    }

    getDependencyTargetAssignments({ dependency, assignmentStore }) {
        const event = dependency.targetEvent;
        return event ? this.getEventAssignments({ event, assignmentStore }) : [];
    }

    getDependencyAssignments({ dependency, assignmentStore }) {
        [].concat(
            this.getDependencySourceAssignments({ dependency, assignmentStore }),
            this.getDependencyTargetAssignments({ dependency, assignmentStore })
        );
    }

    getDependencyAssignmentsAsFromToArray({ dependency, assignmentStore }) {
        const
            fromAssignments = this.getDependencySourceAssignments({ dependency, assignmentStore }),
            toAssignments   = this.getDependencyTargetAssignments({ dependency, assignmentStore });

        return fromAssignments.reduce((assignments, from) => {
            return toAssignments.reduce((assignments, to) => {
                assignments.push({ from, to });
                return assignments;
            }, assignments);
        }, []);
    }

    isDependencySourceAssignment({ dependency, assignment }) {
        return dependency.from === assignment.eventId;
    }

    isDependnecyTargetAssignment({ dependency, assignment }) {
        return dependency.to === assignment.eventId;
    }

    isValidDependency({ sourceEvent, targetEvent, type, dependencyStore }) {
        return dependencyStore.isValidDependency(
            sourceEvent.id,
            targetEvent.id,
            type
        );
    }

    isValidDependencyToCreate({ sourceEvent, targetEvent, type, dependencyStore }) {
        return dependencyStore.isValidDependencyToCreate(
            sourceEvent.id,
            targetEvent.id,
            type
        );
    }

    createDependency({ sourceEvent, targetEvent, type, fromSide, toSide, dependencyStore }) {
        return dependencyStore.add({
            from : sourceEvent.id,
            to   : targetEvent.id,
            type,
            fromSide,
            toSide
        })[0];
    }
};

/**
 * @module Scheduler/data/api/ResourceAPI
 */

/**
 * Resource model data API mixin
 *
 * The mixin should be mixed alongside with other API mixins, because it might rely on them.
 *
 * @mixin
 */
var ResourceAPI = Target => class ResourceAPI extends (Target || Base) {

};

// TODO: remove this
//import BatchAPI from './BatchAPI.js';

/**
 * @module Scheduler/data/api/DataAPI
 */

/**
 * This mixin combines all data layer APIs and provides a way to call API method regardless
 * if it conflicts with host class method.
 *
 * @mixin
 */
var DataAPI = Target => {

    // Add new APIs here
    const APIs = [
        AssignmentAPI,
        DependencyAPI,
        EventAPI,
        ResourceAPI
        //TODO: remove this
        //BatchAPI
    ];

    const RAW_API = base(Base).mixes(...APIs);

    return class DataAPI extends (Target || Base) {
        /**
         * Data layer API gateway
         *
         * @property {Object}
         */
        get dataApi() {
            if (!this._dataApi) {
                this._dataApi = new RAW_API({ host : this.dataApiHost || this });
            }
            return this._dataApi;
        }
    };
};

/**
 * @module Scheduler/feature/Dependencies
 */

const
    fromBoxSide = [
        'left',
        'left',
        'right',
        'right'
    ],
    toBoxSide   = [
        'left',
        'right',
        'left',
        'right'
    ];

/**
 * Feature that draws dependencies between events Uses a {@link Scheduler.data.DependencyStore DependencyStore} to determine which dependencies to draw, if
 * none is defined one will be created automatically. Dependencies can also be specified as Scheduler#dependencies, see
 * example below.
 *
 * This feature is **disabled** by default. It is **not** supported in vertical mode.
 *
 * @mixes Core/mixin/Delayable
 * @mixes Scheduler/feature/mixin/DependencyCreation
 *
 * @extends Core/mixin/InstancePlugin
 * @demo Scheduler/dependencies
 * @externalexample scheduler/Dependencies.js
 */
class Dependencies extends base(InstancePlugin).mixes(
    DependencyCreation,
    SchedulerFeatureDataLayer,
    Delayable,
    DataAPI
) {

    /**
     * Fired when dependencies are rendered
     * @event dependenciesDrawn
     * @param {Boolean} [partial] Optional event parameter. `true` when subset of dependencies is repainted, omitted
     * when all lines were repainted.
     */

    //region Config

    static get $name() {
        return 'Dependencies';
    }

    static get defaultConfig() {
        return {
            /**
             * Path finder instance configuration
             * @config {Object}
             */
            pathFinderConfig : null,

            /**
             * The CSS class to add to a dependency line when hovering over it
             * @config {String}
             * @default
             * @private
             */
            overCls : 'b-sch-dependency-over',

            /**
             * The CSS class applied to dependency lines
             * @config {String}
             * @default
             * @private
             */
            baseCls : 'b-sch-dependency',

            /**
             * Store that holds dependencies (using DependencyModel or subclass thereof). A store will be automatically
             * created if none is specified
             * @config {Scheduler.data.DependencyStore}
             */
            store : null,

            /**
             * Dependency definitions (data to DependencyModels). Will be added to store. Can also be specified on
             * Scheduler for convenience
             * @config {DependencyModel[]|Object[]}
             */
            dependencies : null,

            highlightDependenciesOnEventHover : false,

            /**
             * Set to true to show a tooltip when hovering a dependency line
             * @config {Boolean}
             */
            showTooltip : true,

            /**
             * A tooltip config object that will be applied to the dependency hover tooltip. Can be used to for example
             * customize delay
             * @config {Object}
             */
            tooltip : null,

            bufferSize : 50,

            cacheGridSize : {
                x     : 500,
                index : 25
            },

            drawnDependencies     : [],
            drawnLines            : [],
            dependenciesToRefresh : new Map(),

            storeClass : DependencyStore
        };
    }

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            chain  : ['render', 'renderContents', 'onElementClick', 'onElementDblClick', 'onElementMouseOver', 'onElementMouseOut'],
            assign : ['getElementForDependency', 'getDependencyForElement']
        };
    }

    //endregion

    //region Init & destroy

    construct(scheduler, config = {}) {
        const me = this;

        if (scheduler.isVertical) {
            throw new Error('Dependencies feature is not supported in vertical mode');
        }

        // Many things may schedule a draw. Ensure it only happens once, on the next frame.
        // And Ensure it really is on the *next* frame after invocation by passing
        // the cancelOutstanding flag.
        me.doScheduleDraw = me.createOnFrame('draw', [], me, true);

        super.construct(scheduler, config);

        me.pathFinder = new RectangularPathFinder(me.pathFinderConfig);
        delete me.pathFinderConfig;

        me.lineDefAdjusters = me.createLineDefAdjusters();
    }

    doDestroy() {
        this.tooltip && this.tooltip.destroy();
        super.doDestroy();
    }

    doDisable(disable) {
        this.updateCreateListeners();

        if (this.client.isPainted) {
            this.draw();
        }

        super.doDisable(disable);
    }

    //endregion

    //region Regions need cleanup

    exposeSchedulerDependenciesProperty() {
        const me = this;

        if (me.dependenciesPropertyExposed) {
            delete me.client.dependencies;
        }

        Object.defineProperty(me.client, 'dependencies', {
            configurable : true,
            get          : () => me.dependencyStore.records,
            set          : dependencies => me.dependencyStore.data = dependencies
        });

        me.dependenciesPropertyExposed = true;
    }

    get rowStore() {
        return this.resourceStore;
    }

    // referenced in feature a lot
    get scheduler() {
        return this.client;
    }

    getResourceStoreListenersConfig() {
        return {
            refresh : this.onRowStoreRefresh
        };
    }

    obtainDependencyStore(scheduler, config) {
        let store = (config && config.store) || super.obtainDependencyStore(scheduler, config);

        // Backward compatibility
        if (store === true || !store) {
            store = new this.storeClass();
        }

        return store;
    }

    getDependencyStoreListenersConfig() {
        return {
            change : this.onDependencyChange
        };
    }

    onDependencyStoreChange(newStore, oldStore) {
        const
            me        = this,
            scheduler = me.client;

        // When assigning a new store there is no point in keeping anything cached
        me.resetGridCache();
        me.resetBoundsCache();

        scheduler.dependencyStore = newStore;

        if (newStore) {
            if (!me.dependenciesPropertyExposed && scheduler.dependencies) {
                newStore.data = scheduler.dependencies;
                delete scheduler.dependencies;
            }

            // TODO: deprecate and get rid of this
            if (me.dependencies) {
                newStore.data = me.dependencies;
                delete me.dependencies;
            }

            // TODO: This is rather doubtfull code, investigate it
            // used to store meta per scheduler on models, in case they are used in multiple schedulers
            newStore.metaMapId = scheduler.id;

            // TODO: This is very unclear code, investigate it, and better get rid of it
            // Ask the client for its eventStore after we set our store.
            // Its eventStore getter attempts to read our store.
            newStore.eventStore = scheduler.eventStore;

            // expose getter/setter for dependencies on scheduler
            me.exposeSchedulerDependenciesProperty();
        }
    }

    getAssignmentStoreListenersConfig() {
        return {
            change  : this.onAssignmentChange,
            refresh : this.onAssignmentRefresh
        };
    }

    getEventStoreListenersConfig() {
        return {
            change : this.onEventChange
        };
    }

    createMarkers() {
        const
            me        = this,
            svg       = me.client.svgCanvas,
            endMarker = me.endMarker = me.initMarkerElement('arrowEnd', '8', 'M0,0 L0,6 L9,3 z');

        // Edge and IE11 do not support required svg 2.0 orient value
        if (BrowserHelper.isEdge || BrowserHelper.isIE11) {
            const startMarker = me.startMarker = me.initMarkerElement('arrowStart', '1', 'M0,3 L9,6 L9,0 z');

            svg.appendChild(startMarker);
        }
        else {
            endMarker.setAttribute('orient', 'auto-start-reverse');
        }

        svg.appendChild(endMarker);
    }

    /**
     * Creates SVG marker element (arrow) which is used for all dependency lines
     * @private
     * @param {String} id Id of the marker element
     * @param {String} refX
     * @param {String} arrowPath Path defining arrow
     */
    initMarkerElement(id, refX, arrowPath) {
        return DomHelper.createElement({
            id,
            tag          : 'marker',
            ns           : 'http://www.w3.org/2000/svg',
            markerHeight : 9,
            markerWidth  : 9,
            refX,
            refY         : 3,
            viewBox      : '0 0 9 6',
            orient       : 'auto',
            markerUnits  : 'userSpaceOnUse',
            children     : [{
                tag : 'path',
                ns  : 'http://www.w3.org/2000/svg',
                d   : arrowPath
            }]
        });
    }

    /**
     * Returns an array of functions used to alter path config when no path found.
     * It first tries to shrink arrow margins and secondly hides arrows entirely
     * @private
     * @returns {Function[]}
     */
    createLineDefAdjusters() {
        const scheduler = this.client;

        function shrinkArrowMargins(lineDef) {
            let adjusted = false;

            if (lineDef.startArrowMargin > scheduler.barMargin || lineDef.endArrowMargin > scheduler.barMargin) {
                lineDef.startArrowMargin = lineDef.endArrowMargin = scheduler.barMargin;
                adjusted = true;
            }

            return adjusted ? lineDef : adjusted;
        }

        function resetArrowMargins(lineDef) {
            let adjusted = false;

            if (lineDef.startArrowMargin > 0 || lineDef.endArrowMargin > 0) {
                lineDef.startArrowMargin = lineDef.endArrowMargin = 0;
                adjusted = true;
            }

            return adjusted ? lineDef : adjusted;
        }

        // function shrinkStartEndMarginsBy2(lineDef) {
        //     let adjusted = false;
        //
        //     if (lineDef.hasOwnProperty('startHorizontalMargin') && lineDef.startHorizontalMargin > 2) {
        //         lineDef.startHorizontalMargin = Math.round(lineDef.startHorizontalMargin / 2);
        //         adjusted = true;
        //     }
        //     if (lineDef.hasOwnProperty('startVerticalMargin') && lineDef.startVerticalMargin > 2) {
        //         lineDef.startVerticalMargin = Math.round(lineDef.startVerticalMargin / 2);
        //         adjusted = true;
        //     }
        //     if (lineDef.hasOwnProperty('endHorizontalMargin') && lineDef.endHorizontalMargin > 2) {
        //         lineDef.endHorizontalMargin = Math.round(lineDef.endHorizontalMargin / 2);
        //         adjusted = true;
        //     }
        //     if (lineDef.hasOwnProperty('endVerticalMargin') && lineDef.endVerticalMargin > 2) {
        //         lineDef.endVerticalMargin = Math.round(lineDef.endVerticalMargin / 2);
        //         adjusted = true;
        //     }
        //
        //     return adjusted ? lineDef : adjusted;
        // }
        //
        // function resetArrowSizes(lineDef) {
        //     let adjusted = false;
        //
        //     if (lineDef.startArrowSize > 0 || lineDef.endArrowSize > 0) {
        //         lineDef.startArrowSize = lineDef.endArrowSize = 0;
        //         adjusted = true;
        //     }
        //
        //     return adjusted ? lineDef : adjusted;
        // }

        return [
            shrinkArrowMargins,
            resetArrowMargins//,
            // shrinkStartEndMarginsBy2,
            // shrinkStartEndMarginsBy2,
            // shrinkStartEndMarginsBy2,
            // resetArrowSizes
        ];
    }

    //endregion

    //region Elements

    getElementForDependency(dependency, assignmentData = null) {
        let selector = `[depId="${dependency.id}"]`;

        if (assignmentData) {
            selector += `[fromId="${assignmentData.from.id}"][toId="${assignmentData.to.id}"]`;
        }

        return this.client.svgCanvas.querySelector(selector);
    }

    getDependencyForElement(element) {
        const id = typeof element === 'string' ? element : element.getAttribute('depId');

        // TODO: DataAPI?
        return this.dependencyStore.getById(id);
    }

    //endregion

    //region Events

    //region Events that triggers redraw

    onToggleNode() {
        // Need to repopulate grid cache
        this.dependencyGridCache = null;
        // node toggled in tree, can affect resources both above and below, need to redraw all.
        this.scheduleDraw(true);
    }

    // onEventLayout() {
    //     this.scheduleDraw(true);
    // }

    onViewportResize() {
        this.scheduleDraw(true);
    }

    /**
     * Flags for redrawing if a rows height has changed
     * @private
     */
    onTranslateRow({ row }) {
        // a changetotalheight event is fired after translations, if a rowHeight change is detected here it will redraw
        // all dependencies
        if (row.lastTop >= 0 && row.top !== row.lastTop) {
            this.scheduleDraw(true);
        }
    }

    /**
     * Redraws all dependencies if a rows height changed, as detected in onTranslateRow
     * @private
     */
    onChangeTotalHeight() {
        // redraw all dependencies if the height changes. Could be caused by resource add/remove.
        // in reality not all deps needs to be redrawn, those fully above the row which changed height could be left
        // as is, but determining that would likely require more processing than redrawing
        this.scheduleDraw(true);
    }

    /**
     * Draws dependencies on horizontal scroll
     * @private
     */
    onHorizontalScroll({ subGrid }) {
        // ResizeMonitor triggers scroll during render, make sure we have been drawn some other way before redrawing
        if (this.isDrawn && subGrid === this.client.timeAxisSubGrid) {
            this.scheduleDraw(false);
        }
    }

    /**
     * Draws dependencies on vertical scroll
     * @private
     */
    onVerticalScroll() {
        // ResizeMonitor triggers scroll during render, make sure render is done
        if (this.isDrawn) {
            // Do not invalidate on scroll, if height changes it will be invalidated anyway
            this.scheduleDraw(false);
        }
    }

    onRowsRefresh() {
        this.scheduleDraw(true);
    }

    /**
     * When rows are rerendered, better redraw dependencies (might have been collapsed etc).
     * @private
     */
    onRowsRerender() {
        this.scheduleDraw(true);
    }

    /**
     * Redraws dependencies when a row has changed
     * @private
     */
    onRowStoreRefresh({ action }) {
        switch (action) {
            case 'sort':
            case 'filter':
            case 'batch':
                // Will need to recreate grid cache after sort, filter, and any unspecified
                // set of operations encapsulated by a batch, and redraw everything
                this.dependencyGridCache = null;
                return this.scheduleDraw(true);
        }
    }

    // TODO: refactor this! maybe add dataLayerBindOnRender : Boolean configuration option to get rid of if scheduler is rendered check
    /**
     * Redraws dependencies when a dependency has changed
     * @private
     */
    onDependencyChange({ action, record, records }) {
        const me = this;

        if (!me.client.isPainted || me.disabled) {
            return;
        }

        switch (action) {
            case 'dataset':
                me.dependencyGridCache = {};
            // dataset should fall through to add after clearing the cache
            // eslint disable no-fallthrough
            case 'add':
                // dependency added, draw it

                // Check if there is a cache exists. If it does - use it,
                // if not - create one after all records are drawn, this will cache all existing records
                const cache = me._dependencyGridCache;

                records.forEach(dependency => {
                    // Previously this code would draw added dependencies here, no matter if in view or not. To not have
                    // to have the logic for determining whats in view or not here also, simply do a full draw below.
                    // Old approach was especially costly when using CrudManager, which adds on load

                    cache && me.addToGridCache(dependency);
                });

                if (!cache) {
                    me._thisIsAUsedExpression(me.dependencyGridCache);
                }

                me.scheduleDraw();

                return;
            case 'update':
                // Dependency updated. Might have changed source or target, redraw it completely
                return me.scheduleRefreshDependency(record);
            case 'remove':
                // dependencies removed, release elements and remove from cache
                records.forEach(dependency => {
                    me.releaseDependency(dependency, true);
                    me.removeFromCache(dependency);
                });
                me.client.trigger('dependenciesDrawn');
                return;
            // Removing all or filtering -> full redraw
            case 'removeall':
            case 'filter':
                me.dependencyGridCache = null;
                // continue to schedule draw
                break;
        }

        // other changes (removeall, dataset, filter) trigger full redraw
        me.scheduleDraw(true);
    }

    /**
     * Redraws dependencies when an event has changed
     * @private
     */
    onEventChange({ action, record }) {
        switch (action) {
            case 'filter':
                // filtering events, need to redraw all dependencies
                return this.scheduleDraw(true);
            case 'update':
                if (!record.isEvent) {
                    this.drawForTimeSpan(record, true);
                }
                else {
                    // event updated, need to redraw dependencies for all events in its row since it might have changed
                    // vertical position (from changing startDate, duration, name or anything if using custom sorter)
                    const eventRecords = [record];
                    // Collect all events for all resources which have this event assigned... they might all be affected
                    record.resources.forEach(resourceRecord => eventRecords.push(...resourceRecord.events));
                    new Set(eventRecords).forEach(eventRecord => this.drawForTimeSpan(eventRecord, true));
                }
                break;
            case 'removeall':
                this.resetGridCache();
                return this.scheduleDraw(true);
        }

        // adding event has no effect on dependencies, unless it changes row height. in which case it will be handled
        // by onTranslateRow().
        // updating an event might also change row height, handled the same way.
        // removing events will also remove dependencies, thus handled in onDependencyChange
    }

    onAssignmentRefresh({ action }) {
        if (action === 'dataset') {
            // Assigning using EventEdit replaces all assignments. Taking the easy way out, throwing cache away
            this.resetGridCache();
            this.scheduleDraw(true);
        }
    }

    onAssignmentChange({ action, record, records }) {
        const me = this;

        if (record) {
            records = [record];
        }

        if (action === 'add' || action === 'remove' || action === 'update') {
            records.forEach(assignment => {
                const dependencies = this.dataApi.getAssignmentDependencies({
                    assignment,
                    dependencyStore : this.dependencyStore
                });

                dependencies.forEach(dependency => {
                    // New assignment added by other means than EventEdit
                    if (action === 'add') {
                        me.scheduleRefreshDependency(dependency);
                    }
                    // Event unassigned, remove dep line
                    else if (action === 'remove') {
                        let assignments;

                        // Removed source?
                        if (this.dataApi.isDependencySourceAssignment({ dependency, assignment })) {
                            // Might point to a multi assigned event, need to remove all lines
                            assignments = this.dataApi.getDependencyTargetAssignments({
                                dependency,
                                assignmentStore : this.assignmentStore
                            }).map(
                                to => ({ from : assignment, to })
                            );
                        }
                        // Nope, target
                        else {
                            // Might point to a multi assigned event, need to remove all lines
                            assignments = this.dataApi.getDependencySourceAssignments({
                                dependency,
                                assignmentStore : this.assignmentStore
                            }).map(
                                from => ({ from, to : assignment })
                            );
                        }

                        assignments.forEach(assignmentData => {
                            me.releaseDependency(dependency, assignmentData);
                            me.removeFromCache(dependency, assignmentData);
                        });
                    }
                    // Single assignment updated, redraw lines for it
                    else if (action === 'update') {
                        this.dataApi.getDependencyAssignmentsAsFromToArray({ dependency, assignmentStore : this.assignmentStore }).filter(
                            a => (a.from === record || a.to === record)
                        ).forEach(assignmentData => {
                            this.scheduleRefreshDependency(dependency, assignmentData);
                        });
                    }
                });
            });
        }
    }

    //endregion

    onElementClick(event) {
        const me = this;

        if (event.target.matches('.' + me.baseCls)) {
            const
                dependency = DomDataStore.get(event.target).dependency,
                eventName  = event.type === 'click' ? 'Click' : 'DblClick';

            /**
             * Fires on the owning Scheduler/Gantt when a click is registered on a dependency line.
             * @event dependencyClick
             * @param {Scheduler.view.Scheduler} source The scheduler
             * @param {Scheduler.model.DependencyModel} dependency
             * @param {MouseEvent} event
             */
            /**
             * Fires on the owning Scheduler/Gantt when a click is registered on a dependency line.
             * @event dependencyDblClick
             * @param {Scheduler.view.Scheduler} source The scheduler
             * @param {Scheduler.model.DependencyModel} dependency
             * @param {MouseEvent} event
             */
            me.client.trigger(`dependency${eventName}`, {
                dependency,
                event
            });
        }
    }

    onElementDblClick(event) {
        return this.onElementClick(event);
    }

    onElementMouseOver(event) {
        const me = this;

        if (event.target.matches('.' + me.baseCls)) {
            const dependency = DomDataStore.get(event.target).dependency;

            /**
             * Fires on the owning Scheduler/Gantt when the mouse moves over a dependency line.
             * @event dependencyMouseOver
             * @param {Scheduler.view.Scheduler} source The scheduler
             * @param {Scheduler.model.DependencyModel} dependency
             * @param {MouseEvent} event
             */
            me.client.trigger('dependencyMouseOver', {
                dependency,
                event
            });

            if (me.overCls) me.highlight(dependency, me.overCls); // TODO: dataApi?
        }
    }

    onElementMouseOut(event) {
        const me = this;

        if (event.target.matches('.' + me.baseCls)) {
            const dependency = DomDataStore.get(event.target).dependency;

            /**
             * Fires on the owning Scheduler/Gantt when the mouse moves out of a dependency line.
             * @event dependencyMouseOut
             * @param {Scheduler.view.Scheduler} source The scheduler
             * @param {Scheduler.model.DependencyModel} dependency
             * @param {MouseEvent} event
             */
            me.client.trigger('dependencyMouseOut', {
                dependency,
                event
            });

            if (me.overCls && !dependency.meta.removed) me.unhighlight(dependency);
        }
    }

    //endregion

    //region Highlight

    highlight(dependency, cls = this.overCls) {
        const element = this.getElementForDependency(dependency);

        element && element.classList.add(cls);
        dependency.highlight(cls); // TODO: dataApi?
    }

    unhighlight(dependency, cls = this.overCls) {
        const element = this.getElementForDependency(dependency);

        element && element.classList.remove(cls);
        dependency.unhighlight(cls); // TODO: dataApi?
    }

    highlightEventDependencies(timespan) {
        timespan.allDependencies.forEach(dep => this.highlight(dep));
    }

    unhighlightEventDependencies(timespan) {
        timespan.allDependencies.forEach(dep => this.unhighlight(dep));
    }

    //endregion

    //region Determining dependencies to draw

    // Neither resource can be hidden for a dependency to be considered visible
    isDependencyVisible(dependency, assignmentData = null) {
        const
            me                                     = this,
            { dataApi, resourceStore, eventStore } = me,
            from                                   = dataApi.getDependencySourceEvent({ dependency }),
            to                                     = dataApi.getDependencyTargetEvent({ dependency });

        // Bail out early in case source or target doesn't exist
        if (!(from && to)) {
            return false;
        }

        let fromResource, toResource;

        // Using multi-assignment, resource obtained from assignment
        if (assignmentData) {
            fromResource = dataApi.getAssignmentResource({ assignment : assignmentData.from, resourceStore });
            toResource = dataApi.getAssignmentResource({ assignment : assignmentData.to, resourceStore });

            // Filtering EventStore does not filter AssignmentStore, determine if Event is available in this case
            if (eventStore.isFiltered && (eventStore.indexOf(from) === -1 || eventStore.indexOf(to) === -1)) {
                return false;
            }
        }
        // Not using assignments, resource obtained from event
        else {
            fromResource = dataApi.getEventResource({ event : from, resourceStore });
            toResource = dataApi.getEventResource({ event : to, resourceStore });
        }

        return from instanceof Model &&
            // Verify these are real existing Resources and not placeholders (resource not existing in resource store)
            fromResource instanceof ResourceModel &&
            toResource instanceof ResourceModel &&
            !fromResource.instanceMeta(resourceStore).hidden &&
            !toResource.instanceMeta(resourceStore).hidden;
    }

    // Get the bounding box for either the source or the target event
    getBox(dependency, source, assignmentData = null) {
        const eventRecord = this.getTimeSpanRecordFromDependency(dependency, source);

        let resource;

        // Multi-assignment, get resource from assignment
        if (assignmentData) {
            resource = this.dataApi.getAssignmentResource({
                assignment    : assignmentData[source ? 'from' : 'to'],
                resourceStore : this.resourceStore
            });
        }
        // Single, get resource from event
        else {
            resource = this.dataApi.getEventResource({ event : eventRecord, resourceStore : this.resoureStore });
        }

        // TODO: change getResourceEventBox to use Rectangle
        return this.client.getResourceEventBox(eventRecord, resource, true);
    }

    // Get source or target events resource
    getRowRecordFromDependency(dependency, source, assignmentData) {
        let rowRecord;

        // Multi-assigned, use assignments resource
        if (assignmentData) {
            rowRecord = this.dataApi.getAssignmentResource({
                assignment    : assignmentData[source ? 'from' : 'to'],
                resourceStore : this.resourceStore
            });
        }
        // Not multi-assigned, get events resource
        else {
            rowRecord = this.dataApi.getEventResource({
                event         : this.getTimeSpanRecordFromDependency(dependency, source),
                resourceStore : this.resourceStore
            });
        }

        return rowRecord;
    }

    // Get source or target event
    getTimeSpanRecordFromDependency(dependency, source = true) {
        return dependency[`${source ? 'source' : 'target'}Event`];
    }

    getMetaId(assignmentData = null) {
        return assignmentData ? `${this.client.id}-ass${assignmentData.from.id}-ass${assignmentData.to.id}` : this.client.id;
    }

    // Gets the source and target events bounds and unions them to determine the dependency bounds
    getDependencyBounds(dependency, assignmentData = null) {
        const
            me        = this,
            scheduler = me.client,
            ddr       = dependency.getDateRange();

        // quick bailout for hidden rows
        if (!scheduler.rowManager.rowCount || !me.isDependencyVisible(dependency, assignmentData)) {
            return null;
        }
        // quick bailout in case dependency dates and view dates do not intersect
        if (!(ddr && DateHelper.intersectSpans(ddr.start, ddr.end, scheduler.startDate, scheduler.endDate))) {
            return null;
        }

        const
            metaId       = me.getMetaId(assignmentData),
            instanceMeta = dependency.instanceMeta(metaId),
            startBox     = me.getBox(dependency, true, assignmentData),
            endBox       = me.getBox(dependency, false, assignmentData);

        // Can't draw dependency if either start or end is in collapsed row
        if (!startBox || !endBox) {
            return null;
        }

        // If we are forcing recalculation of dep bounds, or there are no calculated bounds for this dependency
        // or the calculated bounds were based on a "best guess", then recalculate the bounds.
        if (me._resetBoundsCache || !instanceMeta.bounds || !instanceMeta.bounds.layout) {
            const
                from           = me.getTimeSpanRecordFromDependency(dependency, true),
                to             = me.getTimeSpanRecordFromDependency(dependency, false),
                startRectangle = startBox instanceof Rectangle ? startBox : new Rectangle(
                    startBox.start,
                    startBox.top,
                    startBox.end - startBox.start,
                    startBox.bottom - startBox.top
                ),
                endRectangle   = endBox instanceof Rectangle ? endBox : new Rectangle(
                    endBox.start,
                    endBox.top,
                    endBox.end - endBox.start,
                    endBox.bottom - endBox.top
                ),
                bounds         = Rectangle.union(startRectangle, endRectangle);

            if (!scheduler.isGantt) {
                [[from, startRectangle, startBox], [to, endRectangle, endBox]].map(([record, rectangle, eventBox]) => {
                    // When using other milestoneLayoutMode than default milestones should be treated as normal events.
                    // Milestones are zero width by default, so we must measure the milestone el's height
                    // (or icon el width) and use that as the width. We cannot use the event's calculated height because
                    // if there are labels, the milestone diamond will be smaller.
                    // If the event doesn't have an element, then it's outside of the rendered block and the exact
                    // width doesn't matter.
                    if (scheduler.milestoneLayoutMode === 'default' && record.isMilestone) {
                        if (!scheduler.milestoneWidth && eventBox.eventEl && record.iconCls) {
                            scheduler.milestoneWidth = eventBox.eventEl.firstElementChild.offsetWidth;
                        }

                        // If it could not be measured due to the event being outside of the rendered block
                        // we have to use the calculated height.
                        const milestoneWidth = scheduler.milestoneWidth || rectangle.height;
                        rectangle.left -= milestoneWidth / 2;
                        rectangle.right += milestoneWidth / 2;
                    }
                });
            }

            instanceMeta.bounds = {
                bounds,
                startRectangle,
                endRectangle,

                // Cache whether both rectangles are based on the true layout
                // or a best guess approximation to be recalculated
                // next time through.
                layout : startBox.layout && endBox.layout
            };
        }

        return dependency.instanceMeta(metaId).bounds;
    }

    // Grid cache is a virtual grid holding info on which dependencies intersects its virtual cells.
    // Used to determine which dependencies should be considered for drawing, iterating over all dependencies each update
    // gets too costly when count increases (>10000).
    //
    // Illustration shows entire schedule area, dddd is a dependency line, vvv is viewport, xxx virtual cell border:
    //
    // ----------------------------------
    // |     vvvvvxvvvvv                |
    // |     v    x    v                |
    // |     v d  x    v                |
    // |     v d  x    v                |
    // |xxxxxvxdxxx    v                |
    // |     vvdvvxvvvvv                |
    // |       d  x                     |
    // |       d  x                     |
    // |       d  x                     |
    // |xxxxxxxdxxxxxxx                 |
    // |       d  x                     |
    // |       d  x                     |
    // |          x                     |
    // |          x                     |
    // |xxxxxxxxxxxxxxx                 |
    // ----------------------------------
    //
    // The dependency crosses three virtual grid cells [0,0], [0,1] and [0,2]. Stored in a map in cache:
    // {
    //    0 : {
    //      0 : [ d, ... ],
    //      1 : [ d, ... ],
    //      2 : [ d, ... ]
    //    }
    // }
    //
    // Viewport crosses four virtual grid cells [0,0], [1,0], [0,1], [1,1]. Those cells are checked in the cached map to
    // find out which rows should be considered for drawing.
    //
    // This approach minimizes the amount of iteration needed
    get dependencyGridCache() {
        const me = this;

        if (!me._dependencyGridCache) {
            me._dependencyGridCache = {};
            me.dependencyStore.forEach(dependency => me.addToGridCache(dependency));
        }

        return me._dependencyGridCache;
    }

    // With multi-assign each dependency might be drawn several times
    getIteratableDependencyAssignments(dependency) {
        return this.assignmentStore ? this.dataApi.getDependencyAssignmentsAsFromToArray({
            dependency,
            assignmentStore : this.assignmentStore
        }) : [null]; // On purpose, to be iterable
    }

    addToGridCache(dependency) {
        const
            me                                               = this,
            { dependencyGridCache, cacheGridSize, rowStore } = me,
            assignmentDataArray                              = me.getIteratableDependencyAssignments(dependency);

        assignmentDataArray.forEach(assignmentData => {
            const dependencyBounds = me.getDependencyBounds(dependency, assignmentData);

            if (dependencyBounds) {
                const
                    metaId        = me.getMetaId(assignmentData),
                    meta          = dependency.instanceMeta(metaId),
                    metaGridCache = meta.gridCache = [],

                    // Using index vertically rather than y for reliability with variable row height
                    fromIndex     = rowStore.indexOf(me.getRowRecordFromDependency(dependency, true, assignmentData)),
                    toIndex       = rowStore.indexOf(me.getRowRecordFromDependency(dependency, false, assignmentData)),
                    topIndex      = Math.min(fromIndex, toIndex),
                    bottomIndex   = Math.max(fromIndex, toIndex),

                    // Convert dependency bounds/index into virtual grid cells
                    box           = dependencyBounds.bounds,
                    boxLeft       = Math.floor(Math.max(box.x, 0) / cacheGridSize.x),
                    boxRight      = Math.floor(box.right / cacheGridSize.x),
                    boxTop        = Math.floor(topIndex / cacheGridSize.index),
                    boxBottom     = Math.floor(bottomIndex / cacheGridSize.index);

                let cacheX, cacheY, x, y;

                // Store the dependency in the virtual cells which it intersects
                for (x = boxLeft; x <= boxRight; x++) {
                    cacheX = dependencyGridCache[x] || (dependencyGridCache[x] = {});

                    for (y = boxTop; y <= boxBottom; y++) {
                        cacheY = cacheX[y] || (cacheX[y] = []);

                        // only push to the cache if it is not already there
                        if (!cacheY.find(i => i.dependency.id === dependency.id && i.assignmentData === assignmentData && i.metaId === metaId)) {
                            cacheY.push({ dependency, assignmentData, metaId });
                        }
                        metaGridCache.push([x, y]);
                    }
                }
            }
        });
    }

    removeFromCache(dependency, assignmentData = null) {
        const me = this;

        let assignments;

        // Some short-cut case
        if (assignmentData) {
            assignments = [assignmentData];
        }
        else {
            assignments = this.getIteratableDependencyAssignments(dependency);
        }

        assignments.forEach(assignmentData => {
            const
                metaId = me.getMetaId(assignmentData),
                meta   = dependency.instanceMeta(metaId);

            meta.gridCache && me._dependencyGridCache && meta.gridCache.forEach(([x, y]) => {
                if (me._dependencyGridCache.hasOwnProperty(x) && me._dependencyGridCache[x].hasOwnProperty(y)) {
                    const
                        entries = me._dependencyGridCache[x][y],
                        index   = entries.findIndex(d => d.dependency === dependency && (d.assignmentData === assignmentData || (d.assignmentData.from === assignmentData.from && d.assignmentData.to === assignmentData.to)));

                    // Cannot use ArrayHelper#remove since it cannot compare deeply
                    if (index > -1) {
                        entries.splice(index, 1);
                    }
                }
            });

            meta.bounds = null;
            meta.gridCache = null;
        });
    }

    set dependencyGridCache(cache) {
        this._dependencyGridCache = cache;
    }

    // Reset cached bounds, not grid cache since it is expensive to create. It is so coarse anyway so should be fine
    // with most changes, except for sorting and similar. Reset on demand instead
    resetBoundsCache() {
        // Not actually resetting here, would just be costly to iterate and reset per dependency, instead flagging to
        // force cached value to be updated
        this._resetBoundsCache = true;
    }

    // In some cases we do need to reset cache, like when time axis is reconfigured
    resetGridCache() {
        this.dependencyGridCache = null;
    }

    //endregion

    //region Draw & render

    //region Lines

    prepareLineDef(dependency, dependencyDrawData, assignmentData = null) {
        const
            me     = this,
            source = me.getTimeSpanRecordFromDependency(dependency, true),
            target = me.getTimeSpanRecordFromDependency(dependency, false),
            type   = dependency.type;

        let startSide = dependency.fromSide,
            endSide   = dependency.toSide;

        // Fallback to view trait if dependency start side is not given
        if (!startSide) {
            switch (true) {
                case type === DependencyModel.Type.StartToEnd:
                    startSide = me.getConnectorStartSide(source);
                    break;

                case type === DependencyModel.Type.StartToStart:
                    startSide = me.getConnectorStartSide(source);
                    break;

                case type === DependencyModel.Type.EndToStart:
                    startSide = me.getConnectorEndSide(source);
                    break;

                case type === DependencyModel.Type.EndToEnd:
                    startSide = me.getConnectorEndSide(source);
                    break;

                default:
                    throw new Error('Invalid dependency type: ' + type);
            }
        }

        // Fallback to view trait if dependency end side is not given /*or can be obtained from type*/
        if (!endSide) {
            switch (true) {
                case type === DependencyModel.Type.StartToEnd:
                    endSide = me.getConnectorEndSide(target);
                    break;

                case type === DependencyModel.Type.StartToStart:
                    endSide = me.getConnectorStartSide(target);
                    break;

                case type === DependencyModel.Type.EndToStart:
                    endSide = me.getConnectorStartSide(target);
                    break;

                case type === DependencyModel.Type.EndToEnd:
                    endSide = me.getConnectorEndSide(target);
                    break;

                default:
                    throw new Error('Invalid dependency type: ' + type);
            }
        }

        const { startRectangle, endRectangle } = dependencyDrawData;

        return {
            startBox : {
                start  : startRectangle.x,
                end    : startRectangle.right,
                top    : startRectangle.y,
                bottom : startRectangle.bottom
            },

            endBox : {
                start  : endRectangle.x,
                end    : endRectangle.right,
                top    : endRectangle.y,
                bottom : endRectangle.bottom
            },
            startSide : startSide,
            endSide   : endSide
        };
    }

    // Draws a single SVG line that represents the dependency
    drawLine(canvas, dependency, points, assignmentData = null, cache = true) {
        const
            scheduler = this.client,
            metaId    = this.getMetaId(assignmentData);

        // Reuse existing element if possible
        let line = dependency.instanceMeta(metaId).lineElement;

        if (!line || !cache) {
            line = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');

            if (cache) {
                dependency.instanceMeta(metaId).lineElement = line;
            }

            line.setAttribute('depId', dependency.id);
            if (assignmentData) {
                line.setAttribute('fromId', assignmentData.from.id);
                line.setAttribute('toId', assignmentData.to.id);
            }
            canvas.appendChild(line);
        }

        // TODO: Use DomHelper.syncClassList

        // className is SVGAnimatedString for svg elements, reading attribute instead
        line.classList.length && line.classList.remove.apply(line.classList, line.getAttribute('class').split(' '));

        line.classList.add(this.baseCls);

        if (dependency.cls) {
            line.classList.add(dependency.cls);
        }
        if (dependency.bidirectional) {
            line.classList.add('b-sch-bidirectional-line');
        }
        if (dependency.highlighted) {
            line.classList.add(...dependency.highlighted.split(' '));
        }
        if (BrowserHelper.isIE11) {
            const
                ddr       = dependency.getDateRange(true),
                viewStart = scheduler.startDate;

            if (ddr.start < viewStart) {
                line.classList.add('b-no-start-marker');
            }
            if (ddr.end < viewStart) {
                line.classList.add('b-no-end-marker');
            }
        }

        line.setAttribute('points', !points ? '' : points.map((p, i) => i !== points.length - 1 ? `${p.x1},${p.y1}` : `${p.x1},${p.y1} ${p.x2},${p.y2}`).join(' '));

        DomDataStore.set(line, {
            dependency
        });

        return line;
    }

    //endregion

    /**
     * Re-caches and redraws a dependency, for all assignments.
     * @param {Scheduler.model.DependencyModel} dependency Dependency to refresh
     */
    refreshDependency(dependency) {
        const
            me          = this,
            assignments = me.getIteratableDependencyAssignments(dependency);

        // Release dependency element, for all assignments if using AssignmentStore
        me.releaseDependency(dependency, assignments[0] !== null);
        // Remove it from grid & bounds cache
        me.removeFromCache(dependency);
        // Re-add it to grid cache
        me.addToGridCache(dependency);
        // Draw all assignments
        assignments.forEach(assignmentData =>
            me.drawDependency(dependency, null, assignmentData)
        );
    }

    /**
     * Re-caches and redraws a dependency for given assignment.
     * @param {Scheduler.model.DependencyModel} dependency Dependency to refresh
     * @param {Object} assignmentData
     * @param {Scheduler.model.AssignmentModel} assignmentData.from Source assignment
     * @param {Scheduler.model.AssignmentModel} assignmentData.to Target assignment
     * @private
     */
    refreshDependencyAssignment(dependency, assignmentData) {
        const me = this;

        // In case it was assigned to something not in view/timeline, release the line
        me.releaseDependency(dependency, assignmentData);
        // Update cache to only contain whats left of it
        me.removeFromCache(dependency, assignmentData);
        me.addToGridCache(dependency);
        // Draw lines
        me.drawDependency(dependency, null, assignmentData);
    }

    /**
     * Stores all dependencies/assignments that were requested to refresh and schedules repaint on next animation frame
     * @param {Scheduler.model.DependencyModel} dependency Dependency model to refresh
     * @param {Object} [assignmentData] Assignment data
     * @param {Scheduler.model.AssignmentModel} [assignmentData.from] Source assignment
     * @param {Scheduler.model.AssignmentModel} [assignmentData.to] Target assignment
     * @private
     */
    scheduleRefreshDependency(dependency, assignmentData = null) {
        const map = this.dependenciesToRefresh;

        // If this method was called once without assignment data - all lines releated should be repainted
        if (!assignmentData) {
            map.set(dependency, true);
        }
        else if (map.has(dependency)) {
            if (map.get(dependency) !== true) {
                map.get(dependency).add(assignmentData);
            }
        }
        else {
            map.set(dependency, new Set([assignmentData]));
        }

        if (map.size === 1) {
            this.requestAnimationFrame(() => {
                this.refreshDependencyOnFrame();
            });
        }
    }

    /**
     * Repaints scheduled dependencies/assignments
     * @private
     */
    refreshDependencyOnFrame() {
        const
            me  = this,
            map = me.dependenciesToRefresh;
        if (me.client.isPainted) {
            // First clear cache and release dependencies. This will modify DOM
            map.forEach((assignments, dependency) => {
                if (assignments === true) {
                    const assignments = me.getIteratableDependencyAssignments(dependency);
                    // Release dependency element, for all assignments if using AssignmentStore
                    me.releaseDependency(dependency, assignments[0] !== null);
                    // Remove it from grid & bounds cache
                    me.removeFromCache(dependency);
                }
                else {
                    assignments.forEach(assignment => {
                        // In case it was assigned to something not in view/timeline, release the line
                        me.releaseDependency(dependency, assignment);
                        // Update cache to only contain whats left of it
                        me.removeFromCache(dependency, assignment);
                    });
                }
            });

            // Then fill cache before drawing dependencies. This will read the DOM forcing reflow
            map.forEach((assignments, dependency) => {
                // Re-add it to grid cache
                me.addToGridCache(dependency);
            });

            // Finally append elements to the DOM
            map.forEach((assignments, dependency) => {
                if (assignments === true) {
                    assignments = me.getIteratableDependencyAssignments(dependency);
                }

                assignments.forEach(assignmentData => {
                    me.drawDependency(dependency, null, assignmentData);
                });
            });

            map.clear();

            me.client.trigger('dependenciesDrawn', { partial : true });
        }
    }

    /**
     * Draws a single dependency (for a single assignment if using multiple), if in view.
     * @param {Scheduler.model.DependencyModel} dependency Dependency to draw
     */
    drawDependency(dependency, drawData = null, assignmentData = null, canvas = this.client.svgCanvas, cache = true) {
        const
            me                                          = this,
            { drawnDependencies, oldDrawnDependencies } = me,
            // Determines if a dependency should be draw, and if so returns the coordinates of its events
            dependencyDrawData                          = drawData || me.getDependencyBounds(dependency, assignmentData),
            lookup                                      = d => d.dependency === dependency && (d.assignmentData === assignmentData || (d.assignmentData && d.assignmentData.from === assignmentData.from && d.assignmentData.to === assignmentData.to));

        if (!me.disabled && dependencyDrawData) {
            // Build line defs
            const
                lineDef = me.prepareLineDef(dependency, dependencyDrawData),
                lines   = me.pathFinder.findPath(lineDef, me.lineDefAdjusters);

            me.drawLine(canvas, dependency, lines, assignmentData, cache);

            // Do not push dependency to drawn deps if this is a temporary render
            // Cannot use ArrayHelper#include since object wont be the same, only its contents
            if (cache && !drawnDependencies.some(lookup)) {
                drawnDependencies.push({ dependency, assignmentData });
            }
        }

        // Remove from oldDrawnDeps, to not have element removed. Cannot use ArrayHelper#remove as stated above
        const oldIndex = oldDrawnDependencies && oldDrawnDependencies.findIndex(lookup);
        if (oldIndex >= 0) {
            oldDrawnDependencies.splice(oldIndex, 1);
        }
    }

    /**
     * Draws multiple dependencies, called from drawForEvent() or drawFromTask().
     * @private
     */
    drawForTimeSpan(timeSpanRecord, async = false) {
        const me = this;

        // If the client is doing an animated update, we must update at end.
        // That will be asynchronous relative to now, so do not pass on the async flag.
        if (me.client.isAnimating) {
            me.client.on({
                transitionend() {
                    me.drawForTimeSpan(timeSpanRecord, true);
                },
                once : true
            });
        }
        // Otherwise, schedule the draw for the next frame.
        else {
            me.dependencyStore.getTimeSpanDependencies(timeSpanRecord).forEach(dependency => {
                if (async) {
                    me.scheduleRefreshDependency(dependency);
                }
                else {
                    me.refreshDependency(dependency);
                }
            });
        }
    }

    /**
     * Draws all dependencies for the specified event.
     */
    drawForEvent(eventRecord) {
        this.drawForTimeSpan(eventRecord);
    }

    // Redraw all dependencies for a particular eventRecord, using its current element instead of calculating a box
    // Used to do live redraw while resizing or dragging events
    updateDependenciesForTimeSpan(timeSpanRecord, element) {
        const
            me               = this,
            eventRecord      = timeSpanRecord.isAssignment ? timeSpanRecord.event : timeSpanRecord,
            deps             = me.dependencyStore.getTimeSpanDependencies(eventRecord),
            metaId           = me.getMetaId(),
            scheduler        = me.client,
            originalTaskRect = Rectangle.from(element, scheduler.timeAxisSubGridElement);

        let bounds;

        deps.forEach(dep => {
            const assignments = this.getIteratableDependencyAssignments(dep);

            assignments.forEach(assignmentData => {
                const taskRect = originalTaskRect.clone();
                let startRectangle, endRectangle, box;

                // If dragging one multi assigned event the others wont move until it is dropped. Prevent their dep
                // lines from updating by bailing out
                if (assignmentData && assignmentData.from !== timeSpanRecord && assignmentData.to !== timeSpanRecord) {
                    return;
                }

                // Bail out if dependency is not visible (other end might be collapsed)
                if (!me.isDependencyVisible(dep, assignmentData)) {
                    return;
                }

                if (me.getTimeSpanRecordFromDependency(dep, true) === eventRecord) {
                    startRectangle = taskRect;

                    // try to look into dependency cache first
                    if ((bounds = dep.instanceMeta(metaId).bounds)) {
                        endRectangle = bounds.endRectangle;
                    }
                    else {
                        box = me.getBox(dep, false, assignmentData);

                        // Row might be in collapsed node, in which case we get no box
                        if (box) {
                            endRectangle = new Rectangle(
                                box.start,
                                box.top,
                                box.end - box.start,
                                box.bottom - box.top
                            );
                        }
                    }
                }
                else {
                    // try to look into dependency cache first
                    if ((bounds = dep.instanceMeta(metaId).bounds)) {
                        startRectangle = bounds.startRectangle;
                    }
                    else {
                        box = me.getBox(dep, true, assignmentData);

                        // Row might be in collapsed node, in which case we get no box
                        if (box) {
                            startRectangle = new Rectangle(
                                box.start,
                                box.top,
                                box.end - box.start,
                                box.bottom - box.top
                            );
                        }
                    }

                    endRectangle = taskRect;
                }

                if (startRectangle && endRectangle) {
                    me.drawDependency(dep, { startRectangle, endRectangle }, assignmentData);
                }
            });
        });
    }

    scheduleDraw(relayout = false) {
        const me = this;

        // There may be number of concurrent calls to this method, we need to reset cache if at least
        // once it was called with relayout = true
        if (relayout) {
            me.resetBoundsCache();
        }

        // If the scheduler/gantt is doing an animated update, schedule the draw
        // for when that's done so that we get correct element boxes.
        if (me.client.isAnimating) {
            if (!me.clientTransitionRemover) {
                me.clientTransitionRemover = me.client.on({
                    transitionend() {
                        me.clientTransitionRemover();
                        me.clientTransitionRemover = null;
                        me.draw();
                    },
                    once : true
                });
            }
        }
        // Otherwise, schedule the draw for the next frame.
        else {
            me.doScheduleDraw();
        }
    }

    /**
     * Draws all dependencies that overlap the current viewport
     */
    draw(reLayout = false) {
        const
            me        = this,
            scheduler = me.client;

        // Early bailout if we get here before we have any deps or rows rendered
        if (!me.oldDrawnDependencies && !me.dependencyStore.count || !scheduler.isPainted) {
            return;
        }
        // if animation is in progress, schedule drawing and skip current one
        if (scheduler.isAnimating) {
            scheduler.on({
                transitionend() {
                    me.scheduleDraw(true);
                },
                once : true
            });

            return;
        }

        // viewBox is the bounds of the current viewport, used to determine which dependencies to draw
        const viewBox = scheduler.timeAxisSubGrid.viewRectangle;

        if (reLayout) {
            me.resetBoundsCache();
        }

        me.oldDrawnDependencies = me.drawnDependencies;
        me.drawnDependencies = [];

        // too early
        if (!viewBox.width || !viewBox.height) return [];

        // expand viewBox with buffer size
        viewBox.inflate(me.bufferSize);

        // Do not draw if no rows
        if (!me.disabled && me.rowStore.count && scheduler.rowManager.rowCount) {
            const
                consideredDependencies                 = {},
                { dependencyGridCache, cacheGridSize } = me,
                viewLeft                               = Math.floor(Math.max(viewBox.left, 0) / cacheGridSize.x),
                viewRight                              = Math.floor(viewBox.right / cacheGridSize.x),
                topIndex                               = Math.floor(scheduler.rowManager.topRow.dataIndex / cacheGridSize.index),
                bottomIndex                            = Math.floor(scheduler.rowManager.bottomRow.dataIndex / cacheGridSize.index),
                dependenciesToDraw                     = [];

            let x, rowIndex, i;

            // Iterate over virtual dependency grid cells, pushing each dependency that intersects that cell
            for (x = viewLeft; x <= viewRight; x++) {
                for (rowIndex = topIndex; rowIndex <= bottomIndex; rowIndex++) {
                    const
                        cacheX = dependencyGridCache[x],
                        deps   = cacheX && cacheX[rowIndex];

                    for (i = 0; deps && i < deps.length; i++) {
                        const
                            { dependency, assignmentData, metaId } = deps[i],
                            // Unique id for dependency combined with assignment
                            flagId                                 = dependency.id + '-' + metaId;

                        if (!consideredDependencies[flagId]) {
                            // Only draw those actually in view
                            const bounds = me.getDependencyBounds(dependency, assignmentData);
                            // TODO: get rid of this export-specific flag
                            if (bounds && bounds.bounds.intersect(viewBox, true, true) || scheduler.ignoreViewBox) {
                                dependenciesToDraw.push([dependency, bounds, assignmentData]);
                            }

                            consideredDependencies[flagId] = true;
                        }
                    }
                }
            }

            // Append dependencies to the DOM only after all have been calculated
            dependenciesToDraw.forEach(([dependency, bounds, assignmentData]) => {
                me.drawDependency(dependency, bounds, assignmentData);
            });
        }

        // Stop forcing recalculation of bounds
        me._resetBoundsCache = false;

        // Release elements for any dependencies that wasn't drawn
        me.oldDrawnDependencies.forEach(data => me.releaseDependency(data.dependency, data.assignmentData));

        scheduler.trigger('dependenciesDrawn');

        this.isDrawn = true;
    }

    /**
     * Release a dependency that is determined to be no longer visible
     * @param {Scheduler.model.DependencyModel} dependency
     */
    releaseDependency(dependency, assignmentData = null) {
        // Remove for all assignments (related to this client, store might be shared)
        if (assignmentData === true) {
            Object.keys(dependency.meta.map || {}).filter(key => key.startsWith(this.client.id)).forEach(key => {
                const data = dependency.meta.map[key];
                if (data.lineElement) {
                    data.lineElement.remove();
                    data.lineElement = null;
                }
            });
        }
        // Remove specific
        else {
            const
                metaId      = this.getMetaId(assignmentData),
                lineElement = dependency.instanceMeta(metaId).lineElement;

            if (lineElement) {
                dependency.instanceMeta(metaId).lineElement = null;
                // Not reusing elements for other lines currently
                lineElement.remove();
            }
        }
    }

    render() {
        const
            me        = this,
            scheduler = me.client;

        if (me.showTooltip) {
            me.tooltip = me.createTooltip();
        }

        scheduler.timeAxis.on({
            endreconfigure : me.resetGridCache,
            thisObj        : me
        });

        scheduler.rowManager.on({
            refresh           : me.onRowsRefresh, // redraws dependencies after zoom
            changetotalheight : me.onChangeTotalHeight, // redrawn dependencies after group collapse
            thisObj           : me
        });

        // dependencies are drawn on scroll, both horizontal and vertical
        scheduler.on({
            horizontalscroll       : me.onHorizontalScroll,
            svgcanvascreated       : me.createMarkers,
            togglenode             : me.onToggleNode,
            scroll                 : me.onVerticalScroll,
            //            eventlayout      : me.onEventLayout,
            timelineviewportresize : me.onViewportResize,
            thisObj                : me
        });

        if (me.highlightDependenciesOnEventHover) {
            scheduler.on(scheduler.scheduledEventName + 'MouseEnter', (params) => me.highlightEventDependencies(params.eventRecord || params.taskRecord));
            scheduler.on(scheduler.scheduledEventName + 'MouseLeave', (params) => me.unhighlightEventDependencies(params.eventRecord || params.taskRecord));
        }

        me.draw();
    }

    renderContents() {
        this.draw();
    }

    //endregion

    //region Connector sides

    /**
     * Gets displaying item start side
     *
     * @param {Scheduler.model.TimeSpan} timeSpanRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorStartSide(timeSpanRecord) {
        return this.client.currentOrientation.getConnectorStartSide(timeSpanRecord);
    }

    /**
     * Gets displaying item end side
     *
     * @param {Scheduler.model.TimeSpan} timeSpanRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorEndSide(timeSpanRecord) {
        return this.client.currentOrientation.getConnectorEndSide(timeSpanRecord);
    }

    //endregion

    //region Tooltip

    createTooltip() {
        const
            me        = this,
            scheduler = me.client;

        return new Tooltip(Object.assign({
            align          : 'b-t',
            id             : `${scheduler.id}-dependency-tip`,
            //TODO: need some way better to specify this. maybe each feature should be queried?
            forSelector    : `.b-timelinebase:not(.b-eventeditor-editing):not(.b-resizing-event):not(.b-dragcreating):not(.b-dragging-event):not(.b-creating-dependency) .${me.baseCls}`,
            clippedBy      : [scheduler.timeAxisSubGridElement, scheduler.bodyContainer],
            forElement     : scheduler.timeAxisSubGridElement,
            showOnHover    : true,
            hoverDelay     : 0,
            hideDelay      : 0,
            anchorToTarget : false,
            trackMouse     : false,
            getHtml        : me.getHoverTipHtml.bind(me)
        }, me.tooltip || {}));
    }

    /**
     * Generates html for the tooltip shown when hovering a dependency
     * @param {Object} tooltipConfig
     * @returns {string} Html to display in the tooltip
     * @private
     */
    getHoverTipHtml({ activeTarget }) {
        const
            me         = this,
            dependency = me.getDependencyForElement(activeTarget),
            fromEvent  = me.dataApi.getDependencySourceEvent({ dependency, eventStore : this.eventStore }),
            toEvent    = me.dataApi.getDependencyTargetEvent({ dependency, eventStore : this.eventStore });

        return TemplateHelper.tpl`
             <table class="b-sch-dependency-tooltip">
                <tr>
                    <td>${me.L('from')}: </td>
                    <td>${fromEvent.name}</td>
                    <td>
                        <div class="b-sch-box b-${fromBoxSide[dependency.type]}"></div>
                    </td>
                </tr>
                <tr>
                    <td>${me.L('to')}: </td>
                    <td>${toEvent.name}</td>
                    <td><div class="b-sch-box b-${toBoxSide[dependency.type]}"></div></td>
                </tr>
            </table>
        `;
    }

    //endregion
}

Dependencies._$name = 'Dependencies'; GridFeatureManager.registerFeature(Dependencies, false, 'Scheduler');

// region polyfills
// from https://github.com/eligrey/classList.js
if (document.createElementNS && !('classList' in document.createElementNS('http://www.w3.org/2000/svg', 'g'))) {
    (function(view) {
        if (!('Element' in view)) return;

        var classListProp         = 'classList',
            protoProp             = 'prototype',
            elemCtrProto          = view.Element[protoProp],
            objCtr                = Object,
            strTrim               = String[protoProp].trim || function() {
                return this.replace(/^\s+|\s+$/g, '');
            },
            arrIndexOf            = Array[protoProp].indexOf || function(item) {
                for (var i = 0, len = this.length; i < len; i++) {
                    if (i in this && this[i] === item) {
                        return i;
                    }
                }
                return -1;
            },
            // Vendors: please allow content code to instantiate DOMExceptions
            DOMEx                 = function(type, message) {
                this.name = type;
                this.code = DOMException[type]; // eslint-disable-line no-undef
                this.message = message;
            },
            checkTokenAndGetIndex = function(classList, token) {
                if (token === '') {
                    throw new DOMEx('SYNTAX_ERR', 'The token must not be empty.');
                }
                if (/\s/.test(token)) {
                    throw new DOMEx('INVALID_CHARACTER_ERR', 'The token must not contain space characters.');
                }
                return arrIndexOf.call(classList, token);
            },
            ClassList             = function(elem) {
                var trimmedClasses = strTrim.call(elem.getAttribute('class') || ''),
                    classes        = trimmedClasses ? trimmedClasses.split(/\s+/) : [];

                for (var i = 0, len = classes.length; i < len; i++) {
                    this.push(classes[i]);
                }
                this._updateClassName = function() {
                    elem.setAttribute('class', this.toString());
                };
            },
            classListProto        = ClassList[protoProp] = [],
            classListGetter       = function() {
                return new ClassList(this);
            };

        // Most DOMException implementations don't allow calling DOMException's toString()
        // on non-DOMExceptions. Error's toString() is sufficient here.
        DOMEx[protoProp] = Error[protoProp];
        classListProto.item = function(i) {
            return this[i] || null;
        };
        classListProto.contains = function(token) {
            return ~checkTokenAndGetIndex(this, token + '');
        };
        classListProto.add = function() {
            var tokens  = arguments,
                i       = 0,
                l       = tokens.length,
                token,
                updated = false;

            do {
                token = tokens[i] + '';
                if (!~checkTokenAndGetIndex(this, token)) {
                    this.push(token);
                    updated = true;
                }
            }
            while (++i < l);

            if (updated) {
                this._updateClassName();
            }
        };
        classListProto.remove = function() {
            var tokens  = arguments,
                i       = 0,
                l       = tokens.length,
                token,
                updated = false,
                index;

            do {
                token = tokens[i] + '';
                index = checkTokenAndGetIndex(this, token);
                while (~index) {
                    this.splice(index, 1);
                    updated = true;
                    index = checkTokenAndGetIndex(this, token);
                }
            }
            while (++i < l);

            if (updated) {
                this._updateClassName();
            }
        };
        classListProto.toggle = function(token, force) {
            var result = this.contains(token),
                method = result ? force !== true && 'remove' : force !== false && 'add';

            if (method) {
                this[method](token);
            }

            if (force === true || force === false) {
                return force;
            }
            else {
                return !result;
            }
        };
        classListProto.replace = function(token, replacementToken) {
            var index = checkTokenAndGetIndex(token + '');
            if (~index) {
                this.splice(index, 1, replacementToken);
                this._updateClassName();
            }
        };
        classListProto.toString = function() {
            return this.join(' ');
        };

        if (objCtr.defineProperty) {
            var classListPropDesc = {
                get          : classListGetter,
                enumerable   : true,
                configurable : true
            };
            try {
                objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
            }
            catch (ex) { // IE 8 doesn't support enumerable:true
                // adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36
                // modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected
                if (ex.number === undefined || ex.number === -0x7FF5EC54) {
                    classListPropDesc.enumerable = false;
                    objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
                }
            }
        }
        else if (objCtr[protoProp].__defineGetter__) {
            elemCtrProto.__defineGetter__(classListProp, classListGetter);
        }
    }(window));
}

// There is full or partial native classList support, so just check if we need
// to normalize the add/remove and toggle APIs.

(function() {
    var testElement = document.createElement('_');

    testElement.classList.add('c1', 'c2');

    // Polyfill for IE 10/11 and Firefox <26, where classList.add and
    // classList.remove exist but support only one argument at a time.
    if (!testElement.classList.contains('c2')) {
        var createMethod = function(method) {
            var original = DOMTokenList.prototype[method]; // eslint-disable-line no-undef

            DOMTokenList.prototype[method] = function(token) { // eslint-disable-line no-undef
                for (var i = 0, len = arguments.length; i < len; i++) {
                    token = arguments[i];
                    original.call(this, token);
                }
            };
        };
        createMethod('add');
        createMethod('remove');
    }

    testElement.classList.toggle('c3', false);

    // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
    // support the second argument.
    if (testElement.classList.contains('c3')) {
        var _toggle = DOMTokenList.prototype.toggle; // eslint-disable-line no-undef

        DOMTokenList.prototype.toggle = function(token, force) { // eslint-disable-line no-undef
            if (1 in arguments && !this.contains(token) === !force) {
                return force;
            }
            else {
                return _toggle.call(this, token);
            }
        };
    }

    // replace() polyfill
    if (!('replace' in document.createElement('_').classList)) {
        DOMTokenList.prototype.replace = function(token, replacementToken) { // eslint-disable-line no-undef
            var tokens = this.toString().split(' '),
                index  = tokens.indexOf(token + '');

            if (~index) {
                tokens = tokens.slice(index);
                this.remove.apply(this, tokens);
                this.add(replacementToken);
                this.add.apply(this, tokens.slice(1));
            }
        };
    }

    testElement = null;
}());
// endregion

/**
 * @module Scheduler/view/DependencyEditor
 */

/**
 * A dependency editor popup.
 *
 * @extends Core/widget/Popup
 * @private
 */
class DependencyEditor extends Popup {

    static get $name() {
        return 'DependencyEditor';
    }

    static get defaultConfig() {
        return {
            items     : [],
            draggable : {
                handleSelector : ':not(button,.b-field-inner)' // blacklist buttons and field inners
            },
            axisLock : 'flexible'
        };
    }

    processWidgetConfig(widget) {
        const dependencyEditFeature = this.dependencyEditFeature;

        let fieldConfig = {};

        if (widget.ref === 'lagField' && !dependencyEditFeature.showLagField) {
            return false;
        }
        if (widget.ref === 'deleteButton' && !dependencyEditFeature.showDeleteButton) {
            return false;
        }

        Object.assign(widget, fieldConfig);

        return super.processWidgetConfig(widget);
    }

    afterShow(...args) {
        const deleteButton = this.widgetMap.deleteButton;

        // Only show delete button if the dependency record belongs to a store
        if (deleteButton) {
            deleteButton.hidden = !this.record.isPartOfStore();
        }
        super.afterShow(...args);
    }

    onInternalKeyDown(event) {
        this.trigger('keyDown', { event });
        super.onInternalKeyDown(event);
    }
}
DependencyEditor._$name = 'DependencyEditor';

/**
 * @module Scheduler/feature/DependencyEdit
 */

/**
 * Feature that displays a popup containing fields for editing a dependency. Requires the {@link Scheduler.feature.Dependencies Dependencies} feature to be enabled.
 *
 * This feature is **disabled** by default. It does **not** support vertical mode.
 *
 * @extends Core/mixin/InstancePlugin
 * @externalexample scheduler/Dependencies.js
 * @demo Scheduler/dependencies
 */
class DependencyEdit extends InstancePlugin {
    //region Config

    static get $name() {
        return 'DependencyEdit';
    }

    static get defaultConfig() {
        return {
            /**
             * True to hide this editor if a click is detected outside it (defaults to true)
             * @config {Boolean}
             * @default
             * @category Editor
             */
            autoClose : true,

            /**
             * True to save and close this panel if ENTER is pressed in one of the input fields inside the panel.
             * @config {Boolean}
             * @default
             * @category Editor
             */
            saveAndCloseOnEnter : true,

            /**
             * True to show a delete button in the form.
             * @config {Boolean}
             * @default
             * @category Editor widgets
             */
            showDeleteButton : true,

            /**
             * The event that shall trigger showing the editor. Defaults to `dependencydblclick`, set to empty string or `null` to disable editing of dependencies.
             * @config {String}
             * @default
             * @category Editor
             */
            triggerEvent : 'dependencydblclick',

            /**
             * True to show the lag field for the dependency
             * @config {Boolean}
             * @default
             * @category Editor widgets
             */
            showLagField : false,

            dependencyRecord : null,

            /**
             * Default editor configuration, used to configure the Popup.
             * @config {Object}
             * @category Editor
             */
            editorConfig : {
                title       : 'L{Edit dependency}',
                localeClass : this,
                closable    : true,

                items : [
                    /**
                     * Reference to the from name
                     * @member {Core.widget.DisplayField} fromNameField
                     * @readonly
                     */
                    {
                        type        : 'display',
                        localeClass : this,
                        label       : 'L{From}',
                        editable    : false,
                        ref         : 'fromNameField'
                    },
                    /**
                     * Reference to the to name field
                     * @member {Core.widget.DisplayField} toNameField
                     * @readonly
                     */
                    {
                        type        : 'display',
                        localeClass : this,
                        label       : 'L{To}',
                        ref         : 'toNameField'
                    },
                    /**
                     * Reference to the type field
                     * @member {Core.widget.Combo} typeField
                     * @readonly
                     */
                    {
                        type         : 'combo',
                        localeClass  : this,
                        label        : 'L{Type}',
                        name         : 'type',
                        ref          : 'typeField',
                        editable     : false,
                        valueField   : 'id',
                        displayField : 'name',
                        items        : Object.keys(DependencyModel.Type).map(type => {
                            return  {
                                id   : DependencyModel.Type[type],
                                name : this.L(type)
                            };
                        })
                    },

                    /**
                     * Reference to the lag field
                     * @member {Core.widget.DurationField} lagField
                     * @readonly
                     */
                    {
                        type        : 'duration',
                        localeClass : this,
                        label       : 'L{Lag}',
                        name        : 'lag',
                        ref         : 'lagField',
                        allowNegative : true
                    }
                ],

                bbar : [
                    {
                        type : 'widget',
                        cls  : 'b-label-filler'
                    },
                    /**
                     * Reference to the save button, if used
                     * @member {Core.widget.Button} saveButton
                     * @readonly
                     */
                    {
                        color       : 'b-green',
                        localeClass : this,
                        text        : 'L{Save}',
                        ref         : 'saveButton'
                    },
                    /**
                     * Reference to the delete button, if used
                     * @member {Core.widget.Button} deleteButton
                     * @readonly
                     */
                    {
                        color       : 'b-gray',
                        localeClass : this,
                        text        : 'L{Delete}',
                        ref         : 'deleteButton'
                    },
                    /**
                     * Reference to the cancel button, if used
                     * @member {Core.widget.Button} cancelButton
                     * @readonly
                     */
                    {
                        color       : 'b-gray',
                        localeClass : this,
                        text        : 'L{Cancel}',
                        ref         : 'cancelButton'
                    }
                ]
            }
        };
    }

    //endregion

    //region Init & destroy

    construct(client, config) {
        const me = this;

        client.dependencyEdit = me;

        me.dependencyStore = client.dependencyStore;

        super.construct(client, config);

        if (!client.features.dependencies) {
            throw new Error('Dependencies feature required when using DependencyEdit');
        }

        me.clientListenersDetacher = client.on({
            [me.triggerEvent] : me.onActivateEditor,
            thisObj           : me
        });
    }

    doDestroy() {
        this.clientListenersDetacher();

        this.editor && this.editor.destroy();

        super.doDestroy();
    }

    //endregion

    //region Editing

    get editorConfig() {
        return this._editorConfig;
    }

    set editorConfig(editorConfig) {
        const me = this,
            defaultEditorConfig = me.getDefaultConfiguration().editorConfig;

        // Apply editorConfig to the default editorConfig, allowing users to manipulate for example only bbar
        editorConfig = ObjectHelper.assign({}, defaultEditorConfig, editorConfig);

        editorConfig.items = editorConfig.items || [];

        me._editorConfig = editorConfig;
    }

    //endregion

    //region Save

    get isValid() {
        return Object.values(this.editor.widgetMap).every(field => {
            if (!field.name || field.hidden) {
                return true;
            }

            return field.isValid !== false;
        });
    }

    get values() {
        const values = {};

        this.editor.eachWidget(widget => {
            if (!widget.name || widget.hidden) return;

            values[widget.name] = widget.value;
        }, true);

        return values;
    }

    /**
     * Template method, intended to be overridden. Called before the dependency record has been updated.
     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record
     *
     **/
    onBeforeSave(dependencyRecord) {}

    /**
     * Template method, intended to be overridden. Called after the dependency record has been updated.
     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record
     *
     **/
    onAfterSave(dependencyRecord) {}

    /**
     * Updates record being edited with values from the editor
     * @private
     */
    updateRecord(dependency) {
        const values = this.values;

        dependency.beginBatch();

        dependency.set(values);

        if (this.lagField) {
            const lag = this.lagField.value;

            dependency.setLag(lag.magnitude, lag.unit);
        }

        if (this.typeField && 'type' in values) {
            dependency.set({ fromSide : null, toSide : null });
        }

        dependency.endBatch();
    }
    //endregion

    //region Events

    onPopupKeyDown({ event }) {
        if (event.key === 'Enter' && this.saveAndCloseOnEnter && event.target.tagName.toLowerCase() === 'input') {
            // Need to prevent this key events from being fired on whatever receives focus after the editor is hidden
            event.preventDefault();

            this.onSaveClick();
        }
    }

    onSaveClick() {
        if (this.save()) {
            this.editor.hide();
        }
    }

    onDeleteClick() {
        this.deleteDependency();
        this.editor.hide();
    }

    onCancelClick() {
        this.editor.hide();
    }

    //region Editing

    // Called from editDependency() to actually show the editor
    internalShowEditor(dependencyRecord) {
        const me               = this,
            scheduler        = me.client;

        let showPoint = me.lastPointerDownCoordinate;

        /**
         * Fires on the owning Scheduler before an dependency is displayed in the editor.
         * This may be listened for to allow an application to take over dependency editing duties. Returning `false`
         * stops the default editing UI from being shown.
         * @event beforeDependencyEdit
         * @param {Scheduler.view.Scheduler} source The scheduler
         * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependencyEdit feature
         * @param {Scheduler.model.DependencyModel} dependencyRecord The record about to be shown in the editor.
         * @preventable
         */
        if (scheduler.trigger('beforeDependencyEdit', {
            dependencyEdit : me,
            dependencyRecord
        }) === false) {
            return;
        }

        const editor = me.getEditor(dependencyRecord);

        me.loadRecord(dependencyRecord);

        /**
         * Fires on the owning Scheduler when the editor for a dependency is available but before it is shown. Allows
         * manipulating fields before the widget is shown.
         * @event beforeDependencyEditShow
         * @param {Scheduler.view.Scheduler} source The scheduler
         * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependencyEdit feature
         * @param {Scheduler.model.DependencyModel} dependencyRecord The record about to be shown in the editor.
         * @param {Core.widget.Popup} editor The editor popup
         */
        scheduler.trigger('beforeDependencyEditShow', {
            dependencyEdit : me,
            dependencyRecord,
            editor
        });

        if (!showPoint) {
            const center = Rectangle.from(me.client.element).center;

            showPoint = [center.x - editor.width / 2, center.y - editor.height / 2];
        }

        editor.showByPoint(showPoint);
    }

    /**
     * Opens a popup to edit the passed dependency.
     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency to edit
     */
    editDependency(dependencyRecord) {
        if (this.client.readOnly) return;

        this.internalShowEditor(dependencyRecord);
    }

    //endregion

    //region Save

    /**
     * Gets an editor instance. Creates on first call, reuses on consecutive
     * @internal
     * @returns {Scheduler.view.DependencyEditor} Editor popup
     */
    getEditor() {
        const me = this;

        let { editor } = me;

        if (editor) {
            return editor;
        }

        editor = me.editor = new DependencyEditor(ObjectHelper.assign({
            dependencyEditFeature : me,
            autoShow              : false,
            anchor                : true,
            scrollAction          : 'realign',
            clippedBy             : [me.client.timeAxisSubGridElement, me.client.bodyContainer],
            constrainTo           : window,
            autoClose             : me.autoClose,
            cls                   : me.cls,
            listeners             : {
                keydown : me.onPopupKeyDown,
                thisObj : me
            }
        }, me.editorConfig));

        if (editor.items.length === 0) {
            console.warn('Editor configured without any `items`');
        }

        // assign widget refs
        editor.eachWidget(widget => {
            const ref = widget.ref || widget.id;
            // don't overwrite if already defined
            if (ref && !me[ref]) {
                me[ref] = widget;
            }
        });

        me.saveButton && me.saveButton.on('click', me.onSaveClick, me);
        me.deleteButton && me.deleteButton.on('click', me.onDeleteClick, me);
        me.cancelButton && me.cancelButton.on('click', me.onCancelClick, me);

        return me.editor;
    }

    //endregion

    //region Delete

    /**
     * Sets fields values from record being edited
     * @private
     */
    loadRecord(dependency) {
        const me = this;

        me.fromNameField.value = dependency.sourceEvent.name;
        me.toNameField.value = dependency.targetEvent.name;

        if (me.lagField) {
            me.lagField.unit = dependency.lagUnit;
        }

        me.editor.record = me.dependencyRecord = dependency;
    }

    //endregion

    //region Stores

    /**
     * Saves the changes (applies them to record if valid, if invalid editor stays open)
     * @private
     * @fires beforeDependencySave
     * @fires beforeDependencyAdd
     * @fires afterDependencySave
     * @returns {*}
     */
    save() {
        const me                                      = this,
            { client, dependencyRecord } = me;

        if (!dependencyRecord || !me.isValid) return;

        const dependencyStore = me.dependencyStore,
            values          = me.values;

        /**
         * Fires on the owning Scheduler before a dependency is saved
         * @event beforeDependencySave
         * @param {Scheduler.view.Scheduler} source The scheduler instance
         * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be saved
         * @param {Object} values The new values
         * @preventable
         */
        if (client.trigger('beforeDependencySave', {
            dependencyRecord,
            values
        }) !== false) {
            me.onBeforeSave(dependencyRecord);

            me.updateRecord(dependencyRecord);

            // Check if this is a new record
            if (dependencyStore && !dependencyRecord.stores.length) {
                /**
                 * Fires on the owning Scheduler before a dependency is added
                 * @event beforeDependencyAdd
                 * @param {Scheduler.view.Scheduler} source The scheduler
                 * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependency edit feature
                 * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be added
                 * @preventable
                 */
                if (client.trigger('beforeDependencyAdd', { dependencyRecord, dependencyEdit : me }) !== false) {
                    dependencyStore.add(dependencyRecord);
                }
                else {
                    return;
                }
            }

            client.project && client.project.propagate();

            /**
             * Fires on the owning Scheduler after a dependency is successfully saved
             * @event afterDependencySave
             * @param {Scheduler.view.Scheduler} source The scheduler instance
             * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be saved
             */
            client.trigger('afterDependencySave', { dependencyRecord });
            me.onAfterSave(dependencyRecord);
        }

        return dependencyRecord;
    }

    /**
     * Delete dependency being edited
     * @private
     * @fires beforeDependencyDelete
     */
    deleteDependency() {
        const me               = this;

        /**
         * Fires on the owning Scheduler before a dependency is deleted
         * @event beforeDependencyDelete
         * @param {Scheduler.view.Scheduler} source The scheduler instance
         * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record about to be deleted
         * @preventable
         */
        if (me.client.trigger('beforeDependencyDelete', { dependencyRecord : me.dependencyRecord }) !== false) {
            if (me.editor.containsFocus) {
                me.editor.revertFocus();
            }

            me.client.dependencyStore.remove(me.dependencyRecord);
            me.client.project && me.client.project.propagate();

            return true;
        }

        return false;
    }

    //endregion

    //region Events

    onActivateEditor({ dependency, event }) {
        if (!this.disabled) {
            this.lastPointerDownCoordinate = [event.clientX, event.clientY];
            this.editDependency(dependency);
        }
    }

    //endregion
}

DependencyEdit._$name = 'DependencyEdit'; GridFeatureManager.registerFeature(DependencyEdit, false);

/**
 * @module Scheduler/feature/base/TimeSpanRecordContextMenuBase
 */

// This is a version of what Containers do, except that we have to apply our namedItems
// all the way down any configured menu hierarchy, and the resulting structure must
// be available *before* menu instantiation for the processItems method to interrogate.
const applyNamedItems = function(items, namedItems) {
    for (const ref in items) {
        let item = items[ref];
        if (item) {
            if (ref in namedItems) {
                item = items[ref] = typeof item === 'object' ? ObjectHelper.merge(ObjectHelper.clone(namedItems[ref]), item) : namedItems[ref];
            }

            // Our namedItems must apply all the way down any descendant menus.
            // Extract menu here because it may have been applied by a namedItem.
            const menu = item.menu;
            if (menu) {
                applyNamedItems(('items' in menu) ? menu.items : menu, namedItems);
            }
        }
    }
};

/**
 * Abstract base class used by other context menu features such as {@link Scheduler/feature/EventContextMenu EventContextMenu} and
 * {@link Scheduler/feature/ScheduleContextMenu ScheduleContextMenu}.
 * @extends Core/mixin/InstancePlugin
 * @abstract
 */
class TimeSpanRecordContextMenuBase extends InstancePlugin {
    //region Config
    static get defaultConfig() {
        return {
            /**
             * This is a preconfigured set of {@link Core.widget.Container#config-namedItems} used to create the default
             * context menu.
             * @config {Object}
             */
            defaultItems : null,

            /**
             * An {@link Core.widget.Menu Menu} items object containing named child menu items
             * to apply to the feature's provided context menu, see {@link #config-defaultItems}.
             *
             * This may add extra items as below, but may also remove any of the {@link #config-defaultItems}
             * by configuring the name of the item as `false`
             *
             * ```javascript
             * features : {
             *     taskContextMenu : { // use eventContextMenu in the Scheduler product
             *         // This object is applied to the Feature's predefined defaultItems object
             *         items : {
             *             switchToDog : {
             *                 text : 'Dog',
             *                 icon : 'b-fa b-fa-fw b-fa-dog',
             *                 onItem({contextRecord}) {
             *                     contextRecord.dog = true;
             *                     contextRecord.cat = false;
             *                 },
             *                 weight : 500     // Make this second from end
             *             },
             *             switchToCat : {
             *                 text : 'Cat',
             *                 icon : 'b-fa b-fa-fw b-fa-cat',
             *                 onItem({contextRecord}) {
             *                     contextRecord.dog = false;
             *                     contextRecord.cat = true;
             *                 },
             *                 weight : 510     // Make this sink to end
             *             },
             *             add : false // We do not want the "Add" submenu to be available
             *         }
             *     }
             * }
             * ```
             *
             * @config {Object|Object[]}
             */
            items : null,

            /**
             * A function called before displaying the menu that allows manipulations of its items. Called with a
             * single parameter with format { contextRecord, eventElement, items }. Returning `false`
             * from this function prevents the menu from being shown.
             *
             * ```javascript
             * features : {
             *     taskContextMenu : {
             *         processItems({contextRecord, items}) {
             *             // Add or remove items here as needed
             *             if (contextRecord.type === 'Meeting') {
             *                 items.cancel = {
             *                     text   : 'Cancel',
             *                     icon   : 'b-fa b-fa-fw b-fa-ban',
             *                     weight : 200 // Move to end
             *                 };
             *             }
             *
             *             // Hide delete for parents
             *             items.deleteTask.hidden = contextRecord.isParent;
             *         }
             *     }
             * }
             * ```
             *
             * @config {Function}
             */
            processItems : null,

            /**
             * Event which is used to show context menu.
             * Available options are: 'contextmenu', 'click', 'dblclick'.
             * Default value is used from {@link Grid/view/GridBase#config-contextMenuTriggerEvent}
             * @config {String}
             */
            triggerEvent : null

        };
    }

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            assign : ['showEventContextMenu'],
            chain  : [
                'onElementContextMenu',
                'onElementClick',
                'onElementDblClick',
                'onEventSpaceKey'
            ]
        };
    }

    //endregion

    //region Init

    doDestroy() {
        if (this.menu) {
            this.menu.destroy();
        }
    }

    //endregion

    //region Events

    onElementContextMenu(event) {
        this.triggerEvent === 'contextmenu' && this.showEventContextMenu(event);
    }

    onElementClick(event) {
        this.triggerEvent === 'click' && this.showEventContextMenu(event);
    }

    onElementDblClick(event) {
        this.triggerEvent === 'dblclick' && this.showEventContextMenu(event);
    }

    // chained from EventNavigation
    onEventSpaceKey(keyEvent) {
        const targetPoint = Rectangle.from(keyEvent.target).center,
            contextmenuEvent = new MouseEvent('contextmenu', Object.assign({
                clientX : targetPoint.x,
                clientY : targetPoint.y
            }, keyEvent));

        Object.defineProperty(contextmenuEvent, 'target', {
            get() {
                return keyEvent.target;
            }
        });

        this.showEventContextMenu(contextmenuEvent);
    }

    //endregion

    //region Menu handlers

    /**
     * Show event context menu.
     * @param event
     * @fires eventContextMenuItem
     * @internal
     */
    showEventContextMenu(event) {
        const
            me           = this,
            client       = me.client,
            target       = event.target,
            eventElement = DomHelper.up(target, client.eventSelector) || target;

        if (eventElement) {
            const record = me.resolveRecord(eventElement);

            if (record) {
                event.preventDefault();
                me.showContextMenuFor(record, { targetElement : eventElement, event });
            }
        }
    }

    /**
     * Shows context menu for the provided record. If record is not rendered (outside of time span, or collapsed)
     * menu won't appear.
     * @param {Scheduler.model.TimeSpan} record
     * @param {Object} [options]
     * @param {HTMLElement} options.targetElement Element to align context menu to
     * @param {Event} options.event Browser event. If provided menu will be aligned according to clientX/clientY coordinates.
     * If omitted, context menu will be centered to targetElement
     */
    showContextMenuFor(record, options) {}

    // Implement in subclasses to massage options or veto show.
    beforeContextMenuShow() {}

    //endregion

    //region Show/Hide

    /**
     * @param {Object} eventParams
     * @param {Object[]} items
     * @protected
     * @internal
     */
    showContextMenu(eventParams) {
        if (this.disabled) {
            return;
        }

        const
            me                       = this,
            event                    = eventParams.event,
            menuType                 = eventParams.menuType.toLowerCase(),
            eventType                = StringHelper.lowercaseFirstLetter(menuType),
            clientGetItemsMethod     = `get${StringHelper.capitalizeFirstLetter(menuType)}MenuItems`,
            { client, processItems, defaultItems, namedItems } = me,
            point = event ? [event.clientX + 1, event.clientY + 1] : Rectangle.from(eventParams.targetElement).center;
        
        let items = eventParams.items = ObjectHelper.isEmpty(me.items) ? ObjectHelper.clone(defaultItems) : ObjectHelper.merge(ObjectHelper.clone(defaultItems), me.items);

        eventParams.namedItems = namedItems;
        eventParams.selection = client.selectedRecords;
    
        const
            column    = client.getColumnFromElement(eventParams.targetElement),
            cellItems = [];
        
        if (column) {
            client.getCellMenuItems(column, eventParams.taskRecord, cellItems);
            
            const namedCellItems = cellItems.reduce((result, item) => {
                result[item.name] = item;
                
                return result;
            }, {});
    
            items = eventParams.items = ObjectHelper.copyPropertiesIf(items, namedCellItems, Object.keys(namedCellItems));
        }

        // Apply the named items prior to Container's item processing.
        // Our namedItems must cascade to all descendant Menu levels.
        // And they MUST have all been converted prior to the processItems call.
        applyNamedItems(items, namedItems);

        // Call the chainable method which other features use to add their own menu items.
        // For example getEventMenuItems
        if (client[clientGetItemsMethod]) {
            client[clientGetItemsMethod](eventParams, items);
        }

        // Allow user a chance at processing the items and preventing the menu from showing
        if ((!processItems || processItems(eventParams) !== false) && !ObjectHelper.isEmpty(eventParams.items)) {

            // beforeContextMenuShow is a lifecycle method which may be implemented in subclasses to
            // preprocess the event.
            if (me.beforeContextMenuShow(eventParams) !== false) {
                // Trigger event that allows preventing menu or manipulating its items
                if (client.trigger(`${eventType}ContextMenuBeforeShow`, eventParams) !== false) {
                    me.menu = WidgetHelper.showContextMenu(point, {
                        owner        : client,
                        scrollAction : 'hide',
                        clippedBy    : [client.timeAxisSubGridElement, client.bodyContainer],
                        constrainTo  : window,
                        items,
                        onDestroy() {
                            me.menu = null;
                        },
                        // Load up the item event with the contextual info
                        onBeforeItem : itemEvent => {
                            Object.assign(itemEvent, eventParams);
                        },

                        onItem : itemEvent => client.trigger(`${eventType}ContextMenuItem`, itemEvent),

                        listeners : {
                            show({ source : menu }) {
                                eventParams.menu = menu;
                                client.trigger(`${eventType}ContextMenuShow`, eventParams);
                            }
                        }
                    });
                }
            }
        }
    }

    /**
     * Hides the context menu
     * @protected
     * @internal
     */
    hideContextMenu(animate) {
        this.menu && this.menu.hide(animate);
    }

    //endregion

    //region Getters/Setters

    /**
     * Provides the default configuration of the context menu.
     *
     * Concrete classes must all provide their own defaultItems value in their defaultConfig blocks
     * @private
     */
    set defaultItems(defaultItems) {
        this._defaultItems = defaultItems;
    }

    get defaultItems() {
        const result = ObjectHelper.clone(this._defaultItems);

        // Read-only client should have no default items enabled
        if (this.client.readOnly) {
            for (const item in result) {
                result[item] = false;
            }
        }

        return result;
    }

    get triggerEvent() {
        return this._triggerEvent || this.client.contextMenuTriggerEvent;
    }

    set triggerEvent(value) {
        this._triggerEvent = value;
    }

    //endregion

}
TimeSpanRecordContextMenuBase._$name = 'TimeSpanRecordContextMenuBase';

/**
 * @module Scheduler/feature/EventContextMenu
 */

/**
 * Displays a context menu for events. Items are populated by other features and/or application code.
 *
 * To add extra items for all events (Array notation):
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         eventContextMenu : {
 *             // Extra items for all events
 *             items : [
 *                 {
 *                     text : 'Extra',
 *                     icon : 'b-fa b-fa-fw b-fa-flag',
 *                     onItem({eventRecord}) {
 *                         eventRecord.flagged = true;
 *                     }
 *                 }
 *             ]
 *         }
 *     }
 * });
 * ```
 *
 * To add extra items for all events (Object notation):
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         eventContextMenu : {
 *             // Extra items for all events
 *             items : {
 *                 extraItems : {
 *                     text : 'Extra',
 *                     icon : 'b-fa b-fa-fw b-fa-flag',
 *                     onItem({eventRecord}) {
 *                         eventRecord.flagged = true;
 *                     }
 *                 }
 *             }
 *         }
 *     }
 * });
 * ```
 *
 * To remove existing items:
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         eventContextMenu : {
 *             items : {
 *                 deleteEvent   : false,
 *                 unassignEvent : false
 *             }
 *         }
 *     }
 * });
 * ```
 *
 * Manipulate existing items for all events or specific events:
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         eventContextMenu : {
 *             // Process items before menu is shown
 *             processItems({eventRecord, items}) {
 *                  // Push an extra item for conferences
 *                  if (eventRecord.type === 'conference') {
 *                      items.showSessionItem = {
 *                          text : 'Show sessions',
 *                          onItem({eventRecord}) {
 *                              // ...
 *                          }
 *                      };
 *                  }
 *
 *                  // Do not show menu for secret events
 *                  if (eventRecord.type === 'secret') {
 *                      return false;
 *                  }
 *             }
 *         }
 *     }
 * });
 * ```
 *
 * This feature is **enabled** by default
 *
 * @extends Scheduler/feature/base/TimeSpanRecordContextMenuBase
 * @demo Scheduler/eventcontextmenu
 */
class EventContextMenu extends TimeSpanRecordContextMenuBase {
    //region Config

    static get $name() {
        return 'EventContextMenu';
    }

    static get defaultConfig() {
        return {
            /**
             * An array of extra menu items to add to the context menu
             *
             * ```javascript
             * const scheduler = new Scheduler({
             *     features : {
             *         eventContextMenu : {
             *             // Extra items for all events
             *             items : [
             *                 {
             *                     text : 'Extra',
             *                     icon : 'b-fa b-fa-fw b-fa-flag',
             *                     onItem({eventRecord}) {
             *                         eventRecord.flagged = true;
             *                     }
             *                 }
             *             ]
             *         }
             *     }
             * });
             * ```
             *
             * or items config to add extra items to the context menu or hide default items
             *
             * ```javascript
             * const scheduler = new Scheduler({
             *     features : {
             *         eventContextMenu : {
             *             items : {
             *                 // Add custom 'Extra' item
             *                 extra : {
             *                     text : 'Extra',
             *                     icon : 'b-fa b-fa-fw b-fa-flag',
             *                     onItem({eventRecord}) {
             *                         eventRecord.flagged = true;
             *                     }
             *                 },
             *                 // Hide default 'Delete event' and 'Unassign event' items
             *                 deleteEvent   : false,
             *                 unassignEvent : false
             *             }
             *         }
             *     }
             * });
             * ```
             *
             * @config {Object|Object[]}
             */
            items : null,

            /**
             * A function called before displaying the menu that allows manipulations of its items.
             * Called with a single parameter with format { date, resourceRecord, items }.
             * Returning `false` from this function prevents the menu from being shown.
             *
             * ```javascript
             * features : {
             *     eventContextMenu : {
             *         // Process items before menu is shown
             *         processItems({eventRecord, items}) {
             *              // Push an extra item for conferences
             *              if (eventRecord.type === 'conference') {
             *                  items.showSessionItem = {
             *                      text : 'Show sessions',
             *                      onItem({eventRecord}) {
             *                          // ...
             *                      }
             *                  };
             *              }
             *
             *              // Do not show menu for secret events
             *              if (eventRecord.type === 'secret') {
             *                  return false;
             *              }
             *         }
             *     }
             * }
             * ```
             *
             * @config {Function}
             */
            processItems : null,

            /**
             * This is a preconfigured set of {@link Core.widget.Container#config-namedItems} used to create the default context menu.
             *
             * The provided defaultItems setting is
             *
             *```javascript
             *    {
             *        deleteEvent   : true,
             *        unassignEvent : true
             *    }
             *```
             *
             * The `namedItems` provided by this feature are listed below. These are the property
             * names which you may configure in the feature's {@link #config-items} config:
             *
             * - `deleteEvent` Deletes the context event.
             * - `unassignEvent` Unassigns the context event from the context resource.
             *
             * To remove existing items, set corresponding keys to `false`
             *
             * ```javascript
             * const scheduler = new Scheduler({
             *     features : {
             *         eventContextMenu : {
             *             items : {
             *                 deleteEvent   : false,
             *                 unassignEvent : false
             *             }
             *         }
             *     }
             * });
             * ```
             *
             * See the feature config in the above example for details.
             * @config {Object}
             */
            defaultItems : {
                deleteEvent   : true,
                unassignEvent : true
            }
        };
    }
    //endregion

    //region Events

    /**
     * Fired from scheduler before the context menu is shown for an event. Allows manipulation of the items
     * to show in the same way as in `processItems`. Returning false from a listener prevents the menu from
     * being shown.
     * @event eventContextMenuBeforeShow
     * @preventable
     * @param {Scheduler.view.Scheduler} source
     * @param {Object} items Menu item configs
     * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered
     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used
     * @param {HTMLElement} eventElement
     */

    /**
     * Fired from scheduler when an item is selected in the context menu.
     * @event eventContextMenuItem
     * @param {Scheduler.view.Scheduler} source
     * @param {Core.widget.MenuItem} item
     * @param {Scheduler.model.EventModel} eventRecord
     * @param {Scheduler.model.ResourceModel} resourceRecord
     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used
     * @param {HTMLElement} eventElement
     */

    /**
     * Fired from scheduler after showing the context menu for an event
     * @event eventContextMenuShow
     * @preventable
     * @param {Scheduler.view.Scheduler} source
     * @param {Core.widget.Menu} menu The menu
     * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered
     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used
     * @param {HTMLElement} eventElement
     */

    //endregion

    //region Events

    resolveRecord(element) {
        return this.client.resolveEventRecord(element);
    }

    //endregion

    /**
     * Shows context menu for the provided event. If record is not rendered (outside of time span/filtered)
     * menu won't appear.
     * @param {Scheduler.model.EventModel} eventRecord
     * @param {Object} [options]
     * @param {HTMLElement} options.targetElement Element to align context menu to
     * @param {Event} options.event Browser event. If provided menu will be aligned according to clientX/clientY coordinates.
     * If omitted, context menu will be centered to taskElement
     */
    showContextMenuFor(eventRecord, { targetElement, event } = {}) {
        const
            me         = this,
            { client } = me;

        if (!targetElement) {
            targetElement = client.getElementsFromEventRecord(eventRecord)[0];

            // If record is not rendered, do nothing
            if (!targetElement) {
                return;
            }
        }

        me.showContextMenu({
            menuType         : 'event',
            eventElement     : targetElement,
            targetElement,
            eventRecord,
            resourceRecord   : client.resolveResourceRecord(targetElement),
            assignmentRecord : client.resolveAssignmentRecord(targetElement),
            event
        });
    }

    set defaultItems(defaultItems) {
        this._defaultItems = defaultItems;
    }

    get defaultItems() {
        const result = super.defaultItems;

        if (!this.client.assignmentStore) {
            result.unassignEvent = false;
        }

        return result;
    }

    get namedItems() {
        const
            me         = this,
            { client } = me;

        if (!me._namedItems) {
            me._namedItems = {
                deleteEvent : {
                    text   : client.L('Delete event'),
                    icon   : 'b-icon b-icon-trash',
                    weight : -160,
                    onItem : ({ menu, eventRecord }) => {
                        // We must synchronously push focus back into the menu's triggering
                        // event so that the our beforeRemove handlers can move focus onwards
                        // to the closest remaining event.
                        // Otherwise, the menu's default hide processing on hide will attempt
                        // to move focus back to the menu's triggering event which will
                        // by then have been deleted.
                        const revertTarget = menu.focusInEvent && menu.focusInEvent.relatedTarget;
                        if (revertTarget) {
                            revertTarget.focus();
                            client.navigator.activeItem = revertTarget;
                        }
                        client.removeRecords([eventRecord]);
                    }
                },
                unassignEvent : {
                    text   : client.L('Unassign event'),
                    icon   : 'b-icon b-icon-unassign',
                    weight : -150,
                    name   : 'unassignEvent',
                    onItem : ({ menu, eventRecord, resourceRecord }) => {
                        // We must synchronously push focus back into the menu's triggering
                        // event so that the our beforeRemove handlers can move focus onwards
                        // to the closest remaining event.
                        // Otherwise, the menu's default hide processing on hide will attempt
                        // to move focus back to the menu's triggering event which will
                        // by then have been deleted.
                        const revertTarget = menu.focusInEvent && menu.focusInEvent.relatedTarget;
                        if (revertTarget) {
                            revertTarget.focus();
                            client.navigator.activeItem = revertTarget;
                        }
                        eventRecord.unassign(resourceRecord);
                    }
                }
            };
        }

        return me._namedItems;
    }
}

EventContextMenu.featureClass = '';

EventContextMenu._$name = 'EventContextMenu'; GridFeatureManager.registerFeature(EventContextMenu, true, 'Scheduler');

//import styles from '../../../resources/sass/tooltip/clocktemplate.scss';

/**
 * @module Scheduler/tooltip/ClockTemplate
 */

/**
 * A template showing a clock, it consumes an object containing a date and a text
 * @private
 */
class ClockTemplate extends Base {
    static get defaultConfig() {
        return {
            minuteHeight : 8,
            minuteTop    : 2,
            hourHeight   : 8,
            hourTop      : 2,
            handLeft     : 10,
            div          : document.createElement('div'),
            scheduler    : null, // should be passed to the constructor
            // `b-sch-clock-day` for calendar icon
            // `b-sch-clock-hour` for clock icon
            template     : function(data) {
                return `<div class="b-sch-clockwrap b-sch-clock-${this.mode} ${data.cls || ''}">
                    <div class="b-sch-clock">
                        <div class="b-sch-hour-indicator">${DateHelper.format(data.date, 'MMM')}</div>
                        <div class="b-sch-minute-indicator">${DateHelper.format(data.date, 'D')}</div>
                        <div class="b-sch-clock-dot"></div>
                    </div>
                    <span class="b-sch-clock-text">${data.text}</span>
                </div>`;
            }
        };
    }

    construct(config) {
        super.construct(config);

        
    }

    generateContent(data) {
        const
            me   = this,
            date = data.date,
            html = me.template(data),
            div  = me.div;

        div.innerHTML = html;
        me.updateDateIndicator(div, date);

        return div.innerHTML;
    }

    updateDateIndicator(el, date) {
        const
            hourIndicatorEl   = el.querySelector('.b-sch-hour-indicator'),
            minuteIndicatorEl = el.querySelector('.b-sch-minute-indicator');

        if (date && hourIndicatorEl && minuteIndicatorEl) {
            if (this.mode === 'hour') {
                hourIndicatorEl.style.transform   = `rotate(${(date.getHours() % 12) * 30}deg)`;
                minuteIndicatorEl.style.transform = `rotate(${date.getMinutes() * 6}deg)`;
            } else {
                hourIndicatorEl.style.transform   = 'none';
                minuteIndicatorEl.style.transform = 'none';
            }
        }
    }

    // `day` mode for calendar icon
    // `hour` mode for clock icon
    get mode() {
        const
            unitLessThanDay        = DateHelper.compareUnits(this.scheduler.timeAxisViewModel.timeResolution.unit, 'day') < 0,
            formatContainsHourInfo = DateHelper.formatContainsHourInfo(this.scheduler.displayDateFormat);

        return unitLessThanDay && formatContainsHourInfo ? 'hour' : 'day';
    }

    set template(template) {
        this._template = template;
    }

    /**
     * Get the clock template, which accepts an object of format { date, text }
     * @returns {function(*): string}
     */
    get template() {
        return this._template;
    }
}
ClockTemplate._$name = 'ClockTemplate';

/**
 * @module Scheduler/feature/base/DragBase
 */

//TODO: shift to copy
//TODO: dragging of event that starts & ends outside of view

/**
 * Base class for EventDrag (Scheduler) and TaskDrag (Gantt) features. Contains shared code. Not to be used directly.
 *
 * @extends Core/mixin/InstancePlugin
 * @abstract
 */
class DragBase extends InstancePlugin {
    //region Config

    static get defaultConfig() {
        return {
            // documented on Schedulers EventDrag feature and Gantts TaskDrag
            dragTipTemplate : data => `
                <div class="b-sch-tip-${data.valid ? 'valid' : 'invalid'}">
                    ${data.startClockHtml}
                    ${data.endClockHtml}
                    <div class="b-sch-tip-message">${data.message}</div>
                </div>
            `,

            // documented on Schedulers EventDrag feature, not used for Gantt
            constrainDragToResource : true,

            /**
             * Specifies whether or not to show tooltip while dragging event
             * @config {Boolean}
             * @default
             */
            showTooltip : true,

            /**
             * When enabled, the event being dragged always "snaps" to the exact start date that it will have after drop.
             * @config {Boolean}
             * @default
             */
            showExactDropPosition : false,

            /**
             * Set to `false` to allow dragging tasks outside of the client Scheduler.
             * Useful when you want to drag tasks between multiple Scheduler instances
             * @config {Boolean}
             * @default
             */
            constrainDragToTimeline : true,

            /*
            * The store from which the dragged items are mapped to the UI.
            * In Scheduler's implementation of this base class, this will be
            * an EventStore, in Gantt's implementations, this will be a TaskStore.
            * Because both derive from this base, we must refer to it as this.store.
            * @private
            */
            store : null,

            /**
             * An object used to configure the internal {@link Core.helper.DragHelper} class
             * @config {Object}
             * @default
             */
            dragHelperConfig : null,

            tooltipCls : null
        };
    }

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            chain : ['render']
        };
    }

    //endregion

    //region Init

    /**
     * Called when scheduler is rendered. Sets up drag and drop and hover tooltip.
     * @private
     */
    render() {
        const
            me   = this,
            view = me.client;

        if (me.drag) {
            me.drag.destroy();
        }

        me.drag = new DragHelper(Object.assign({
            name                : me.constructor.name, // usefull when debugging with multiple draggers
            mode                : 'translateXY',
            lockY               : me.constrainDragToResource,
            minX                : true, // Allows dropping with start before time axis
            maxX                : true, // Allows dropping with end after time axis
            constrain           : false,
            cloneTarget         : !me.constrainDragToTimeline,
            dragWithin          : me.constrainDragToTimeline ? null : document.body,
            hideOriginalElement : true,
            outerElement        : view.timeAxisSubGridElement,
            targetSelector      : view.eventSelector,
            isElementDraggable  : (el, event) => !view.readOnly && me.isElementDraggable(el, event),
            scrollManager       : me.constrainDragToTimeline ? view.scrollManager : null,
            transitionDuration  : view.transitionDuration,
            listeners           : {
                beforedragstart : 'onBeforeDragStart',
                dragstart       : 'onDragStart',
                drag            : 'onDrag',
                drop            : 'onDrop',
                abort           : 'onDragAbort',
                reset           : 'onDragReset',
                thisObj         : me
            }
        }, me.dragHelperConfig));

        view.rowManager.on({
            changeTotalHeight : 'updateYConstraint',
            thisObj           : me
        });

        if (me.showTooltip) {
            me.clockTemplate = new ClockTemplate({
                scheduler : view
            });
        }
    }

    doDestroy() {
        const me = this;
        me.drag && me.drag.destroy();
        me.clockTemplate && me.clockTemplate.destroy();
        me.tip && me.tip.destroy();
        super.doDestroy();
    }

    //endregion

    //region Drag events

    onBeforeDragStart({ context, event }) {
        const
            me               = this,
            client           = me.client,
            name             = client.scheduledEventName,
            eventRecord      = client.resolveEventRecord(context.element),
            resourceLockAxis = me.isHorizontal ? 'lockY' : 'lockX';

        if (me.disabled || !eventRecord || !eventRecord.isDraggable) {
            return false;
        }

        // Cache the date corresponding to the drag start point so that on drag, we can always
        // perform the same calculation to then find the time delta without having to calculate
        // the new start end end times from the position that the element is.
        context.pointerStartDate = client.getDateFromXY([context.startClientX, context.startPageY], null, false);

        const result = client.trigger(`before${name}Drag`, {
            eventRecord,
            context : me.dragData
        }) !== false;

        // Allow constrainDragToResource to be set in the before drag listener
        // Constrain to resource means lockX if we're horizontal, otherwise lockY
        if (result !== false && me.constrainDragToResource) {
            me[resourceLockAxis] = true;
        }
        // Revert to configured value.
        else {
            me[resourceLockAxis] = me.config[resourceLockAxis];
        }

        if (result !== false) {
            me.updateYConstraint(eventRecord);
        }

        return result;
    }

    /**
     * Triggered when dragging of an event starts. Initializes drag data associated with the event being dragged.
     * @private
     */
    onDragStart({ context, event }) {
        const
            me     = this,
            client = me.client,
            name   = client.scheduledEventName;

        me.currentOverClient = client;
        me.scrollClients = {};

        me.onMouseOverNewTimeline(client);

        const dragData = me.dragData = me.getDragData(context, event);

        if (me.showTooltip) {
            const tipTarget = dragData.context.dragProxy ? dragData.context.dragProxy.firstChild : context.element;

            if (!me.tip) {
                me.tip = new Tooltip({
                    id                       : `${client.id}-event-drag-tip`,
                    align                    : 'b-t',
                    autoShow                 : true,
                    updateContentOnMouseMove : true,
                    clippedBy                : me.constrainDragToTimeline ? [client.timeAxisSubGridElement, client.bodyContainer] : null,
                    forElement               : tipTarget,
                    getHtml                  : me.getTipHtml.bind(me),
                    // During drag, it must be impossible for the mouse to be over the tip.
                    style                    : 'pointer-events:none',
                    cls                      : me.tooltipCls
                });

                me.tip.on('innerhtmlupdate', me.updateDateIndicator, me);
            }
            else {
                me.tip.showBy(tipTarget);
            }
        }

        // me.copyKeyPressed = me.isCopyKeyPressed();
        //
        // if (me.copyKeyPressed) {
        //     dragData.refElements.addCls('sch-event-copy');
        //     dragData.originalHidden = true;
        // }

        // Trigger eventDragStart or taskDragStart depending on product
        client.trigger(`${name}DragStart`, {
            [`${name}Records`] : dragData.draggedRecords,
            context            : dragData
        });
    }

    updateDateIndicator() {
        const
            { startDate, endDate } = this.dragData,
            tip                    = this.tip,
            endDateElement         = tip.element.querySelector('.b-sch-tooltip-enddate');

        this.clockTemplate.updateDateIndicator(tip.element, startDate);

        endDateElement && this.clockTemplate.updateDateIndicator(endDateElement, endDate);
    }

    /**
     * Triggered while dragging an event. Updates drag data, validation etc.
     * @private
     */
    onDrag({ context, event }) {
        const
            me    = this,
            dd    = me.dragData,
            start = dd.startDate;

        let client;

        if (me.constrainToTimeline) {
            client = me.client;
        }
        else {
            let target = event.target;

            // Can't detect target under a touch event
            if (/^touch/.test(event.type)) {
                const center = Rectangle.from(dd.context.element, null, true).center;

                target  = DomHelper.elementFromPoint(center.x, center.y);
            }

            client = IdHelper.fromElement(target, 'timelinebase');
        }

        const
            depFeature = me.client.features.dependencies,
            x          = context.newX,
            y          = context.newY;

        if (!client) {
            if (depFeature) {
                depFeature.updateDependenciesForTimeSpan(dd.draggedRecords[0], dd.context.element);
            }
            return;
        }

        if (client !== me.currentOverClient) {
            me.onMouseOverNewTimeline(client);
        }

        //this.checkShiftChange();

        me.updateDragContext(context, event);

        // Snapping not supported when dragging outside a scheduler
        if (me.constrainDragToTimeline && (me.showExactDropPosition || me.client.timeAxisViewModel.snap)) {
            const
                newDate   = client.getDateFromCoordinate(me.getCoordinate(dd.draggedRecords[0], context.element, [x, y])),
                timeDiff  = newDate - dd.sourceDate,
                realStart = new Date(dd.origStart - 0 + timeDiff),
                offset    = client.timeAxisViewModel.getDistanceBetweenDates(realStart, dd.startDate);

            if (dd.startDate >= client.timeAxis.startDate && offset != null) {
                DomHelper.addTranslateX(context.element, offset);
            }
        }

        // Let product specific implementations trigger drag event (eventDrag, taskDrag)
        me.triggerEventDrag(dd, start);

        let valid = me.checkDragValidity(dd, event);

        if (valid && typeof valid !== 'boolean') {
            context.message = valid.message || '';
            valid = valid.valid;
        }

        context.valid = valid !== false;

        if (me.showTooltip) {
            me.tip.realign();
        }

        if (depFeature) {
            depFeature.updateDependenciesForTimeSpan(dd.draggedRecords[0], dd.context.element.querySelector(client.eventInnerSelector));
        }
    }

    onMouseOverNewTimeline(newTimeline) {
        const
            me = this,
            scrollClients = me.scrollClients;

        me.currentOverClient.element.classList.remove('b-dragging-' + me.currentOverClient.scheduledEventName);

        newTimeline.element.classList.add('b-dragging-' + newTimeline.scheduledEventName);

        if (!(newTimeline.id in scrollClients)) {
            const scrollManager = newTimeline.scrollManager;

            scrollManager.startMonitoring({
                element : newTimeline.timeAxisSubGridElement
            });
            scrollClients[newTimeline.id] = newTimeline;
        }

        me.currentOverClient = newTimeline;
    }

    /**
     * Triggered when dropping an event. Finalizes the operation.
     * @private
     */
    onDrop({ context, event }) {
        const
            me                              = this,
            { currentOverClient, dragData } = me;

        if (!context.valid) {
            return me.onInvalidDrop({ context, event });
        }

        let modified = false;

        me.updateDragContext(context, event);

        if (me.tip) {
            me.tip.hide();
        }

        if (context.valid && dragData.startDate && dragData.endDate) {
            dragData.finalize = (...params) => {
                me.finalize(...params);
                context.finalize(...params);
            };

            // Allow implementer to take control of the flow, by returning false from this listener,
            // to show a confirmation popup etc. This event is documented in EventDrag and TaskDrag
            currentOverClient.trigger(`before${currentOverClient.capitalizedEventName}DropFinalize`, {
                context : dragData,
                event
            });

            context.async = dragData.async;

            // Internal validation, making sure all dragged records fit inside the view
            if (!context.async && me.isValidDrop(dragData)) {
                modified = (dragData.startDate - dragData.origStart) !== 0 || dragData.newResource !== dragData.resourceRecord;
            }
        }

        if (!context.async) {
            me.finalize(dragData.valid && context.valid && modified);
        }
    }

    onDragAbort({ context }) {
        const
            me = this,
            { dragData, client } = me,
            { draggedRecords } = dragData;

        client.currentOrientation.onDragAbort(context);

        // otherwise the event disappears on next refresh (#62)
        me.dragData.record.instanceMeta(client).retainElement = false;

        if (me.tip) {
            me.tip.hide();
        }

        // Trigger eventDragAbort / taskDragAbort depending on product
        client.trigger(`${client.capitalizedEventName}DragAbort`, {
            [`${client.scheduledEventName}Records`] : draggedRecords,
            context                                 : dragData
        });
    }

    /**
     * Triggered by drag handler on invalid drop, cleans up.
     * @private
     */
    onInvalidDrop() {
        const me = this;

        me.dragData.draggedRecords.forEach(record => me.resumeElementRedrawing(record));

        if (me.tip) {
            me.tip.hide();
        }
    }

    // For the drag across multiple schedulers, tell all involved scroll managers to stop monitoring
    onDragReset({ source : dragHelper }) {
        const me = this;

        for (const managerId in (me.scrollClients || {})) {
            me.scrollClients[managerId].scrollManager.stopMonitoring(me.scrollClients[managerId].timeAxisSubGridElement);
        }

        if (dragHelper.context && dragHelper.context.started) {
            const { eventBarEls } = me.dragData;

            eventBarEls[0].classList.remove('b-drag-main');
        }

        me.scrollClients = null;

        if (me.currentOverClient) {
            me.currentOverClient.element.classList.remove('b-dragging-' + me.currentOverClient.scheduledEventName);
        }

        // Dependencies are updated dynamically during drag, so ensure they are redrawn
        // if the event snaps back with no change after abort or an invalid drop.
        if (me.dragData && !me.dragData.context.valid) {
            const dependencies = me.currentOverClient.features.dependencies;

            if (dependencies) {
                dependencies.scheduleDraw(true);
            }
        }

        // TODO we should clean this up, requires review of the flow first
        // me.dragData = null;
    }

    /**
     * Triggered internally on invalid drop.
     * @private
     */
    onInternalInvalidDrop() {
        const
            me                    = this,
            { currentOverClient } = me;

        if (me.tip) {
            me.tip.hide();
        }

        me.drag.abort();

        // Documented on EventDrag & TaskDrag features
        currentOverClient.trigger(`after${currentOverClient.capitalizedEventName}Drop`, {
            [currentOverClient.scheduledEventName + 'Records'] : me.dragData.draggedRecords,
            valid                                              : false,
            context                                            : me.dragData
        });
    }

    //endregion

    //region Finalization & validation

    /**
     * Called on drop to update the record of the event being dropped.
     * @private
     * @param {Boolean} updateRecords Specify true to update the record, false to treat as invalid
     */
    async finalize(updateRecords) {
        const
            me = this,
            { currentOverClient : client, dragData } = me,
            { context, draggedRecords } = dragData;

        let result;

        draggedRecords.forEach((record, i) => {
            me.resumeElementRedrawing(record);

            // Ensure the dragged elements are available from the EventMapper's cache
            // It won't return an event that is in use by dragging.
            dragData.eventBarEls[i].classList.remove(me.drag.draggingCls);
        });

        if (updateRecords) {
            // updateRecords may or may not be async.
            // We see if it returns a Promise.
            result = me.updateRecords(dragData);

            // If updateRecords is async, the calling DragHelper must know this and
            // go into a awaitingFinalization state.
            if (result instanceof Promise) {
                context.async = true;
                await result;
            }

            // If the finalize handler decided to change the dragData's validity...
            if (!dragData.valid) {
                me.onInternalInvalidDrop();
            }
            else {
                me.drag.reset();

                // Trigger afterEventDrop or afterTaskDrop depending on product
                client.trigger(`after${client.capitalizedEventName}Drop`, {
                    [`${client.scheduledEventName}Records`] : draggedRecords,
                    valid                                   : true,
                    context                                 : dragData
                });
            }
        }
        else {
            me.onInternalInvalidDrop();
        }

        return result;
    }

    //endregion

    //region Drag data

    /**
     * Updates drag datas dates and validity (calls #validatorFn if specified)
     * @private
     */
    updateDragContext(info, event) {
        const
            me                  = this,
            { drag }            = me,
            dd                  = me.dragData,
            client              = me.currentOverClient,
            { isHorizontal }    = client,
            element             = info.element,
            proxyRegion         = Rectangle.from(element, client.timeAxisSubGridElement),
            record              = dd.draggedRecords[0],
            eventRecord         = record.isAssignment ? record.event : record,
            constrainToTimeSlot = me.constrainDragToTimeSlot || (isHorizontal ? drag.lockX : drag.lockY);

        dd.browserEvent = event;

        if (constrainToTimeSlot) {
            dd.timeDiff = 0;
        }
        else {
            if (client.timeAxis.isContinuous) {
                const
                    { dateConstraints } = dd,
                    { timeAxisSubGrid } = client,
                    { scrollable }      = timeAxisSubGrid,
                    timeAxisRegion      = scrollable.viewport,
                    timeAxisPosition    = client.isHorizontal ? info.clientX - timeAxisRegion.x + scrollable.x : info.clientY - timeAxisRegion.y + scrollable.y,

                    // Use the localized coordinates to ask the TimeAxisViewModel what date the mouse is at.
                    // Pass allowOutOfRange as true in case we have dragged out of either side of the timeline viewport.
                    pointerDate         = client.timeAxisViewModel.getDateFromPosition(timeAxisPosition, null, true),
                    timeDiff            = dd.timeDiff = pointerDate - info.pointerStartDate;

                // calculate and round new startDate based on actual dd.timeDiff
                dd.startDate = me.adjustStartDate(dd.origStart, timeDiff);
                if (dateConstraints) {
                    dd.startDate = DateHelper.constrain(dd.startDate, dateConstraints.start, new Date(dateConstraints.end - eventRecord.durationMS));
                }
                dd.endDate = new Date(dd.startDate - 0 + dd.duration);
            }
            else {
                const range = me.resolveStartEndDates(proxyRegion);

                dd.startDate = range.startDate;
                dd.endDate = range.endDate;
            }
            dd.timeDiff = dd.startDate - dd.origStart;
        }

        Object.assign(dd, me.getProductDragContext(dd));

        if (dd.valid) {
            // If it's fully outside, we don't allow them to drop it - the event would disappear from their control.
            if ((dd.endDate <= client.timeAxis.startDate || dd.startDate >= client.timeAxis.endDate)) {
                dd.context.valid = false;
                dd.context.message = me.L('noDropOutsideTimeline');
            }
            else {
                const result = !event || me.checkDragValidity(dd, event);

                if (!result || typeof result === 'boolean') {
                    dd.context.valid = result !== false;
                    dd.context.message = '';
                }
                else {
                    dd.context.valid = result.valid !== false;
                    dd.context.message = result.message;
                }
            }
        }
        else {
            dd.context.valid = false;
        }
    }

    suspendElementRedrawing(record, suspend = true) {
        record.instanceMeta(this.client).retainElement = suspend;
    }

    resumeElementRedrawing(record) {
        this.suspendElementRedrawing(record, false);
    }

    /**
     * Initializes drag data (dates, constraints, dragged events etc). Called when drag starts.
     * @private
     * @param info
     * @param event
     * @returns {*}
     */
    getDragData(info, event) {
        const
            me     = this,
            client = me.client,
            { record, dateConstraints, eventBarEls, draggedRecords } = me.setupProductDragData(info);

        let origStart         = record.startDate,
            origEnd           = record.endDate,
            timeAxis          = client.timeAxis,
            startsOutsideView = origStart < timeAxis.startDate,
            endsOutsideView   = origEnd > timeAxis.endDate;

        const
            coordinate       = me.getCoordinate(record, info.element, [info.elementStartX, info.elementStartY]),
            clientCoordinate = me.getCoordinate(record, info.element, [info.startClientX, info.startClientY]);

        // prevent elements from being released when out of view
        draggedRecords.forEach(record => me.suspendElementRedrawing(record));

        // Select current without deselecting other events if Ctrl key is pressed
        if (me.drag.startEvent.ctrlKey) {
            me.client.selectEvent(draggedRecords[0], true);
        }

        me.drag[client.isHorizontal ? 'lockX' : 'lockY'] = me.constrainDragToTimeSlot;

        const dragData = {
            context : info,

            dateConstraints,

            eventBarEls,

            record,
            draggedRecords,

            sourceDate       : startsOutsideView ? origStart : client.getDateFromCoordinate(coordinate),
            screenSourceDate : client.getDateFromCoordinate(clientCoordinate, null, false),
            origStart        : origStart,
            origEnd          : origEnd,
            startDate        : origStart,
            endDate          : origEnd,
            timeDiff         : 0,

            startsOutsideView,
            endsOutsideView,

            duration     : origEnd - origStart,
            browserEvent : event // So we can know if SHIFT/CTRL was pressed
        };

        eventBarEls.forEach((el, i) => {
            el.classList.add(me.drag.draggingCls);
            el.classList.remove('b-sch-event-hover');
            el.classList.remove('b-active');
            el.classList.remove('b-first-render');
        });

        if (eventBarEls.length > 1) {
            // RelatedElements are secondary elements moved by the same delta as the grabbed element
            info.relatedElements = eventBarEls.slice(1);
            info.relatedElStartPos = [];
            info.relatedElDragFromPos = [];

            // Move the selected events into a unified cascade.
            if (me.unifiedDrag) {
                // EventBarEls should animate into the cascade
                me.client.isAnimating = true;

                EventHelper.on({
                    element       : eventBarEls[1],
                    transitionend : e => {
                        me.client.isAnimating = false;
                    },
                    once : true
                });

                // Main dragged element should not look different. The relatedElements do.
                eventBarEls[0].classList.add('b-drag-main');

                let [x, y] = DomHelper.getTranslateXY(info.element);

                info.relatedElements.forEach((el, i) => {
                    // Cache the start pos for reversion in case of invalid drag
                    info.relatedElStartPos[i] = DomHelper.getTranslateXY(el);

                    // Move into cascade and cache the dragFrom pos
                    x += 10;
                    y += 10;
                    DomHelper.setTranslateXY(el, x, y);
                    info.relatedElDragFromPos[i] = [x, y];
                });
            }
            else {
                // Start pos and dragFrom pos are the same for non-unified
                info.relatedElements.forEach((el, i) => {
                    info.relatedElStartPos[i] = info.relatedElDragFromPos[i] = DomHelper.getTranslateXY(el);
                });
            }
        }

        return dragData;
    }

    // Provide your custom implementation of this to allow additional selected records to be dragged together with the original one.
    getRelatedRecords(record) {
        return [];
    }

    //endregion

    //region Constraints

    // private
    setupConstraints(constrainRegion, elRegion, tickSize, constrained) {
        const
            me = this,
            xTickSize = !me.showExactDropPosition && tickSize > 1 ? tickSize : 0,
            yTickSize = 0;

        // If `constrained` is false then we haven't specified getDateConstraint method and should constrain mouse position to scheduling area
        // else we have specified date constraints and so we should limit mouse position to smaller region inside of constrained region using offsets and width.
        if (constrained) {
            me.setXConstraint(constrainRegion.left, constrainRegion.right - elRegion.width, xTickSize);
        }
        // And if not constrained, release any constraints from the previous drag.
        else {
            // minX being true means allow the start to be before the time axis.
            // maxX being true means allow the end to be after the time axis.
            me.setXConstraint(true, true, xTickSize);
        }
        me.setYConstraint(constrainRegion.top, constrainRegion.bottom - elRegion.height, yTickSize);
    }

    updateYConstraint(eventRecord) {
        const
            me          = this,
            { client }  = me,
            { context } = me.drag,
            tickSize    = client.timeAxisViewModel.snapPixelAmount;

        // If we're dragging when the vertical size is recalculated by the host grid,
        // we must update our Y constraint unless we are locked in the Y axis.
        if (context && !me.drag.lockY) {
            let constrainRegion;

            // This calculates a relative region which the DragHelper uses within its outerElement
            if (me.constrainDragToTimeline) {
                constrainRegion = client.getScheduleRegion(null, eventRecord);
            }
            // Not constraining to timeline.
            // Unusual configuration, but this must mean no Y constraining.
            else {
                me.setYConstraint(null, null, tickSize);
                return;
            }

            me.setYConstraint(
                constrainRegion.top,
                constrainRegion.bottom - context.element.offsetHeight,
                tickSize
            );
        }
        else {
            me.setYConstraint(null, null, tickSize);
        }
    }

    setXConstraint(iLeft, iRight, iTickSize) {
        const
            me   = this,
            drag = me.drag;

        drag.leftConstraint = iLeft;
        drag.rightConstraint = iRight;

        drag.minX = iLeft;
        drag.maxX = iRight;
    }

    setYConstraint(iUp, iDown, iTickSize) {
        const
            me   = this,
            drag = me.drag;

        drag.topConstraint = iUp;
        drag.bottomConstraint = iDown;

        drag.minY = iUp;
        drag.maxY = iDown;
    }

    //endregion

    //region Other stuff

    adjustStartDate(startDate, timeDiff) {
        return this.client.timeAxis.roundDate(
            new Date(startDate - 0 + timeDiff),
            this.client.snapRelativeToEventStartDate ? startDate : false
        );
    }

    resolveStartEndDates(proxyRect) {
        const { start, end } = this.client.getStartEndDatesFromRectangle(proxyRect, 'round', this.dragData.duration);

        return {
            startDate : start,
            endDate   : end
        };
    }

    //endregion

    //region Dragtip

    /**
     * Gets html to display in tooltip while dragging event. Uses clockTemplate to display start & end dates.
     */
    getTipHtml() {
        const
            me                                     = this,
            { startDate, endDate, draggedRecords } = me.dragData,
            startText = me.client.getFormattedDate(startDate),
            endText   = me.client.getFormattedEndDate(endDate, startDate),
            { valid, message } = me.dragData.context;

        return me.dragTipTemplate({
            valid,
            startDate,
            endDate,
            startText,
            endText,
            message                                   : message || '',
            [me.client.scheduledEventName + 'Record'] : draggedRecords[0],
            dragData                                  : me.dragData,
            startClockHtml                            : me.clockTemplate.template({
                date : startDate,
                text : startText,
                cls  : 'b-sch-tooltip-startdate'
            }),
            endClockHtml : draggedRecords[0].isMilestone ? '' : me.clockTemplate.template({
                date : endDate,
                text : endText,
                cls  : 'b-sch-tooltip-enddate'
            })
        });
    }

    //endregion

    /**
     * Disable this feature
     * @property {Boolean}
     */
    get disabled() {
        return this._disabled;
    }

    set disabled(disabled) {
        this._disabled = disabled;
    }

    //region Product specific, implemented in subclasses

    // Check if element can be dropped at desired location
    isValidDrop(dragData) {
        throw new Error('Implement in subclass');
    }

    // Similar to the fn above but also calls validatorFn
    checkDragValidity(dragData) {
        throw new Error('Implement in subclass');
    }

    // Update records being dragged
    updateRecords(context) {
        throw new Error('Implement in subclass');
    }

    // Determine if an element can be dragged
    isElementDraggable(el, event) {
        throw new Error('Implement in subclass');
    }

    // Get coordinate for correct axis
    getCoordinate(record, element, coord) {
        throw new Error('Implement in subclass');
    }

    // Product specific drag data
    setupProductDragData(info) {
        throw new Error('Implement in subclass');
    }

    // Product specific data in drag context
    getProductDragContext(dd) {
        throw new Error('Implement in subclass');
    }

    //endregion
}
DragBase._$name = 'DragBase';

/**
 * @module Scheduler/feature/EventDrag
 */

const nullResourceArray = [null];

//TODO: relay events as in Dependencies. (drag -> eventdrag etc)
//TODO: shift to copy
//TODO: dragging of event that starts & ends outside of view

/**
 * Allows user to drag and drop events within the scheduler, to change startDate or resource assignment.
 *
 * This feature is **enabled** by default
 *
 * @example
 * // constrain drag to current resource
 * let scheduler = new Scheduler({
 *   features: {
 *     eventDrag: {
 *       constrainDragToResource: true
 *     }
 *   }
 * });
 *
 * @extends Scheduler/feature/base/DragBase
 * @demo Scheduler/basic
 * @externalexample scheduler/EventDrag.js
 */
class EventDrag extends base(DragBase).mixes(
    SchedulerFeatureDataLayer,
    DataAPI
) {
    //region Config

    static get $name() {
        return 'EventDrag';
    }

    static get defaultConfig() {
        return {
            /**
             * Template used to generate drag tooltip contents.
             * ```
             * const scheduler = new Scheduler({
             *   features : {
             *     eventDrag : {
             *       dragTipTemplate({eventRecord, startText}) {
             *         return `${eventRecord.name}: ${startText}`
             *       }
             *     }
             *   }
             * });
             * ```
             * @config {Function} dragTipTemplate
             * @param {Object} data Tooltip data
             * @param {Scheduler.model.EventModel} data.eventRecord
             * @param {Boolean} data.valid Currently over a valid drop target or not
             * @param {Date} data.startDate New start date
             * @param {Date} data.endDate New end date
             * @param {String} data.startText Formatted new start date
             * @param {String} data.endText Formatted new end date
             * @param {String} data.startClockHtml Pre-generated HTML to display startDate as clock/calendar
             * @param {String} data.endClockHtml Pre-generated HTML to display endDate as clock/calendar
             * @param {Object} data.dragData Detailed drag context
             * @returns {String}
             */

            /**
             * Set to true to only allow dragging events within the same resource.
             * @config {Boolean}
             * @default
             */
            constrainDragToResource : false,

            /**
             * Set to true to only allow dragging events to different resources, and disallow rescheduling by dragging.
             * @config {Boolean}
             * @default
             */
            constrainDragToTimeSlot : false,

            /**
             * An empty function by default, but provided so that you can perform custom validation on
             * the item being dragged. This function is called during the drag and drop process and also after the drop is made.
             * Return true if the new position is valid, false to prevent the drag.
             * @param {Object} context A drag drop context object
             * @param {Date} context.startDate New start date
             * @param {Date} context.endDate New end date
             * @param {Scheduler.model.EventModel[]} context.draggedRecords Event records which were dragged
             * @param {Scheduler.model.ResourceModel} context.newResource New resource record
             * @param {Event} event The event object
             * @return {Boolean} `true` if this validation passes
             * @config {Function}
             */
            validatorFn : () => {},

            /**
             * The `this` reference for the validatorFn
             * @config {Object}
             */
            validatorFnThisObj : null,

            /**
             * When the host Scheduler is `{@link Scheduler.view.mixin.EventSelection#config-multiEventSelect multiEventSelect}: true`
             * then, there are two modes of dragging *within the same Scheduler*.
             *
             * Non unified means that all selected events are dragged by the same number of resource rows.
             *
             * Unified means that all selected events are collected together and dragged as one, and are all dropped
             * on the same targeted resource row at the same targeted time.
             * @config {Boolean}
             * @default false
             */
            unifiedDrag : null
        };
    }

    //endregion

    //region Events

    /**
     * Fired on the owning Scheduler to allow implementer to prevent immediate finalization by setting `data.context.async = true`
     * in the listener, to show a confirmation popup etc
     * ```
     *  scheduler.on('beforeeventdropfinalize', ({context}) => {
     *      context.async = true;
     *      setTimeout(() => {
     *          // async code don't forget to call finalize
     *          context.finalize();
     *      }, 1000);
     *  })
     * ```
     * @event beforeEventDropFinalize
     * @param {Scheduler.view.Scheduler} source Scheduler instance
     * @param {Object} context
     * @param {Boolean} context.async Set true to handle dragdrop asynchronously (e.g. to wait for user
     * @param {Scheduler.model.EventModel} context.targetEventRecord Event record for drop target
     * @param {Scheduler.model.ResourceModel} context.newResource Resource record for drop target
     * confirmation)
     * @param {Function} context.finalize Call this method to finalize dragdrop. This method accepts one
     * argument: pass true to update records, or false, to ignore changes
     */

    /**
     * Fired on the owning Scheduler after event drop
     * @event afterEventDrop
     * @param {Scheduler.view.Scheduler} source
     * @param {Scheduler.model.EventModel[]} eventRecords
     * @param {Boolean} valid
     * @param {Object} context
     */

    /**
     * Fired on the owning Scheduler when an event is dropped
     * @event eventDrop
     * @param {Scheduler.view.Scheduler} source
     * @param {Scheduler.model.EventModel[]} eventRecords
     * @param {Boolean} isCopy
     * @param {Object} context
     * @param {Scheduler.model.EventModel} context.targetEventRecord Event record for drop target
     * @param {Scheduler.model.ResourceModel} context.newResource Resource record for drop target
     */

    /**
     * Fired on the owning Scheduler before event dragging starts. Return false to prevent the action
     * @event beforeEventDrag
     * @param {Scheduler.view.Scheduler} source
     * @param {Scheduler.model.EventModel} eventRecord
     * @param {Object} context
     */

    /**
     * Fired on the owning Scheduler when event dragging starts
     * @event eventDragStart
     * @param {Scheduler.view.Scheduler} source
     * @param {Scheduler.model.EventModel[]} eventRecords
     * @param {Object} context
     */

    /**
     * Fired on the owning Scheduler when event is dragged
     * @event eventDrag
     * @param {Scheduler.view.Scheduler} source
     * @param {Scheduler.model.EventModel[]} eventRecords
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Scheduler.model.ResourceModel} newResource
     * @param {Object} context
     */

    /**
     * Fired on the owning Scheduler after an event drag operation has been aborted
     * @event eventDragAbort
     * @param {Scheduler.view.Scheduler} source
     * @param {Scheduler.model.EventModel[]} eventRecords
     * @param {Object} context
     */
    //endregion

    //region Data layer

    // Deprecated. Use this.client instead
    get scheduler() {
        return this.client;
    }

    // Deperecated. Use this.eventStore instead
    get store() {
        return this.eventStore;
    }

    //endregion

    //region Drag events

    isElementDraggable(el, event) {
        const
            { scheduler }   = this,
            eventElement    = DomHelper.up(el, scheduler.eventSelector),
            { eventResize } = scheduler.features;

        if (!eventElement || this.disabled) {
            return false;
        }

        // displaying something resizable within the event?
        if (el.matches('[class$="-handle"]')) {
            return false;
        }

        const eventRecord = scheduler.resolveEventRecord(eventElement);

        // using EventResize and over a virtual handle?
        // Milestones cannot be resized
        if (eventResize && !eventRecord.isMilestone && eventResize.resize.overAnyHandle(event, eventElement)) {
            return false;
        }

        return true;
    }

    triggerEventDrag(dd, start) {
        // If there has been a change...
        if (dd.startDate - start !== 0 || dd.newResource !== dd.resourceRecord) {
            this.scheduler.trigger('eventDrag', {
                eventRecords : dd.draggedRecords,
                startDate    : dd.startDate,
                endDate      : dd.endDate,
                newResource  : dd.newResource,
                context      : dd
            });
        }
    }

    onDragStart({ context, event }) {
        const eventContextMenuFeature = this.client.features.eventContextMenu;

        super.onDragStart({ context, event });

        // If this is a touch action, hide the context menu which may have shown
        if (eventContextMenuFeature) {
            eventContextMenuFeature.hideContextMenu(false);
        }
    }

    //endregion

    //region Finalization & validation

    /**
     * Checks if an event can be dropped on the specified resource.
     * @private
     * @returns {Boolean} Valid (true) or invalid (false)
     */
    isValidDrop(dragData) {
        const { newResource, resourceRecord } = dragData;
        let sourceRecord = dragData.draggedRecords[0];

        // Not allowed to drop an event to group header
        if (newResource.meta.specialRow) {
            return false;
        }

        // Not allowed to assign an event twice to the same resource -
        // which might happen when we deal with an assignment store
        if (resourceRecord !== newResource) {
            // if we operate assignments
            if (sourceRecord instanceof AssignmentModel) {
                sourceRecord = this.dataApi.getAssignmentEvent({ assignment : sourceRecord, eventStore : this.eventStore });
                return !this.dataApi.isAssignmentForResource({ assignment : sourceRecord, resource : newResource, resourceStore : this.resourceStore });
            }
            else {
                return !this.dataApi.isEventAssignedToResource({ event : sourceRecord, resource : newResource, resourceStore : this.resourceStore, assignmentStore : this.assignmentStore });
            }
        }

        return true;
    }

    checkDragValidity(dragData, event) {
        const
            me        = this,
            scheduler = this.currentOverClient;

        let result = me.dragData.context.valid;

        if (result) {
            // First make sure DragHelper thinks it's a valid drag, then scheduler domain checks
            if (!scheduler.allowOverlap && !scheduler.isDateRangeAvailable(
                dragData.startDate,
                dragData.endDate,
                dragData.draggedRecords[0],
                dragData.newResource
            )) {
                result = {
                    valid   : false,
                    message : me.L('eventOverlapsExisting')
                };
            }
            else {
                result = me.validatorFn.call(
                    me.validatorFnThisObj || me,
                    dragData,
                    event
                );
            }
        }

        return result;
    }

    //endregion

    //region Update records

    /**
     * Update events being dragged.
     * @private
     * @param context Drag data.
     */
    updateRecords(context) {
        const
            me              = this,
            fromScheduler   = me.scheduler,
            toScheduler     = me.currentOverClient,
            copyKeyPressed  = false, //me.isCopyKeyPressed(),
            {
                assignmentStore,
                eventStore
            } = fromScheduler,
            {
                draggedRecords
            } = context;

        let result;

        // Move event to the correct event Store in case of dragging across multiple schedulers
        // TOODO @mats, what if these are Assignments? See "Multiple assignment mode" below.
        // Both Schedulers would have to have assignmentStores.
        if (eventStore !== toScheduler.eventStore) {
            // Removing deassigns events from their resources
            eventStore.remove(draggedRecords);

            // This will not affect the UI because the events are not assigned to any resource
            toScheduler.eventStore.add(draggedRecords);
        }

        // Multiple assignment mode
        if (assignmentStore) {
            if (toScheduler !== fromScheduler) {
                throw new Error('Assignments cannot be dragged cross-scheduler');
            }
            result = me.updateRecordsMultipleAssignmentMode(fromScheduler, toScheduler, context, copyKeyPressed);
        }
        // Single assignment mode
        else {
            result = me.updateRecordsSingleAssignmentMode(fromScheduler, toScheduler, context, copyKeyPressed);
        }

        // Tell the world there was a successful drop
        toScheduler.trigger('eventDrop', {
            eventRecords         : draggedRecords,
            isCopy               : copyKeyPressed,
            event                : context.browserEvent,
            targetEventRecord    : context.targetEventRecord,
            targetResourceRecord : context.newResource,
            context
        });

        return result;
    }

    /**
     * Update records being dragged, scheduler mode. Sets resource and start date.
     * @private
     */
    updateRecordsSingleAssignmentMode(fromScheduler, toScheduler, context, copy) {
        // The code is written to emit as few store events as possible
        const
            me                      = this,
            isCrossScheduler        = (fromScheduler !== toScheduler),
            {
                eventStore: fromEventStore,
                resourceStore
            }                       = fromScheduler,
            {
                draggedRecords,
                timeDiff,
                resourceRecord : fromResource,
                newResource    : toResource
            }                       = context,
            unifiedDrag             = me.unifiedDrag || (isCrossScheduler && draggedRecords.length > 1),
            toAdd = [],
            // By how many resource rows has the drag moved.
            indexDiff   = me.constrainDragToResource ? 0 : resourceStore.indexOf(fromResource) - resourceStore.indexOf(toResource),
            event1Date  = me.adjustStartDate(draggedRecords[0].startDate, timeDiff);

        let updated;

        draggedRecords.forEach((draggedEvent, i) => {
            const
                eventBar = context.eventBarEls[i],
                oldGeneration = draggedEvent.generation,
                // grabbing resources early, since after ".copy()" the record won't belong to any store
                // and ".getResources()" won't work. If it's a move to another scheduler, ensure the
                // array still has a length. The process function will do an assign as opposed
                // to a reassign
                relatedResources = isCrossScheduler ? nullResourceArray : draggedEvent.resources;

            // If changing resource, the element wont be found in SchedulerStores#onEventBeforeCommit and thus the
            // committing cls wont be applied. Apply it here, in case we are using a backend. If we are not, it will be
            // replaced anyway on the immediate redraw
            eventBar.querySelector(fromScheduler.eventInnerSelector).classList.add(fromScheduler.committingCls);

            if (copy) {
                draggedEvent = draggedEvent.fullCopy(null);
                toAdd.push(draggedEvent);
            }
            else if (fromEventStore !== toScheduler.eventStore) {
                // Removing deassigns events from their resources
                fromEventStore.remove(draggedRecords);

                // This will not affect the UI because the events are not assigned to any resource
                toScheduler.eventStore.add(draggedRecords);

                // Make the event mapper reuse this element
                draggedEvent.instanceMeta(toScheduler).fromDragProxy = true;
            }

            // Process original dragged record
            draggedEvent.beginBatch();

            // calculate new startDate (and round it) based on timeDiff
            let newStartDate = unifiedDrag ? event1Date : me.adjustStartDate(draggedEvent.startDate, timeDiff);

            (indexDiff !== 0 || unifiedDrag || isCrossScheduler) && relatedResources.length && relatedResources.forEach(r => {
                let newResource = toResource;

                // If not dragging events as a unified block, distribute each to a new resource
                // using the same offset as the dragged event.
                if (!unifiedDrag && !isCrossScheduler) {
                    let newIndex = resourceStore.indexOf(r) - indexDiff;

                    if (newIndex < 0) {
                        newIndex = 0;
                    }
                    else if (newIndex >= resourceStore.getCount()) {
                        newIndex = resourceStore.getCount() - 1;
                    }

                    newResource = resourceStore.getAt(newIndex);
                }

                if (r) {
                    draggedEvent.reassign(r, newResource);
                }
                else {
                    draggedEvent.assign(newResource);
                }

                if (toScheduler.mode !== 'vertical') {
                    const
                        isRendered = toScheduler.rowManager.getRowFor(newResource) && toScheduler.isInTimeAxis(draggedEvent),
                        newId = isRendered ? toScheduler.getEventRenderId(draggedEvent, newResource) : null;

                    // Ensure the element gets preferentially reused for its own new render
                    // when batching of its changes is ended and it fires events through its eventStore
                    if (newId) {
                        // If it's cross-scheduler, the element has to be moved into the element
                        // recycling cache of the toScheduler, and positioned in its foregroundCanvas
                        if (isCrossScheduler) {
                            const elRect = Rectangle.from(context.context.element, toScheduler.foregroundCanvas, true),
                                clone = context.context.element.cloneNode(true);

                            // Ensure that after inserting the dragged element clone into the toScheduler's foregoundCanvas
                            // it's at the same visual position that it was dragged to.
                            DomHelper.setTranslateXY(clone, elRect.x, elRect.y);
                            clone.classList.remove('b-first-render');
                            clone.classList.remove('b-active');
                            clone.classList.remove('b-drag-proxy');
                            clone.classList.remove('b-dragging');

                            // This puts a clone of the dragged element into the toScheduler's recycling cache
                            // *AND* inserts it into the toScheduler's foregroundCanvas.
                            toScheduler.currentOrientation.cacheTimeSpanElement(draggedEvent, newResource, clone);
                        }
                        else {
                            toScheduler.currentOrientation.releaseTimeSpanDiv(eventBar, true);
                            toScheduler.currentOrientation.updateElementId(eventBar, newId);
                        }
                    }
                    // If the event has been moved out of rendering, just discard the element
                    else {
                        eventBar.remove();
                    }
                }
            });

            draggedEvent.setStartDate(newStartDate, true, fromEventStore.skipWeekendsDuringDragDrop);

            draggedEvent.endBatch();

            // We need to know whether we have successfully made an update in order to
            // sync the dragContext's valid flag.
            if (draggedEvent.generation !== oldGeneration) {
                updated = true;
            }
        });

        if (toAdd.length) {
            const count = fromEventStore.count;
            fromEventStore.add(toAdd);
            if (fromEventStore.count !== count) {
                updated = true;
            }
        }

        if (!updated) {
            context.valid = false;
        }
    }

    /**
     * Update records being dragged, gantt mode. Sets resource and start date.
     * @private
     */
    updateRecordsMultipleAssignmentMode(fromScheduler, toScheduler, context, copy) {
        const
            me               = this,
            isCrossScheduler = (fromScheduler !== toScheduler),
            { eventStore }   = fromScheduler,
            {
                draggedRecords,
                timeDiff,
                resourceRecord : fromResource,
                newResource    : toResource
            }                = context,
            // In case multiSelect is true, several assignments to one event may be processed here. We will store
            // ids of processed events here to avoid setting incorrect start date
            handledEventsMap = {};

        let updated;

        draggedRecords.forEach((assignment, i) => {
            const
                event         = assignment.event,
                eventBar      = context.eventBarEls[i],
                oldGeneration = event.generation,
                newId         = fromScheduler.getEventRenderId(assignment.event, toResource);

            if (handledEventsMap[event.id]) {
                return;
            }

            handledEventsMap[event.id] = true;

            // Ensure the element gets preferentially reused for its own new render
            if (newId) {
                // If it's cross-scheduler, the element has to be moved into the element
                // recycling cache of the toScheduler, and positioned in its foregroundCanvas
                if (isCrossScheduler) {
                    toScheduler.currentOrientation.cacheTimeSpanElement(event, eventBar);
                }
                else {
                    toScheduler.currentOrientation.updateElementId(eventBar, newId);
                }
            }

            event.setStartDate(me.adjustStartDate(event.startDate, timeDiff), true, eventStore.skipWeekendsDuringDragDrop);

            // if we dragged the event to a different resource
            if (fromResource !== toResource) {
                if (copy) {
                    event.assign(toResource);
                }
                else if (!event.isAssignedTo(toResource)) {
                    event.reassign(assignment.resource, toResource);
                }
                else {
                    event.unassign(assignment.resource);
                }
            }

            // We need to know whether we have successfully made an update in order to
            // sync the dragContext's valid flag.
            updated = updated || (assignment.resource !== fromResource) || (event.generation !== oldGeneration);
        });

        if (!updated) {
            context.valid = false;
        }
    }

    //endregion

    //region Drag data

    getProductDragContext(dd) {
        const targetEventRecord = this.scheduler.resolveEventRecord(dd.browserEvent.target);

        let newResource;

        if (this.constrainDragToResource) {
            newResource = dd.resourceRecord;
        }
        else if (!this.constrainDragToTimeline) {
            // If we're dragging freely on the page, require to drag onto a resource row always
            newResource = this.resolveResource();
        }
        else {
            newResource = this.resolveResource() || dd.newResource || dd.resourceRecord;
        }

        return {
            valid : Boolean(newResource),
            newResource,
            targetEventRecord
        };
    }

    setupProductDragData(info) {
        const
            me                 = this,
            scheduler          = me.scheduler,
            element            = info.grabbed,
            eventRecord        = scheduler.resolveEventRecord(element),
            resourceRecord     = scheduler.resolveResourceRecord(element),
            assignmentRecord   = scheduler.resolveAssignmentRecord(element),
            eventRegion        = Rectangle.from(element),
            draggedRecords     = [assignmentRecord || eventRecord],
            eventBarEls        = [];

        if (me.constrainDragToResource && !resourceRecord) {
            throw new Error('Resource could not be resolved for event: ' + eventRecord.id);
        }

        const dateConstraints = scheduler.getDateConstraints(me.constrainDragToResource ? resourceRecord : null, eventRecord);

        if (me.constrainDragToTimeline) {
            me.setupConstraints(
                scheduler.getScheduleRegion(me.constrainDragToResource ? resourceRecord : null, eventRecord),
                eventRegion,
                scheduler.timeAxisViewModel.snapPixelAmount,
                Boolean(dateConstraints)
            );
        }

        // We multi drag other selected events if multiEventSelect is set and
        // (the dragged event is already selected, or the ctrl key is pressed)
        if (scheduler.multiEventSelect && (scheduler.isEventSelected(draggedRecords[0]) || me.drag.startEvent.ctrlKey)) {
            draggedRecords.push.apply(draggedRecords, me.getRelatedRecords(assignmentRecord || eventRecord));
        }

        // Collecting all elements to drag
        draggedRecords.forEach(r => {
            let eventBarEl;

            if (r instanceof AssignmentModel) {
                eventBarEl = scheduler.getElementFromEventRecord(r.event, r.resource);
            }
            else {
                eventBarEl = scheduler.getElementFromEventRecord(r, r.resource);
            }

            // It's selected but unrendered. This happens when multi-selected events are dragged such
            // that on drop, they are outside of the timeline or the rendered block, and become unrendered.
            // Users will expect the event to be "there" so we have to bring it into existence
            // just for the drag.
            if (!eventBarEl) {
                const rd = scheduler.generateTplData(r, r.resource, { timeAxis : true, viewport : true });

                rd.top = rd.row ? (rd.top + rd.row.top) : scheduler.getResourceEventBox(r, r.resource, true).top;
                eventBarEl = scheduler.currentOrientation.renderTimeSpan(rd, {}, null, true);

                // Make it be reused after drag
                scheduler.currentOrientation.availableDivs.add(eventBarEl);
                eventBarEl = eventBarEl.innerElement;
            }

            eventBarEls.push(eventBarEl);
        });

        // What is dragged is the wrapper.
        eventBarEls.forEach((el, i) => eventBarEls[i] = el.parentNode);

        return { record : eventRecord, dateConstraints, eventBarEls, draggedRecords };
    }

    /**
     * Initializes drag data (dates, constraints, dragged events etc). Called when drag starts.
     * @private
     * @param info
     * @param event
     * @returns {*}
     */
    getDragData(info, event) {
        return Object.assign(super.getDragData(info, event), {
            resourceRecord : this.scheduler.resolveResourceRecord(info.grabbed)
        });
    }

    /**
     * Provide your custom implementation of this to allow additional selected records to be dragged together with the original one.
     * @param {Scheduler.model.EventModel} eventRecord The eventRecord about to be dragged
     * @return {Scheduler.model.EventModel[]} An array of event records to drag together with the original event
     */
    getRelatedRecords(eventRecord) {
        return this.scheduler.selectedEvents.filter(selectedRecord => selectedRecord !== eventRecord && selectedRecord.isDraggable);
    }

    /**
     * Get correct axis coordinate depending on schedulers mode (horizontal -> x, vertical -> y). Also takes milestone
     * layout into account.
     * @private
     * @param {Scheduler.model.EventModel} eventRecord Record being dragged
     * @param {HTMLElement} element Element being dragged
     * @param {Number[]} coord XY coordinates
     * @returns {Number|Number[]} X,Y or XY
     */
    getCoordinate(eventRecord, element, coord) {
        const scheduler = this.currentOverClient;

        if (scheduler.isHorizontal) {
            let x = coord[0];

            // Adjust coordinate for milestones if using a layout mode, since they are aligned differently than events
            if (scheduler.milestoneLayoutMode !== 'default' && eventRecord.isMilestone) {
                switch (scheduler.milestoneAlign) {
                    case 'center':
                        x += element.offsetWidth / 2;
                        break;
                    case 'end':
                        x += element.offsetWidth;
                        break;
                }
            }

            return x;
        }
        else {
            let y = coord[1];
            // Adjust coordinate for milestones if using a layout mode, since they are aligned differently than events
            if (scheduler.milestoneLayoutMode !== 'default' && eventRecord.isMilestone) {
                switch (scheduler.milestoneAlign) {
                    case 'center':
                        y += element.offsetHeight / 2;
                        break;
                    case 'end':
                        y += element.offsetHeight;
                        break;
                }
            }

            return y;
        }
    }

    /**
     * Get resource record occluded by the drag proxy.
     * @private
     * @returns {Scheduler.model.ResourceModel}
     */
    resolveResource() {
        const
            me = this,
            client = me.currentOverClient,
            { isHorizontal } = client,
            { context } = me.dragData,
            element = context.dragProxy || context.element,
            // Page coords for elementFromPoint
            pageRect    = Rectangle.from(element, null, true),
            y           = (client.isVertical || me.unifiedDrag) ? context.clientY : pageRect.center.y,
            // Local coords to resolve resource in vertical
            localRect   = Rectangle.from(element, me.currentOverClient.timeAxisSubGridElement, true),
            { x : lx, y : ly } = localRect.center;

        // This is benchmarked as the fastest way to find a Grid Row from a viewport Y coordinate
        // so use it in preference to elementFromPoint (which causes a forced synchonous layout) in horiontal mode.
        if (isHorizontal) {
            const row = client.rowManager.getRowAt(y);

            return row && client.resourceStore.getAt(row.dataIndex);
        }

        // In vertical mode, just use the X coordinate to find out which resource we are under.
        // The method requires that a .b-sch-timeaxis-cell element be passed.
        // There is only one in vertical mode, so use that.
        return client.resolveResourceRecord(client.timeAxisSubGridElement.querySelector('.b-sch-timeaxis-cell'), [lx, ly]);
    }

    //endregion

    //region Other stuff

    adjustStartDate(startDate, timeDiff) {
        const scheduler = this.currentOverClient;

        return scheduler.timeAxis.roundDate(new Date(startDate - 0 + timeDiff), scheduler.snapRelativeToEventStartDate ? startDate : false);
    }

    resolveStartEndDates(proxyRect) {
        const
            scheduler     = this.currentOverClient,
            dd            = this.dragData;

        let { start : startDate, end : endDate } = scheduler.getStartEndDatesFromRectangle(proxyRect, 'round', dd.duration);

        if (!dd.startsOutsideView) {
            // Make sure we didn't target a start date that is filtered out, if we target last hour cell (e.g. 21:00) of
            // the time axis, and the next tick is 08:00 following day. Trying to drop at end of 21:00 cell should target start of next cell
            if (startDate && !scheduler.timeAxis.dateInAxis(startDate, false)) {
                const tick = scheduler.timeAxis.getTickFromDate(startDate);

                if (tick >= 0) {
                    startDate = scheduler.timeAxis.getDateFromTick(tick);
                }
            }

            endDate = DateHelper.add(startDate, dd.duration, 'ms');
        }
        else if (!dd.endsOutsideView) {
            startDate = DateHelper.add(endDate, -dd.duration, 'ms');
        }

        return {
            startDate,
            endDate
        };
    }

    //endregion
}

EventDrag._$name = 'EventDrag'; GridFeatureManager.registerFeature(EventDrag, true, 'Scheduler');

/**
 * @module Scheduler/feature/base/DragCreateBase
 */

// TODO: add hovertip if EvenDrag feature not used
// TODO: some of the code here could be shared with EventResize. make common base class?
// TODO: touch support
// TODO: mouse up outside not working as it should

/**
 * Base class for EventDragCreate (Scheduler) and TaskDragCreate (Gantt) features. Contains shared code. Not to be used directly.
 *
 * @extends Core/mixin/InstancePlugin
 */
class DragCreateBase extends InstancePlugin {
    //region Config

    static get defaultConfig() {
        return {
            /**
             * true to show a time tooltip when dragging to create a new event
             * @config {Boolean}
             * @default
             */
            showTooltip : true,

            /**
             * Number of pixels the drag target must be moved before dragging is considered to have started. Defaults to 2.
             * @config {Number}
             * @default
             */
            dragTolerance : 2,

            // used by gantt to only allow one task per row
            preventMultiple : false,

            validatorFn : () => {},

            /**
             * `this` reference for the validatorFn
             * @config {Object}
             */
            validatorFnThisObj : null,

            /**
             * CSS class to add to proxy used when creating a new event
             * @config {String}
             * @default
             * @private
             */
            proxyCls : 'b-sch-dragcreator-proxy',

            tipTemplate : data => `
                <div class="b-sch-tip-${data.valid ? 'valid' : 'invalid'}">
                    ${data.startClockHtml}
                    ${data.endClockHtml}
                    <div class="b-sch-tip-message">${data.message}</div>
                </div>
            `
        };
    }

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            chain  : ['onElementMouseDown', 'onElementMouseMove'],
            before : ['onElementContextMenu']
        };
    }

    doDestroy() {
        this.tip && this.tip.destroy();
        this.resize && this.resize.destroy();
        super.doDestroy();
    }

    //endregion

    //region Proxy element & resizing

    /**
     * Adds a proxy element to illustrate the timespan that might be created
     * @param config
     * @param {Core.data.Model} config.rowRecord  The row for which an event proxy element is being created.
     * @param {Number} config.startX the position along the time axis at which to display the proxy element.
     * @param {Number} [config.width] the width of the proxy element.
     */
    addProxy(config) {
        const
            me            = this,
            { client }    = me,
            { barMargin } = client,
            region        = client.currentOrientation.getRowRegion(config.rowRecord);

        let width, height, proxyX, proxyY;

        if (client.isHorizontal) {
            proxyX = ('currentX' in config) ? Math.min(config.startX, config.currentX + 1) : config.startX;
            proxyY = region.y + barMargin;
            width  = config.width || me.dragTolerance;
            height = region.height - barMargin * 2;
        }
        else {
            proxyX = region.x + barMargin;
            proxyY = ('currentY' in config) ? Math.min(config.startY, config.currentY + 1) : config.startY;
            width  = region.width - barMargin * 2;
            height = config.height || me.dragTolerance;
        }

        // This CSS class is to block further drag creates when one is in progress (like awaiting async finalization)
        client.element.classList.add('b-dragcreating');
        // This CSS class is to block hover for other events during actually dragging the proxy
        client.element.classList.add('b-dragcreating-proxy-sizing');

        // We are dragging to size element from nothing. Its size on drag is calculated by its *initial size*, plus the
        // mouse movement delta, so it MUST start at zero for that to yield the correct result.
        return me.proxy = DomHelper.createElement({
            parent        : client.foregroundCanvas,
            className     : me.proxyCls,
            style         : `transform:translate(${proxyX}px, ${proxyY}px);width:${width}px;height:${height}px`,
            // Prevent element from being recycled by DomHelper.sync()
            retainElement : true
        });
    }

    /**
     * Remove proxy element and clean up related stuff
     * @private
     */
    removeProxy() {
        const me = this;
        if (me.proxy) {
            me.proxy.remove();
            me.resize.destroy();
            me.proxy = me.resize = null;

            // This CSS class is to block further drag creates when one is in progress (like awaiting async finalization)
            me.client.element.classList.remove('b-dragcreating');
            // This CSS class is to block hover for other events during actually dragging the proxy
            me.client.element.classList.remove('b-dragcreating-proxy-sizing');
            me.tip && me.tip.hide();
        }
    }

    /**
     * Creates an instance of ResizeHelper used to resize the proxy element
     * @param event
     * @param data
     */
    initResizer(event, data) {
        const me = this;

        let edge;

        if (me.client.isHorizontal) {
            edge = data.currentX > data.startX ? 'right' : 'left';
        }
        else {
            edge = data.currentY > data.startY ? 'bottom' : 'top';
        }

        me.resize && me.resize.destroy();

        me.resize = new ResizeHelper({
            name      : me.constructor.name, // For debugging
            direction : me.client.isVertical ? 'vertical' : 'horizontal',
            isTouch   : event.type.startsWith('touch'),
            grab      : {
                element : me.proxy,
                edge,
                event   : data.startEvent
            },
            allowEdgeSwitch : true,   // Means that they can switch edges; the mouse can cross the zero point and drag the other way
            outerElement    : me.client.timeAxisSubGridElement, // Constrain resize to view
            scrollManager   : me.client.scrollManager,
            scroller        : me.client.timeAxisSubGrid.scrollable, // Scroll in both directions
            listeners       : {
                resizing : me.onResizing,
                resize   : me.onResize,
                cancel   : me.onCancel,
                thisObj  : me
            }
        });

        me.resize.context.resource = data.resource;
    }

    //endregion

    //region Tooltip

    /**
     * Creates a tooltip that displays start & end dates. Anchored to the proxy element
     */
    initTooltip() {
        const
            me     = this,
            client = me.client;

        if (me.showTooltip) {
            if (me.tip) {
                me.tip.showBy(me.getTooltipTarget());
            }
            else {
                me.clockTemplate = new ClockTemplate({
                    scheduler : client
                });

                me.tip = new Tooltip({
                    id                       : `${client.id}-drag-create-tip`,
                    autoShow                 : true,
                    trackMouse               : false,
                    updateContentOnMouseMove : true,
                    getHtml                  : me.getTipHtml.bind(me),
                    align                    : client.isVertical ? 't-b' : 'b100-t100',
                    hideDelay                : 0,
                    axisLock                 : true // Don't want it flipping to the side where we are dragging
                });

                me.tip.on('innerhtmlupdate', me.updateDateIndicator, me);
            }
        }
    }

    updateDateIndicator() {
        const
            me                     = this,
            { startDate, endDate } = me.createContext,
            tip                    = me.tip,
            endDateElement         = tip.element.querySelector('.b-sch-tooltip-enddate');

        if (startDate && endDate) {
            me.clockTemplate.updateDateIndicator(tip.element, startDate);

            endDateElement && me.clockTemplate.updateDateIndicator(endDateElement, endDate);
        }
    }

    /**
     * Updates tooltips contents
     * @returns {*}
     */
    getTipHtml() {
        if (!this.resize.context) return;

        // keeping this on separate row to not mess up look of other declarations
        const
            me        = this,
            client    = me.client,
            {
                edge,
                newX,
                newY,
                elementStartX,
                elementStartY,
                elementWidth,
                elementHeight,
                newWidth,
                newHeight,
                valid,
                message
            } = me.resize.context;

        let start, end;

        if (client.isHorizontal) {
            const
                x    = edge === 'left' ? newX : elementStartX,
                // Coordinates are 0 based, widths are not so subtracting 1 from the widths
                endX = Math.min(Math.max(x + (newWidth || elementWidth) - 1, 0), client.timeAxisViewModel.totalSize - 1);
            start = client.getDateFromCoordinate(x, 'round', true);
            end   = client.getDateFromCoordinate(endX, 'round', true);
        }
        else {
            const
                y    = edge === 'top' ? newY : elementStartY,
                // Coordinates are 0 based, widths are not so subtracting 1 from the widths
                endY = Math.min(Math.max(y + (newHeight || elementHeight) - 1, 0), client.timeAxisViewModel.totalSize - 1);
            start = client.getDateFromCoordinate(y, 'round', true);
            end   = client.getDateFromCoordinate(endY, 'round', true);
        }

        const
            first     = DateHelper.min(start, end),
            last      = DateHelper.max(start, end),
            startText = first && client.getFormattedDate(first),
            endText   = last && end && client.getFormattedEndDate(last, first);

        return me.tipTemplate({
            valid          : valid,
            startDate      : first,
            endDate        : last,
            startText      : startText,
            endText        : endText,
            message        : message,
            startClockHtml : me.clockTemplate.template({
                date : first,
                text : startText,
                cls  : 'b-sch-tooltip-startdate'
            }),
            endClockHtml : me.clockTemplate.template({
                // actual end date and display date may differ
                date : client.getDisplayEndDate(last, first),
                text : endText,
                cls  : 'b-sch-tooltip-enddate'
            })
        });
    }

    //endregion

    //region Finalize (create EventModel)

    finalize(doCreate) {
        const me = this;

        const resetFinalization = () => {
            me.proxy.retainElement = false;
            me.reset();
        };

        const completeFinalization = () => {
            me.client.trigger('afterDragCreate', {
                proxyElement : me.proxy
            });

            resetFinalization();
        };

        if (doCreate) {
            // Call product specific implementation
            const result = me.finalizeDragCreate(me.createContext);

            if (result instanceof Promise) {
                result.then(completeFinalization, resetFinalization);
            }
            else {
                completeFinalization();
            }
        }
        else {
            completeFinalization();
        }
    }

    //endregion

    //region Events

    onElementMouseDown(event) {
        const
            me = this,
            { client } = me;

        // detect mouse down directly in scheduler cell
        if (event.button === 0 && event.target.matches('.b-sch-timeaxis-cell') && !me.disabled && !client.readOnly) {
            const rowRecord = client.isVertical
                ? client.resolveResourceRecord(event)
                : client.getRecordFromElement(event.target);

            // no drag creation in group headers etc.
            if (rowRecord.meta.specialRow) {
                return;
            }

            if (me.preventMultiple && !me.isRowEmpty(rowRecord)) {
                return;
            }

            me.monitorMove = true;
            me.createContext = {
                startEvent   : event,
                startScreenX : event.screenX,
                startScreenY : event.screenY,
                startX       : event.offsetX,
                startY       : event.offsetY,
                cellElement  : event.target,
                rowRecord
            };

            

            me.mouseUpDetacher = EventHelper.on({
                element : document.body,
                mouseup : 'onMouseUp',
                once    : true,
                thisObj : this
            });
        }
    }

    onElementMouseMove(event) {
        const me = this;

        if (me.monitorMove) {
            const
                { createContext, client } = me,
                delta                     = me.client.isVertical
                    ? createContext.startScreenY - event.screenY
                    : createContext.startScreenX - event.screenX;

            if (Math.abs(delta) > me.dragTolerance) {
                const
                    dateTime = client.getDateFromDomEvent(event),
                    region   = Rectangle.from(client.timeAxisSubGridElement, null, true);

                if (me.handleBeforeDragCreate(dateTime, event) === false) {
                    me.monitorMove = false;
                    return;
                }

                // Math.max with 0 because if the mousedown is within dragTolerance of
                // the left edge and then drag goes left, dragging can begin with
                // the X in negative territory.
                createContext.currentX = Math.max(event.clientX - region.x + client.timeAxisSubGrid.scrollable.x, 0);
                createContext.currentY = Math.max(event.clientY - region.y + client.timeAxisSubGrid.scrollable.y, 0);
                me.addProxy(me.createContext);

                me.initResizer(event, me.createContext);
                me.initTooltip();

                me.monitorMove = false;

                client.trigger('dragCreateStart', {
                    proxyElement : me.proxy
                });
            }
        }

        // If dragcreate is async, resizer was already reset and we should not
        // align tooltip anymore
        if (me.proxy && me.showTooltip && me.resize.context) {
            me.tip.alignTo(me.getTooltipTarget());
        }
    }

    getTooltipTarget() {
        const
            me     = this,
            target = Rectangle.from(me.proxy, null, true);

        if (me.client.isVertical) {
            // Align to the dragged edge of the proxy, and then bump bottom so that the anchor aligns perfectly.
            if (me.resize.context.edge === 'bottom') {
                target.y = target.bottom - 1;
            }
            target.height = me.tip.anchorSize[1] / 2;
        }
        else {
            // Align to the dragged edge of the proxy, and then bump right so that the anchor aligns perfectly.
            if (me.resize.context.edge === 'right') {
                target.x = target.right - 1;
            }
            target.width = me.tip.anchorSize[0] / 2;
        }

        return { target };
    }

    onMouseUp() {
        const me = this;

        me.client.element.classList.remove('b-dragcreating-proxy-sizing');

        me.monitorMove = false;
    }

    /**
     * Prevent right click when drag creating
     * @returns {Boolean}
     * @internal
     */
    onElementContextMenu() {
        if (this.proxy) return false;
    }

    onResizing({ context, event }) {
        const
            me         = this,
            client     = me.client,
            x          = context.edge === 'left' ? context.newX : context.elementStartX,
            y          = context.edge === 'top' ? context.newY : context.elementStartY,
            // Coordinates are 0 based, widths are not so subtracting 1 from the widths
            endX       = Math.min(x + Math.max((context.newWidth || context.elementWidth) - 1, 0), client.timeAxisViewModel.totalSize - 1),
            endY       = Math.min(y + Math.max((context.newHeight || context.elementHeight) - 1, 0), client.timeAxisViewModel.totalSize - 1),
            startCoord = client.isVertical ? y : x,
            endCoord   = client.isVertical ? endY : endX,
            first      = client.getDateFromCoordinate(startCoord, 'round', true),
            last       = client.getDateFromCoordinate(endCoord, 'round', true),
            dc         = me.dateConstraints;

        let start = DateHelper.min(first, last),
            end   = DateHelper.max(first, last);

        if (dc) {
            end = DateHelper.constrain(end, dc.start, dc.end);
            start = DateHelper.constrain(start, dc.start, dc.end);
        }

        Object.assign(me.createContext, {
            startDate : start,
            endDate   : end
        });

        context.valid = me.checkValidity(me.createContext, event);
        context.message = '';

        if (context.valid && typeof context.valid !== 'boolean') {
            context.message = context.valid.message;
            context.valid = context.valid.valid;
        }

        // If users returns nothing, that's interpreted as valid
        context.valid = (context.valid !== false);
    }

    onResize({ context : { valid }, event }) {
        const
            me                     = this,
            { startDate, endDate } = me.createContext;

        if (!startDate || !endDate || (endDate - startDate <= 0)) valid = false;

        me.createContext = me.prepareCreateContextForFinalization(me.createContext, event, me.finalize.bind(me));

        if (valid) {
            me.client.trigger('beforeDragCreateFinalize', {
                context      : me.createContext,
                event,
                proxyElement : me.proxy
            });
        }

        // Drag create could be finalized immediately
        if (me.createContext) {
            // OMG, how not to confuse those contexts?
            me.resize.context.async = me.createContext.async;

            if (!me.createContext.async) {
                me.finalize(valid);
            }
            else {
                // We do not want to remove resizer yet, because it will also remove context and proxy element (or resize to 0 width)
                // Instead we blindfold resize helper to prevent event resize from starting parallel drag create
                me.resize.removeListeners();
            }
        }
    }

    prepareCreateContextForFinalization(createContext, event, finalize, async = false) {
        return Object.assign({}, createContext, {
            async,
            event,
            finalize
        });
    }

    get dragging() {
        return this.resize;
    }

    onCancel() {
        this.cancel();
    }

    cancel() {
        this.reset();
        this.mouseUpDetacher && this.mouseUpDetacher();
    }

    reset() {
        const me = this;

        me.removeProxy();
        me.createContext = null;
        me.monitorMove = false;
    }

    //endregion

    //region Product specific, implemented in subclasses

    checkValidity(context, event) {
        throw new Error('Implement in subclass');
    }

    triggerDragCreateEnd(newRecord, context) {
        throw new Error('Implement in subclass');
    }

    handleBeforeDragCreate(dateTime, event) {
        throw new Error('Implement in subclass');
    }

    isRowEmpty(rowRecord) {
        throw new Error('Implement in subclass');
    }

    //endregion
}
DragCreateBase._$name = 'DragCreateBase';

/**
 * @module Scheduler/feature/EventDragCreate
 */

// TODO: add hovertip if EventDrag feature not used
// TODO: some of the code here could be shared with EventResize. make common base class?
// TODO: touch support
// TODO: mouse up outside not working as it should

/**
 * Feature that allows the user to create new events by dragging in empty parts of the scheduler rows.
 *
 * This feature is **enabled** by default
 *
 * **NOTE:** Incompatible with {@link Scheduler.feature.Pan Pan} feature.
 *
 * @extends Scheduler/feature/base/DragCreateBase
 * @demo Scheduler/basic
 * @externalexample scheduler/EventDragCreate.js
 */
class EventDragCreate extends DragCreateBase {
    //region Config

    static get $name() {
        return 'EventDragCreate';
    }

    static get defaultConfig() {
        return {
            /**
             * An empty function by default, but provided so that you can perform custom validation on the event being created.
             * Return true if the new event is valid, false to prevent an event being created.
             * @param {Object} context A drag create context
             * @param {Date} context.startDate Event start date
             * @param {Date} context.endDate Event end date
             * @param {Scheduler.model.EventModel} context.record Event record
             * @param {Scheduler.model.ResourceModel} context.resourceRecord Resource record
             * @param {Event} event The event object
             * @return {Boolean} `true` if this validation passes
             * @config {function}
             */
            validatorFn : () => {}
        };
    }

    //endregion

    //region Events

    /**
     * Fires on the owning Scheduler after the new event has been created.
     * @event dragCreateEnd
     * @param {Scheduler.view.Scheduler} source
     * @param {Scheduler.model.EventModel} newEventRecord
     * @param {Scheduler.model.ResourceModel} resourceRecord
     * @param {MouseEvent} event The ending mouseup event.
     * @param {HTMLElement} proxyElement The proxy element showing the drag creation zone.
     */

    /**
     * Fires on the owning Scheduler at the beginning of the drag gesture
     * @event beforeDragCreate
     * @param {Scheduler.view.Scheduler} source
     * @param {Scheduler.model.ResourceModel} resourceRecord
     * @param {Date} date The datetime associated with the drag start point.
     */

    /**
     * Fires on the owning Scheduler after the drag start has created a proxy element.
     * @event dragCreateStart
     * @param {Scheduler.view.Scheduler} source
     * @param {HTMLElement} proxyElement The proxy representing the new event.
     */

    /**
     * Fired on the owning Scheduler to allow implementer to prevent immediate finalization by setting `data.context.async = true`
     * in the listener, to show a confirmation popup etc
     * ```
     *  scheduler.on('beforedragcreatefinalize', ({context}) => {
     *      context.async = true;
     *      setTimeout(() => {
     *          // async code don't forget to call finalize
     *          context.finalize();
     *      }, 1000);
     *  })
     * ```
     * @event beforeDragCreateFinalize
     * @param {Scheduler.view.Scheduler} source Scheduler instance
     * @param {HTMLElement} proxyElement Proxy element, representing future event
     * @param {Object} context
     * @param {Boolean} context.async Set true to handle drag create asynchronously (e.g. to wait for user
     * confirmation)
     * @param {Function} context.finalize Call this method to finalize drag create. This method accepts one
     * argument: pass true to update records, or false, to ignore changes
     */

    /**
     * Fires on the owning Scheduler at the end of the drag create gesture whether or not
     * a new event was created by the gesture.
     * @event afterDragCreate
     * @param {Scheduler.view.Scheduler} source
     * @param {HTMLElement} proxyElement The proxy element showing the drag creation zone.
     */

    //endregion

    //region Init

    construct(scheduler, config) {
        const me = this;

        me.scheduler = scheduler;

        // Assign eventStore as store, it is used when drag creating by shared code
        me.store = scheduler.eventStore;

        super.construct(scheduler, config);
    }

    //endregion

    //region Scheduler specific implementation

    finalizeDragCreate(context) {
        const newEventRecord = new this.store.modelClass({
            startDate : context.startDate,
            endDate   : context.endDate
        });

        this.proxy.dataset.eventId = newEventRecord.id;
        this.scheduler.trigger('dragCreateEnd', {
            newEventRecord,
            resourceRecord : context.rowRecord,
            event          : context.event,
            proxyElement   : this.proxy
        });
    }

    handleBeforeDragCreate(dateTime, event) {
        const
            me     = this,
            result = me.scheduler.trigger('beforeDragCreate', {
                resourceRecord : me.createContext.rowRecord,
                date           : dateTime,
                event
            });

        if (result) {
            // Tooltip will not be activated while drag is in progress,
            // but we need to hide it deliberately on drag start
            const tipFeature = me.scheduler.features.scheduleTooltip;
            if (tipFeature) {
                tipFeature.hoverTip && tipFeature.hoverTip.hide();
            }
        }

        // Save date constraints
        me.dateConstraints = me.scheduler.getDateConstraints(me.createContext.rowRecord, dateTime);

        return result;
    }

    checkValidity(context, event) {
        const
            me     = this,
            client = me.client;

        // Nicer for users of validatorFn
        context.resourceRecord = context.rowRecord;

        return (
            client.allowOverlap ||
            client.isDateRangeAvailable(context.startDate, context.endDate, null, context.resourceRecord)
        ) && me.validatorFn.call(me.validatorFnThisObj || me, context, event);
    }

    // Determine if resource already has events or not
    isRowEmpty(resourceRecord) {
        const events = this.store.getEventsForResource(resourceRecord);
        return !events || !events.length;
    }

    //endregion
}

EventDragCreate._$name = 'EventDragCreate'; GridFeatureManager.registerFeature(EventDragCreate, true, 'Scheduler');

/**
 * @module Scheduler/feature/EventDragSelect
 */

/**
 * Enables users to click and drag to select events inside the Scheduler's timeline.
 *
 * This feature is **disabled** by default.
 *
 * **NOTE:** Incompatible with {@link Scheduler.feature.EventDragCreate EventDragCreate} and the {@link Scheduler.feature.Pan Pan} features.
 *
 * @extends Core/mixin/InstancePlugin
 * @mixes Core/mixin/Delayable
 *
 * @example
 * let scheduler = new Scheduler({
 *   features : {
 *     eventDragSelect      : true,
 *     eventDragCreate      : false
 *   }
 * });
 *
 * @demo Scheduler/dragselection
 * @classtype eventDragSelect
 */
class EventDragSelect extends Delayable(InstancePlugin) {
    // region Init

    static get $name() {
        return 'EventDragSelect';
    }

    construct(timeline, config) {
        this.timeline = timeline;

        timeline.multiEventSelect = true;

        if (timeline.features.eventDragCreate || timeline.features.pan) {
            throw new Error('Cannot combine this feature with Pan or EventDragCreate features');
        }

        const targetSelectors = [
            '.b-timeline-subgrid .b-grid-cell',
            '.b-timeline-subgrid'
        ];

        this.targetSelector = targetSelectors.join(',');

        super.construct(timeline, config);
    }

    //endregion

    //region Plugin config

    // Plugin configuration. This plugin chains some of the functions in Scheduler.
    static get pluginConfig() {
        return {
            chain : ['onElementMouseDown', 'onElementMouseMove', 'onElementMouseUp']
        };
    }

    //endregion

    onElementMouseDown(event) {
        const
            me = this,
            scheduler = me.client;

        // only react to mouse input, and left button
        if (event.touches || event.button !== 0 || me.disabled) {
            return;
        }

        // only react to mousedown directly on grid cell or subgrid element
        if (event.target.matches(me.targetSelector)) {
            me.startX = event.clientX;
            me.startY = event.clientY;

            me.element = DomHelper.createElement({
                tag       : 'div',
                className : 'b-dragselect-rect'
            }, true)[0];

            Widget.floatRoot.appendChild(me.element);
            scheduler.element.classList.add('b-dragselecting');

            // Since the dragselect element is in the floatRoot, we want to use viewport-based coordinates, so we pass
            // ignorePageScroll=true when calling Rectangle.from():
            me.eventRectangles = Array.from(scheduler.element.querySelectorAll(scheduler.eventSelector)).map(el => ({
                rectangle : Rectangle.from(el, /* ignorePageScroll = */ true),
                record    : scheduler.resolveEventRecord(el)
            }));

            scheduler.clearEventSelection();
            me.subGridElementRect = Rectangle.from(scheduler.timeAxisSubGrid.element, /* ignorePageScroll = */ true);

            // No key processing during drag selection
            scheduler.navigator.disabled = true;
        }
    }

    onElementMouseMove(event) {
        const me = this;

        // Synthetic mousemove event has no button for IE11
        // Detect if a mouseup happened outside our element (or browser window for that matter). Note 'buttons' is not supported by Safari
        if (event.buttons === 0 && (!BrowserHelper.isSafari && (!BrowserHelper.isIE11 || event.isTrusted))) {
            me.onElementMouseUp(event);
            return;
        }

        if (typeof me.startX === 'number') {
            const
                x          = Math.max(event.clientX, me.subGridElementRect.left),
                y          = Math.max(event.clientY, me.subGridElementRect.top),
                left       = Math.min(me.startX, x),
                top        = Math.min(me.startY, y),
                width      = Math.abs(me.startX - x),
                height     = Math.abs(me.startY - y),
                rect       = new Rectangle(left, top, width, height).constrainTo(me.subGridElementRect);

            DomHelper.setTranslateXY(me.element, rect.left, rect.top);
            me.element.style.width  = rect.width + 'px';
            me.element.style.height = rect.height + 'px';

            me.rectangle  = rect;

            me.updateSelection();
        }
    }

    onElementMouseUp(event) {
        const me = this;

        if (typeof me.startX === 'number') {
            me.element && me.element.remove();
            me.client.element.classList.remove('b-dragselecting');
            me.startX = me.startY = null;

            // Navigator will react to the 'click' event which clears selection, bypass this with a short timeout
            me.setTimeout(() => me.client.navigator.disabled = false, 100);
        }
    }

    updateSelection() {
        const
            me = this,
            renderedEventRects = me.eventRectangles,
            rectangle = me.rectangle;

        for (let i = 0, len = renderedEventRects.length; i < len; i++) {
            const
                eventData = renderedEventRects[i],
                shouldSelect = rectangle.intersect(eventData.rectangle, true);

            if (shouldSelect && !eventData.selected) {
                eventData.selected = true;

                me.client.selectEvent(eventData.record, true);
            }
            else if (!shouldSelect && eventData.selected) {
                eventData.selected = false;

                me.client.deselectEvent(eventData.record);
            }
        }
    }
}

EventDragSelect._$name = 'EventDragSelect'; GridFeatureManager.registerFeature(EventDragSelect, false, 'Scheduler');

/**
 * @module Scheduler/feature/base/EditBase
 */

const DH = DateHelper,
    makeDate = (fields) => {
        // single field, update record directly
        if (fields.length === 1) return fields[0].value;
        // two fields, date + time
        else if (fields.length === 2) {
            const [date, time] = fields[0] instanceof DateField ? fields : fields.reverse(),
                dateValue = DH.parse(date.value);

            dateValue.setHours(
                time.value.getHours(),
                time.value.getMinutes(),
                time.value.getSeconds(),
                time.value.getMilliseconds()
            );

            return dateValue;
        }
        // shouldn't happen...
        return null;
    },
    copyTime = (dateTo, dateFrom) => {
        let d = new Date(dateTo.getTime());
        d.setHours(dateFrom.getHours(), dateFrom.getMinutes());
        return d;
    },
    adjustEndDate = (startDate, startTime, me) => {
        // The end datetime just moves in response to the changed start datetime, keeping the same duration.
        if (startDate && startTime) {
            const newEndDate = DH.add(copyTime(me.startDateField.value, me.startTimeField.value), me.eventRecord.durationMS, 'milliseconds');
            me.endDateField.value = newEndDate;
            me.endTimeField.value = DH.clone(newEndDate);
        }
    };

/**
 * Base class for EventEdit (Scheduler) and TaskEdit (Gantt) features. Contains shared code. Not to be used directly.
 *
 * @extends Core/mixin/InstancePlugin
 */
class EditBase extends InstancePlugin {
    //region Config

    // TODO: check which configs are actually used

    static get defaultConfig() {
        return {
            /**
             * True to hide this editor if a click is detected outside it (defaults to true)
             * @config {Boolean}
             * @default
             * @category Editor
             */
            autoClose : true,

            /**
             * True to save and close this panel if ENTER is pressed in one of the input fields inside the panel.
             * @config {Boolean}
             * @default
             * @category Editor
             */
            saveAndCloseOnEnter : true,

            triggerEvent : null,

            /**
             * True to show a delete button in the form.
             * @config {Boolean}
             * @default
             * @category Editor widgets
             */
            showDeleteButton : true,

            /**
             * True to show a text field for entering event name
             * @config {Boolean}
             * @default
             * @category Editor widgets
             */
            showNameField : true,

            /**
             * Config for the `startTimeField` constructor.
             * @config {Object}
             * @category Editor widgets
             */
            startTimeConfig : null,

            /**
             * Config for the `startDateField` constructor.
             * @config {Object}
             * @category Editor widgets
             */
            startDateConfig : null,

            /**
             * Config for the `endTimeField` constructor.
             * @config {Object}
             * @category Editor widgets
             */
            endTimeConfig : null,

            /**
             * Config for the `endDateField` constructor.
             * @config {Object}
             * @category Editor widgets
             */
            endDateConfig : null,

            /**
             * This config parameter is passed to the `startDateField` and `endDateField` constructor.
             * @config {String}
             * @default
             * @category Editor widgets
             */
            dateFormat : 'L', // date format that uses browser locale

            /**
             * This config parameter is passed to the `startTimeField` and `endTimeField` constructor.
             * @config {String}
             * @default
             * @category Editor widgets
             */
            timeFormat : 'LT', // date format that uses browser locale

            /**
             * Default editor configuration, which widgets it shows etc.
             * @config {Object}
             * @category Editor
             */
            editorConfig : null,

            /**
             * Array of widgets. Will be inserted above buttons unless an index is
             * specified for the widget:
             * ```
             * new Grid({
             *   features : {
             *     eventEdit : {
             *       extraItems : [
             *         { type : 'text', index : 1 },
             *         ...
             *       ]
             *     }
             *   }
             * });
             * ```
             * @config {String|Object[]}
             * @category Editor widgets
             */
            extraItems : null,

            /**
             * This config has been deprecated in favour of {@link #config-extraItems}.
             * @deprecated 2.1
             * @config {String|Object[]}
             * @category Editor widgets
             */
            extraWidgets : null
        };
    }

    //endregion

    //region Init & destroy

    construct(client, config) {
        const me = this;

        client.eventEdit = me;

        super.construct(client, config);

        me.clientListenersDetacher = client.on({
            [me.triggerEvent] : me.onActivateEditor,
            dragcreateend     : me.onDragCreateEnd,
            thisObj           : me
        });
    }

    doDestroy() {
        this.clientListenersDetacher();

        this.editor && this.editor.destroy();

        super.doDestroy();
    }

    //endregion

    //region Editing

    get editorConfig() {
        return this._editorConfig;
    }

    set editorConfig(editorConfig) {
        const me = this,
            defaultEditorConfig = me.getDefaultConfiguration().editorConfig;

        // Apply editorConfig to the default editorConfig, allowing users to manipulate for example only bbar
        editorConfig = ObjectHelper.assign({}, defaultEditorConfig, editorConfig);

        editorConfig.items = editorConfig.items || [];

        // Massage the incoming widgets according to our needs before caching the configuration for use in getEditor.
        me.insertExtraWidgetsIntoDefaultWidgets(editorConfig);

        me._editorConfig = editorConfig;
    }

    get extraWidgets() {
        if (!this._skipWarn) {
            console.warn('`extraWidgets` was deprecated in 2.1, please change your code to use `extraItems`');
        }
        return this._extraItems;
    }

    set extraWidgets(widgets) {
        console.warn('`extraWidgets` was deprecated in 2.1, please change your code to use `extraItems`');
        this._extraItems = widgets;
    }

    // TODO: When removing extraWidgets above, these can also be removed
    get extraItems() {
        const me = this;

        // Pull in extraWidgets, for compatibility
        me._skipWarn = true;
        me._thisIsAUsedExpression(me.extraWidgets);
        me._skipWarn = false;

        return me._extraItems;
    }

    set extraItems(items) {
        this._extraItems = items;
    }

    /**
     * Insert extra fields into default Editor fields according to specific rules:
     * - If no index provided insert them into `extraItems` placeholder (or at the end if not);
     * - If index provided sort ASC and insert one by one, but only after no-index fields are inserted;
     * - If `extraItems` placeholder exists, don't take widgets that go after it into account;
     * @private
     */
    insertExtraWidgetsIntoDefaultWidgets(editorConfig) {
        const me = this;

        if (!me.extraItems || !me.extraItems.length) {
            return;
        }

        // Find default extra widgets position
        let index = editorConfig.items.findIndex(widget => widget.type === 'extraItems'),
            tail;

        // If extra widgets placeholder exists
        if (index > -1) {
            // Remove extra widgets placeholder from its position
            editorConfig.items.splice(index, 1);

            // Backup everything that goes after extra widgets placeholder, like Save/Delete/Cancel buttons
            tail = editorConfig.items.splice(index);
        }

        // Split extra widgets on 2 parts: those which have index and those which haven't
        let withIndex    = me.extraItems.filter(widget => widget.index >= 0),
            withoutIndex = me.extraItems.filter(widget => !(widget.index >= 0));

        // Add those without index to the end of the default widgets
        editorConfig.items = editorConfig.items.concat(withoutIndex);

        // Sort those which have index in ASC order, so we insert fields in series
        withIndex.sort((widgetA, widgetB) => widgetA.index - widgetB.index);

        // And now insert extra widgets at their individually specified index
        withIndex.forEach(widget => editorConfig.items.splice(widget.index, 0, widget));

        if (tail && tail.length) {
            // Return backuped fields to the end of the widgets
            editorConfig.items = editorConfig.items.concat(tail);
        }
    }

    onDatesChange(params) {
        const me = this,
            field = params.source,
            value = params.value;

        switch (field.ref) {
            case 'startDateField':
                me.startTimeField && adjustEndDate(value, me.startTimeField.value, me);
                break;

            case 'startTimeField':
                me.startDateField && adjustEndDate(me.startDateField.value, value, me);
                break;
        }

        if (me.endTimeField) {
            // If the event starts and ends on the same day, the time fields need
            // to have their min and max set against each other.
            if (DH.isEqual(DH.clearTime(me.startDateField.value), DH.clearTime(me.endDateField.value))) {
                me.endTimeField.min = me.startTimeField.value;
            }
            else {
                me.endTimeField.min = null;
            }
        }
    }

    //endregion

    //region Save

    async save() {
        throw new Error('Implement in subclass');
    }

    get isValid() {
        const me = this;
        return Object.values(me.editor.widgetMap).every(field => {
            if (!field.name || field.hidden) {
                return true;
            }

            return field.isValid !== false;
        });
    }

    get values() {
        const
            me          = this,
            startFields = [],
            endFields   = [],
            values      = {};

        me.editor.eachWidget(widget => {
            const name = widget.name;

            if (!name || widget.hidden) {
                return;
            }

            switch (name) {
                case 'startDate':
                    startFields.push(widget);
                    break;
                case 'endDate':
                    endFields.push(widget);
                    break;
                case 'resource':
                    values[name] = widget.record;
                    break;
                default:
                    values[name] = widget.value;
            }
        }, true);

        values.startDate = makeDate(startFields);
        values.endDate = makeDate(endFields);

        // Since there is no duration field in the editor,
        // we don't need to recalc duration value on each date change.
        // It's enough to return correct duration value in `values`,
        // so the record will get updated with the correct data.
        values.duration = DH.diff(values.startDate, values.endDate, me.editor.record.durationUnit, true);

        return values;
    }

    /**
     * Template method, intended to be overridden. Called before the event record has been updated.
     * @param {Scheduler.model.EventModel} eventRecord The event record
     *
     **/
    onBeforeSave(eventRecord) {}

    /**
     * Template method, intended to be overridden. Called after the event record has been updated.
     * @param {Scheduler.model.EventModel} eventRecord The event record
     *
     **/
    onAfterSave(eventRecord) {}

    /**
     * Updates record being edited with values from the editor
     * @private
     */
    updateRecord(record) {
        const { values } = this;

        // Clean resourceId / resources out of values when using assignment store, it will handle the assignment
        if (this.scheduler.assignmentStore) {
            delete values.resource;
        }

        record.set(values);
    }

    //endregion

    //region Events

    resetEditingContext() {
        const me = this;
        // reset flag indicating that we are editing
        me.isEditing = false;
        me.client.element.classList.remove('b-eventeditor-editing');
        me.phantomEventElement && me.phantomEventElement.remove();
        me.phantomEventElement = null;
    }

    onPopupKeyDown({ event }) {
        if (event.key === 'Enter' && this.saveAndCloseOnEnter && event.target.tagName.toLowerCase() === 'input') {
            // Need to prevent this key events from being fired on whatever receives focus after the editor is hidden
            event.preventDefault();

            // If enter key was hit in an input element of a start field, need to adjust end date fields (the same way as if #onDatesChange handler was called)
            if (event.target.name === 'startDate') {
                adjustEndDate(this.startDateField.value, this.startTimeField.value, this);
            }

            this.onSaveClick();
        }
    }

    async onSaveClick() {
        const saved = await this.save();

        if (saved) {
            this.editor.close();
        }
    }

    async onDeleteClick() {
        const removed = await this.deleteEvent();

        if (removed) {
            // We expect deleteEvent will trigger close if autoClose is true and focus has moved out,
            // otherwise need to call it manually
            if (!this.editor.autoClose || this.editor.containsFocus) {
                this.editor.close();
            }
        }
    }

    onCancelClick() {
        this.editor.close();
    }

    //endregion
}
EditBase._$name = 'EditBase';

/**
 * @module Scheduler/view/EventEditor
 */

/**
 * Provided event editor dialog.
 *
 * @extends Core/widget/Popup
 * @private
 */
class EventEditor extends Popup {

    static get $name() {
        return 'EventEditor';
    }

    static get defaultConfig() {
        return {
            items     : [],
            draggable : {
                handleSelector : ':not(button,.b-field-inner)' // blacklist buttons and field inners
            },
            axisLock : 'flexible'
        };
    }

    processWidgetConfig(widget) {
        const me               = this,
            eventEditFeature = me.eventEditFeature;

        if (widget.type === 'extraItems') {
            return false;
        }

        let fieldConfig = {};

        if (widget.ref === 'resourceField') {
            if (!eventEditFeature.showResourceField) return false;

            // Can't use store directly since it may be grouped and then contains irrelevant group records
            me.resourceStore = widget.store = new eventEditFeature.resourceStore.constructor({
                chained         : true,
                chainAllRecords : true, // By default it chains processedRecords, leading to only "expanded" resources showing up in editor
                masterStore     : eventEditFeature.resourceStore,
                chainedFilterFn : record => !record.meta.specialRow
            });

            widget.multiSelect = Boolean(eventEditFeature.scheduler.assignmentStore);

            if (eventEditFeature.resourceFieldConfig) fieldConfig = eventEditFeature.resourceFieldConfig;
        }

        if (widget.ref === 'nameField' && !eventEditFeature.showNameField) return false;

        if (widget.ref === 'deleteButton' && !eventEditFeature.showDeleteButton) return false;

        if ((widget.name === 'startDate' || widget.name === 'endDate') && widget.type === 'date') {
            fieldConfig.format = eventEditFeature.dateFormat;
        }

        if ((widget.name === 'startDate' || widget.name === 'endDate') && widget.type === 'time') {
            fieldConfig.format = eventEditFeature.timeFormat;
        }

        if (eventEditFeature.startDateConfig && widget.name === 'startDate' && widget.type === 'date') {
            fieldConfig = eventEditFeature.startDateConfig;
        }

        if (eventEditFeature.startTimeConfig && widget.name === 'startDate' && widget.type === 'time') {
            fieldConfig = eventEditFeature.startTimeConfig;
        }

        if (eventEditFeature.endDateConfig && widget.name === 'endDate' && widget.type === 'date') {
            fieldConfig = eventEditFeature.endDateConfig;
        }

        if (eventEditFeature.endTimeConfig && widget.name === 'endDate' && widget.type === 'time') {
            fieldConfig = eventEditFeature.endTimeConfig;
        }

        Object.assign(widget, fieldConfig);

        return super.processWidgetConfig(widget);
    }

    show(...args) {
        // Updated chained store. It is not done automatically for grouping/trees.
        if (this.resourceStore) {
            this.resourceStore.fillFromMaster();
        }

        super.show(...args);
    }

    afterShow(...args) {
        const deleteButton = this.widgetMap.deleteButton;

        // Only show delete button if the event belongs to a store
        if (deleteButton) {
            deleteButton.hidden = this.readOnly || !this.record.stores.length;
        }
        super.afterShow(...args);
    }

    onInternalKeyDown(event) {
        this.trigger('keyDown', { event });
        super.onInternalKeyDown(event);
    }

    set readOnly(readOnly) {
        const { deleteButton, saveButton, cancelButton } = this.widgetMap;

        this._readOnly = readOnly;

        this.element.classList[readOnly ? 'add' : 'remove']('b-readonly');

        this.eachWidget(widget => {
            if (!('_originalReadOnly' in widget)) {
                // since `readOnly` on Field takes `disabled` into account, `widget.readOnly` doesn't represent initial value
                widget._originalReadOnly = widget._readOnly || false;
            }

            if (readOnly) {
                widget.readOnly = readOnly;
            }
            // Editor readonly: false means reset child widgets to their initial settings.
            else {
                widget.readOnly = widget._originalReadOnly;
            }
        });

        if (deleteButton) {
            deleteButton.hidden = readOnly;
        }

        if (saveButton) {
            saveButton.hidden = readOnly;
        }

        if (cancelButton) {
            cancelButton.hidden = readOnly;
        }
    }

    get readOnly() {
        return this._readOnly;
    }
}
EventEditor._$name = 'EventEditor';

/**
 * @module Scheduler/view/recurrence/RecurrenceConfirmationPopup
 */

/**
 * Confirmation dialog showing up before modifying a recurring event or some of its occurrences.
 * For recurring events the dialog notifies user that the event change/removal will cause all its occurrences
 * change/removal and asks to confirm the action.
 *
 * And for occurrences the dialog allows to choose if user wants to affect all further occurrences, this occurrence only or cancel the change.
 *
 * Usage example:
 *
 * ```javascript
 * const confirmation = new RecurrenceConfirmationPopup();
 *
 * confirmation.confirm({
 *     eventRecord : recurringEvent,
 *     actionType  : "delete",
 *     changerFn   : () => recurringEvent.remove(event)
 * });
 * ```
 *
 * @classType recurrenceconfirmation
 * @extends Core/widget/Popup
 */
class RecurrenceConfirmationPopup extends Popup {

    static get $name() {
        return 'RecurrenceConfirmationPopup';
    }

    static get defaultConfig() {
        return {
            localizableProperties : [],
            align                 : 'b-t',
            autoShow              : false,
            autoClose             : false,
            centered              : true,
            scrollAction          : 'realign',
            constrainTo           : window,
            draggable             : true,
            closable              : true,
            floating              : true,
            eventRecord           : null,
            cls                   : 'b-sch-recurrenceconfirmation',
            bbar                  : [
                /**
                 * Reference to the "apply changes to multiple occurrences" button, if used
                 * @member {Core.widget.Button} changeMultipleButton
                 * @readonly
                 */
                {
                    color       : 'b-green',
                    localeClass : this,
                    text        : 'L{Yes}',
                    ref         : 'changeMultipleButton'
                },
                /**
                 * Reference to the button that causes changing of the event itself only, if used
                 * @member {Core.widget.Button} changeSingleButton
                 * @readonly
                 */
                {
                    color       : 'b-gray',
                    localeClass : this,
                    text        : 'L{update-only-this-btn-text}',
                    ref         : 'changeSingleButton'
                },
                /**
                 * Reference to the cancel button, if used
                 * @member {Core.widget.Button} cancelButton
                 * @readonly
                 */
                {
                    color       : 'b-gray',
                    localeClass : this,
                    text        : 'L{Cancel}',
                    ref         : 'cancelButton'
                }
            ]
        };
    }

    construct(...args) {
        const me = this;

        super.construct(...args);

        const { changeMultipleButton, changeSingleButton, cancelButton } = me.widgetMap;

        changeMultipleButton && changeMultipleButton.on('click', me.onChangeMultipleButtonClick, me);
        changeSingleButton && changeSingleButton.on('click', me.onChangeSingleButtonClick, me);
        cancelButton && cancelButton.on('click', me.onCancelButtonClick, me);

        me.on('toolclick', me.onToolClick, me);
    }

    onChangeMultipleButtonClick() {
        this.processMultipleRecords();
        this.close();
    }

    onChangeSingleButtonClick() {
        this.processSingleRecord();
        this.close();
    }

    onCancelButtonClick() {
        this.cancelFn && this.cancelFn.call(this.thisObj);
        this.close();
    }

    onToolClick({ tool }) {
        if (tool.handler === 'close' && this.cancelFn) {
            this.cancelFn.call(this.thisObj);
        }
    }

    /**
     * Displays the confirmation.
     * Example usage:
     *
     * ```javascript
     * const popup = new RecurrenceConfirmationPopup();
     *
     * popup.confirm({
     *     eventRecord,
     *     actionType : "delete",
     *     changerFn  : () => eventStore.remove(record)
     * });
     * ```
     *
     * @param {Object}                     config               The following config options are supported:
     * @param {Scheduler.model.EventModel} config.eventRecord   Event being modified.
     * @param {String}                     config.actionType    Type of modification to be applied to the event. Can be either "update" or "delete".
     * @param {Function}                   config.changerFn     A function that should be called to apply the change to the event upon user choice.
     * @param {Function}                   [config.thisObj]     `changerFn` and `cancelFn` functions scope.
     * @param {Function}                   [config.cancelFn]    Function called on `Cancel` button click.
     */
    confirm(config = {}) {
        const me = this;

        

        [
            'actionType',
            'eventRecord',
            'title',
            'html',
            'changerFn',
            'cancelFn',
            'thisObj'
        ].forEach(prop => {
            if (prop in config) me[prop] = config[prop];
        });

        me.updatePopupContent();

        return super.show(config);
    }

    updatePopupContent() {
        const
            me = this,
            { changeMultipleButton, changeSingleButton, cancelButton } = me.widgetMap;

        let { eventRecord, actionType = 'update' } = me,
            isMaster = eventRecord && eventRecord.isRecurring;

        // the following lines are added to satisfy the 904_unused localization test
        // to let it know that these locales are used:
        // me.L('delete-further-message')
        // me.L('update-further-message')
        // me.L('delete-all-message')
        // me.L('update-all-message')
        // me.L('delete-further-btn-text')
        // me.L('update-further-btn-text')
        // me.L('delete-only-this-btn-text')
        // me.L('update-only-this-btn-text')

        if (isMaster) {
            changeMultipleButton.text = me.L('Yes');
            me.html = me.L(`${actionType}-all-message`);
        }
        else {
            changeMultipleButton.text = me.L(`${actionType}-further-btn-text`);
            me.html = me.L(`${actionType}-further-message`);
        }

        changeSingleButton.text = me.L(`${actionType}-only-this-btn-text`);
        cancelButton.text       = me.L('Cancel');

        // TODO: so far we hide 'Only this event' option for a recurring event itself until this case is supported
        if (isMaster) {
            changeSingleButton.hide();
        }
        else {
            changeSingleButton.show();
        }

        me.width = me.L('width');

        // the following lines are added to satisfy the 904_unused localization test
        // to let it know that these locales are used:
        // this.L('delete-title') not found
        // this.L('update-title') not found
        me.title = me.L(`${actionType}-title`);
    }

    processMultipleRecords() {
        const
            { eventRecord, changerFn, thisObj } = this,
            { recurringEvent }                  = eventRecord,
            stopDate                            = new Date(eventRecord.startDate - 1);

        eventRecord.beginBatch();

        // apply changes to the occurrence
        changerFn.call(thisObj, eventRecord);

        // reset occurrence linkage to the "master" event
        eventRecord.recurringTimeSpanId = null;

        eventRecord.endBatch();

        // stop the previous recurrence
        if (recurringEvent) {
            recurringEvent.recurrence.endDate = stopDate;
        }
    }

    processSingleRecord() {
        const
            { eventRecord, changerFn, thisObj } = this,
            { recurringEvent, startDate }  = eventRecord;

        eventRecord.beginBatch();

        changerFn.call(thisObj);

        eventRecord.recurrence = null;

        eventRecord.endBatch();

        recurringEvent.addExceptionDate(startDate);
    }

    updateLocalization() {
        this.updatePopupContent();
        super.updateLocalization();
    }

}
RecurrenceConfirmationPopup._$name = 'RecurrenceConfirmationPopup'; BryntumWidgetAdapterRegister.register('recurrenceconfirmation', RecurrenceConfirmationPopup);

/**
 * @module Scheduler/view/recurrence/field/RecurrenceFrequencyCombo
 */

/**
 * A combobox field allowing to pick frequency in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.
 *
 * @extends Core/widget/Combo
 * @classType recurrencefrequencycombo
 */
class RecurrenceFrequencyCombo extends LocalizableComboItems(Combo) {

    static get $name() {
        return 'RecurrenceFrequencyCombo';
    }

    static get defaultConfig() {
        return {
            editable     : false,
            displayField : 'text',
            valueField   : 'value'
        };
    }

    buildLocalizedItems() {
        return [
            { value : 'DAILY',   text : this.L('Daily') },
            { value : 'WEEKLY',  text : this.L('Weekly') },
            { value : 'MONTHLY', text : this.L('Monthly') },
            { value : 'YEARLY',  text : this.L('Yearly') }
        ];
    }
}
RecurrenceFrequencyCombo._$name = 'RecurrenceFrequencyCombo'; BryntumWidgetAdapterRegister.register('recurrencefrequencycombo', RecurrenceFrequencyCombo);

/**
 * @module Scheduler/view/recurrence/field/RecurrenceCombo
 */

/**
 * A combobox field displaying the recurrence by either mode: `Daily`, `Weekly`, `Monthly` or `Yearly` if the recurrence
 * has no other non-default settings, or `Custom...` if the recurrence has custom setting applied.
 *
 * @extends Scheduler/view/recurrence/field/RecurrenceFrequencyCombo
 * @classType recurrencecombo
 */
class RecurrenceCombo extends RecurrenceFrequencyCombo {

    static get $name() {
        return 'RecurrenceCombo';
    }

    static get defaultConfig() {
        return {
            customValue             : 'custom',
            placeholder             : 'None',
            // TODO: draw a splitting line
            splitCls                : 'b-recurrencecombo-split',
            items                   : true,
            highlightExternalChange : false
        };
    }

    buildLocalizedItems() {
        const me = this;

        return [
            { value : 'none', text : me.L('None') },
            ...super.buildLocalizedItems(),
            { value : me.customValue, text : me.L('Custom...'), cls : me.splitCls }
        ];
    }

    set value(value) {
        // Use 'none' instead of falsy value
        value = value || 'none';

        super.value = value;
    }

    get value() {
        return super.value;
    }

    set recurrence(recurrence) {
        const me = this;

        if (recurrence) {
            me.value = me.isCustomRecurrence(recurrence) ? me.customValue : recurrence.frequency;
        }
        else {
            me.value = null;
        }
    }

    isCustomRecurrence(recurrence) {
        const { interval, days, monthDays, months } = recurrence;

        return Boolean(interval > 1 || (days && days.length) || (monthDays && monthDays.length) || (months && months.length));
    }
}
RecurrenceCombo._$name = 'RecurrenceCombo'; BryntumWidgetAdapterRegister.register('recurrencecombo', RecurrenceCombo);

/**
 * @module Scheduler/view/recurrence/RecurrenceLegendButton
 */

/**
 * Class implementing a button which text displays the associated recurrence info in a human readable form.
 * @extends Core/widget/Button
 * @classType recurrencelegendbutton
 */
class RecurrenceLegendButton extends Button {

    static get $name() {
        return 'RecurrenceLegendButton';
    }

    static get defaultConfig() {
        return {
            localizableProperties : [],
            recurrence            : null
        };
    }

    /**
     * Sets the recurrence to display description for.
     * @param {Scheduler.model.RecurrenceModel} recurrence Recurrence model.
     */
    set recurrence(recurrence) {
        this._recurrence = recurrence;
        this.updateLegend();
    }

    get recurrence() {
        return this._recurrence;
    }

    set eventStartDate(eventStartDate) {
        this._eventStartDate = eventStartDate;
        this.updateLegend();
    }

    get eventStartDate() {
        return this._eventStartDate;
    }

    updateLegend() {
        const
            me             = this,
            { recurrence } = me;

        me.text = recurrence ? RecurrenceLegend.getLegend(recurrence, me.eventStartDate) : '';
    }

    onLocaleChange() {
        // on locale switch we update the button text to use proper language
        this.updateLegend();
    }

    updateLocalization() {
        this.onLocaleChange();
        super.updateLocalization();
    }
}

RecurrenceLegendButton._$name = 'RecurrenceLegendButton'; BryntumWidgetAdapterRegister.register('recurrencelegendbutton', RecurrenceLegendButton);

/**
 * @module Scheduler/view/recurrence/field/RecurrenceDaysCombo
 */

/**
 * A combobox field allowing to pick days for the `Monthly` and `Yearly` mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.
 *
 * @extends Core/widget/Combo
 * @classType recurrencedayscombo
 */
class RecurrenceDaysCombo extends LocalizableComboItems(Combo) {

    static get $name() {
        return 'RecurrenceDaysCombo';
    }

    static get defaultConfig() {
        const allDaysValue = 'SU,MO,TU,WE,TH,FR,SA';

        return {
            allDaysValue,
            editable            : false,
            defaultValue        : allDaysValue,
            workingDaysValue    : 'MO,TU,WE,TH,FR',
            nonWorkingDaysValue : 'SU,SA',
            splitCls            : 'b-recurrencedays-split',
            displayField        : 'text',
            valueField          : 'value'
        };
    }

    buildLocalizedItems() {
        const me = this;

        me._weekDays = null;

        return me.weekDays.concat([
            { value : me.allDaysValue,        text : me.L('day'), cls : me.splitCls },
            { value : me.workingDaysValue,    text : me.L('weekday') },
            { value : me.nonWorkingDaysValue, text : me.L('weekend day') }
        ]);
    }

    get weekDays() {
        const me = this;

        if (!me._weekDays) {
            const weekStartDay = DateHelper.weekStartDay;

            const dayNames = DateHelper.getDayNames().map((text, index) => ({ text, value : RecurrenceDayRuleEncoder.encodeDay(index) }));

            // we should start week w/ weekStartDay
            me._weekDays = dayNames.slice(weekStartDay).concat(dayNames.slice(0, weekStartDay));
        }

        return me._weekDays;
    }

    set value(value) {
        const me = this;

        if (value && Array.isArray(value)) {
            value = value.join(',');
        }

        // if the value has no matching option in the store we need to use default value
        if (!value || !me.store.findRecord('value', value)) {
            value = me.defaultValue;
        }

        super.value = value;
    }

    get value() {
        let value = super.value;

        if (value && Array.isArray(value)) {
            value = value.join(',');
        }

        return value;
    }
}

RecurrenceDaysCombo._$name = 'RecurrenceDaysCombo'; BryntumWidgetAdapterRegister.register('recurrencedayscombo', RecurrenceDaysCombo);

/**
 * @module Scheduler/view/recurrence/field/RecurrenceDaysButtonGroup
 */

/**
 * A segmented button field allowing to pick days for the "Weekly" mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.
 *
 * @extends Core/widget/ButtonGroup
 */
class RecurrenceDaysButtonGroup extends ButtonGroup {

    static get $name() {
        return 'RecurrenceDaysButtonGroup';
    }

    static get defaultConfig() {
        return {
            defaults : {
                cls        : 'b-raised',
                toggleable : true
            }
        };
    }

    construct(config = {}) {
        const me = this;

        config.columns = 7;
        config.items   = me.buildItems();

        super.construct(config);
    }

    updateItemText(item) {
        const day = RecurrenceDayRuleEncoder.decodeDay(item.value)[0];

        item.text = DateHelper.getDayName(day).substring(0, 3);
    }

    buildItems() {
        const me = this;

        if (!me.__items) {
            const weekStartDay = DateHelper.weekStartDay;

            const dayNames = DateHelper.getDayNames().map((text, index) => ({
                text  : text.substring(0, 3),
                value : RecurrenceDayRuleEncoder.encodeDay(index)
            }));

            // we should start week w/ weekStartDay
            me.__items = dayNames.slice(weekStartDay).concat(dayNames.slice(0, weekStartDay));
        }

        return me.__items;
    }

    set value(value) {
        if (value && Array.isArray(value)) {
            value = value.join(',');
        }

        super.value = value;
    }

    get value() {
        let value = super.value;

        if (value && Array.isArray(value)) {
            value = value.join(',');
        }

        return value;
        // return value ? value.split(',') : [];
    }

    onLocaleChange() {
        // update button texts on locale switch
        this.items.forEach(this.updateItemText, this);
    }

    updateLocalization() {
        this.onLocaleChange();
        super.updateLocalization();
    }

    get widgetClassList() {
        const classList = super.widgetClassList;
        // to look more like a real field
        classList.push('b-field');
        return classList;
    }
}
RecurrenceDaysButtonGroup._$name = 'RecurrenceDaysButtonGroup'; BryntumWidgetAdapterRegister.register('recurrencedaysbuttongroup', RecurrenceDaysButtonGroup);

/**
 * A segmented button field allowing to pick month days for the `Monthly` mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.
 *
 * @extends Core/widget/ButtonGroup
 */
class RecurrenceMonthDaysButtonGroup extends ButtonGroup {

    static get $name() {
        return 'RecurrenceMonthDaysButtonGroup';
    }

    static get defaultConfig() {
        return {
            defaults : {
                toggleable : true,
                cls        : 'b-raised'
            }
        };
    }

    get minValue() {
        return 1;
    }

    get maxValue() {
        return 31;
    }

    construct(config = {}) {
        const me = this;

        config.columns = 7;
        config.items   = me.buildItems();

        super.construct(config);
    }

    buildItems() {
        const
            me    = this,
            items = [];

        for (let value = me.minValue; value <= me.maxValue; value++) {
            // button config
            items.push({
                text : value + '',
                value
            });
        }

        return items;
    }

    get widgetClassList() {
        const classList = super.widgetClassList;
        // to look more like a real field
        classList.push('b-field');
        return classList;
    }

}
RecurrenceMonthDaysButtonGroup._$name = 'RecurrenceMonthDaysButtonGroup'; BryntumWidgetAdapterRegister.register('recurrencemonthdaysbuttongroup', RecurrenceMonthDaysButtonGroup);

/**
 * A segmented button field allowing to pick months for the `Yearly` mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.
 *
 * @extends Core/widget/ButtonGroup
 */
class RecurrenceMonthsButtonGroup extends ButtonGroup {

    static get $name() {
        return 'RecurrenceMonthsButtonGroup';
    }

    static get defaultConfig() {
        return {
            defaults : {
                toggleable : true,
                cls        : 'b-raised'
            }
        };
    }

    construct(config = {}) {
        const me = this;

        config.columns = 4;
        config.items   = me.buildItems();

        super.construct(config);
    }

    buildItems() {
        return DateHelper.getMonthNames().map((item, index) => ({
            text  : item.substring(0, 3),
            value : index + 1 // 1-based
        }));
    }

    updateItemText(item) {
        item.text = DateHelper.getMonthName(item.value - 1).substring(0, 3);
    }

    onLocaleChange() {
        // update button texts on locale switch
        this.items.forEach(this.updateItemText, this);
    }

    updateLocalization() {
        this.onLocaleChange();
        super.updateLocalization();
    }

    get widgetClassList() {
        const classList = super.widgetClassList;
        // to look more like a real field
        classList.push('b-field');
        return classList;
    }

}
RecurrenceMonthsButtonGroup._$name = 'RecurrenceMonthsButtonGroup'; BryntumWidgetAdapterRegister.register('recurrencemonthsbuttongroup', RecurrenceMonthsButtonGroup);

/**
 * @module Scheduler/view/recurrence/field/RecurrenceStopConditionCombo
 */

/**
 * A combobox field allowing to choose stop condition for the recurrence in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.
 *
 * @extends Core/widget/Combo
 * @classType recurrencestopconditioncombo
 */
class RecurrenceStopConditionCombo extends LocalizableComboItems(Combo) {

    static get $name() {
        return 'RecurrenceStopConditionCombo';
    }

    static get defaultConfig() {
        return {
            editable     : false,
            placeholder  : 'Never',
            displayField : 'text',
            valueField   : 'value'
        };
    }

    buildLocalizedItems() {
        return [
            { value : 'never', text : this.L('Never') },
            { value : 'count', text : this.L('After') },
            { value : 'date',  text : this.L('On date') }
        ];
    }

    set value(value) {
        // Use 'never' instead of falsy value
        value = value || 'never';

        super.value = value;
    }

    get value() {
        return super.value;
    }

    get recurrence() {
        return this._recurrence;
    }

    set recurrence(recurrence) {
        let value = null;

        if (recurrence.endDate) {
            value = 'date';
        }
        else if (recurrence.count) {
            value = 'count';
        }

        this._recurrence = recurrence;

        this.value = value;
    }
}
RecurrenceStopConditionCombo._$name = 'RecurrenceStopConditionCombo'; BryntumWidgetAdapterRegister.register('recurrencestopconditioncombo', RecurrenceStopConditionCombo);

/**
 * @module Scheduler/view/recurrence/field/RecurrencePositionsCombo
 */

/**
 * A combobox field allowing to specify day positions in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence editor}.
 *
 * @extends Core/widget/Combo
 * @classType recurrencepositionscombo
 */
class RecurrencePositionsCombo extends LocalizableComboItems(Combo) {

    static get $name() {
        return 'RecurrencePositionsCombo';
    }

    static get defaultConfig() {
        return {
            editable     : false,
            splitCls     : 'b-sch-recurrencepositions-split',
            displayField : 'text',
            valueField   : 'value',
            defaultValue : 1,
            maxPosition  : 5
        };
    }

    buildLocalizedItems() {
        const me = this;

        return me.buildDayNumbers().concat([
            // the following lines are added to satisfy the 904_unused localization test
            // to let it know that these locales are used:
            // this.L('position-1')
            { value : '-1', text : me.L('position-1'), cls : me.splitCls }
        ]);
    }

    buildDayNumbers() {
        const me = this;

        // the following lines are added to satisfy the 904_unused localization test
        // to let it know that these locales are used:
        // this.L('position1')
        // this.L('position2')
        // this.L('position3')
        // this.L('position4')
        // this.L('position5')

        return ArrayHelper.populate(me.maxPosition, i => (
            { value : i, text : me.L(`position${i}`) }
        ));
    }

    set value(value) {
        const me = this;

        if (value && Array.isArray(value)) {
            value = value.join(',');
        }

        // if the value has no matching option in the store we need to use default value
        if (!value || !me.store.findRecord('value', value)) {
            value = me.defaultValue;
        }

        super.value = value;
    }

    get value() {
        const value = super.value;

        return value ? `${value}`.split(',').map(item => parseInt(item, 10)) : [];
    }

}
RecurrencePositionsCombo._$name = 'RecurrencePositionsCombo'; BryntumWidgetAdapterRegister.register('recurrencepositionscombo', RecurrencePositionsCombo);

/**
 * @module Scheduler/view/recurrence/RecurrenceEditor
 */

/**
 * Class implementing a dialog to edit {@link Scheduler.model.RecurrenceModel Recurrence model}.
 * The class is used by the {@link Scheduler.feature.RecurringEvents recurring events} feature and you don't need to instantiate it normally.
 * Before showing the dialog need to use {@link #property-record} to load a {@link Scheduler.model.RecurrenceModel Recurrence model}
 * data into the editor fields. For example:
 *
 * ```javascript
 * // make the editor instance
 * const editor = new RecurrenceEditor();
 * // load recurrnce model into it
 * editor.record = new RecurrenceModel({ frequency : "WEEKLY" });
 * // display the editor
 * editor.show();
 * ```
 *
 * @extends Core/widget/Popup
 * @classType recurrenceeditor
 */
class RecurrenceEditor extends Popup {

    static get $name() {
        return 'RecurrenceEditor';
    }

    static get defaultConfig() {
        return {
            draggable : true,
            closable  : true,
            floating  : true,
            cls       : 'b-recurrenceeditor',
            title     : 'L{Repeat event}',
            autoClose : true,
            width     : 400,
            items     : {
                frequencyField           : true,
                daysButtonField          : true,
                monthDaysRadioField      : true,
                monthDaysButtonField     : true,
                monthsButtonField        : true,
                positionAndDayRadioField : true,
                stopRecurrenceField      : true,
                countField               : true,
                endDateField             : true,
                intervalField            : true,
                positionsCombo           : true,
                daysCombo                : true
            },
            namedItems : {
                frequencyField : {
                    type        : 'recurrencefrequencycombo',
                    name        : 'frequency',
                    localeClass : this,
                    label       : 'L{Frequency}',
                    weight      : 10,
                    onChange    : 'up.onFrequencyFieldChange'
                },
                intervalField : {
                    type        : 'numberfield',
                    weight      : 15,
                    name        : 'interval',
                    localeClass : this,
                    label       : 'L{Every}',
                    labels      : [
                        {
                            align     : 'end',
                            reference : 'intervalUnit',
                            style     : {
                                width : '50em'
                            }
                        }
                    ],
                    min        : 1,
                    allowBlank : false
                },
                daysButtonField : {
                    type         : 'recurrencedaysbuttongroup',
                    weight       : 20,
                    name         : 'days',
                    forFrequency : 'WEEKLY'
                },
                // the radio button enabling "monthDaysButtonField" in MONTHLY mode
                monthDaysRadioField : {
                    type         : 'checkbox',
                    weight       : 30,
                    toggleGroup  : 'radio',
                    forFrequency : 'MONTHLY',
                    localeClass  : this,
                    label        : 'L{Each}',
                    checked      : true,
                    onChange     : 'up.onMonthDaysRadioFieldChange'
                },
                monthDaysButtonField : {
                    type         : 'recurrencemonthdaysbuttongroup',
                    weight       : 40,
                    name         : 'monthDays',
                    forFrequency : 'MONTHLY'
                },
                monthsButtonField : {
                    type         : 'recurrencemonthsbuttongroup',
                    weight       : 50,
                    name         : 'months',
                    forFrequency : 'YEARLY'
                },
                // the radio button enabling positions & days combos in MONTLY & YEARLY modes
                positionAndDayRadioField : {
                    type         : 'checkbox',
                    weight       : 60,
                    toggleGroup  : 'radio',
                    forFrequency : 'MONTHLY|YEARLY',
                    localeClass  : this,
                    label        : 'L{On the}',
                    onChange     : 'up.onPositionAndDayRadioFieldChange'
                },
                positionsCombo : {
                    type         : 'recurrencepositionscombo',
                    weight       : 80,
                    name         : 'positions',
                    forFrequency : 'MONTHLY|YEARLY'
                },
                daysCombo : {
                    type         : 'recurrencedayscombo',
                    weight       : 90,
                    name         : 'days',
                    forFrequency : 'MONTHLY|YEARLY',
                    flex         : 1
                },
                stopRecurrenceField : {
                    type        : 'recurrencestopconditioncombo',
                    weight      : 100,
                    localeClass : this,
                    label       : 'L{End repeat}',
                    onChange    : 'up.onStopRecurrenceFieldChange'
                },
                countField : {
                    type        : 'numberfield',
                    weight      : 110,
                    name        : 'count',
                    min         : 2,
                    localeClass : this,
                    allowBlank  : false,
                    disabled    : true,
                    label       : ' ',
                    labels      : [
                        {
                            align     : 'end',
                            reference : 'countUnit',
                            label     : 'L{time(s)}'
                        }
                    ]

                },
                endDateField : {
                    type       : 'datefield',
                    weight     : 120,
                    name       : 'endDate',
                    hidden     : true,
                    disabled   : true,
                    label      : ' ',
                    allowBlank : false
                }
            },
            bbar : [
                {
                    type : 'widget',
                    cls  : 'b-label-filler'
                },
                {
                    type        : 'button',
                    color       : 'b-green',
                    ref         : 'saveButton',
                    localeClass : this,
                    text        : 'L{Save}',
                    onClick     : 'up.onSaveClick'
                },
                {
                    type        : 'button',
                    color       : 'b-gray',
                    ref         : 'cancelButton',
                    localeClass : this,
                    text        : 'L{Cancel}',
                    onClick     : 'up.onCancelClick'
                }

            ]
        };
    }

    /**
     * Recurrence record loaded into the editor.
     * @property {Scheduler.model.RecurrenceModel}
     */
    get record() {
        return super.record;
    }

    set record(record) {
        super.record = record;

        const
            me        = this,
            event     = record.timeSpan,
            startDate = event && event.startDate,
            {
                daysButtonField,
                monthDaysButtonField,
                monthsButtonField,
                monthDaysRadioField,
                positionAndDayRadioField,
                stopRecurrenceField
            } = me.widgetMap;

        // some fields default values are calculated based on event "startDate" value
        if (startDate) {
            // if no "days" value provided
            if (!record.days || !record.days.length) {
                daysButtonField.value = [RecurrenceDayRuleEncoder.encodeDay(startDate.getDay())];
            }

            // if no "monthDays" value provided
            if (!record.monthDays || !record.monthDays.length) {
                monthDaysButtonField.value = startDate.getDate();
            }

            // if no "months" value provided
            if (!record.months || !record.months.length) {
                monthsButtonField.value = startDate.getMonth() + 1;
            }
        }

        // if the record has both "days" & "positions" fields set check "On the" checkbox
        if (record.days && record.positions) {
            positionAndDayRadioField.check();
            // TODO: if toggleGroup members are not painted automatic unchecking doesn't work
            if (!me.isPainted) {
                monthDaysRadioField.uncheck();
            }
        }
        else {
            monthDaysRadioField.check();
            // TODO: if toggleGroup members are not painted automatic unchecking doesn't work
            if (!me.isPainted) {
                positionAndDayRadioField.uncheck();
            }
        }

        stopRecurrenceField.recurrence = record;
    }

    onSaveClick() {
        const me = this;

        if (me.saveHandler) {
            me.saveHandler.call(me.thisObj || me, me, me.record);
        }
        else {
            me.updateRecord();
            me.close();
        }
    }

    onCancelClick() {
        const me = this;

        if (me.cancelHandler) {
            me.cancelHandler.call(me.thisObj || me, me, me.record);
        }
        else {
            me.close();
        }
    }

    /**
     * Updates the provided recurrence model with the contained form data.
     * If recurrence model is not provided updates the last loaded recurrence model.
     */
    updateRecord(recurrence) {
        // get values relevant to the RecurrenceModel (from enabled fields only)
        const values = this.getValues((w) => w.name in recurrence && !w.disabled);

        recurrence.set(values);
    }

    toggleStopFields() {
        const
            me = this,
            { countField, endDateField } = me.widgetMap;

        switch (me.widgetMap.stopRecurrenceField.value) {

            case 'count' :
                countField.show();
                countField.enable();
                endDateField.hide();
                endDateField.disable();
                break;

            case 'date' :
                countField.hide();
                countField.disable();
                endDateField.show();
                endDateField.enable();
                break;

            default :
                countField.hide();
                endDateField.hide();
                countField.disable();
                endDateField.disable();
        }
    }

    onMonthDaysRadioFieldChange({ checked }) {
        const { monthDaysButtonField } = this.widgetMap;

        monthDaysButtonField.disabled = !checked || !this.isWidgetAvailableForFrequency(monthDaysButtonField);
    }

    onPositionAndDayRadioFieldChange({ checked }) {
        const { daysCombo, positionsCombo } = this.widgetMap;

        // toggle day & positions combos
        daysCombo.disabled = positionsCombo.disabled = !checked || !this.isWidgetAvailableForFrequency(daysCombo);
    }

    onStopRecurrenceFieldChange() {
        this.toggleStopFields();
    }

    isWidgetAvailableForFrequency(widget, frequency = this.widgetMap.frequencyField.value) {
        return !widget.forFrequency || widget.forFrequency.indexOf(frequency) > -1;
    }

    onFrequencyFieldChange({ value, valid }) {
        const
            me  = this,
            items = me.queryAll((w) => 'forFrequency' in w);

        if (valid && value) {
            for (let i = 0; i < items.length; i++) {
                const item = items[i];

                if (me.isWidgetAvailableForFrequency(item, value)) {
                    item.show();
                    item.enable();
                }
                else {
                    item.hide();
                    item.disable();
                }
            }

            // The following lines are added to satisfy the 904_unused localization test
            // to let it know that these locales are used:
            // this.L('DAILYintervalUnit')
            // this.L('WEEKLYintervalUnit')
            // this.L('MONTHLYintervalUnit')
            // this.L('YEARLYintervalUnit')
            me.widgetMap.intervalField.intervalUnit.innerHTML = me.L(`${value}intervalUnit`);

            me.toggleFieldsState();
        }
    }

    toggleFieldsState() {
        const me = this,
            { widgetMap } = this;

        me.onMonthDaysRadioFieldChange({ checked : widgetMap.monthDaysRadioField.checked });
        me.onPositionAndDayRadioFieldChange({ checked : widgetMap.positionAndDayRadioField.checked });
        me.onStopRecurrenceFieldChange();
    }

    updateLocalization() {
        // do extra labels translation (not auto-translated yet)
        const { countField, intervalField, frequencyField } = this.widgetMap;

        countField.countUnit.innerHTML = this.L('time(s)');
        intervalField.intervalUnit.innerHTML = this.L(`${frequencyField.value}intervalUnit`);

        super.updateLocalization();
    }

}

RecurrenceEditor._$name = 'RecurrenceEditor'; BryntumWidgetAdapterRegister.register('recurrenceeditor', RecurrenceEditor);

/**
 * @module Scheduler/feature/mixin/RecurringEventEdit
 */

/**
 * This mixin class provides recurring events functionality to the {@link Scheduler.feature.EventEdit event editor}.
 * @mixin
 */
var RecurringEventEdit = Target => class RecurringEventEdit extends (Target || Base) {

    static get $name() {
        return 'RecurringEventEdit';
    }

    static get defaultConfig() {
        return {
            recurringEventsItems : [
                /**
                 * Reference to the `Repeat` event field, if used
                 * @member {Scheduler.view.recurrence.field.RecurrenceCombo} recurrenceCombo
                 * @readonly
                 */
                {
                    type     : 'recurrencecombo',
                    label    : 'L{Repeat}',
                    ref      : 'recurrenceCombo'
                },
                /**
                 * Reference to the button that opens the event repeat settings dialog, if used
                 * @member {Scheduler.view.recurrence.RecurrenceLegendButton} editRecurrenceButton
                 * @readonly
                 */
                {
                    type : 'recurrencelegendbutton',
                    ref  : 'editRecurrenceButton',
                    name : 'recurrenceRule',
                    flex : '1'
                }
            ],

            /**
             * Set to `false` to hide recurring fields in event editor,
             * even if the {@link Scheduler.feature.RecurringEvents Recurring Events} feature is enabled
             * @config {Boolean}
             * @category Recurring
             */
            showRecurringUI : null
        };
    }

    insertExtraWidgetsIntoDefaultWidgets(editorConfig) {
        // inject recurring events widgets first
        this.processEditorConfig(editorConfig);

        super.insertExtraWidgetsIntoDefaultWidgets(editorConfig);
    }

    processEditorConfig(editorConfig) {
        const { items } = editorConfig;

        // find extraItems positions in the array
        const extraItemsIndex = items.findIndex(item => item.type === 'extraItems');

        // if no extraItems in the array ..append
        if (extraItemsIndex < 0) {
            items.push(...this.recurringEventsItems);
        }
        // otherwise insert before extraItems
        else {
            items.splice(extraItemsIndex, 0, ...this.recurringEventsItems);
        }
    }

    construct(scheduler, config) {
        const me = this;

        super.construct(scheduler, config);

        me.scheduler.on({
            beforeEventDelete : me.onRecurrableEventBeforeDelete,
            beforeEventSave   : me.onRecurrableEventBeforeSave,
            thisObj           : me
        });
    }

    doDestroy() {
        this._recurrenceConfirmation && this.recurrenceConfirmation.destroy();
        this._recurrenceEditor && this.recurrenceEditor.destroy();

        super.doDestroy();
    }

    get isRecurringEnabled() {
        return Boolean(this.scheduler.features.recurringEvents && !this.scheduler.features.recurringEvents.disabled);
    }

    onEditorConstructed(editor) {
        const me = this;

        editor.on('hide', me.onRecurringEventEditorHide, me);

        me.editRecurrenceButton && me.editRecurrenceButton.on('click', me.onEditRecurrenceClick, me);
        me.recurrenceCombo.on('change', me.onRecurrenceComboChange.bind(me));
    }

    internalShowEditor() {
        this.toggleRecurringFieldsVisibility(this.isRecurringEnabled && this.showRecurringUI !== false);
    }

    toggleRecurringFieldsVisibility(show = true) {
        const methodName = show ? 'show' : 'hide';

        this.editRecurrenceButton && this.editRecurrenceButton[methodName]();
        this.recurrenceCombo && this.recurrenceCombo[methodName]();
    }

    onRecurringEventEditorHide({ source }) {
        const { recurrenceEditor, recurrenceConfirmation } = this;

        if (recurrenceEditor && recurrenceEditor.isVisible) {
            recurrenceEditor.hide();
        }
        if (recurrenceConfirmation && recurrenceConfirmation.isVisible) {
            recurrenceConfirmation.hide();
        }
    }

    // Builds RecurrenceModel to load into the recurrenceEditor
    // It builds the model based on either:
    // - recurrence rule string (if provided)
    // - or the event being edited recurrence (if the event is repeating)
    // - or simply make a recurrence model w/ default state (by default means: Frequency=Daily, Interval=1)
    makeRecurrence(rule) {
        const
            event     = this.eventRecord,
            eventCopy = event.copy();

        let recurrence = event.recurrence;

        if (!rule && recurrence) {
            recurrence = recurrence.copy();
        }
        else {
            recurrence = new event.recurrenceModel({ rule });
        }

        // bind cloned recurrence to the cloned event
        recurrence.timeSpan = eventCopy;
        // update cloned event w/ start date from the UI field
        eventCopy.setStartDate(this.values.startDate);

        recurrence.suspendTimeSpanNotifying();

        return recurrence;
    }

    onRecurrableEventBeforeSave({ eventRecord, context }) {
        const me = this;

        if (eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence)) {
            me.recurrenceConfirmation.confirm({
                actionType : 'update',
                eventRecord,
                changerFn() {
                    context.finalize(true);
                },
                cancelFn() {
                    context.finalize(false);
                }
            });

            // signalizes that we plan to decide save or not asynchronously
            context.async = true;

            return false;
        }
    }

    showDisplayConfirmationOnEventDelete(eventRecord) {
        return this.isEditing && this.eventRecord === eventRecord && eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence);
    }

    onRecurrableEventBeforeDelete({ eventRecords, context }) {
        const [eventRecord] = eventRecords;

        if (this.showDisplayConfirmationOnEventDelete(eventRecord)) {
            this.recurrenceConfirmation.confirm({
                actionType : 'delete',
                eventRecord,
                changerFn() {
                    context.finalize(true);
                },
                cancelFn() {
                    context.finalize(false);
                }
            });

            return false;
        }
    }

    set recurrenceConfirmation(recurrenceConfirmation) {
        this._recurrenceConfirmation = recurrenceConfirmation;
    }

    get recurrenceConfirmation() {
        const me = this;

        let recurrenceConfirmation = me._recurrenceConfirmation;

        if (!recurrenceConfirmation || !recurrenceConfirmation.$name) {
            recurrenceConfirmation = WidgetHelper.createWidget(Object.assign({
                type  : 'recurrenceconfirmation',
                owner : me.getEditor()
            }, recurrenceConfirmation));

            me._recurrenceConfirmation = recurrenceConfirmation;
        }

        return recurrenceConfirmation;
    }

    set recurrenceEditor(recurrenceEditor) {
        this._recurrenceEditor = recurrenceEditor;
    }

    get recurrenceEditor() {
        const me = this;

        let recurrenceEditor = me._recurrenceEditor;

        if (!recurrenceEditor || !recurrenceEditor.$name) {
            recurrenceEditor = WidgetHelper.createWidget(Object.assign({
                type         : 'recurrenceeditor',
                autoShow     : false,
                owner        : me.getEditor(),
                scrollAction : 'realign',
                clippedBy    : [me.scheduler.timeAxisSubGridElement, me.scheduler.bodyContainer],
                constrainTo  : window,
                anchor       : true,
                saveHandler  : me.recurrenceEditorSaveHandler,
                thisObj      : me
            }, recurrenceEditor));

            me._recurrenceEditor = recurrenceEditor;
        }

        return recurrenceEditor;
    }

    showRecurrenceEditor() {
        const
            me = this,
            { recurrenceEditor, eventRecord } = me;

        if (recurrenceEditor && eventRecord && eventRecord.supportsRecurring) {

            // if the event has no recurrence yet ..initialize it before showing recurrence editor
            if (!me.recurrence) {
                me.recurrence = me.makeRecurrence();
            }

            // update the cloned recurrence w/ up to date start date value
            me.recurrence.timeSpan.setStartDate(me.values.startDate);

            // load RecurrenceModel record into the recurrence editor
            recurrenceEditor.record = me.recurrence;

            recurrenceEditor.showBy(me.recurrenceCombo.element);
        }
    }

    onEditRecurrenceClick() {
        this.showRecurrenceEditor();
    }

    loadRecurrenceData(recurrence) {
        this.recurrence = recurrence;

        this.updateRecurrenceFields(recurrence);
    }

    updateRecurrenceFields(recurrence) {
        const me = this;

        if (me.recurrenceCombo) {
            me.recurrenceCombo.recurrence = recurrence;
        }

        // update the recurrence legend
        if (me.editRecurrenceButton) {
            me.editRecurrenceButton.recurrence = recurrence;
            me.editRecurrenceButton.value      = recurrence ? recurrence.rule : null;

            if (recurrence && me.isRecurringEnabled && me.showRecurringUI !== false) {
                me.editRecurrenceButton.show();
            }
            else {
                me.editRecurrenceButton.hide();
            }
        }
    }

    onRecurrenceComboChange({ source, value, userAction }) {
        const me = this;

        if (value == source.customValue) {
            // if user picked "Custom" - show recurrence editor
            if (userAction) {
                me.showRecurrenceEditor();
            }
        }
        // user has picked some frequency -> make a new recurrence based on it
        else {
            me.loadRecurrenceData(value ? me.makeRecurrence(`FREQ=${value}`) : null);
        }
    }

    recurrenceEditorSaveHandler(editor, recurrence) {
        // apply changes to the kept recurrence
        editor.updateRecord(recurrence);

        // update the recurrence related UI
        this.updateRecurrenceFields(recurrence);

        editor.close();
    }

    onDatesChange(...args) {
        super.onDatesChange(...args);

        const
            me = this,
            { editRecurrenceButton } = me;

        if (!me.loadingRecord && editRecurrenceButton) {
            const { startDate } = me.values;
            if (startDate) editRecurrenceButton.eventStartDate = startDate;
        }
    }

    internalLoadRecord(eventRecord, resourceRecord) {
        if (this.recurrenceCombo && eventRecord && eventRecord.supportsRecurring) {
            this.loadRecurrenceData(eventRecord.recurrence ? this.makeRecurrence() : null);
        }
    }
};

/**
 * @module Scheduler/feature/EventEdit
 */

/**
 * Feature that displays a popup containing fields for editing event data.
 *
 * To customize its contents you can:
 *
 * * Toggle visibility of some built in widgets: `showResourceField`, `showNameField` and `showDeleteButton`
 * * Change the date format of the date & time fields: `dateFormat` and `timeFormat`
 * * Configure date & time fields: `startDateConfig`, `startTimeConfig`, `endDateConfig` and `endTimeConfig`
 * * Configure the resource field: `resourceFieldConfig`
 * * Append additional fields: `extraItems`
 * * Advanced: Replace entire contents using `editorConfig`
 *
 * This feature is **enabled** by default
 *
 * @mixes Scheduler/feature/mixin/RecurringEventEdit
 * @extends Scheduler/feature/base/EditBase
 * @demo Scheduler/eventeditor
 * @externalexample scheduler/EventEdit.js
 */
class EventEdit extends RecurringEventEdit(EditBase) {
    //region Config

    static get $name() {
        return 'EventEdit';
    }

    // TODO: check which configs are actually used

    static get defaultConfig() {
        return {
            /**
             * The event that shall trigger showing the editor. Defaults to `eventdblclick`, set to `` or null to disable editing of existing events.
             * @config {String}
             * @default
             * @category Editor
             */
            triggerEvent : 'eventdblclick',

            /**
             * True to show a combo for picking resource
             * @config {Boolean}
             * @default
             * @category Editor widgets
             */
            showResourceField : true,

            // TODO remove this config?
            /**
             * Config for the resourceField constructor.
             * @config {Object}
             * @category Editor widgets
             */
            resourceFieldConfig : null,

            /**
             * The data field in the model that defines the eventType.
             * Applied as class (b-eventtype-xx) to the editors element, to allow showing/hiding fields depending on
             * eventType. Dynamic toggling of fields in the editor is activated by using `ref: 'eventTypeField'` on
             * your widget:
             *
             * ```javascript
             * const scheduler = new Scheduler({
             *    features : {
             *       eventEdit  : {
             *           extraItems : [
             *               {
             *                   type  : 'combo',
             *                   name  : 'eventType',
             *                   ref   : 'eventTypeField',
             *                   label : 'Type',
             *                   items : ['Appointment', 'Internal', 'Meeting']
             *               }
             *           ]
             *        }
             *     }
             * });
             * ```
             *
             * @config {String}
             * @default
             * @category Editor
             */
            typeField : 'eventType',

            /**
             * The current {@link Scheduler.model.EventModel} record, which is being edited by the event editor.
             * @property {Scheduler.model.EventModel}
             * @readonly
             */
            eventRecord : null,

            /**
             * Specify `true` to put the editor in read only mode.
             * @config {Boolean}
             * @default false
             */
            readOnly : null,

            /**
             * The configuration for the internal editor widget. With this config you can control which widgets to shows, if popup should be modal etc.
             *
             * ```javascript
             * const scheduler = new Scheduler({
             *    features : {
             *       eventEdit  : {
             *           editorConfig : {
             *               modal  : true,
             *               cls    : 'my-editor' // A CSS class
             *           }
             *        }
             *     }
             * });
             * ```
             * @config {Object}
             * @category Editor
             */
            editorConfig : {
                title       : 'L{Edit Event}',
                localeClass : this,
                closable    : true,

                items : [
                    /**
                     * Reference to the name field, if used
                     * @member {Core.widget.TextField} nameField
                     * @readonly
                     */
                    {
                        type        : 'text',
                        localeClass : this,
                        label       : 'L{Name}',
                        clearable   : true,
                        name        : 'name',
                        ref         : 'nameField'
                    },
                    /**
                     * Reference to the resource field, if used
                     * @member {Core.widget.Combo} resourceField
                     * @readonly
                     */
                    {
                        type         : 'combo',
                        localeClass  : this,
                        label        : 'L{Resource}',
                        name         : 'resource',
                        ref          : 'resourceField',
                        editable     : true,
                        valueField   : 'id',
                        displayField : 'name'
                    },
                    /**
                     * Reference to the start date field, if used
                     * @member {Core.widget.DateField} startDateField
                     * @readonly
                     */
                    {
                        type        : 'date',
                        cls         : 'b-inline',
                        clearable   : false,
                        required    : true,
                        localeClass : this,
                        label       : 'L{Start}',
                        name        : 'startDate',
                        ref         : 'startDateField',
                        flex        : '1 0 60%'
                    },
                    /**
                     * Reference to the start time field, if used
                     * @member {Core.widget.TimeField} startTimeField
                     * @readonly
                     */
                    {
                        type      : 'time',
                        clearable : false,
                        required  : true,
                        name      : 'startDate',
                        ref       : 'startTimeField',
                        cls       : 'b-match-label',
                        flex      : '1 0 40%'
                    },
                    /**
                     * Reference to the end date field, if used
                     * @member {Core.widget.DateField} endDateField
                     * @readonly
                     */
                    {
                        type        : 'date',
                        cls         : 'b-inline',
                        clearable   : false,
                        required    : true,
                        localeClass : this,
                        label       : 'L{End}',
                        name        : 'endDate',
                        ref         : 'endDateField',
                        flex        : '1 0 60%'
                    },
                    /**
                     * Reference to the end time field, if used
                     * @member {Core.widget.TimeField} endTimeField
                     * @readonly
                     */
                    {
                        type      : 'time',
                        clearable : false,
                        required  : true,
                        name      : 'endDate',
                        ref       : 'endTimeField',
                        cls       : 'b-match-label',
                        flex      : '1 0 40%'
                    },
                    {
                        // widgets specified in extraItems will be inserted here
                        type : 'extraItems'
                    }
                ],

                bbar : [
                    {
                        type : 'widget',
                        cls  : 'b-label-filler'
                    },
                    /**
                     * Reference to the save button, if used
                     * @member {Core.widget.Button} saveButton
                     * @readonly
                     */
                    {
                        color       : 'b-green',
                        localeClass : this,
                        text        : 'L{Save}',
                        ref         : 'saveButton'
                    },
                    /**
                     * Reference to the delete button, if used
                     * @member {Core.widget.Button} deleteButton
                     * @readonly
                     */
                    {
                        color       : 'b-gray',
                        localeClass : this,
                        text        : 'L{Delete}',
                        ref         : 'deleteButton'
                    },
                    /**
                     * Reference to the cancel button, if used
                     * @member {Core.widget.Button} cancelButton
                     * @readonly
                     */
                    {
                        color       : 'b-gray',
                        localeClass : this,
                        text        : 'L{Cancel}',
                        ref         : 'cancelButton'
                    }
                ]
            }
        };
    }

    static get pluginConfig() {
        return {
            chain : [
                'getEventMenuItems',
                'onEventEnterKey'
            ],
            assign : ['editEvent']
        };
    }

    //endregion

    //region Init & destroy

    construct(scheduler, config) {
        const me = this;

        me.scheduler = scheduler;
        me.eventStore = scheduler.eventStore;
        me.resourceStore = scheduler.resourceStore;

        super.construct(scheduler, config);
    }

    //endregion

    //region Editing

    /**
     * Get/set readonly state
     * @property {Boolean}
     */
    get readOnly() {
        return this.editor ? this.editor.readOnly : this._readOnly;
    }

    set readOnly(readOnly) {
        this._readOnly = readOnly;

        if (this.editor) {
            this.editor.readOnly = readOnly;
        }
    }

    /**
     * Gets an editor instance. Creates on first call, reuses on consecutive
     * @internal
     * @returns {Core.widget.Popup} Editor popup
     */
    getEditor() {
        const me = this;

        let { editor } = me;

        if (editor) {
            return editor;
        }

        editor = me.editor = new EventEditor(me.getEditorConfig());

        if (editor.items.length === 0) {
            console.warn('Event Editor configured without any `items`');
        }

        // add listeners programmatically so users cannot override them accidentally
        editor.on({
            beforehide : me.resetEditingContext,
            keydown    : me.onPopupKeyDown,
            thisObj    : me
        });

        // assign widget variables, using widget name: startDate -> me.startDateField
        // widgets with id set use that instead, id -> me.idField
        Object.values(editor.widgetMap).forEach(widget => {
            const ref = widget.ref || widget.id;
            // don't overwrite if already defined
            if (ref && !me[ref]) {
                me[ref] = widget;

                switch (widget.name) {
                    case 'startDate':
                    case 'endDate':
                        widget.on('change', me.onDatesChange, me);
                        break;
                }
            }
        });

        // launch onEditorConstructed hook if provided
        me.onEditorConstructed && me.onEditorConstructed(editor);

        me.eventTypeField && me.eventTypeField.on('change', me.onEventTypeChange, me);

        me.saveButton && me.saveButton.on('click', me.onSaveClick, me);
        me.deleteButton && me.deleteButton.on('click', me.onDeleteClick, me);
        me.cancelButton && me.cancelButton.on('click', me.onCancelClick, me);

        return me.editor;
    }

    getEditorConfig() {
        const
            me                           = this,
            { autoClose, cls, readOnly } = me;

        return ObjectHelper.assign({
            eventEditFeature : me,
            align            : 'b-t',
            id               : `${me.scheduler.id}-event-editor`,
            autoShow         : false,
            anchor           : true,
            scrollAction     : 'realign',
            clippedBy        : [me.scheduler.timeAxisSubGridElement, me.scheduler.bodyContainer],
            constrainTo      : window,
            autoClose,
            readOnly,
            cls
        }, me.editorConfig);
    }

    // Called from editEvent() to actually show the editor
    internalShowEditor(eventRecord, resourceRecord, element = null) {
        const
            me           = this,
            scheduler    = me.scheduler,
            // Align to the element (b-sch-event) and not the wrapper
            eventElement = element || DomHelper.down(
                scheduler.getElementFromEventRecord(eventRecord, resourceRecord),
                scheduler.eventInnerSelector
            );

        // Event not in current TimeAxis - cannot be edited without extending the TimeAxis.
        // If there's no event element and the eventRecord is not in the store, we still
        // edit centered on the Scheduler - we're adding a new event
        if (eventElement || !eventRecord.isPartOfStore(scheduler.eventStore)) {
            /**
             * Fires on the owning Scheduler before an event is displayed in an editor.
             * This may be listened for to allow an application to take over event editing duties. Returning `false`
             * stops the default editing UI from being shown.
             * @event beforeEventEdit
             * @param {Scheduler.view.Scheduler} source The scheduler
             * @param {Scheduler.feature.EventEdit} eventEdit The eventEdit feature
             * @param {Scheduler.model.EventModel} eventRecord The record about to be shown in the event editor.
             * @param {Scheduler.model.ResourceModel} resourceRecord The Resource record for the event. If the event
             * is being created, it will not contain a resource, so this parameter specifies the resource the
             * event is being created for.
             * @param {HTMLElement} eventElement The element which represents the event in the scheduler display.
             * @preventable
             */
            if (scheduler.trigger('beforeEventEdit', {
                eventEdit : me,
                eventRecord,
                resourceRecord,
                eventElement
            }) === false) {
                scheduler.element.classList.remove('b-eventeditor-editing');
                me.phantomEventElement && me.phantomEventElement.remove();
                me.phantomEventElement = null;
                return;
            }

            me.resourceRecord = resourceRecord;

            const editor = me.getEditor(eventRecord);

            super.internalShowEditor && super.internalShowEditor(eventRecord, resourceRecord, element);

            if (me.typeField) {
                me.toggleEventType(eventRecord.get(me.typeField));
            }

            /**
             * Fires on the owning Scheduler when the editor for an event is available but before it is populated with
             * data and shown. Allows manipulating fields etc.
             * @event beforeEventEditShow
             * @param {Scheduler.view.Scheduler} source The scheduler
             * @param {Scheduler.feature.EventEdit} eventEdit The eventEdit feature
             * @param {Scheduler.model.EventModel} eventRecord The record about to be shown in the event editor.
             * @param {Scheduler.model.ResourceModel} resourceRecord The Resource record for the event. If the event
             * is being created, it will not contain a resource, so this parameter specifies the resource the
             * event is being created for.
             * @param {HTMLElement} eventElement The element which represents the event in the scheduler display.
             * @param {Core.widget.Popup} editor The editor
             */
            scheduler.trigger('beforeEventEditShow', {
                eventEdit : me,
                eventRecord,
                resourceRecord,
                eventElement,
                editor
            });

            // raise flag indicating that we are editing an event
            me.isEditing = true;

            me.loadRecord(eventRecord, resourceRecord);

            if (eventElement) {
                eventElement.classList.add('b-editing');
                editor.showBy({
                    target : eventElement,
                    anchor : true
                });
            }
            // We are adding a new event. Display the editor centered in the Scheduler
            else {
                editor.showBy({
                    target : scheduler.element,
                    anchor : false,
                    align  : 'c-c'
                });
            }

            // Adjust time field step increment based on timeAxis resolution
            const timeResolution = scheduler.timeAxisViewModel.timeResolution;

            if (timeResolution.unit === 'hour' || timeResolution.unit === 'minute') {
                me.startTimeField.step = me.endTimeField.step = `${timeResolution.increment}${timeResolution.unit}`;
            }
        }
    }

    /**
     * Opens an editor for the passed event. This function is exposed on Scheduler and can be called as
     * `scheduler.editEvent()`.
     * @param {Scheduler.model.EventModel} eventRecord Event to edit
     * @param {Scheduler.model.ResourceModel} [resourceRecord] The Resource record for the event.
     * This parameter is needed if the event is newly created for a resource and has not been assigned, or when using
     * multi assignment.
     * @param {HTMLElement} [element] Element to anchor editor to (defaults to events element)
     */
    editEvent(eventRecord, resourceRecord, element = null) {
        const
            me          = this,
            scheduler   = me.scheduler,
            isNewRecord = scheduler.eventStore.indexOf(eventRecord) < 0;

        if (me.isEditing) {
            // old editing flow already running, clean it up
            me.resetEditingContext();
        }

        if (scheduler.readOnly || me.disabled) {
            return;
        }

        // The Promise being async allows a mouseover to trigger the event tip
        // unless we add the editing class immediately.
        scheduler.element.classList.add('b-eventeditor-editing');

        if (!resourceRecord) {
            if (eventRecord.resource) {
                resourceRecord = eventRecord.resource;
            }
            // New event not yet in store has not got the relation set up, use id if available
            else if (eventRecord.resourceId) {
                resourceRecord = scheduler.resourceStore.getById(eventRecord.resourceId);
            }
        }

        if (isNewRecord) {
            // Assume ownership of the phantom element
            this.phantomEventElement = element;
        }

        // If element is specified (call triggered by EventDragCreate)
        // Then we can align to that, and no scrolling is necessary.
        // If we are simply being asked to edit a new event which is not
        // yet added, the editor is centered, and no scroll is necessary
        if (element || isNewRecord) {
            me.internalShowEditor(eventRecord, resourceRecord, element);
        }
        else {
            // Ensure event is in view before showing the editor.
            // Note that we first need to extend the time axis to include
            // currently out of range events.
            scheduler.scrollResourceEventIntoView(resourceRecord, eventRecord, null, {
                animate        : true,
                edgeOffset     : 0,
                extendTimeAxis : false
            }).then(() => me.internalShowEditor(eventRecord, resourceRecord), () => scheduler.element.classList.remove('b-eventeditor-editing'));
        }
    }

    /**
     * Sets fields values from record being edited
     * @private
     */
    loadRecord(eventRecord, resourceRecord) {
        this.loadingRecord = true;

        this.internalLoadRecord(eventRecord, resourceRecord);

        this.loadingRecord = false;
    }

    internalLoadRecord(eventRecord, resourceRecord) {
        const
            me             = this,
            { eventStore } = me.client;

        me.eventRecord = eventRecord;
        me.resourceRecord = resourceRecord;

        me.editor.record = eventRecord;

        if (me.resourceField) {
            const resources = eventStore.getResourcesForEvent(eventRecord);

            // If this is an unassigned event, select the resource we've been provided
            if (!eventStore.storage.includes(eventRecord, true) && me.resourceRecord) {
                me.resourceField.value = me.resourceRecord[me.resourceField.valueField];
            }
            else if (me.scheduler.assignmentStore) {
                me.resourceField.value = resources.map((resource) => resource[me.resourceField.valueField]);
            }
        }

        super.internalLoadRecord(eventRecord, resourceRecord);
    }

    toggleEventType(eventType) {
        // expose eventType in dataset, for querying and styling
        this.editor.element.dataset.eventType = eventType || '';

        // toggle visibility of widgets belonging to eventTypes
        this.editor.eachWidget(widget =>
            widget.dataset && widget.dataset.eventType && (widget.hidden = widget.dataset.eventType !== eventType)
        );
    }

    //endregion

    //region Save

    // Override of EditBase get values, to include resourceId when not using AssignmentStore
    get values() {
        const values = super.values;

        // Use resourceId with single assignment mode
        if (!this.scheduler.assignmentStore && values.resource) {
            values.resourceId = values.resource.id;
            delete values.resource;
        }

        return values;
    }

    finalizeEventSave(eventRecord, resourceRecords, resolve, reject) {
        const
            me                        = this,
            { scheduler, eventStore } = me;

        me.onBeforeSave(eventRecord);

        eventRecord.beginBatch();
        me.updateRecord(eventRecord);
        eventRecord.endBatch();

        // Check if this is a new record
        if (eventStore && !eventRecord.stores.length) {
            /**
             * Fires on the owning Scheduler before an event is added
             * @event beforeEventAdd
             * @param {Scheduler.view.Scheduler} source The Scheduler instance.
             * @param {Scheduler.model.EventModel} eventRecord The record about to be added
             * @param {Scheduler.model.ResourceModel[]} resources **Deprecated** Use `resourceRecords` instead
             * @param {Scheduler.model.ResourceModel[]} resourceRecords Resources that the record is assigned to
             * @preventable
             */
            if (scheduler.trigger('beforeEventAdd', {
                eventRecord,
                resourceRecords,
                resources : resourceRecords
            }) !== false) {
                // Hand over the proxy element to be used by the new event
                // if it's inside the rendered time axis
                if (scheduler.isInTimeAxis(eventRecord)) {
                    if (me.phantomEventElement) {
                        const eventTpl = scheduler.generateTplData(eventRecord, resourceRecords[0]);

                        // Adopt the proxy as an event element.
                        if (eventTpl) {
                            DomHelper.syncClassList(me.phantomEventElement, eventTpl.wrapperCls);
                            DomHelper.createElement({
                                tag       : 'div',
                                parent    : me.phantomEventElement,
                                className : eventTpl.cls.toString()
                            });

                            // This is a signal that it's from a drag-create, so needs to stay
                            me.phantomEventElement.classList.add('b-sch-dragcreator-proxy');
                            me.phantomEventElement.id = eventTpl.id;
                            me.phantomEventElement.dataset.syncId = eventRecord.id;
                            scheduler.isHorizontal && scheduler.currentOrientation.releaseTimeSpanDiv(me.phantomEventElement, true);
                            me.phantomEventElement = null;

                            // Flag to let HorizontalEventMapper know that it should reuse the element even though the
                            // event is new
                            eventRecord.instanceMeta(scheduler).fromDragProxy = true;
                        }
                    }
                }
                // If the event is outside of the rendered time span, remove the element.
                else {
                    me.phantomEventElement.remove();
                }

                // Add to eventStore first, then assign the resource. Order is necessary since assigning might
                // involve an AssignmentStore
                me.eventStore.add(eventRecord);
                me.eventStore.assignEventToResource(eventRecord, resourceRecords);

                // If a filter was reapplied and filtered out the newly added event we need to clean up the drag proxy...
                if (!me.eventStore.includes(eventRecord)) {
                    // Feels a bit strange having that responsibility here, but since it is already handled
                    const proxyElement = scheduler.element.querySelector('.b-sch-dragcreator-proxy');

                    if (proxyElement) {
                        scheduler.currentOrientation.availableDivs.remove(proxyElement);
                        proxyElement.remove();
                    }
                }
            }
            else {
                resolve(false);
                return;
            }
        }
        else if (scheduler.assignmentStore) {
            me.eventStore.assignEventToResource(eventRecord, resourceRecords, true);
        }

        /**
         * Fires on the owning Scheduler after an event is successfully saved
         * @event afterEventSave
         * @param {Scheduler.view.Scheduler} source The scheduler instance
         * @param {Scheduler.model.EventModel} eventRecord The record about to be saved
         */
        scheduler.trigger('afterEventSave', { eventRecord });
        me.onAfterSave(eventRecord);

        resolve(eventRecord);
    }

    /**
     * Saves the changes (applies them to record if valid, if invalid editor stays open)
     * @private
     * @fires beforeEventSave
     * @fires beforeEventAdd
     * @fires afterEventSave
     * @returns {Promise}
     * @async
     */
    save() {
        return new Promise((resolve, reject) => {
            const
                me                         = this,
                { scheduler, eventRecord } = me;

            if (!eventRecord || !me.isValid) {
                resolve(false);
                return;
            }

            const
                { eventStore, values } = me,
                resourceRecords        = me.resourceField && me.resourceField.records || [me.resourceRecord],
                resourceRecord         = resourceRecords[0];

            // Check for potential overlap scenarios before saving. TODO needs to be indicated in the UI
            if (!me.scheduler.allowOverlap && eventStore) {
                const abort = resourceRecords.some((resource) => {
                    return !eventStore.isDateRangeAvailable(values.startDate, values.endDate, eventRecord, resource);
                });

                if (abort) {
                    resolve(false);
                    return;
                }
            }

            const context = {
                finalize(saveEvent) {
                    try {
                        if (saveEvent !== false) {
                            me.finalizeEventSave(eventRecord, resourceRecords, resolve, reject);
                        }
                        else {
                            resolve(false);
                        }
                    }
                    catch (e) {
                        reject(e);
                    }
                }
            };

            /**
             * Fires on the owning Scheduler before an event is saved
             * @event beforeEventSave
             * @param {Scheduler.view.Scheduler} source The scheduler instance
             * @param {Scheduler.model.EventModel} eventRecord The record about to be saved
             * @param {Scheduler.model.ResourceModel} resourceRecord [DEPRECATED IN FAVOR OF `resourceRecords`] The resource to which the event is assigned
             * @param {Scheduler.model.ResourceModel[]} resourceRecords The resources to which the event is assigned
             * @param {Object} values The new values
             * @param {Object} context Extended save context:
             * @param {Boolean} [context.async] Set this to `true` in a listener to indicate that the listener will asynchronously decide to prevent or not the event save.
             * @param {Function} context.finalize Function to call to finalize the save. Used when `async` is `true`. Provide `false` to the function to prevent the save.
             * @preventable
             */
            if (scheduler.trigger('beforeEventSave', {
                eventRecord,
                resourceRecords,
                resourceRecord,
                values,
                context
            }) !== false) {
                context.finalize();
            }
            // truthy context.async means than a listener will decide to approve saving asynchronously
            else if (!context.async) {
                resolve();
            }
        });
    }

    //endregion

    //region Delete

    /**
     * Delete event being edited
     * @returns {Promise}
     * @fires beforeEventDelete
     * @private
     * @async
     */
    deleteEvent() {
        return new Promise((resolve, reject) => {
            const
                me                      = this,
                { eventRecord, editor } = me;

            me.scheduler.removeRecords([eventRecord], (removeRecord) => {
                // The reason it does it here is to move focus *before* it gets deleted,
                // and then there's code in the delete to see that it's deleting the focused one,
                // and jump forwards or backwards to move to the next or previous event
                // See 'Should allow key activation' test in tests/view/mixins/EventNavigation.t.js
                if (removeRecord && editor.containsFocus) {
                    editor.revertFocus();
                }

                resolve(removeRecord);
            });
        });
    }

    //endregion

    //region Stores

    get resourceStore() {
        return this._resourceStore;
    }

    set resourceStore(store) {
        this._resourceStore = store;
        if (this.resourceField) {
            this.resourceField.store = store;
        }
    }

    //endregion

    //region Events

    onActivateEditor({ eventRecord, resourceRecord, eventElement }) {
        this.editEvent(eventRecord, resourceRecord, eventElement);
    }

    onDragCreateEnd({ newEventRecord, resourceRecord, proxyElement }) {
        const me = this;

        if (!me.disabled) {
            // Call scheduler template method
            me.scheduler.onEventCreated(newEventRecord);

            // Clone proxy after showing editor so it's not deleted
            const phantomEventElement = proxyElement.cloneNode(true);
            phantomEventElement.removeAttribute('id');
            proxyElement.parentElement.appendChild(phantomEventElement);

            me.editEvent(newEventRecord, resourceRecord, phantomEventElement);
        }
    }

    // chained from EventNavigation
    onEventEnterKey({ assignmentRecord, eventRecord }) {
        if (assignmentRecord) {
            this.editEvent(eventRecord, assignmentRecord.resource);
        }
        else if (eventRecord) {
            this.editEvent(eventRecord, eventRecord.resource);
        }
    }

    // Toggle fields visibility when changing eventType
    onEventTypeChange({ value }) {
        this.toggleEventType(value);
    }

    //endregion

    //region Context menu

    getEventMenuItems({ eventRecord, resourceRecord, items }) {
        if (!this.scheduler.readOnly) {
            items.editEvent = {
                text   : this.L('Edit Event'),
                icon   : 'b-icon b-icon-edit',
                weight : -200,
                onItem : () => {
                    this.editEvent(eventRecord, resourceRecord);
                }
            };
        }
    }

    //endregion
}

EventEdit._$name = 'EventEdit'; GridFeatureManager.registerFeature(EventEdit, true, 'Scheduler');

/**
 * @module Scheduler/feature/EventFilter
 */

/**
 * Adds event filter menu items to the timeline header context menu.
 *
 * This feature is **enabled** by default
 *
 * @extends Core/mixin/InstancePlugin
 */
class EventFilter extends InstancePlugin {
    // Plugin configuration. This plugin chains some of the functions in Grid.

    static get $name() {
        return 'EventFilter';
    }

    static get pluginConfig() {
        return {
            chain : ['getHeaderMenuItems']
        };
    }

    construct(scheduler, config) {
        super.construct(scheduler, config);

        this.scheduler = scheduler;
    }

    /**
     * Populates the header context menu items.
     * @param {Grid.column.Column} column Column for which the menu will be shown
     * @param {Object[]} items Array of menu items
     * @internal
     */
    getHeaderMenuItems(column, items) {
        const me = this;

        if (column.type !== 'timeAxis') return;

        items.push({
            text     : me.L('filterEvents'),
            icon     : 'b-fw-icon b-icon-filter',
            disabled : me.disabled,
            menu     : {
                type  : 'popup',
                items : [{
                    type                 : 'textfield',
                    cls                  : 'b-eventfilter b-last-row',
                    clearable            : true,
                    keyStrokeChangeDelay : 300,
                    label                : me.L('byName'),
                    width                : 200,
                    listeners            : {
                        change  : me.onEventFilterChange,
                        thisObj : me
                    }
                }],
                onBeforeShow({ source : menu }) {
                    const
                        [filterByName] = menu.items,
                        filter         = me.scheduler.eventStore.filters.getBy('property', 'name');

                    filterByName.value = filter && filter.value;
                }
            }
        });
    }

    onEventFilterChange({ value }) {
        const me = this;

        if (value !== '') {
            me.scheduler.eventStore.filter('name', value);
        }
        else {
            me.scheduler.eventStore.removeFieldFilter('name');
        }
    }
}

EventFilter.featureClass = 'b-event-filter';

EventFilter._$name = 'EventFilter'; GridFeatureManager.registerFeature(EventFilter, true, ['Scheduler', 'Gantt']);

//TODO: Prevent right click while resizing (do it in ResizeHelper?)

/**
 * @module Scheduler/feature/base/ResizeBase
 */

const tipAlign = {
    'top'    : 'b-t',
    'right'  : 'b100-t100',
    'bottom' : 't-b',
    'left'   : 'b0-t0'
};

/**
 * Base class for EventResize (Scheduler) and TaskResize (Gantt) features. Contains shared code. Not to be used directly.
 *
 * @extends Core/mixin/InstancePlugin
 * @abstract
 */
class ResizeBase extends InstancePlugin {
    //region Config

    static get defaultConfig() {
        return {
            /**
             * `false` to not show a tooltip while resizing
             * @config {Boolean}
             * @default
             */
            showTooltip : true,

            /**
             * true to see exact event length during resizing
             * @config {Boolean}
             * @default
             */
            showExactResizePosition : false,

            /**
             * An empty function by default, but provided so that you can perform custom validation on
             * the item being resized. Return true if the new duration is valid, false to signal that it is not.
             * @param {Object} context The resize context, contains the record & dates.
             * @param {Event} e The browser Event object
             * @return {Boolean}
             * @config {Function}
             */
            validatorFn : () => {},

            /**
             * `this` reference for the validatorFn
             * @config {Object}
             */
            validatorFnThisObj : null,

            /**
             * The tooltip instance to show while resizing an event or a configuration object for the {@link Core.widget.Tooltip}.
             * @config {Core.widget.Tooltip}
             */
            tip : null,

            tipTemplate : data => `
                <div class="b-sch-tip-${data.valid ? 'valid' : 'invalid'}">
                    ${data.startClockHtml}
                    ${data.endClockHtml}
                    <div class="b-sch-tip-message">${data.message}</div>
                </div>
            `
        };
    }

    static get pluginConfig() {
        return {
            chain : ['render']
        };
    }

    //endregion

    //region Init & destroy

    render() {
        const me = this;

        me.resize && me.resize.destroy();

        me.resize = me.createResizeHelper();

        if (me.showTooltip) {
            me.clockTemplate = new ClockTemplate({
                scheduler : me.client
            });
        }
    }

    doDestroy() {
        const me = this;

        me.tip && me.tip.destroy();
        me.clockTemplate && me.clockTemplate.destroy();
        me.resize && me.resize.destroy();

        super.doDestroy();
    }

    //endregion

    //region Events

    isElementResizable(element, event) {
        const
            { client, resize } = this,
            timespanRecord     = client.resolveTimeSpanRecord(element);

        if (client.readOnly) {
            return false;
        }

        let resizable = timespanRecord && timespanRecord.isResizable;

        // go up from "handle" to resizable element
        element = DomHelper.up(event.target, client.eventSelector);

        // Not resizable if the mousedown is on a resizing handle of
        // a percent bar.
        const
            handleHoldingElement = element ? element.firstElementChild : element,
            handleEl             = event.target.closest('[class$="-handle"]');

        if (!resizable || (handleEl && handleEl !== handleHoldingElement)) {
            return false;
        }

        let startsOutside = element.classList.contains('b-sch-event-startsoutside'),
            endsOutside   = element.classList.contains('b-sch-event-endsoutside');

        if (resizable === true) {
            if (startsOutside && endsOutside) {
                return false;
            }
            else if (startsOutside) {
                resizable = 'end';
            }
            else if (endsOutside) {
                resizable = 'start';
            }
            else {
                return resize.overStartHandle(event, element) || resize.overEndHandle(event, element);
            }
        }

        if (
            (startsOutside && resizable === 'start') ||
            (endsOutside && resizable === 'end')
        ) {
            return false;
        }

        if (
            (resize.overStartHandle(event, element) && resizable === 'start') ||
            (resize.overEndHandle(event, element) && resizable === 'end')
        ) {
            return true;
        }

        return false;
    }

    onBeforeResizeStart({ element, event }) {
        const
            { client }     = this,
            name           = client.scheduledEventName,
            timespanRecord = client.resolveTimeSpanRecord(element);

        if (this.disabled) {
            return false;
        }

        // trigger beforeEventResize or beforeTaskResize depending on product
        return client.trigger(
            `before${client.capitalizedEventName}Resize`,
            { [name + 'Record'] : timespanRecord, event }
        ) !== false;
    }

    onResizeStart({ context, event }) {
        const
            me             = this,
            client         = me.client,
            timespanRecord = client.resolveTimeSpanRecord(context.element),
            name           = client.scheduledEventName;

        client.element.classList.add('b-resizing-event');

        // Let products to their specific stuff
        me.setupProductResizeContext(context, event);

        if (me.showTooltip) {
            if (me.tip) {
                me.tip.align = tipAlign[context.edge];
                me.tip.showBy(me.getTooltipTarget());
            }
            else {
                me.tip = new Tooltip({
                    id                       : `${client.id}-event-resize-tip`,
                    autoShow                 : true,
                    axisLock                 : true,
                    trackMouse               : false,
                    updateContentOnMouseMove : true,
                    getHtml                  : me.getTipHtml.bind(me),
                    align                    : tipAlign[context.edge],
                    hideDelay                : 0
                });

                me.tip.on('innerhtmlupdate', me.updateDateIndicator, me);
            }
        }

        // flag to not allow release of element when scrolling
        timespanRecord.instanceMeta(client).retainElement = true;

        // Trigger eventResizeStart or taskResizeStart depending on product
        client.trigger(`${name}ResizeStart`, { [`${name}Record`] : timespanRecord, event });
    }

    updateDateIndicator() {
        const
            { edge, startDate, endDate } = this.resize.context,
            { element }                  = this.tip;

        if (startDate || endDate) {
            if (edge === 'right' || edge === 'bottom') {
                this.clockTemplate.updateDateIndicator(element.querySelector('.b-sch-tooltip-enddate'), endDate);
            }
            else {
                this.clockTemplate.updateDateIndicator(element, startDate);
            }
        }
    }

    getTooltipTarget() {
        const
            me     = this,
            target = Rectangle.from(me.resize.context.element, null, true);

        if (me.resize.direction === 'horizontal') {
            // Align to the dragged edge of the proxy, and then bump right so that the anchor aligns perfectly.
            if (me.resize.context.edge === 'right') {
                target.x = target.right - 1;
            }
            target.width = me.tip.anchorSize[0] / 2;
        }
        else {
            // Align to the dragged edge of the proxy, and then bump bottom so that the anchor aligns perfectly.
            if (me.resize.context.edge === 'bottom') {
                target.y = target.bottom - 1;
            }
            target.height = me.tip.anchorSize[1] / 2;
        }

        return { target };
    }

    onResizing({ context, event }) {
        const
            me                = this,
            { client }        = me,
            depFeature        = client.features.dependencies,
            timespanRecord    = me.getTimespanRecord(context),
            name              = client.scheduledEventName,
            { element, edge } = context,
            xy                = DomHelper.getTranslateXY(element);

        let start, end;

        if (edge === 'top' || edge === 'left') {
            end = timespanRecord.endDate;

            if (client.snapRelativeToEventStartDate) {
                start = client.getDateFromXY(xy, null, true);
                start = client.timeAxis.roundDate(start, timespanRecord.startDate);
            }
            else {
                start = client.getDateFromXY(xy, 'round', true);
            }
        }
        // bottom || right
        else {
            xy[0] += element.offsetWidth;
            xy[1] += element.offsetHeight;

            start = timespanRecord && timespanRecord.startDate;

            if (client.snapRelativeToEventStartDate) {
                end = client.getDateFromXY(xy, null, true);
                end = client.timeAxis.roundDate(end, timespanRecord.endDate);
            }
            else {
                end = client.getDateFromXY(xy, 'round', true);
            }
        }

        start = start || context.startDate;
        end = end || context.endDate;

        if (context.dateConstraints) {
            start = DateHelper.constrain(start, context.dateConstraints.start, context.dateConstraints.end);
            end = DateHelper.constrain(end, context.dateConstraints.start, context.dateConstraints.end);
        }

        if (me.showExactResizePosition || client.timeAxisViewModel.snap) {
            const exactSize = edge === 'top' || edge === 'left'
                ? client.timeAxisViewModel.getDistanceBetweenDates(start, timespanRecord.endDate)
                : client.timeAxisViewModel.getDistanceBetweenDates(timespanRecord.startDate, end);

            switch (edge) {
                case 'top':
                    DomHelper.setTranslateY(element, context.elementStartY + context.elementWidth - exactSize);
                    element.style.height = exactSize + 'px';
                    break;
                case 'right':
                    element.style.width = exactSize + 'px';
                    break;
                case 'bottom':
                    element.style.height = exactSize + 'px';
                    break;
                case 'left':
                    DomHelper.setTranslateX(element, context.elementStartX + context.elementWidth - exactSize);
                    element.style.width = exactSize + 'px';
                    break;
            }
        }

        const dateChanged = context.endDate - end !== 0 || context.startDate - start !== 0;

        context.endDate = end;
        context.startDate = start;

        // No need to query on every pixel of mouse move
        if (dateChanged) {
            context.valid = me.checkValidity(context, event);
        }

        // Trigger eventPartialResize or taskPartialResize depending on product
        client.trigger(`${name}PartialResize`, {
            [`${name}Record`] : timespanRecord,
            startDate         : start,
            endDate           : end,

            element,
            context
        });

        if (depFeature) {
            depFeature.updateDependenciesForTimeSpan(timespanRecord, element);
        }

        if (me.showTooltip) {
            me.tip.alignTo(me.getTooltipTarget());
        }
    }

    checkValidity(context, event) {
        let valid = context.startDate && context.endDate > context.startDate && this.validatorFn.call(this.validatorFnThisObj || this, context, event);

        if (valid && typeof valid !== 'boolean') {
            context.message = valid.message || '';

            valid = valid.valid;
        }

        return valid !== false;
    }

    onFinishResize({ source : drag, context, event }) {
        const
            me             = this,
            timespanRecord = me.getTimespanRecord(context),
            oldStart       = timespanRecord.startDate,
            oldEnd         = timespanRecord.endDate,
            start          = context.startDate || oldStart,
            end            = context.endDate || oldEnd,
            client         = me.client;

        let modified = false;

        // allow release of element again
        timespanRecord.instanceMeta(client).retainElement = false;

        const old = context.finalize;
        context.finalize = (...params) => {
            // We are overriding context of the resize helper. It is finalized automatically on sync resize. Which means,
            // we should only call finalize if context is async.
            context.async && me.finalize(...params);
            old.call(context, params);
        };

        context.valid = start && end && (end - start > 0) && // Input sanity check
            ((start - oldStart !== 0) || (end - oldEnd !== 0)) && // Make sure start OR end changed
            context.valid !== false;

        if (context.valid) {
            // Seems to be a valid resize operation, ask outside world if anyone wants to take control over the finalizing,
            // to show a confirm dialog prior to applying the new values. Triggers beforeEventResizeFinalize or
            // beforeTaskResizeFinalize depending on product
            client.trigger(`before${client.scheduledEventName}ResizeFinalize`, { context, event });
            modified = true;
        }

        if (!context.async) {
            me.finalize(modified);
        }
    }

    onCancelResize({ context }) {
        const timespanRecord = this.getTimespanRecord(context);

        // resizing may not have started at all (just clicking a resize handle)
        if (timespanRecord) {
            timespanRecord.instanceMeta(this.client).retainElement = false;
        }

        this.finalize(false);
    }

    finalize(updateRecord) {
        const
            me             = this,
            { client }     = me,
            context        = me.resize.context,
            timespanRecord = me.getTimespanRecord(context),
            name           = client.scheduledEventName;

        let wasChanged = false;

        if (me.tip) {
            me.tip.hide();
        }

        if (context.started) {
            if (updateRecord) {
                // Scheduler and gantt updates the record differently
                wasChanged = me.internalUpdateRecord(context, timespanRecord);
            }

            if (!updateRecord || !wasChanged) {
                const dependencies = client.features.dependencies;

                me.resize.abortResize(null, true);

                // Dependencies are updated dynamically during resize, so ensure they are redrawn
                // if the event snaps back with no change.
                if (dependencies) {
                    dependencies.scheduleDraw(true);
                }
            }
        }

        client.element.classList.remove('b-resizing-event');

        // Triggers eventResizeEnd or taskResizeEnd depending on product
        client.trigger(`${name}ResizeEnd`, {
            changed           : wasChanged,
            [`${name}Record`] : timespanRecord || client.resolveEventRecord(context.element)
        });
    }

    //endregion

    //region Tooltip

    getTipHtml({ tip }) {
        const me = this;
        let { startDate, endDate, valid, message } = me.resize.context;

        // Empty string hides the tip - we get called before the Resizer, so first call will be empty
        if (!startDate || !endDate) {
            return tip.html;
        }

        if (message === undefined) message = '';

        endDate = me.client.getDisplayEndDate(endDate, startDate);

        let startText = me.client.getFormattedDate(startDate),
            endText   = me.client.getFormattedDate(endDate);

        return me.tipTemplate({
            valid,
            startDate,
            endDate,
            startText,
            endText,
            message,
            startClockHtml : me.clockTemplate.template({
                date : startDate,
                text : startText,
                cls  : 'b-sch-tooltip-startdate'
            }),
            endClockHtml : me.clockTemplate.template({
                date : endDate,
                text : endText,
                cls  : 'b-sch-tooltip-enddate'
            })
        });
    }

    //endregion

    //region Product specific, implemented in subclasses

    getRowRecord(context) {
        throw new Error('Implement in subclass');
    }

    getTimespanRecord(context) {
        throw new Error('Implement in subclass');
    }

    setupProductResizeContext(context, event) {
        throw new Error('Implement in subclass');
    }

    // Store containing the timespan record being resized
    get store() {
        throw new Error('Implement in subclass');
    }

    //endregion
}
ResizeBase._$name = 'ResizeBase';

//TODO: Prevent right click while resizing (do it in ResizeHelper?)

/**
 * @module Scheduler/feature/EventResize
 */

/**
 * Feature that allows resizing an event by dragging its end.
 *
 * By default it displays a tooltip with the new start and end dates, formatted using
 * {@link Scheduler/view/mixin/TimelineViewPresets#config-displayDateFormat}.
 *
 * This feature is **enabled** by default
 *
 * @extends Scheduler/feature/base/ResizeBase
 * @demo Scheduler/basic
 * @externalexample scheduler/EventResize.js
 */
class EventResize extends ResizeBase {
    //region Events

    /**
     * Fired on the owning Scheduler before resizing starts. Return false to prevent operation
     * @event beforeEventResize
     * @param {Scheduler.model.EventModel} eventRecord
     * @param {Event} event
     */

    /**
     * Fires on the owning Scheduler when event resizing starts
     * @event eventResizeStart
     * @param {Scheduler.model.EventModel} eventRecord
     * @param {Event} event
     */

    /**
     * Fires on the owning Scheduler on each resize move event
     * @event eventPartialResize
     * @param {Scheduler.model.EventModel} eventRecord
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {HTMLElement} element
     */

    /**
     * Fired on the owning Scheduler to allow implementer to prevent immediate finalization by setting `data.context.async = true`
     * in the listener, to show a confirmation popup etc
     * ```
     *  scheduler.on('beforeeventresizefinalize', ({context}) => {
     *      context.async = true;
     *      setTimeout(() => {
     *          // async code don't forget to call finalize
     *          context.finalize();
     *      }, 1000);
     *  })
     * ```
     * @event beforeEventResizeFinalize
     * @param {Object} data
     * @param {Scheduler.view.Scheduler} data.source Scheduler instance
     * @param {Object} data.context
     * @param {Boolean} data.context.async Set true to handle resize asynchronously (e.g. to wait for user
     * confirmation)
     * @param {Function} data.context.finalize Call this method to finalize resize. This method accepts one
     * argument: pass true to update records, or false, to ignore changes
     */

    /**
     * Fires on the owning Scheduler after the resizing gesture has finished.
     * @event eventResizeEnd
     * @param {Boolean} wasChanged
     * @param {Scheduler.model.EventModel} eventRecord
     */

    //endregion

    //region Scheduler specifics

    static get $name() {
        return 'EventResize';
    }

    createResizeHelper() {
        const
            me = this,
            client = me.client;

        return new ResizeHelper({
            direction               : client.isVertical ? 'vertical' : 'horizontal',
            name                    : me.constructor.$name, // for debugging
            isElementResizable      : (el, event) => me.isElementResizable(el, event),
            targetSelector          : client.eventSelector,
            handleContainerSelector : client.eventInnerSelector,
            resizingCls             : 'b-sch-event-wrap-resizing',
            allowResize             : me.isElementResizable.bind(me),
            outerElement            : client.timeAxisSubGridElement, // constrain resize to view
            scrollManager           : client.scrollManager,
            dragThreshold           : 0,
            dynamicHandleSize       : true,
            reservedSpace           : 5,
            scroller                : client.timeAxisSubGrid.scrollable, // allow reading correct x & y scroll
            listeners               : {
                beforeresizestart : me.onBeforeResizeStart,
                resizestart       : me.onResizeStart,
                resizing          : me.onResizing,
                resize            : me.onFinishResize,
                cancel            : me.onCancelResize,
                thisObj           : me
            }
        });
    }

    // Store used by ResizeBase to detect updates on dropped record
    get store() {
        return this.client.eventStore;
    }

    // Used by ResizeBase to get an eventRecord from the drag context
    getTimespanRecord(context) {
        return context.eventRecord;
    }

    getRowRecord(context) {
        return context.resourceRecord;
    }

    // Injects Scheduler specific data into the drag context
    setupProductResizeContext(context, event) {
        const
            scheduler      = this.client,
            eventRecord    = scheduler.resolveEventRecord(context.element),
            resourceRecord = scheduler.resolveResourceRecord(context.element);

        Object.assign(context, {
            eventRecord,
            resourceRecord,
            dateConstraints : scheduler.getDateConstraints(resourceRecord, eventRecord)
        });
    }

    onResizeStart({ context, event }) {
        super.onResizeStart({ context, event });

        // Hide terminals when resizing starts
        if (this.client.features.dependencies) {
            this.client.features.dependencies.hideTerminals(context.element);
        }

        // Add resizing cls to inner element, as expected by styling
        context.element.querySelector('.b-sch-event').classList.add('b-sch-event-resizing');
    }

    checkValidity(context, event) {
        return (
            this.client.allowOverlap ||
            this.client.isDateRangeAvailable(context.startDate, context.endDate, context.eventRecord, context.resourceRecord)
        ) && super.checkValidity(context, event);
    }

    onFinishResize({ source, context, event }) {
        super.onFinishResize({ source, context, event });

        // When resizing is done successfully, mouse should be over element, so we show terminals
        if (this.client.features.dependencies) {
            this.client.features.dependencies.showTerminals(context.eventRecord, context.element);
        }
    }

    internalUpdateRecord(context, timespanRecord) {
        const
            { store } = this,
            { generation } = timespanRecord;

        if (context.edge === 'left' || context.edge === 'top') {
            timespanRecord.setStartDate(context.startDate, false, store.skipWeekendsDuringDragDrop);
        }
        else {
            timespanRecord.setEndDate(context.endDate, false, store.skipWeekendsDuringDragDrop);
        }

        // The record has been changed
        if (timespanRecord.generation !== generation) {
            return true;
        }

        // The record has not been changed
        this.client.repaintEventsForResource(context.resourceRecord);
        return false;
    }

    finalize(updateRecord) {
        this.resize.context.element.querySelector('.b-sch-event').classList.remove('b-sch-event-resizing');
        super.finalize(updateRecord);
    }

    //endregion
}

EventResize._$name = 'EventResize'; GridFeatureManager.registerFeature(EventResize, true, 'Scheduler');

/**
 * @module Scheduler/feature/base/TooltipBase
 */

/**
 * Base class for EventTooltip (Scheduler) and TaskTooltip (Gantt) features. Contains shared code. Not to be used directly.
 *
 * @extends Core/mixin/InstancePlugin
 */
class TooltipBase extends InstancePlugin {
    //region Config

    static get defaultConfig() {
        return {

            /**
             * Specify true to have tooltip updated when mouse moves, if you for example want to display date at mouse
             * position.
             * @config {Boolean}
             * @default
             * @category Misc
             */
            autoUpdate : false,

            template : null,

            cls : null,

            align : 'b-t',

            clockTemplate : null
        };
    }

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            chain : ['render']
        };
    }

    //endregion

    //region Init

    construct(client, config) {
        const me = this;

        // process initial config into an actual config object
        config = me.processConfig(config);

        super.construct(client, config);

        // Default triggering selector is the client's inner element selector
        if (!me.forSelector) {
            me.forSelector = `${client.eventInnerSelector}:not(.b-dragproxy)`;
        }

        me.clockTemplate = new ClockTemplate({
            scheduler : client
        });

        client.on({
            [`before${client.scheduledEventName}drag`] : () => {
                me.tooltip && me.tooltip.hide();
            }
        });
    }

    // TooltipBase feature handles special config cases, where user can supply a function to use as template
    // instead of a normal config object
    processConfig(config) {
        if (typeof config === 'function') {
            return {
                template : config
            };
        }

        return config;
    }

    // override setConfig to process config before applying it (used mainly from ReactScheduler)
    setConfig(config) {
        super.setConfig(this.processConfig(config));
    }

    doDestroy() {
        this.clockTemplate && this.clockTemplate.destroy();
        this.tooltip && this.tooltip.destroy();

        super.doDestroy();
    }

    doDisable(disable) {
        if (this.tooltip) {
            this.tooltip.disabled = disable;
        }

        super.doDisable(disable);
    }

    //endregion

    render() {
        const
            me             = this,
            client         = me.client,
            ignoreSelector = [
                '.b-dragselecting',
                '.b-eventeditor-editing',
                '.b-resizing-event',
                '.b-dragcreating',
                `.b-dragging-${client.scheduledEventName}`,
                '.b-creating-dependency',
                '.b-dragproxy'
            ].map(cls => `:not(${cls})`).join('');

        if (me.tooltip) {
            me.tooltip.destroy();
        }

        /**
         * A reference to the tooltip instance, which will have a special `eventRecord` property that
         * you can use to get data from the contextual event record to which this tooltip is related.
         * @member {Core.widget.Tooltip} tooltip
         * @readonly
         * @category Misc
         */
        me.tooltip = new Tooltip(
            Object.assign({
                axisLock       : 'flexible',
                id             : me.tipId || `${me.client.id}-event-tip`,
                cls            : me.tipCls,
                forSelector    : `.b-timelinebase${ignoreSelector} ${me.forSelector}`,
                scrollAction   : 'realign',
                clippedBy      : [client.timeAxisSubGridElement, client.bodyContainer],
                forElement     : client.timeAxisSubGridElement,
                showOnHover    : true,
                hoverDelay     : 0,
                hideDelay      : 100,
                anchorToTarget : true,
                allowOver      : Boolean(me.config.items || me.config.tools),
                getHtml        : me.getTipHtml.bind(me),
                disabled       : me.disabled
            },
            me.config)
        );

        me.tooltip.on('innerhtmlupdate', me.updateDateIndicator, me);
    }

    updateDateIndicator() {
        const me           = this,
            client         = me.client,
            tip            = me.tooltip,
            timeSpanRecord = tip.activeTarget && client.resolveTimeSpanRecord(tip.activeTarget),
            endDateElement = tip.element.querySelector('.b-sch-tooltip-enddate');

        if (!timeSpanRecord) return;

        me.clockTemplate.updateDateIndicator(tip.element, timeSpanRecord.startDate);

        endDateElement && me.clockTemplate.updateDateIndicator(endDateElement, timeSpanRecord.endDate);
    }

    resolveTimeSpanRecord(forElement) {
        return this.client.resolveTimeSpanRecord(forElement);
    }

    getTipHtml({ tip, activeTarget }) {
        const
            me             = this,
            client         = me.client,
            recordProp     = me.recordType || `${client.scheduledEventName}Record`,
            timeSpanRecord = me.resolveTimeSpanRecord(activeTarget);

        // If user has mouseovered a fading away element of a deleted event,
        // an event record will not be found. In this case the tip must hide.
        if (timeSpanRecord) {
            const
                { startDate, endDate } = timeSpanRecord,
                startText              = client.getFormattedDate(startDate),
                endDateValue           = client.getDisplayEndDate(endDate, startDate),
                endText                = client.getFormattedDate(endDateValue);

            tip.eventRecord = timeSpanRecord;
            tip.title = timeSpanRecord.name;

            return me.template({
                tip,
                // eventRecord for Scheduler, taskRecord for Gantt
                [`${recordProp}`] : timeSpanRecord,
                startDate,
                endDate,
                startText,
                endText,
                startClockHtml    : me.clockTemplate.template({
                    date : startDate,
                    text : startText,
                    cls  : 'b-sch-tooltip-startdate'
                }),
                endClockHtml : timeSpanRecord.isMilestone ? '' : me.clockTemplate.template({
                    date : endDateValue,
                    text : endText,
                    cls  : 'b-sch-tooltip-enddate'
                })
            });
        }
        else {
            tip.hide();
            return '';
        }
    }
}
TooltipBase._$name = 'TooltipBase';

/**
 * @module Scheduler/feature/EventTooltip
 */

/**
 * Displays a tooltip when hovering events. The template used to render the tooltip can be customized, see {@link #config-template}.
 * Config options are also applied to the tooltip shown, see {@link Core.widget.Tooltip} for available options.
 *
 * ## Showing local data
 * To show a basic "local" tooltip (with data available in the Event record) upon hover:
 * ```javascript
 * new Scheduler({
 *   features : {
 *     eventTooltip : {
 *         // Tooltip configs can be used here
 *         align : 'l-r' // Align left to right,
 *         // A custom HTML template
 *         template : data => `<dl>
 *           <dt>Assigned to:</dt>
 *              <dt>Time:</dt>
 *              <dd>
 *                  ${DateHelper.format(data.eventRecord.startDate, 'LT')} - ${DateHelper.format(data.eventRecord.endDate, 'LT')}
 *              </dd>
 *              ${data.eventRecord.get('note') ? `<dt>Note:</dt><dd>${data.eventRecord.note}</dd>` : ''}
 *
 *              ${data.eventRecord.get('image') ? `<dt>Image:</dt><dd><img class="image" src="${data.eventRecord.get('image')}"/></dd>` : ''}
 *          </dl>
 *     }
 *   }
 * });
 * ```
 *
 * ## Showing remotely loaded data
 * Loading remote data into the event tooltip is easy. Simply use the {@link #config-template} and return a Promise which yields the content to show.
 * ```javascript
 * new Scheduler({
 *   features : {
 *     eventTooltip : {
 *        template : ({ eventRecord }) => AjaxHelper.get(`./fakeServer?name=${eventRecord.name}`).then(response => response.text())
 *     }
 *   }
 * });
 * ```
 * This feature is **enabled** by default
 *
 * By default, the tooltip {@link Core.widget.Widget#config-scrollAction realigns on scroll}
 * meaning that it will stay aligned with its target should a scroll interaction make the target move.
 *
 * If this is causing performance issues in a Scheduler, such as if there are many dozens of events
 * visible, you can configure this feature with `scrollAction: 'hide'`. This feature's configuration is
 * applied to the tooltip, so that will mean that the tooltip will hide if its target is moved by a
 * scroll interaction.
 *
 * @extends Scheduler/feature/base/TooltipBase
 * @demo Scheduler/basic
 * @externalexample scheduler/EventTooltip.js
 */
class EventTooltip extends TooltipBase {
    //region Config

    static get $name() {
        return 'EventTooltip';
    }

    static get defaultConfig() {
        return {
            /**
             * A function which receives data about the event and returns a string, or a Promise yielding a string (for async tooltips), to be displayed in the tooltip.
             * This method will be called with an object containing the fields below
             * @param {Object} data
             * @param {Scheduler.model.EventModel} data.eventRecord
             * @param {Date} data.startDate
             * @param {Date} data.endDate
             * @param {String} data.startText
             * @param {String} data.endText
             * @config {Function} template
             */
            template : data => `
                ${data.eventRecord.name ? `<div class="b-sch-event-title">${data.eventRecord.name}</div>` : ''}
                ${data.startClockHtml}
                ${data.endClockHtml}`,

            cls : 'b-sch-event-tooltip'
        };
    }

    //endregion
}

EventTooltip._$name = 'EventTooltip'; GridFeatureManager.registerFeature(EventTooltip, true, 'Scheduler');

/**
 * @module Grid/feature/mixin/SummaryFormatter
 */

/**
 * Mixin for Summary and GroupSummary that handles formatting sums.
 * @mixin
 * @private
 */
var SummaryFormatter = Target => class SummaryFormatter extends (Target || Base) {
    /**
     * Calculates sums and returns as a html table
     * @param {Grid.column.Column} column Column to calculate sum for
     * @param {Core.data.Model[]} records Records to include in calculation
     * @param {String} cls CSS class to apply to summary table
     * @returns {string}
     */
    generateHtml(column, records, cls) {
        const store = this.store,
            summaries = column.summaries ||
                  (column.sum ? [{ sum : column.sum, renderer : column.summaryRenderer }] : []);

        let html = `<table class="${cls}">`;

        summaries.forEach(config => {
            let type = config.sum,
                sum  = null;

            if (type === true) type = 'sum';

            switch (type) {
                case 'sum':
                case 'add':
                    sum = store.sum(column.field, records);
                    break;
                case 'max':
                    sum = store.max(column.field, records);
                    break;
                case 'min':
                    sum = store.min(column.field, records);
                    break;
                case 'average':
                case 'avg':
                    sum = store.average(column.field, records);
                    break;
                case 'count':
                    sum = records.length;
                    break;
                case 'countNotEmpty':
                    sum = records.reduce((sum, record) => {
                        const value = record[column.field];
                        return sum + (value !== null && value !== undefined ? 1 : 0);
                    }, 0);
                    break;
            }

            if (typeof type === 'function') {
                sum = records.reduce(type, 'seed' in config ? config.seed : 0);
            }

            if (sum !== null) {
                const valueCls = 'b-grid-summary-value',
                    // value to display, either using renderer or as is
                    valueHtml = config.renderer
                        ? config.renderer({ config, sum })
                        : sum,
                    // optional label
                    labelHtml = config.label
                        ? `<td class="b-grid-summary-label">${config.label}</td>`
                        : '';

                let summaryHtml;

                // no <td>s in html, wrap it (always the case when not using renderer)
                if (!String(valueHtml).includes('<td>')) {
                    summaryHtml = labelHtml
                        // has label, use returned html as value cell
                        ? `${labelHtml}<td class="${valueCls}">${valueHtml}</td>`
                        // no label, span entire table
                        : `<td colspan="2" class="${valueCls}">${valueHtml}</td>`;
                }
                // user is in charge of giving correct formatting
                else {
                    summaryHtml = valueHtml;
                }

                html += `<tr>${summaryHtml}</tr>`;
            }
        });

        return html + '</table>';
    }
};

/**
 * @module Grid/feature/GroupSummary
 */

/**
 * Displays a summary row as a group footer in a grouped grid. Uses same configuration options on columns as
 * {@link Grid.feature.Summary}.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * ```
 * features : {
 *     group        : 'city',
 *     groupSummary : true
 * }
 * ```
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @demo Grid/groupsummary
 * @classtype groupsummary
 * @externalexample feature/GroupSummary.js
 */
class GroupSummary extends SummaryFormatter(InstancePlugin) {
    //region Init

    static get $name() {
        return 'GroupSummary';
    }

    construct(grid, config) {
        const me = this;

        Object.assign(me, {
            grid  : grid,
            store : grid.store
        });

        super.construct(grid, config);

        if (!grid.features.group) {
            throw new Error('Requires Group feature to work, please enable');
        }

        me.store.on({
            update  : me.onStoreUpdate,
            // need to run before grids listener, to flag for full refresh
            prio    : 1,
            thisObj : me
        });

        me.grid.rowManager.on({
            beforerenderrow : me.onBeforeRenderRow,
            rendercell      : me.renderCell,
            thisObj         : me
        });
    }

    doDisable(disable) {
        // Flag that will make the Store insert rows for group footers
        this.store.useGroupFooters = !disable;

        // Refresh groups to show/hide footers
        if (!this.isConfiguring) {
            this.store.group();
        }

        super.doDisable(disable);
    }

    //endregion

    //region Render

    /**
     * Called before rendering row contents, used to reset rows no longer used as group summary rows
     * @private
     */
    onBeforeRenderRow({ row, record }) {
        if (row.isGroupFooter && !record.meta.hasOwnProperty('groupFooterFor')) {
            // not a group row, remove css
            row.isGroupFooter = false;
            row.removeCls('b-group-footer');
            // force full "redraw" when rendering cells
            row.forceInnerHTML = true;
        }
    }

    /**
     * Called when a cell is rendered, styles the group rows first cell.
     * @private
     */
    renderCell({ column, cellElement, rowElement, row, record, size }) {
        const me = this;

        // no need to do the code below if not grouping
        if (!me.store.isGrouped) return;

        if (record.meta.hasOwnProperty('groupFooterFor')) {
            // this is a group row, add css
            rowElement.classList.add('b-group-footer');
            row.isGroupFooter = true;

            // returns height config or count. config format is { height, count }. where `height is in px and should be
            // added to value calculated from `count
            const heightSetting = me.updateSummaryHtml(cellElement, column, record.meta.groupRecord.groupChildren);

            const count = typeof heightSetting === 'number' ? heightSetting : heightSetting.count;

            // number of summaries returned, use to calculate cell height
            if (count > 1) {
                size.height = me.grid.rowHeight + count * me.grid.rowHeight * 0.1;
            }

            // height config with height specified, added to cell height
            if (heightSetting.height) {
                size.height += heightSetting.height;
            }
        }
    }

    updateSummaryHtml(cellElement, column, records) {
        records = records.slice();
        records.pop(); // last record is group footer, remove

        const html = this.generateHtml(column, records, 'b-grid-group-summary');

        // First time, set table
        if (!cellElement.children.length) {
            cellElement.innerHTML = html;
        }
        // Following times, sync changes
        else {
            DomHelper.sync(html, cellElement.firstElementChild);
        }

        // return summary "count", used to set row height
        return column.summaries ? column.summaries.length : column.sum ? 1 : 0;
    }

    //endregion

    //region Events

    /**
     * Updates summaries on store changes (except record update, handled below)
     * @private
     */
    onStoreUpdate({ source : store, changes }) {
        if (!this.disabled && store.isGrouped) {
            // If a grouping field is among the changes, StoreGroup#onDataChanged will
            // take care of the update by re-sorting.
            if (changes && store.groupers.find(grouper => grouper.field in changes)) {
                return;
            }
            // only update summary when a field that affects summary is changed
            // TODO: this should maybe be removed, another column might depend on the value for its summary?
            const shouldUpdate = Object.keys(changes).some(field => {
                const colField = this.grid.columns.get(field);
                // check existence, since a field not used in a column might have changed
                return Boolean(colField) && (Boolean(colField.sum) || Boolean(colField.summaries));
            });

            if (shouldUpdate) {
                this.grid.forceFullRefresh = true;
            }
        }
    }

    //endregion
}

GroupSummary.featureClass = 'b-group-summary';

GroupSummary._$name = 'GroupSummary'; GridFeatureManager.registerFeature(GroupSummary);

/**
 * @module Scheduler/view/Header
 */

/**
 * Custom header subclass which handles the existence of the special TimeAxisColumn
 *
 * @extends Grid/view/Header
 * @private
 */
class Header$1 extends Header {
    static get $name() {
        return 'SchedulerHeader';
    }

    refreshContent() {
        // Only render contents into the header once as it contains the special rendering of the TimeAxisColumn
        if (this.headersElement && this.headersElement.childNodes.length === 0) {
            super.refreshContent();
        }
    }
}
Header$1._$name = 'Header';

/**
 * @module Scheduler/view/model/TimeAxisViewModel
 */

/**
 * This class is an internal view model class, describing the visual representation of a {@link Scheduler.data.TimeAxis}.
 * The config for the header rows is described in the {@link Scheduler.preset.ViewPreset#field-headers headers}.
 * To calculate the size of each cell in the time axis, this class requires:
 *
 * - availableSpace  - The total width or height available for the rendering
 * - tickSize       - The fixed width or height of each cell in the lowest header row. This value is normally read from the
 * {@link Scheduler.preset.ViewPreset viewPreset} but this can also be updated programmatically using the {@link #property-tickSize} setter
 *
 * Normally you should not interact with this class directly.
 *
 * @extends Core/mixin/Events
 */
class TimeAxisViewModel extends Events() {
    //region Default config

    // TODO: replace _availableSpace etc with availableSpace in config and make setters work during config phase

    static get defaultConfig() {
        return {
            /**
             * The time axis providing the underlying data to be visualized
             * @config {Scheduler.data.TimeAxis}
             * @internal
             */
            timeAxis : null,

            /**
             * The available width/height, this is normally not known by the consuming UI component using this model
             * class until it has been fully rendered. The consumer of this model should set
             * {@link #property-availableSpace} when its width has changed.
             * @config {Number}
             * @internal
             */
            availableSpace : null,

            /**
             * The "tick width" for horizontal mode or "tick height" for vertical mode, to use for the cells in the
             * bottom most header row.
             * This value is normally read from the {@link Scheduler.preset.ViewPreset viewPreset}
             * @config {Number}
             * @default
             * @internal
             */
            tickSize : 100,

            /**
             * true if there is a requirement to be able to snap events to a certain view resolution.
             * This has implications of the {@link #config-tickSize} that can be used, since all widths must be in even pixels.
             * @config {Boolean}
             * @default
             * @internal
             */
            snap : false,

            /**
             * true if cells in the bottom-most row should be fitted to the {@link #property-availableSpace available space}.
             * @config {Boolean}
             * @default
             * @internal
             */
            forceFit : false,

            headers : null,

            calendar : null,

            mode : 'horizontal', // or 'vertical'

            //used for Exporting. Make sure the tick columns are not recalculated when resizing.
            suppressFit : false,

            // cache of the config currently used.
            columnConfig : [],

            // the view preset name to apply initially
            viewPreset : null,

            // The default header level to draw column lines for
            columnLinesFor : null,

            // To give a link to the eventStore inside the header renderer if provided
            eventStore : null,

            originalTickSize : null,

            headersDatesCache : []
        };
    }

    //endregion

    //region Init & destroy

    construct(config) {
        const me = this;

        // getSingleUnitInPixels results are memoized because of frequent calls during rendering.
        me.unitToPixelsCache = {};

        super.construct(config);

        let viewPreset = me.timeAxis.viewPreset || me.viewPreset;

        if (viewPreset) {
            if (viewPreset instanceof ViewPreset) {
                me.consumeViewPreset(viewPreset);
            }
            else {
                let preset = pm.getPreset(viewPreset);
                preset && me.consumeViewPreset(preset);
            }
        }

        // When time axis is changed, reconfigure the model
        me.timeAxis.on('reconfigure', me.onTimeAxisReconfigure, me);

        me.configured = true;
    }

    doDestroy() {
        this.timeAxis.un('reconfigure', this.onTimeAxisReconfigure, this);
    }

    /**
     * Returns an array representing the headers of the current timeAxis. Each element is an array representing the cells for that level in the header.
     * @return {Object[]} An array of headers, each element being an array representing each cell (with start date and end date) in the timeline representation.
     * @internal
     */
    get columnConfig() {
        return this._columnConfig;
    }

    set columnConfig(config) {
        this._columnConfig = config;
    }

    get headers() {
        return this._headers;
    }

    set headers(headers) {
        if (headers && headers.length && headers[headers.length - 1].cellGenerator) {
            throw new Error('`cellGenerator` cannot be used for the bottom level of your headers. Use TimeAxis#generateTicks() instead.');
        }

        this._headers = headers;
    }

    get isTimeAxisViewModel() {
        return true;
    }

    //endregion

    //region Events

    /**
     * Fires after the model has been updated.
     * @event update
     * @param {Scheduler.view.model.TimeAxisViewModel} source The model instance
     */

    /**
     * Fires after the model has been reconfigured.
     * @event reconfigure
     * @param {Scheduler.view.model.TimeAxisViewModel} source The model instance
     */

    //endregion

    //region Mode

    /**
     * Using horizontal mode?
     * @returns {Boolean}
     * @readonly
     * @internal
     */
    get isHorizontal() {
        return this.mode !== 'vertical';
    }

    /**
     * Using vertical mode?
     * @returns {Boolean}
     * @readonly
     * @internal
     */
    get isVertical() {
        return this.mode === 'vertical';
    }

    /**
     * Gets/sets the forceFit value for the model. Setting it will cause it to update its contents and fire the
     * {@link #event-update} event.
     * @property {Boolean}
     * @internal
     */
    set forceFit(value) {
        if (value !== this._forceFit) {
            this._forceFit = value;
            this.update();
        }
    }

    //endregion

    //region Reconfigure & update

    reconfigure(config) {
        // clear the cached headers
        const me = this;

        me.headers = null;

        // Ensure correct ordering
        me.setConfig(config);

        me.trigger('reconfigure');
    }

    onTimeAxisReconfigure({ source : timeAxis, suppressRefresh }) {
        if (this.viewPreset !== timeAxis.viewPreset) {
            this.consumeViewPreset(timeAxis.viewPreset);
        }
        if (!suppressRefresh) {
            this.update();
        }
    }

    /**
     * Updates the view model current timeAxis configuration and available space.
     * @param {Number} [availableSpace] The available space for the rendering of the axis (used in forceFit mode)
     * @param {Boolean} [silent] Pass `true` to suppress the firing of the `update` event.
     * @param {Boolean} [forceUpdate] Pass `true` to fire the `update` event even if the size has not changed.
     * @internal
     */
    update(availableSpace, silent = false, forceUpdate = false) {
        const
            me           = this,
            { timeAxis, headers } = me;

        // We're in configuration, or no change, quit
        if (me.isConfiguring || me._availableSpace === availableSpace) {
            if (forceUpdate) {
                me.trigger('update');
            }
            return;
        }

        me._availableSpace = Math.max(availableSpace || me.availableSpace || 0, 0);

        if (typeof me.availableSpace !== 'number') {
            throw new Error('Invalid available space provided to TimeAxisModel');
        }

        // Despite available space is 0, we still should generate column config in order for scheduler to render
        if (me.availableSpace <= 0) {
            console.warn('No available space provided for time axis. Make sure you have set width for horizontal mode and height for vertical');
        }

        me.columnConfig = [];

        // The "column width" is considered to be the width of each tick in the lowest header row and this width
        // has to be same for all cells in the lowest row.
        const tickSize = me._tickSize = me.calculateTickSize(me.originalTickSize);

        if (typeof tickSize !== 'number' || tickSize <= 0) {
            throw new Error('Invalid timeAxis tick size');
        }

        // getSingleUnitInPixels results are memoized because of frequent calls during rendering.
        me.unitToPixelsCache = {};

        // totalSize is cached because of frequent calls which calculate it.
        me._totalSize = null;

        // Generate the underlying date ranges for each header row, which will provide input to the cell rendering
        for (let pos = 0, { length } = headers; pos < length; pos++) {
            const header = headers[pos];

            if (header.cellGenerator) {
                const headerCells = header.cellGenerator.call(me, timeAxis.startDate, timeAxis.endDate);

                me.columnConfig[pos] = me.createHeaderRow(pos, header, headerCells);
            }
            else {
                me.columnConfig[pos] = me.createHeaderRow(pos, header);
            }
        }

        if (!silent) {
            me.trigger('update');
        }
    }

    //endregion

    //region CalendarColumn

    // /**
    //  * Will update columns start/end dates to perform date/coordinate lookups
    //  * @param {Object[]} columns Array of column configs including start/end dates
    //  * @private
    //  */
    // updateCalendarColumnDates(columns) {
    //     this.calendarColumnDates = [];
    //
    //     for (let i = 0; i < columns.length; i++) {
    //         let obj = columns[i];
    //         this.calendarColumnDates.push([obj.start, obj.end]);
    //     }
    // }

    // // TODO: make getter
    // /**
    //  * Returns current column start/end dates array
    //  * @returns {Date[]}
    //  * @private
    //  */
    // getCalendarColumnDates() {
    //     return this.calendarColumnDates;
    // }

    //endregion

    //region Date / position mapping

    /**
     * Returns the distance in pixels for a timespan with the given start and end date.
     * @param {Date} start start date
     * @param {Date} end end date
     * @return {Number} The length of the time span
     * @category Date mapping
     */
    getDistanceBetweenDates(start, end) {
        return Math.round(this.getPositionFromDate(end) - this.getPositionFromDate(start));
    }

    /**
     * Returns the distance in pixels for a time span
     * @param {Number} durationMS Time span duration in ms
     * @return {Number} The length of the time span
     * @category Date mapping
     */
    getDistanceForDuration(durationMs) {
        let me      = this,
            tick    = this.timeAxis.getAt(0),
            pxPerMs = me.tickSize / (tick.endDate - tick.startDate);

        return pxPerMs * durationMs;
    }

    /**
     * Gets the position of a date on the projected time axis or -1 if the date is not in the timeAxis.
     * @param {Date} date the date to query for.
     * @returns {Number} the coordinate representing the date
     * @category Date mapping
     */
    getPositionFromDate(date, options = {}) {
        const me = this,
            tick = me.getScaledTick(date, options);

        if (tick === -1) {
            return -1;
        }

        return Math.round(me.tickSize * (tick - me.timeAxis.visibleTickStart));
    }

    // Translates a tick along the time axis to facilitate scaling events when excluding certain days or hours
    getScaledTick(date, { respectExclusion, snapToNextIncluded, isEnd, min, max }) {
        const
            { timeAxis } = this,
            { include, unit, weekStartDay }  = timeAxis;

        let tick = timeAxis.getTickFromDate(date);

        if (tick !== -1 && respectExclusion && include) {
            let tickChanged = false;

            // Stretch if we are using a larger unit than 'hour', except if it is 'day'. If so, it is already handled
            // by a cheaper reconfiguration of the ticks in `generateTicks`
            if (include.hour && DateHelper.compareUnits(unit, 'hour') > 0 && unit !== 'day') {
                const { from, to, lengthFactor, center } = include.hour,
                    // Original hours
                    originalHours = date.getHours(),
                    // Crop to included hours
                    croppedHours = Math.min(Math.max(originalHours, from), to);

                // If we are not asked to snap (when other part of span is not included) any cropped away hour
                // should be considered excluded
                if (!snapToNextIncluded && croppedHours !== originalHours) {
                    return -1;
                }

                const
                    // Should scale hour and smaller units (seconds will hardly affect visible result...)
                    fractionalHours = croppedHours + date.getMinutes() / 60,
                    // Number of hours from the center    |xxxx|123c----|xxx|
                    hoursFromCenter = center - fractionalHours,
                    // Step from center to stretch event  |x|112233c----|xxx|
                    newHours = center - hoursFromCenter * lengthFactor;

                // Adding instead of setting to get a clone of the date, to not affect the original
                date = DateHelper.add(date, newHours - originalHours, 'h');

                tickChanged = true;
            }

            if (include.day && DateHelper.compareUnits(unit, 'day') > 0) {
                const { from, to, lengthFactor, center } = include.day;

                //region Crop
                let checkDay = date.getDay();

                // End date is exclusive, check the day before if at 00:00
                if (isEnd && date.getHours() === 0 && date.getMinutes() === 0 && date.getSeconds() === 0 && date.getMilliseconds() === 0) {
                    if (--checkDay < 0) {
                        checkDay = 6;
                    }
                }
                let addDays = 0;

                if (checkDay < from || checkDay >= to) {
                    // If end date is in view but start date is excluded, snap to next included day
                    if (snapToNextIncluded) {

                        // Step back to "to-1" (not inclusive) for end date
                        if (isEnd) {
                            addDays = (to - checkDay - 8) % 7;
                        }
                        // Step forward to "from" for start date
                        else {
                            addDays = (from - checkDay + 7) % 7;
                        }

                        date = DateHelper.add(date, addDays, 'd');
                        date = DateHelper.startOf(date, 'd', false);

                        // Keep end after start and vice versa
                        if (
                            (max && date.getTime() >= max) ||
                            (min && date.getTime() <= min)
                        ) {
                            return -1;
                        }
                    }
                    else {
                        // day excluded at not snapping to next
                        return -1;
                    }
                }
                //endregion

                const
                    // Center to stretch around, for some reason pre-calculated cannot be used for sundays :)
                    fixedCenter = date.getDay() === 0 ? 0 : center,
                    // Should scale day and smaller units (minutes will hardly affect visible result...)
                    fractionalDay = date.getDay() + date.getHours() / 24, //+ dateClone.getMinutes() / (24 * 1440),
                    // Number of days from the calculated center
                    daysFromCenter = fixedCenter - fractionalDay,
                    // Step from center to stretch event
                    newDay = fixedCenter - daysFromCenter * lengthFactor;

                // Adding instead of setting to get a clone of the date, to not affect the original
                date = DateHelper.add(date, newDay - fractionalDay + weekStartDay, 'd');

                tickChanged = true;
            }

            // Now the date might start somewhere else (fraction of ticks)
            if (tickChanged) {
                // When stretching date might end up outside of time axis, making it invalid to use. Clip it to time axis
                // to circumvent this
                date = DateHelper.constrain(date, timeAxis.startDate, timeAxis.endDate);

                // Get a new tick based on the "scaled" date
                tick = timeAxis.getTickFromDate(date);
            }
        }

        return tick;
    }

    /**
     * Gets the date for a position on the time axis
     * @param {Number} position The page X or Y coordinate
     * @param {String} [roundingMethod] The rounding method to use
     * @param {Boolean} [allowOutOfRange=false] By default, this returns `null` if the position is outside
     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.
     * @returns {Date} the Date corresponding to the xy coordinate
     * @category Date mapping
     */
    getDateFromPosition(position, roundingMethod, allowOutOfRange = false) {
        const me       = this,
            timeAxis = me.timeAxis,
            tick     = me.getScaledPosition(position) / me.tickSize + timeAxis.visibleTickStart;

        if (tick < 0 || tick > timeAxis.count) {
            if (allowOutOfRange) {
                // Subtract the correct number of tick units from the start date
                if (tick < 0) {
                    return DateHelper.add(timeAxis.startDate, tick, timeAxis.unit);
                }
                // Add the correct number of tick units to the end date
                return DateHelper.add(timeAxis.endDate, tick - timeAxis.count, timeAxis.unit);
            }
            return null;
        }

        return timeAxis.getDateFromTick(tick, roundingMethod);
    }

    // Translates a position along the time axis to facilitate scaling events when excluding certain days or hours
    getScaledPosition(position) {
        const
            { include, unit, weekStartDay }  = this.timeAxis;

        // Calculations are

        if (include) {
            const dayWidth = this.getSingleUnitInPixels('day');

            // Have to calculate day before hour to get end result correct
            if (include.day && DateHelper.compareUnits(unit, 'day') > 0) {
                const { from, lengthFactor } = include.day,
                    // Scaling happens within a week, determine position within it
                    positionInWeek = position % (dayWidth * 7),
                    // Store were the week starts to be able to re-add it after scale
                    weekStartPosition = position - positionInWeek;
                // Scale position using calculated length per day factor, adding the width of excluded days
                position = positionInWeek / lengthFactor + (from - weekStartDay) * dayWidth + weekStartPosition;
            }

            // Hours are not taken into account when viewing days, since the day ticks are reconfigured in
            // `generateTicks` instead
            if (include.hour && DateHelper.compareUnits(unit, 'hour') > 0 && unit !== 'day') {
                const { from, lengthFactorExcl } = include.hour,
                    hourWidth = this.getSingleUnitInPixels('hour'),
                    // Scaling happens within a day, determine position within it
                    positionInDay = position % dayWidth,
                    // Store were the day starts to be able to re-add it after scale
                    dayStartPosition = position - positionInDay;
                // Scale position using calculated length per day factor, adding the width of excluded hours
                position = positionInDay / lengthFactorExcl + from * hourWidth + dayStartPosition;
            }
        }

        return position;
    }

    /**
     * Returns the amount of pixels for a single unit
     * @internal
     * @return {Number} The unit in pixel
     */
    getSingleUnitInPixels(unit) {
        const me = this;

        return me.unitToPixelsCache[unit] || (me.unitToPixelsCache[unit] = DateHelper.getUnitToBaseUnitRatio(me.timeAxis.unit, unit, true) * me.tickSize / me.timeAxis.increment);
    }

    /**
     * [Experimental] Returns the pixel increment for the current view resolution.
     * @internal
     * @return {Number} The increment
     */
    get snapPixelAmount() {
        if (this.snap) {
            const { resolution } = this.timeAxis;
            return (resolution.increment || 1) * this.getSingleUnitInPixels(resolution.unit);
        }
        else {
            return 1;
        }
    }

    //endregion

    //region Sizes

    /**
     * Get/set the current time column size (the width or height of a cell in the bottom-most time axis header row,
     * depending on mode)
     * @internal
     * @property {Number}
     */
    get tickSize() {
        return this._tickSize;
    }

    set tickSize(size) {
        this.setTickSize(size, false);
    }

    setTickSize(size, suppressEvent) {
        this._tickSize = this.originalTickSize = size;

        this.update(undefined, suppressEvent);
    }

    get timeResolution() {
        return this.timeAxis.resolution;
    }

    // Calculates the time column width/height based on the value defined viewPreset "tickWidth/tickHeight". It also
    // checks for the forceFit view option and the snap, both of which impose constraints on the time column width
    // configuration.
    calculateTickSize(proposedSize) {
        const
            me = this,
            { forceFit, timeAxis } = me,
            timelineUnit = timeAxis.unit;

        let size   = 0,
            ratio  = 1; //Number.MAX_VALUE;

        if (me.snap) {
            const resolution = timeAxis.resolution;
            ratio = DateHelper.getUnitToBaseUnitRatio(timelineUnit, resolution.unit) * resolution.increment;
        }
        // else {
        //     const measuringUnit = DH.getMeasuringUnit(timelineUnit);
        //     Math.min(ratio, DH.getUnitToBaseUnitRatio(timelineUnit, measuringUnit));
        // }

        if (!me.suppressFit) {
            const
                ticks        = timeAxis.visibleTickTimeSpan,
                // TODO: change this to always floor if we want to prevent scheduler scroll when not really needed
                fittingSize = Math[forceFit ? 'floor' : 'round'](me.availableSpace / ticks);

            size = (forceFit || proposedSize < fittingSize) ? fittingSize : proposedSize;

            if (ratio > 0 && (!forceFit || ratio < 1)) {
                // For touch, make sure we always fill the available space with forceFit (to not show edges of side-time-pickers)
                const method = (forceFit ? 'floor' : 'round');
                size = Math.round(Math.max(1, Math[method](ratio * size)) / ratio);
            }
        }
        else {
            size = proposedSize;
        }

        return size;
    }

    /**
     * Returns the total width/height of the time axis representation, depending on mode.
     * @return {Number} The width or height
     * @internal
     * @readonly
     */
    get totalSize() {
        return this._totalSize || (this._totalSize = Math.round(this.tickSize * this.timeAxis.visibleTickTimeSpan));
    }

    /**
     * Get/set the available space for the time axis representation. If size changes it will cause it to update its
     * contents and fire the {@link #event-update} event.
     * @internal
     * @property {Number}
     */
    get availableSpace() {
        return this._availableSpace;
    }

    set availableSpace(space) {
        const me = this;
        // We should only need to repaint fully if the tick width has changed (which will happen if forceFit is set, or if the full size of the time axis doesn't
        // occupy the available space - and gets stretched
        me._availableSpace = Math.max(0, space);

        if (me._availableSpace > 0) {
            const newTickSize = me.calculateTickSize(me.originalTickSize);

            if (newTickSize > 0 && newTickSize !== me.tickSize) {
                me.update();
            }
        }
    }

    //endregion

    //region Fitting & snapping

    /**
     * Returns start dates for ticks at the specified level in format { date, isMajor }.
     * @param {Number} level Level in headers array, `0` meaning the topmost...
     * @param {Boolean} useLowestHeader Use lowest level
     * @param getEnd
     * @returns {Array}
     * @internal
     */
    getDates(level = this.columnLinesFor, useLowestHeader = false, getEnd = false) {
        const me            = this,
            ticks         = [],
            linesForLevel = useLowestHeader ? me.lowestHeader : level,
            majorLevel    = me.majorHeaderLevel,
            levelUnit     = me.headers && me.headers[level].unit,
            majorUnit     = majorLevel != null && me.headers && me.headers[majorLevel].unit,
            validMajor    = majorLevel != null && DateHelper.doesUnitsAlign(majorUnit, levelUnit),
            hasGenerator  = !!(me.headers && me.headers[linesForLevel].cellGenerator);

        if (hasGenerator) {
            const cells = me.columnConfig[linesForLevel];

            for (let i = 1, l = cells.length; i < l; i++) {
                ticks.push({ date : cells[i].startDate });
            }
        }
        else {
            me.forEachInterval(linesForLevel, (start, end) => {
                ticks.push({
                    date    : getEnd ? end : start,
                    // do not want to consider tick to be major tick, hence the check for majorHeaderLevel
                    isMajor : majorLevel !== level && validMajor && me.isMajorTick(getEnd ? end : start)
                });
            });
        }

        return ticks;
    }

    get forceFit() {
        return this._forceFit;
    }

    /**
     * This function fits the time columns into the available space in the time axis column.
     * @param {Boolean} suppressEvent `true` to skip firing the 'update' event.
     * @internal
     */
    fitToAvailableSpace(suppressEvent) {
        const proposedSize = Math.floor(this.availableSpace / this.timeAxis.visibleTickTimeSpan);
        this.setTickSize(proposedSize, suppressEvent);
    }

    get snap() {
        return this._snap;
    }

    /**
     * Gets/sets the snap value for the model. Setting it will cause it to update its contents and fire the
     * {@link #event-update} event.
     * @property {Boolean}
     * @internal
     */
    set snap(value) {
        if (value !== this._snap) {
            this._snap = value;
            if (this.configured) this.update();
        }
    }

    //endregion

    //region Headers

    // private
    createHeaderRow(position, headerRowConfig, headerCells) {
        const
            me                = this,
            cells             = [],
            align             = headerRowConfig.align,
            today             = DateHelper.clearTime(new Date()),
            headerCellCls     = headerRowConfig.headerCellCls || '',
            createCellContext = (start, end, i, data) => {
                let value = DateHelper.format(start, headerRowConfig.dateFormat);

                const cellData = {
                    align,
                    start,
                    end,
                    value : data ? data.header : value,
                    headerCellCls,
                    width : this.getDistanceBetweenDates(start, end),
                    index : i
                };

                if (cellData.width === 0) {
                    return;
                }

                // Vertical mode uses absolute positioning for header cells
                cellData.coord = size;
                size += cellData.width;

                me.headersDatesCache[position][start.getTime()] = 1;

                if (headerRowConfig.renderer) {
                    value = headerRowConfig.renderer.call(headerRowConfig.thisObj || me, start, end, cellData, i, me.eventStore);

                    cellData.value = value == null ? '' : value;
                }

                // To be able to style individual day cells, weekends or other important days
                if (headerRowConfig.unit === 'day' && (!headerRowConfig.increment || headerRowConfig.increment === 1)) {
                    cellData.headerCellCls += ' b-sch-dayheadercell-' + start.getDay();

                    if (me.calendar && me.calendar.isWeekend(start)) {
                        cellData.headerCellCls += ' b-sch-dayheadercell-nonworking';
                    }

                    if (DateHelper.clearTime(start, true) - today === 0) {
                        cellData.headerCellCls += ' b-sch-dayheadercell-today';
                    }
                }

                cells.push(cellData);
            };

        let size = 0;

        me.headersDatesCache[position] = {};

        if (headerCells) {
            headerCells.forEach((cellData, i) => createCellContext(cellData.start, cellData.end, i, cellData));
        }
        else {
            me.forEachInterval(position, createCellContext);
        }

        return cells;
    }

    get mainHeader() {
        return ('mainHeaderLevel' in this) ? this.headers[this.mainHeaderLevel] : this.bottomHeader;
    }

    get bottomHeader() {
        return this.headers[this.headers.length - 1];
    }

    get lowestHeader() {
        return this.headers.length - 1;
    }

    /**
     * This method is meant to return the level of the header which 2nd lowest.
     * It is used for {@link #function-isMajorTick} method
     * @return {String}
     * @private
     */
    get majorHeaderLevel() {
        const { headers } = this;

        if (headers) {
            return Math.max(headers.length - 2, 0);
        }

        return null;
    }

    //endregion

    //region Ticks

    /**
     * For vertical view (and column lines plugin) we sometimes want to know if current tick starts along with the
     * upper header level.
     * @param {Date} date
     * @return {Boolean}
     * @private
     */
    isMajorTick(date) {
        const nextLevel = this.majorHeaderLevel;
        // if forceFit is used headersDatesCache won´t have been generated yet on the first call here,
        // since no size is set yet
        return nextLevel != null && this.headersDatesCache[nextLevel] && this.headersDatesCache[nextLevel][date.getTime()] || false;
    }

    /**
     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
     * Return false to break the iteration.
     * @param {Number} position The index of the header in the headers array.
     * @param {Function} iteratorFn The function to call, will be called with start date, end date and "tick index"
     * @param {Object} [thisObj] `this` reference for the function
     * @internal
     */
    forEachInterval(position, iteratorFn, thisObj = this) {
        const { headers } = this;

        if (headers) {
            // This is the lowest header row, which should be fed the data in the tickStore (or a row above using same unit)
            if (position === headers.length - 1) {
                this.timeAxis.forEach((r, index) =>
                    iteratorFn.call(thisObj, r.startDate, r.endDate, index)
                );
            }
            // All other rows
            else {
                const header = headers[position];

                this.timeAxis.forEachAuxInterval(header.unit, header.increment, iteratorFn, thisObj);
            }
        }
    }

    /**
     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
     * Return false to break the iteration.
     * @internal
     * @param {Function} iteratorFn The function to call
     * @param {Object} [thisObj] `this` reference for the function
     */
    forEachMainInterval(iteratorFn, thisObj) {
        this.forEachInterval(this.mainHeaderLevel, iteratorFn, thisObj);
    }

    //endregion

    //region ViewPreset

    consumeViewPreset(preset) {
        const me = this;

        // clear the cached headers
        me.headers = null;

        me._thisIsAUsedExpression(me.tickSize);

        // Since we are bypassing the tickSize setter below, ensure that
        // the config initial setter has been removed by referencing the property.
        // We only do this to avoid multiple updates from this. TODO: Fix this issue,
        // and do not bypass setters.
        me.viewPreset = preset;

        Object.assign(me, {
            headers         : preset.headers,
            columnLinesFor  : preset.columnLinesFor,
            mainHeaderLevel : preset.mainHeaderLevel,
            _tickSize       : me.isHorizontal ? preset.tickWidth : preset.tickHeight
        });

        me.originalTickSize = me.tickSize;
    }

    //endregion

    // //region Calendar
    //
    // setCalendar(cal) {
    //     if (cal !== this.calendar) {
    //         this.calendar = cal;
    //
    //         if (cal) {
    //             this.update();
    //         }
    //     }
    // }
    //
    // //endregion
}
TimeAxisViewModel._$name = 'TimeAxisViewModel';

// Used to avoid having to create huge amounts of Date objects
const tempDate = new Date();

/**
 * @module Scheduler/view/mixin/TimelineDateMapper
 */

/**
 * Mixin that contains functionality to convert between coordinates and dates etc.
 *
 * @mixin
 */
var TimelineDateMapper = Target => class TimelineDateMapper extends (Target || Base) {
    //region Coordinate <-> Date

    /**
     * Gets the date for an X or Y coordinate, either local to the view element or the page based on the 3rd argument.
     * If the coordinate is not in the currently rendered view, null will be returned unless the `allowOutOfRange`
     * parameter is passed a `true`.
     * @param {Number} coordinate The X or Y coordinate
     * @param {String} [roundingMethod] The rounding method to use
     * @param {Boolean} [local] true if the coordinate is local to the scheduler view element
     * @param {Boolean} [allowOutOfRange] By default, this returns `null` if the position is outside
     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.
     * @returns {Date} The Date corresponding to the X or Y coordinate
     * @category Dates
     */
    getDateFromCoordinate(coordinate, roundingMethod, local = true, allowOutOfRange = false) {
        if (!local) {
            coordinate = this.currentOrientation.translateToScheduleCoordinate(coordinate);
        }

        return this.timeAxisViewModel.getDateFromPosition(coordinate, roundingMethod, allowOutOfRange);
    }

    /**
     * Gets the date for the passed X coordinate.
     * If the coordinate is not in the currently rendered view, null will be returned.
     * @param {Number} x The X coordinate
     * @param {String} roundingMethod The rounding method to use
     * @returns {Date} the Date corresponding to the x coordinate
     * @param {Boolean} [local] true if the coordinate is local to the scheduler element
     * @category Dates
     * @deprecated 3.0 Use {@link #function-getDateFromXY} if you have a coordinate pair, or
     * {@link #function-getDateFromCoordinate} if you have the correct position depending upon orientation.
     */
    getDateFromX(x, roundingMethod, local = true) {
        return this.getDateFromCoordinate(x, roundingMethod, local);
    }

    /**
     * Gets the date for an XY coordinate regardless of the orientation of the time axis.
     * @param {Array} xy The page X and Y coordinates
     * @param {String} [roundingMethod] Optional, 'floor' to floor the value or 'round' to round the value to nearest increment
     * @param {Boolean} [local] true if the coordinate is local to the scheduler element
     * @param {Boolean} [allowOutOfRange] By default, this returns `null` if the position is outside
     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.
     * @returns {Date} the Date corresponding to the xy coordinate
     * @category Dates
     */
    getDateFromXY(xy, roundingMethod, local = true, allowOutOfRange = false) {
        return this.currentOrientation.getDateFromXY(xy, roundingMethod, local, allowOutOfRange);
    }

    /**
     * Gets the time for a DOM event such as 'mousemove' or 'click' regardless of the orientation of the time axis.
     * @param {Event} e the Event instance
     * @param {String} [roundingMethod] Optional, 'floor' to floor the value or 'round' to round the value to nearest increment
     * @param {Boolean} [allowOutOfRange] By default, this returns `null` if the position is outside
     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.
     * @returns {Date} The date corresponding to the EventObject's position along the orientation of the time axis.
     * @category Dates
     */
    getDateFromDomEvent(e, roundingMethod, allowOutOfRange = false) {
        return this.getDateFromXY([e.x, e.y], roundingMethod, false, allowOutOfRange);
    }

    /**
     * Gets the start and end dates for an element Region
     * @param {Core.helper.util.Rectangle} rect The rectangle to map to start and end dates
     * @param {String} roundingMethod The rounding method to use
     * @param {Number} duration The duration in MS of the underlying event
     * @returns {Object} an object containing start/end properties
     */
    getStartEndDatesFromRectangle(rect, roundingMethod, duration) {
        const
            me               = this,
            { isHorizontal } = me,
            timeSpanEnd      = isHorizontal ? me.timeAxisSubGrid.width : me.timeAxisSubGrid.height,
            startPos         = isHorizontal ? rect.x : rect.top,
            endPos           = isHorizontal ? rect.right : rect.bottom;

        let start, end;

        // Element within bounds
        if (startPos >= 0 && endPos < timeSpanEnd) {
            start = me.getDateFromCoordinate(startPos, null, true);
            end = me.getDateFromCoordinate(endPos, null, true);
        }
        // Starts before, start is worked backwards from end
        else if (startPos < 0) {
            end = me.getDateFromCoordinate(endPos, roundingMethod, true);
            start = DateHelper.add(end, -duration, 'ms');
        }
        // Ends after, end is calculated from the start
        else {
            start = me.getDateFromCoordinate(startPos, roundingMethod, true);
            end = DateHelper.add(start, duration, 'ms');
        }

        return {
            start, end
        };
    }
    //endregion

    //region Date display

    /**
     * Get/set format to use when displaying dates. Usually set by specifying a view preset
     * @property {String}
     * @category Dates
     */
    get displayDateFormat() {
        return this._displayDateFormat;
    }

    set displayDateFormat(format) {
        this._displayDateFormat = format;

        // Start/EndDateColumn listens for this to change their format to match
        this.trigger('displayDateFormatChange', { format });
    }

    /**
     * Method to get a formatted display date
     * @private
     * @param {Date} date The date
     * @return {String} The formatted date
     */
    getFormattedDate(date) {
        return DateHelper.format(date, this.displayDateFormat);
    }

    /**
     * Method to get a displayed end date value, see {@link #function-getFormattedEndDate} for more info.
     * @private
     * @param {Date} endDate The date to format
     * @param {Date} startDate The start date
     * @return {Date} The date value to display
     */
    getDisplayEndDate(endDate, startDate) {
        if (
            // If time is midnight,
            endDate.getHours() === 0 && endDate.getMinutes() === 0 &&

            // and end date is greater then start date
            (!startDate || !(endDate.getYear() === startDate.getYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() === startDate.getDate())) &&

            // and UI display format doesn't contain hour info (in this case we'll just display the exact date)
            !DateHelper.formatContainsHourInfo(this.displayDateFormat)
        ) {
            // format the date inclusively as 'the whole previous day'.
            endDate = DateHelper.add(endDate, -1, 'day');
        }

        return endDate;
    }

    /**
     * Method to get a formatted end date for a scheduled event, the grid uses the "displayDateFormat" property defined in the current view preset.
     * End dates are formatted as 'inclusive', meaning when an end date falls on midnight and the date format doesn't involve any hour/minute information,
     * 1ms will be subtracted (e.g. 2010-01-08T00:00:00 will first be modified to 2010-01-07 before being formatted).
     * @private
     * @param {Date} endDate The date to format
     * @param {Date} startDate The start date
     * @return {String} The formatted date
     */
    getFormattedEndDate(endDate, startDate) {
        return this.getFormattedDate(this.getDisplayEndDate(endDate, startDate));
    }

    //endregion

    //region Other date functions

    /**
     * Gets the x or y coordinate relative to the scheduler element, or page coordinate (based on the 'local' flag)
     * If the coordinate is not in the currently rendered view, -1 will be returned.
     * @param {Date|Number} date the date to query for (or a date as ms)
     * @param {Boolean|Object} options true to return a coordinate local to the scheduler view element (defaults to true),
     * also accepts a config object like { local : true }.
     * @returns {Number} the x or y position representing the date on the time axis
     * @category Dates
     */
    getCoordinateFromDate(date, options = true) {
        const me = this,
            { timeAxisViewModel } = me,
            { isContinuous, startMS, endMS, startDate, unit } = me.timeAxis,
            dateMS = date.valueOf();

        // Avoiding to break the API while allowing passing options through to getPositionFromDate()
        if (options === true) {
            options = {
                local : true
            };
        }
        else if (!options) {
            options = {
                local : false
            };
        }
        else if (!('local' in options)) {
            options.local = true;
        }

        let pos;

        // TODO for 2.0 try to normalize and just use dates as input for this method,
        // then this if-statement would not be needed
        if (!(date instanceof Date)) {
            tempDate.setTime(date);
            date = tempDate;
        }

        // Shortcut for continuous time axis that is using a unit that can be reliably translated to days (or smaller)
        if (isContinuous && date.getTimezoneOffset() === startDate.getTimezoneOffset() && DateHelper.getUnitToBaseUnitRatio(unit, 'day') !== -1) {

            if (dateMS < startMS || dateMS > endMS) {
                return -1;
            }
            pos = Math.round((dateMS - startMS) / (endMS - startMS) * timeAxisViewModel.totalSize);
        }
        // Non-continuous or using for example months (vary in length)
        else {
            pos = timeAxisViewModel.getPositionFromDate(date, options);
        }

        if (!options.local) {
            pos = me.currentOrientation.translateToPageCoordinate(pos);
        }

        return pos;
    }

    /**
     * Returns the distance in pixels for the time span in the view.
     * @param {Date} startDate The start date of the span
     * @param {Date} endDate The end date of the span
     * @return {Number} The distance in pixels
     * @category Dates
     */
    getTimeSpanDistance(startDate, endDate) {
        return this.timeAxisViewModel.getDistanceBetweenDates(startDate, endDate);
    }

    /**
     * Returns the center date of the currently visible timespan of scheduler.
     *
     * @return {Date} date Center date for the viewport.
     * @readonly
     * @category Dates
     */
    get viewportCenterDate() {
        const me       = this,
            timeAxis = me.timeAxis,
            subGrid  = me.timeAxisSubGrid,
            scroller = subGrid.scrollable,
            centerX  = scroller.x + subGrid.width / 2,
            centerY  = scroller.y + subGrid.height / 2;

        if (timeAxis.isContinuous) {
            // Calculate center pixel in the viewport.
            // Then Calculate how far through the axis range that is.
            const scrollCenter = me.isHorizontal ? (centerX / scroller.scrollWidth) : (centerY / scroller.scrollHeight),
                centerMilli = timeAxis.startMS + (timeAxis.endMS - timeAxis.startMS) * scrollCenter;

            return new Date(centerMilli);
        }
        else {
            const xy = me.isHorizontal ? [centerX, 0] : [0, centerY];

            return me.getDateFromXY(xy, null, true);
        }
    }

    get viewportCenterDateCached() {
        return this.cachedCenterDate || (this.cachedCenterDate = this.viewportCenterDate);
    }

    //endregion

    //region TimeAxis getters/setters

    /**
     * Gets/sets the current time resolution object, which contains a unit identifier and an increment count { unit, increment }.
     * This value means minimal task duration you can create using UI.
     * For example when you drag create a task or drag & drop a task, if increment is 5 and unit is 'minute'
     * that means that you can create a 5 min long task, or move it 5 min forward/backward.
     * This value is taken from viewPreset {@link Scheduler.preset.ViewPreset#field-timeResolution timeResolution} config by default.
     *
     * ```javascript
     * timeResolution : {
     *   unit      : 'minute',  //Valid values are "millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year".
     *   increment : 5
     * }
     * ```
     *
     * @property {Object}
     * @category Dates
     */
    get timeResolution() {
        return this.timeAxis.resolution;
    }

    set timeResolution(increment) {
        this.timeAxis.resolution = {
            increment,
            unit : this.timeAxis.resolution.unit
        };
    }

    //endregion

    //region Snap

    /**
     * Controls whether the scheduler should snap to the resolution when interacting with it
     * @property {Boolean}
     * @category Dates
     */
    set snap(enabled) {
        // timeAxisViewModel is not created yet during configuration
        if (!this.isConfiguring) {
            this.timeAxisViewModel.snap = enabled;
        }
        else {
            this._snap = enabled;
        }
    }

    get snap() {
        // timeAxisViewModel is not created yet during configuration
        if (this.isConfiguring) {
            return this._snap;
        }
        return this.timeAxisViewModel.snap;
    }

    //endregion

    onSchedulerHorizontalScroll({ subGrid, scrollLeft }) {
        // Invalidate cached center date unless we are scrolling to center on it.
        if (!this.scrollingToCenter) {
            this.cachedCenterDate = null;
        }
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

/**
 * @module Scheduler/view/mixin/TimelineDomEvents
 */

const eventNameMap = {
    mousedown   : 'MouseDown',
    mouseup     : 'MouseUp',
    click       : 'Click',
    dblclick    : 'DblClick',
    contextmenu : 'ContextMenu',
    mouseover   : 'MouseOver',
    mouseout    : 'MouseOut'
};

/**
 * Mixin that handles dom events (click etc) for scheduler and rendered events.
 *
 * @mixin
 */
var TimelineDomEvents = Target => class TimelineDomEvents extends (Target || Base) {
    //region Default config

    static get defaultConfig() {
        return {
            // TODO: PORT longpress missing
            scheduledBarEvents : {
                mousedown   : 'handleScheduledBarEvent',
                mouseup     : 'handleScheduledBarEvent',
                click       : 'handleScheduledBarEvent',
                dblclick    : 'handleScheduledBarEvent',
                contextmenu : 'handleScheduledBarEvent',
                mouseover   : 'handleScheduledBarEvent',
                mouseout    : 'handleScheduledBarEvent'
            },

            // TODO: PORT pinch, pinchstart, pinchend missing
            schedulerEvents : {
                click       : 'handleScheduleEvent',
                dblclick    : 'handleScheduleEvent',
                contextmenu : 'handleScheduleEvent',
                mousemove   : 'handleScheduleEvent'
            }
        };
    }

    //endregion

    //region Init

    /**
     * Adds listeners for DOM events for the scheduler and its events.
     * Which events is specified in Scheduler#scheduledBarEvents and Scheduler#schedulerEvents.
     * @private
     */
    initDomEvents() {
        const me = this;

        // Set thisObj and element of the configured listener specs.
        me.scheduledBarEvents.element = me.schedulerEvents.element = me.timeAxisSubGridElement;
        me.scheduledBarEvents.thisObj = me.schedulerEvents.thisObj = me;

        // same listener used for different events
        EventHelper.on(me.scheduledBarEvents);
        EventHelper.on(me.schedulerEvents);
    }

    //endregion

    //region Event handling

    getTimeSpanMouseEventParams(eventElement, event) {
        throw new Error('Implement in subclass');
    }

    getScheduleMouseEventParams(cellData, event) {
        throw new Error('Implement in subclass');
    }

    /**
     * Wraps dom Events for rendered scheduler EventModels and fires prefixed as our events.
     * For example click -> eventclick
     * @private
     * @param event
     */
    handleScheduledBarEvent(event) {
        const me           = this,
            eventElement = DomHelper.up(event.target, me.eventInnerSelector),
            eventName    = eventNameMap[event.type] || StringHelper.capitalizeFirstLetter(event.type);

        if (eventElement) {
            me.trigger(me.scheduledEventName + eventName, me.getTimeSpanMouseEventParams(eventElement, event));
        }
    }

    /**
     * Wraps dom Events for the scheduler and fires as our events.
     * For example click -> scheduleClick
     * @private
     * @param event
     */
    handleScheduleEvent(event) {
        const
            me           = this,
            eventElement = DomHelper.up(event.target, me.eventSelector),
            cellElement  = !eventElement && DomHelper.up(event.target, '.' + me.timeCellCls),
            eventName    = eventNameMap[event.type] || StringHelper.capitalizeFirstLetter(event.type);

        if (cellElement) {
            const
                clickedDate = me.getDateFromDomEvent(event, 'floor'),
                cellData    = DomDataStore.get(cellElement),
                index       = cellData.row.dataIndex,
                tickIndex   = me.timeAxis.getTickFromDate(clickedDate),
                tick        = me.timeAxis.getAt(Math.floor(tickIndex));

            if (tick) {
                me.trigger('schedule' + eventName, Object.assign({
                    date          : clickedDate,
                    tickStartDate : tick.startDate,
                    tickEndDate   : tick.endDate,
                    row           : cellData.row,
                    index,
                    event
                }, me.getScheduleMouseEventParams(cellData, event)));
            }
        }
    }

    /**
     * Relays mouseover events as eventmouseenter if over rendered event.
     * Also adds Scheduler#overScheduledEventClass to the hovered element.
     * @private
     */
    onElementMouseOver(event) {
        super.onElementMouseOver(event);

        const me           = this,
            target       = event.target;

        // We must be over the event bar
        if (target.closest(me.eventInnerSelector)) {
            const eventElement = target.closest(me.eventSelector);

            eventElement.classList.add(me.overScheduledEventClass);

            if (eventElement !== me.hoveredEventNode && !me.preventOverCls) {
                me.hoveredEventNode = eventElement;

                const params = me.getTimeSpanMouseEventParams(eventElement, event);
                if (params) {
                    // do not fire this event if model cannot be found
                    // this can be the case for "b-sch-dragcreator-proxy" elements for example
                    me.trigger(me.scheduledEventName + 'MouseEnter', params);
                }
            }
        }
        else {
            me.hoveredEventNode = null;
        }
    }

    /**
     * Relays mouseout events as eventmouseleave if out from rendered event.
     * Also removes Scheduler#overScheduledEventClass from the hovered element.
     * @private
     */
    onElementMouseOut(event) {
        super.onElementMouseOut(event);

        const me = this;

        // We must be over the event bar
        if (event.target.closest(me.eventInnerSelector) && me.resolveTimeSpanRecord(event.target) && me.hoveredEventNode) {
            // out to child shouldn't count...
            if (event.relatedTarget && DomHelper.isDescendant(event.target.closest(me.eventInnerSelector), event.relatedTarget)) return;

            me.unhover(event);
        }
    }

    unhover(event) {
        const me           = this,
            eventElement = me.hoveredEventNode;
        if (eventElement) {
            eventElement.classList.remove(me.overScheduledEventClass);
            me.trigger(me.scheduledEventName + 'MouseLeave', me.getTimeSpanMouseEventParams(eventElement, event));
            me.hoveredEventNode = null;
        }
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

/**
 * @module Scheduler/view/mixin/TimelineViewPresets
 */

/**
 * View preset handling.
 *
 * A Scheduler's {@link #config-presets} are loaded with a default set of {@link Scheduler.preset.ViewPreset ViewPresets}
 * which are defined by the system in the {@link Scheduler.preset.PresetManager PresetManager}.
 *
 * The zooming feature works by reconfiguring the Scheduler with a new {@link Scheduler.preset.ViewPreset ViewPreset} selected
 * from the {@link #config-presets} store.
 *
 * {@link Scheduler.preset.ViewPreset ViewPresets} can be added and removed from the store to change the amount of available steps.
 * Range of zooming in/out can be also modified with {@link Scheduler.view.mixin.TimelineZoomable#config-maxZoomLevel} / {@link Scheduler.view.mixin.TimelineZoomable#config-minZoomLevel} properties.
 *
 * This mixin adds additional methods to the column : {@link Scheduler.view.mixin.TimelineZoomable#property-maxZoomLevel}, {@link Scheduler.view.mixin.TimelineZoomable#property-minZoomLevel}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomToLevel}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomIn},
 * {@link Scheduler.view.mixin.TimelineZoomable#function-zoomOut}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomInFull}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomOutFull}.
 *
 * **Notice**: Zooming doesn't work properly when `forceFit` option is set to true for the Schedulker or for filtered timeaxis.
 *
 * @mixin
 */
var TimelineViewPresets = Target => class TimelineViewPresets extends (Target || Base) {
    //region Default config

    static get defaultConfig() {
        return {
            /**
             * A string key used to lookup a predefined {@link Scheduler.preset.ViewPreset} (e.g. 'weekAndDay', 'hourAndDay'),
             * managed by {@link Scheduler.preset.PresetManager}. See {@link Scheduler.preset.PresetManager} for more information.
             * Or a config object for a viewPreset.
             *
             * Options:
             * - 'secondAndMinute'
             * - 'minuteAndHour'
             * - 'hourAndDay'
             * - 'dayAndWeek'
             * - 'weekAndDay'
             * - 'weekAndMonth',
             * - 'monthAndYear'
             * - 'year'
             * - 'manyYears'
             * - 'weekAndDayLetter'
             * - 'weekDateAndMonth'
             * - 'day'
             * - 'week'
             *
             * If passed as a config object, the settings from the viewPreset with the provided `base` property will be used along
             * with any overridden values in your object.
             *
             * To override:
             * ```javascript
             * viewPreset : {
             *   base    : 'hourAndDay',
             *   id      : 'myHourAndDayPreset',
             *   headers : [
             *       {
             *           unit      : "hour",
             *           increment : 12,
             *           renderer  : (startDate, endDate, headerConfig, cellIdx) => {
             *               return "";
             *           }
             *       }
             *   ]
             * }
             * ```
             * or set a new valid preset config if the preset is not registered in the {@link Scheduler.preset.PresetManager}.
             *
             * When you use scheduler in weekview mode, this config is used to pick view preset. If passed view preset is not
             * supported by weekview (only 2 supported by default - 'day' and 'week') default preset will be used - 'week'.
             * @config {String|Object}
             * @default
             * @category Common
             */
            viewPreset : 'weekAndDayLetter',

            /**
             * Defines how dates will be formatted in tooltips etc. This config has priority over similar config on the
             * view preset. For allowed values see {@link Core.helper.DateHelper#function-format-static}.
             * @config {String}
             * @category Scheduled events
             */
            displayDateFormat : null,

            /**
             * An array of {@link Scheduler.preset.ViewPreset ViewPreset} config objects
             * which describes the available timeline layouts for this scheduler.
             *
             * By default, a predefined set is loaded from the {@link Scheduler.preset.PresetManager PresetManager}.
             *
             * A {@link Scheduler.preset.ViewPreset ViewPreset} describes the granularity of the
             * timeline view and the layout and subdivisions of the timeline header.
             * @config {Object[]} presets
             *
             * @category Common
             */
            presets : true
        };
    }

    //endregion

    //region Get/set

    /**
     * Get the {@link Scheduler.preset.PresetStore PresetStore} created for the Scheduler,
     * or set an array of {@link Scheduler.preset.ViewPreset ViewPreset} config objects.
     * @property {Scheduler.preset.PresetStore|Object[]}
     * @category Common
     */
    set presets(presets) {
        if (presets === true) {
            presets = pm.allRecords;
        }

        this._presets = new PresetStore({
            data : presets
        });
    }

    get presets() {
        return this._presets;
    }

    /**
     * Get/set the current view preset
     * @property {Scheduler.preset.ViewPreset|String}
     * @category Common
    */
    get viewPreset() {
        return this._viewPreset;
    }

    set viewPreset(preset) {
        // TODO: remove deprecated compatibility layer in V4
        if (!(preset instanceof ViewPreset) && preset.name && !preset.base) {
            VersionHelper.deprecate('Scheduler', '4.0.0', 'ViewPreset name config replaced by base config. See https://www.bryntum.com/docs/scheduler/#guides/upgrades/3.0.md');
            preset.base = preset.name;
        }
        if (!this._viewPreset || !this._viewPreset.equals(preset)) {
            this.setViewPreset(preset);
        }
    }

    normalizePreset(preset) {
        const
            me          = this,
            input       = preset,
            { presets } = me;

        // They may have passed a string id, an number index, or ViewPreset config object.
        if (!(preset instanceof ViewPreset)) {
            // A config of a preset, instantiate it based upon any base that may be requested.
            // This may be one that's supplied by Bryntum in the PresetManager, or one that has been
            // previously added to this Scheduler's preset store.
            if (typeof preset === 'object') {
                // Look up any existing ViewPreset that it is based upon.
                if (preset.base) {
                    // Look locally first, then in the PresetManager
                    const base = presets.getById(preset.base) || pm.getById(preset.base);

                    if (!base) {
                        throw new Error(`ViewPreset base '${preset.base}' does not exist`);
                    }
                    // The config is based upon the base's data with the new Preset type's normalized data object merged in.
                    // MUST run the incoming data block through the constructor in order to apply the backward compatibility
                    // processing to the data block to be merged with the base.
                    preset = ObjectHelper.merge(ObjectHelper.clone(base.data), pm.createRecord(preset).data);
                }

                // Ensure the new ViewPreset has a legible, logical id which does not already
                // exist in our store.
                if (preset.id) {
                    preset = presets.createRecord(preset);
                }
                else {
                    preset = presets.createRecord(ObjectHelper.assign({}, preset));
                    preset.id = preset.generateId(presets);
                }
            }
            // Must be an index or id
            else {
                if (typeof preset === 'number') {
                    preset = presets.getAt(preset);
                }
                else {
                    preset = presets.getById(preset) || pm.getById(preset);
                }
            }

            if (!preset) {
                throw new Error(`Invalid ViewPreset requested: ${input}`);
            }
        }

        // An instance.
        // If an existing id is used, this will replace it.
        return presets.add(preset)[0];
    }

    /**
     * Sets the current view preset. See the {@link Scheduler.preset.PresetManager} class for details.
     *
     * @param {String|Object|Scheduler.preset.ViewPreset} preset The id of the new preset (see {@link Scheduler.preset.PresetManager} for details)
     * @param {Date} [startDate] A new start date for the time axis
     * @param {Date} [endDate] A new end date for the time axis
     * @private
     */
    setViewPreset(preset, startDate, endDate, initial, options = {}) {
        const
            me               = this,
            {
                isHorizontal,
                _timeAxis : timeAxis    // Do not tickle the getter, we are just peeking to see if it's there yet.
            } = me,
            event            = {
                startDate,
                endDate,
                from : me.viewPreset
            };

        // normalize preset (applies preset customizations or gets a predefined preset)
        preset = event.to = event.preset = me.normalizePreset(preset);

        // No extra options, and the current one specified, or one that is identical in configuration: Do nothing to the UI.
        if (!Object.keys(options).length && me._viewPreset && (me._viewPreset === preset || me._viewPreset.equals(preset))) {
            return;
        }

        // This is set if the object is inside the Base constructor's configure method.
        initial = initial || me.isConfiguring;

        let centerDate = options.centerDate;

        /**
         * Fired before the {@link #config-viewPreset} is changed.
         * @event beforePresetChange
         * @param {Scheduler.view.Scheduler} source This Scheduler instance.
         * @param {Date} startDate The new start date of the timeline.
         * @param {Date} endDate The new end date of the timeline.
         * @param {Scheduler.preset.ViewPreset} from The outgoing ViewPreset.
         * @param {Scheduler.preset.ViewPreset} to The ViewPreset being switched to.
         * @preventable
         */
        /**
         * Fired before the {@link #config-viewPreset} is changed.
         * @event beforeZoomChange
         * @param {Scheduler.view.Scheduler} source This Scheduler instance.
         * @param {Date} startDate The new start date of the timeline.
         * @param {Date} endDate The new end date of the timeline.
         * @param {Scheduler.preset.ViewPreset} from The outgoing ViewPreset.
         * @param {Scheduler.preset.ViewPreset} to The ViewPreset being switched to.
         * @preventable
         * @deprecated 3.0 Use {@link #event-beforePresetChange} instead. A zoom level is a ViewPreset.
         */
        if (initial || (me.trigger('beforePresetChange', event) !== false && me.trigger('beforeZoomChange', event) !== false)) {
            me._viewPreset = preset;

            // Raise flag to prevent partner from changing view preset if one is in progress
            me._viewPresetChanging = true;

            // prefer to use displayDateFormat configured on the panel
            me.displayDateFormat = me.config.displayDateFormat || preset.displayDateFormat;

            if (timeAxis) {
                // None of this reconfiguring should cause a refresh
                me.suspendRefresh();

                // Timeaxis may already be configured (in case of sharing with the timeline partner), no need to reconfigure it
                if (!(initial && timeAxis.isConfigured)) {
                    const timeAxisCfg = {
                        weekStartDay : me.weekStartDay,
                        startTime    : me.startTime,
                        endTime      : me.endTime
                    };

                    if (initial) {
                        if (timeAxis.count === 0 || startDate) {
                            timeAxisCfg.startDate = startDate || new Date();
                            timeAxisCfg.endDate = endDate;
                        }
                    }
                    else {
                        // if startDate is provided we use it and the provided endDate
                        if (startDate) {
                            timeAxisCfg.startDate = startDate;
                            timeAxisCfg.endDate = endDate;

                            // if both dates are provided we can calculate centerDate for the viewport
                            if (!centerDate && endDate) {
                                // TODO: PORT infitieScroll stuff
                                // if (me.infiniteScroll && view.cachedScrollDate && view.cachedScrollDateIsCentered) {
                                //     centerDate = view.cachedScrollDate;
                                // } else {
                                centerDate = new Date((startDate.getTime() + endDate.getTime()) / 2);
                                //}
                            }

                            // when no start/end dates are provided we use the current timespan
                        }
                        else {
                            timeAxisCfg.startDate = timeAxis.startDate;
                            timeAxisCfg.endDate = endDate || timeAxis.endDate;

                            if (!centerDate) {
                                // TODO: PORT inifiteScroll stuff
                                // if (me.infiniteScroll && view.cachedScrollDate && view.cachedScrollDateIsCentered) {
                                //     centerDate = view.cachedScrollDate;
                                // } else {
                                // TODO: PORT needed?
                                //centerDate = me.getViewportCenterDateCached();
                                centerDate = me.viewportCenterDate;
                                //}
                            }
                        }
                    }

                    timeAxis.isConfigured = false;
                    timeAxis.viewPreset = preset;
                    timeAxis.reconfigure(timeAxisCfg, true);

                    me.timeAxisViewModel.reconfigure({
                        viewPreset : me.viewPreset,
                        headers    : preset.headers,

                        // Default to bottom if `columnLinesFor` config is not specified
                        columnLinesFor : preset.columnLinesFor != null ? preset.columnLinesFor : preset.headers.length - 1,

                        // TODO: PORT rowHeightHorizontal??
                        rowHeightHorizontal : me.readRowHeightFromPreset ? preset.rowHeight : me.rowHeight,
                        tickSize            : isHorizontal ? preset.tickWidth : preset.tickHeight || preset.tickWidth || 60
                    });

                    // Allow refresh to run after the reconfiguring
                    me.resumeRefresh();
                }

                // TODO: PORT vertical later
                // if (isVertical) {
                //     me.setColumnWidth(me.resourceColumnWidth || preset.resourceColumnWidth || 100, true);
                // }

                me.refresh();

                // if view is rendered and scroll is not disabled by "notScroll" option
                if (!options.notScroll && me.isPainted) {
                    // and we have centerDate to scroll to
                    if (centerDate) {
                        // remember the central date we scroll to (it gets reset after user scroll)
                        me.cachedCenterDate = centerDate;

                        // setViewPreset method on a partner panels should be executed with same arguments.
                        // if one partner was provided with a centerDate, other one has to be too to generate exact
                        // header and set same scroll
                        event.centerDate = centerDate;

                        let x = null;

                        // TODO: PORT vertical later
                        // if (isVertical) {
                        //     y = Math.max(Math.floor(view.getCoordinateFromDate(centerDate, true) - view.getViewContainerHeight() / 2), 0);
                        //     me.viewPresetActiveScroll = { top : y };
                        //     view.scrollVerticallyTo(y);
                        // } else {
                        x = Math.max(Math.floor(me.getCoordinateFromDate(centerDate, true) - me.timeAxisSubGrid.width / 2), 0);
                        me.viewPresetActiveScroll = { left : x };

                        // The horizontal scroll handler must not invalidate the cached center
                        // when this scroll event rolls round on the next frame.
                        me.scrollingToCenter = true;

                        me.scrollHorizontallyTo(x, false);

                        // Release the lock on scrolling invalidating the cached center.
                        me.setTimeout(() => {
                            me.scrollingToCenter = false;
                        }, 100);
                        //}

                        // if we don't have a central date to scroll at we reset scroll (this is bw compatible behavior)
                    }
                    else {
                        // TODO: PORT vertical later
                        // if (isHorizontal) {
                        me.scrollHorizontallyTo(0, false);
                        //} else {
                        //    view.scrollVerticallyTo(0);
                        //}
                    }
                }
            }

            /**
             * Fired after the {@link #config-viewPreset} has changed.
             * @event presetChange
             * @param {Scheduler.view.Scheduler} source This Scheduler instance.
             * @param {Date} startDate The new start date of the timeline.
             * @param {Date} centerDate The new center date of the timeline.
             * @param {Date} endDate The new end date of the timeline.
             * @param {Scheduler.preset.ViewPreset} from The outgoing ViewPreset.
             * @param {Scheduler.preset.ViewPreset} to The ViewPreset being switched to.
             * @preventable
             */
            /**
             * Fired after the {@link #config-viewPreset} has changed.
             * @event zoomChange
             * @param {Scheduler.view.Scheduler} source This Scheduler instance.
             * @param {Date} startDate The new start date of the timeline.
             * @param {Date} centerDate The new center date of the timeline.
             * @param {Date} endDate The new end date of the timeline.
             * @param {Scheduler.preset.ViewPreset} from The outgoing ViewPreset.
             * @param {Scheduler.preset.ViewPreset} to The ViewPreset being switched to.
             * @preventable
             * @deprecated 3.0 Use {@link #event-presetChange} instead. A zoom level is a ViewPreset.
             */
            me.trigger('presetChange', event);
            me.trigger('zoomChange', event);
        }

        me._viewPresetChanging = false;
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

/**
 * @module Scheduler/view/mixin/TimelineZoomable
 */

/**
 * Mixin providing "zooming" functionality.
 *
 * The zoom levels are stored as instances of {@link Scheduler.preset.ViewPreset ViewPreset}s, and are
 * cached centrally in the {@link Scheduler.preset.PresetManager PresetManager}.
 *
 * The default presets are loaded into the {@link Scheduler.view.mixin.TimelineViewPresets#config-presets}
 * store upon Scheduler instantiation. Preset selection is covered in the
 * {@link Scheduler.view.mixin.TimelineViewPresets TimelineViewPresets} mixin.
 *
 * To specify custom zoom levels please provide a set of view presets to the global PresetManager store **before** scheduler creation,
 * or provide a set of view presets to a specific scheduler only:
 *
 * ```javascript
 * const myScheduler = new Scheduler({
 *     presets : [
 *         {
 *             base : 'hourAndDay',
 *             id   : 'MyHourAndDay',
 *             // other preset configs....
 *         },
 *         {
 *             base : 'weekAndMonth',
 *             id   : 'MyWeekAndMonth',
 *             // other preset configs....
 *         }
 *     ],
 *     viewPreset : 'MyHourAndDay',
 *     // other scheduler configs....
 *     });
 * ```
 *
 * @mixin
 */
var TimelineZoomable = Target => class TimelineZoomable extends (Target || Base) {
    static get defaultConfig() {
        return {
            /**
             * If true, you can zoom in and out on the the time axis using CTRL-key + mouse wheel.
             * @config {Boolean}
             * @default
             * @category Zoom
             */
            zoomOnMouseWheel : true,

            /**
             * True to zoom to time span when double clicking a time axis cell.
             * @config {Boolean}
             * @default
             * @category Zoom
             */
            zoomOnTimeAxisDoubleClick : true,

            preventScrollZoom : null,

            /**
             * Minimal zoom level to which {@link #function-zoomOut} will work
             * @config {Number}
             * @category Zoom
             */
            minZoomLevel : null,

            /**
             * Maximal zoom level to which {@link #function-zoomIn} will work
             * @config {Number}
             * @category Zoom
             */
            maxZoomLevel : null,

            /**
             * Integer number indicating the size of timespan during zooming. When zooming, the timespan is adjusted to make the scrolling area `visibleZoomFactor` times
             * wider than the timeline area itself. Used in {@link #function-zoomToSpan} and {@link #function-zoomToLevel} functions.
             * @config {Number}
             * @default
             * @category Zoom
             */
            visibleZoomFactor : 5,

            /**
             * Whether the originally rendered timespan should be preserved while zooming. By default it is set to `false`,
             * meaning the timeline panel will adjust the currently rendered timespan to limit the amount of HTML content to render. When setting this option
             * to `true`, be careful not to allow to zoom a big timespan in seconds resolution for example. That will cause **a lot** of HTML content
             * to be rendered and affect performance. You can use {@link #config-minZoomLevel} and {@link #config-maxZoomLevel} config options for that.
             * @config {Boolean}
             * @default
             * @category Zoom
             */
            zoomKeepsOriginalTimespan : null
        };
    }

    construct(config) {
        const me = this;

        super.construct(config);

        if (me.zoomOnMouseWheel) {
            EventHelper.on({
                element : me.timeAxisSubGridElement,
                wheel   : 'onWheel',
                thisObj : me,
                capture : true,
                passive : false
            });
        }

        if (me.zoomOnTimeAxisDoubleClick) {
            me.on('timeaxisheaderdblclick', ({ startDate, endDate }) => {
                if (!me.isVertical) {
                    me.zoomToSpan({
                        startDate,
                        endDate
                    });
                }
            });
        }
    }

    get maxZoomLevel() {
        return this._maxZoomLevel || (this.presets.count - 1);
    }

    /**
     * Get/set the {@link #config-maxZoomLevel} value
     * @property {Number}
     * @category Zoom
     */
    set maxZoomLevel(level) {
        if (typeof level !== 'number') {
            level = this.presets.count - 1;
        }

        if (level < 0 || level >= this.presets.count) {
            throw new Error('Invalid range for `setMinZoomLevel`');
        }

        this._maxZoomLevel = level;
    }

    get minZoomLevel() {
        return this._minZoomLevel || 0;
    }

    /**
     * Sets the {@link #config-minZoomLevel} value
     * @property {Number}
     * @category Zoom
     */
    set minZoomLevel(level) {
        if (typeof level !== 'number') {
            level = 0;
        }

        if (level < 0 || level >= this.presets.count) {
            throw new Error('Invalid range for `minZoomLevel`');
        }

        this._minZoomLevel = level;
    }

    /**
     * Get/set current zoom level. Since zoom can happen to a preset or to a timespan,
     * getter may return float number which is intended to be close to index of one of the existing {@link Scheduler.view.mixin.TimelineViewPresets#config-presets zoom levels}.
     * @property {Number}
     * @category Zoom
     */
    get zoomLevel() {
        return this.presets.indexOf(this.viewPreset);
    }

    // noinspection JSAnnotator
    set zoomLevel(level) {
        this.zoomToLevel(level);
    }

    /*
     * @private
     * Returns number of milliseconds per pixel.
     * @param {Object} level Element from array of {@link Scheduler.view.mixin.TimelineViewPresets#config-presets}.
     * @param {Boolean} ignoreActualWidth If true, then density will be calculated using default zoom level settings.
     * Otherwise density will be calculated for actual tick width.
     * @return {Number} Return number of milliseconds per pixel.
     */
    getMilliSecondsPerPixelForZoomLevel(preset, ignoreActualWidth) {
        const
            { bottomHeader } = preset,
            width            = this.isHorizontal ? preset.tickWidth : preset.tickHeight;

        // trying to convert the unit + increment to a number of milliseconds
        // this number is not fixed (month can be 28, 30 or 31 day), but at least this conversion
        // will be consistent (should be no DST changes at year 1)
        return Math.round(
            (DateHelper.add(new Date(1, 0, 1), bottomHeader.increment || 1, bottomHeader.unit) - new Date(1, 0, 1)) /
            // `actualWidth` is a column width after view adjustments applied to it (see `calculateTickWidth`)
            // we use it if available to return the precise index value from `getCurrentZoomLevelIndex`
            (ignoreActualWidth ? width : preset.actualWidth || width)
        );
    }

    /**
     * Zooms to passed view preset, saving center date. Method accepts config object as a first argument, which can be
     * reduced to primitive type (string,number) when no additional options required. e.g.:
     * ```
     * // zooming to preset
     * scheduler.zoomTo({ preset : 'hourAndDay' })
     * // shorthand
     * scheduler.zoomTo('hourAndDay')
     *
     * // zooming to level
     * scheduler.zoomTo({ level : 0 })
     * // shorthand
     * scheduler.zoomTo(0)
     * ```
     *
     * It is also possible to zoom to a time span by omitting `preset` and `level` configs, in which case scheduler sets
     * the time frame to a specified range and applies zoom level which allows to fit all columns to this range. The
     * given time span will be centered in the scheduling view (unless `centerDate` config provided). In the same time,
     * the start/end date of the whole time axis will be extended to allow scrolling for user.
     * ```
     * // zooming to time span
     * scheduler.zoomTo({ startDate : new Date(..), endDate : new Date(...) })
     *
     * ```
     *
     * @param {Object|String|Number} config Config object, preset name or zoom level index.
     * @param {String} config.preset Preset name to zoom to. Ignores level config in this case
     * @param {Number} config.level Zoom level to zoom to. Is ignored, if preset config is provided
     * @param {Date} config.startDate New time frame start. If provided along with end, view will be centered in this time
     * interval (unless `centerDate` is present)
     * @param {Date} config.endDate New time frame end
     * @param {Date} config.centerDate Date that should be kept in the center. Has priority over start and end params
     * @param {Number} config.width Lowest tick width. Might be increased automatically
     * @param {Number} [config.leftMargin] Amount of pixels to extend span start on (used, when zooming to span)
     * @param {Number} [config.rightMargin] Amount of pixels to extend span end on (used, when zooming to span)
     * @param {Number} [config.adjustStart] Amount of units to extend span start on (used, when zooming to span)
     * @param {Number} [config.adjustEnd] Amount of units to extend span end on (used, when zooming to span)
     * @category Zoom
     */
    zoomTo(config) {
        const me = this;

        if (typeof config === 'object') {
            if (config.preset) {
                me.zoomToLevel(config.preset, config);
            }
            else if (config.level != null) {
                me.zoomToLevel(config.level, config);
            }
            else {
                me.zoomToSpan(config);
            }
        }
        else {
            me.zoomToLevel(config);
        }
    }

    /**
     * Allows zooming to certain level of {@link Scheduler.view.mixin.TimelineViewPresets#config-presets} array. Automatically limits zooming between {@link #config-maxZoomLevel}
     * and {@link #config-minZoomLevel}. Can also set time axis timespan to the supplied start and end dates.
     *
     * @param {Number} preset Level to zoom to.
     * @param {Object} [options] Object, containing options for this method
     * @param {Date} options.startDate New time frame start. If provided along with end, view will be centered in this time
     * interval, ignoring centerDate config.
     * @param {Date} options.endDate New time frame end.
     * @param {Date} options.centerDate Date that should be kept in center. Is ignored when start and end are provided.
     * @param {Number} options.width Lowest tick width. Might be increased automatically
     * @return {Number} level Current zoom level or null if it hasn't changed.
     * @category Zoom
     */
    zoomToLevel(preset, options = {}) {
        // Sanitize numeric zooming.
        if (typeof preset === 'number') {
            preset = Math.min(Math.max(preset, this.minZoomLevel), this.maxZoomLevel);
        }

        const
            me                 = this,
            { config }         = me,
            tickSizeProp       = me.isVertical ? 'tickHeight' : 'tickWidth',
            newPreset          = me.normalizePreset(preset),
            configuredTickSize = newPreset[tickSizeProp],
            startDate          = options.startDate,
            endDate            = options.endDate;

        let span = startDate && endDate ? { startDate, endDate } : null;

        const
            centerDate = options.centerDate || (span ? new Date((startDate.getTime() + endDate.getTime()) / 2) : me.viewportCenterDateCached),
            panelSize  = me.timeAxisSubGrid.width;

        if (!span) {
            // If we revert back to the original settings, and we had an original span
            // then revert back to that span.
            if (config.startDate && config.endDate && config.viewPreset && newPreset.equals(me.normalizePreset(config.viewPreset))) {
                span = {
                    startDate : config.startDate,
                    endDate   : config.endDate
                };
            }
            else {
                span = me.calculateOptimalDateRange(centerDate, panelSize, newPreset);
            }
        }

        // Temporarily override tick size while reconfiguring the TimeAxisViewModel
        if ('width' in options) {
            newPreset.setData(tickSizeProp, options.width);
        }

        me.isZooming = true;

        me.setViewPreset(newPreset, span.startDate || me.startDate, span.endDate || me.endDate, false, { centerDate : centerDate });

        // after switching the view preset the `width` config of the zoom level may change, because of adjustments
        // we will save the real value in the `actualWidth` property, so that `getCurrentZoomLevelIndex` method
        // will return the exact level index after zooming
        newPreset.actualWidth = me.timeAxisViewModel.tickSize;

        me.isZooming = false;

        // Restore the tick size because the default presets are shared.
        newPreset.setData(tickSizeProp, configuredTickSize);
    }

    /**
     * Changes the range of the scheduling chart to fit all the events in its event store.
     * @param {Object} [options] Options object for the zooming operation.
     * @param {Number} [options.leftMargin] Defines margin in pixel between the first event start date and first visible date
     * @param {Number} [options.rightMargin] Defines margin in pixel between the last event end date and last visible date
     */
    zoomToFit(options) {
        const eventStore = this.eventStore,
            span       = eventStore.getTotalTimeSpan();

        options = Object.assign({
            leftMargin  : 0,
            rightMargin : 0
        }, options, span);

        // Make sure we received a time span, event store might be empty
        if (options.startDate && options.endDate) {
            this.zoomToSpan(options);
        }
    }

    /**
     * Sets time frame to specified range and applies zoom level which allows to fit all columns to this range.
     *
     * The given time span will be centered in the scheduling view, in the same time, the start/end date of the whole time axis
     * will be extended in the same way as {@link #function-zoomToLevel} method does, to allow scrolling for user.
     *
     * @param {Object} config The time frame.
     * @param {Date} config.startDate The time frame start.
     * @param {Date} config.endDate The time frame end.
     * @param {Date} [config.centerDate] Date that should be kept in the center. Has priority over start and end params
     * @param {Number} [config.leftMargin] Amount of pixels to extend span start on
     * @param {Number} [config.rightMargin] Amount of pixels to extend span end on
     * @param {Number} [config.adjustStart] Amount of units to extend span start on
     * @param {Number} [config.adjustEnd] Amount of units to extend span end on
     *
     * @return {Number} level Current zoom level or null if it hasn't changed.
     * @category Zoom
     */
    zoomToSpan(config = {}) {
        if (config.leftMargin || config.rightMargin) {
            config.adjustStart = 0;
            config.adjustEnd = 0;
        }

        if (!config.leftMargin) config.leftMargin = 0;
        if (!config.rightMargin) config.rightMargin = 0;

        if (!config.startDate || !config.endDate) throw new Error('zoomToSpan: must provide startDate + endDate dates');

        const
            me           = this,
            // this config enables old zoomToSpan behavior which we want to use for zoomToFit in Gantt
            needToAdjust = config.adjustStart >= 0 || config.adjustEnd >= 0;

        let {
            startDate,
            endDate
        } = config;

        if (needToAdjust) {
            startDate = DateHelper.add(startDate, -config.adjustStart, me.timeAxis.mainUnit);
            endDate   = DateHelper.add(endDate, config.adjustEnd, me.timeAxis.mainUnit);
        }

        if (startDate <= endDate) {
            // get scheduling view width
            const
                { availableSpace } = me.timeAxisViewModel,
                presets = me.presets.allRecords,
                diffMS  = endDate - startDate || 1;

            // if potential width of col is less than col width provided by zoom level
            //   - we'll zoom out panel until col width fit into width from zoom level
            // and if width of column is more than width from zoom level
            //   - we'll zoom in until col width fit won't fit into width from zoom level

            let currLevel = Math.floor(me.zoomLevel),
                inc, range;

            // if we zoomed out even more than the highest zoom level - limit it to the highest zoom level
            if (currLevel === -1) currLevel = 0;

            let msPerPixel             = me.getMilliSecondsPerPixelForZoomLevel(presets[currLevel], true),
                // increment to get next zoom level:
                // -1 means that given timespan won't fit the available width in the current zoom level, we need to zoom out,
                // so that more content will "fit" into 1 px
                //
                // +1 mean that given timespan will already fit into available width in the current zoom level, but,
                // perhaps if we'll zoom in a bit more, the fitting will be better
                candidateLevel         = currLevel + (inc = diffMS / msPerPixel + config.leftMargin + config.rightMargin > availableSpace ? -1 : 1),
                zoomLevel, levelToZoom = null;

            // loop over zoom levels
            while (candidateLevel >= 0 && candidateLevel <= presets.length - 1) {
                // get zoom level
                zoomLevel = presets[candidateLevel];

                msPerPixel = me.getMilliSecondsPerPixelForZoomLevel(zoomLevel, true);
                const spanWidth = diffMS / msPerPixel + config.leftMargin + config.rightMargin;

                // if zooming out
                if (inc === -1) {
                    // if columns fit into available space, then all is fine, we've found appropriate zoom level
                    if (spanWidth <= availableSpace) {
                        levelToZoom = candidateLevel;
                        // stop searching
                        break;
                    }
                    // if zooming in
                }
                else {
                    // if columns still fits into available space, we need to remember the candidate zoom level as a potential
                    // resulting zoom level, the indication that we've found correct zoom level will be that timespan won't fit
                    // into available view
                    if (spanWidth <= availableSpace) {
                        // if it's not currently active level
                        if (currLevel !== candidateLevel - inc) {
                            // remember this level as applicable
                            levelToZoom = candidateLevel;
                        }
                    }
                    else {
                        // Sanity check to find the following case:
                        // If we're already zoomed in at the appropriate level, but the current zoomLevel is "too small" to fit and had to be expanded,
                        // there is an edge case where we should actually just stop and use the currently selected zoomLevel
                        break;
                    }
                }

                candidateLevel += inc;
            }

            // If we didn't find a large/small enough zoom level, use the lowest/highest level
            levelToZoom = levelToZoom != null ? levelToZoom : candidateLevel - inc;

            // presets is the array of all ViewPresets this Scheduler is using
            zoomLevel = presets[levelToZoom];

            const unitToZoom = zoomLevel.bottomHeader.unit;

            if (config.leftMargin || config.rightMargin) {
                // time axis doesn't yet know about new view preset (zoom level) so it cannot round/ceil date correctly
                startDate = new Date(startDate.getTime() - msPerPixel * config.leftMargin);
                endDate   = new Date(endDate.getTime() + msPerPixel * config.rightMargin);
            }

            const tickCount = DateHelper.getDurationInUnit(startDate, endDate, unitToZoom, true) / zoomLevel.bottomHeader.increment;

            if (tickCount === 0) {
                return null;
            }

            const
                customWidth = Math.floor(availableSpace / tickCount),
                centerDate  = config.centerDate || new Date((startDate.getTime() + endDate.getTime()) / 2);

            if (needToAdjust) {
                range = {
                    startDate,
                    endDate
                };
            }
            else {
                range = me.calculateOptimalDateRange(centerDate, availableSpace, zoomLevel);
            }

            return me.zoomToLevel(levelToZoom,
                Object.assign(range, {
                    width : customWidth,
                    centerDate
                })
            );
        }

        return null;
    }

    /**
     * Zooms in the timeline according to the array of zoom levels. If the amount of levels to zoom is given, the view will zoom in by this value.
     * Otherwise a value of `1` will be used.
     *
     * @param {Number} levels (optional) amount of levels to zoom in
     *
     * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
     * @category Zoom
     */
    zoomIn(levels = 1) {
        const currentZoomLevelIndex = this.zoomLevel;

        if (currentZoomLevelIndex >= this.presets.count - 1) return null;

        return this.zoomToLevel(Math.floor(currentZoomLevelIndex) + levels);
    }

    /**
     * Zooms out the timeline according to the array of zoom levels. If the amount of levels to zoom is given, the view will zoom out by this value.
     * Otherwise a value of `1` will be used.
     *
     * @param {Number} levels (optional) amount of levels to zoom out
     *
     * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
     * @category Zoom
     */
    zoomOut(levels = 1) {
        const currentZoomLevelIndex = this.zoomLevel;

        if (currentZoomLevelIndex <= 0) return null;

        return this.zoomToLevel(Math.ceil(currentZoomLevelIndex) - levels);
    }

    /**
     * Zooms in the timeline to the {@link #config-maxZoomLevel} according to the array of zoom levels.
     *
     * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
     * @category Zoom
     */
    zoomInFull() {
        return this.zoomToLevel(this.maxZoomLevel);
    }

    /**
     * Zooms out the timeline to the {@link #config-minZoomLevel} according to the array of zoom levels.
     *
     * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
     * @category Zoom
     */
    zoomOutFull() {
        return this.zoomToLevel(this.minZoomLevel);
    }

    /*
     * Adjusts the timespan of the panel to the new zoom level. Used for performance reasons,
     * as rendering too many columns takes noticeable amount of time so their number is limited.
     * @category Zoom
     * @private
     */
    calculateOptimalDateRange(centerDate, panelSize, viewPreset, userProvidedSpan) {
        // this line allows us to always use the `calculateOptimalDateRange` method when calculating date range for zooming
        // (even in case when user has provided own interval)
        // other methods may override/hook into `calculateOptimalDateRange` to insert own processing
        // (infinite scrolling feature does)
        if (userProvidedSpan) return userProvidedSpan;

        const
            me               = this,
            { timeAxis }     = me,
            { bottomHeader } = viewPreset,
            tickWidth        = me.isHorizontal ? viewPreset.tickWidth : viewPreset.tickHeight;

        if (me.zoomKeepsOriginalTimespan) {
            return {
                startDate : timeAxis.startDate,
                endDate   : timeAxis.endDate
            };
        }

        const
            unit       = bottomHeader.unit,
            difference = Math.ceil(panelSize / tickWidth * bottomHeader.increment * me.visibleZoomFactor / 2),
            startDate  = DateHelper.add(centerDate, -difference, unit),
            endDate    = DateHelper.add(centerDate, difference, unit);

        return {
            startDate : timeAxis.floorDate(startDate, false, unit, bottomHeader.increment),
            endDate   : timeAxis.ceilDate(endDate, false, unit, bottomHeader.increment)
        };
    }

    onWheel(event) {
        const me = this;

        if (event.ctrlKey) {
            event.preventDefault();

            if (!me.preventScrollZoom) {
                if (event.deltaY > 0) {
                    me.zoomOut();
                }
                else if (event.deltaY < 0) {
                    me.zoomIn();
                }
                me.preventScrollZoom = true;
                me.setTimeout(() => me.preventScrollZoom = false, 30);
            }
        }
    }

    /**
     * Changes the time axis timespan to the supplied start and end dates.
     * @param {Date} startDate The new start date
     * @param {Date} endDate The new end date. If not supplied, the {@link Scheduler.preset.ViewPreset#field-defaultSpan} property of the current view preset will be used to calculate the new end date.
     */
    setTimeSpan(startDate, endDate) {
        this.timeAxis.setTimeSpan(startDate, endDate);
    }

    /**
     * Moves the time axis by the passed amount and unit.
     *
     * NOTE: If using a filtered time axis, see {@link Scheduler.data.TimeAxis#function-shift} for more information.
     *
     * @param {Number} amount The number of units to jump
     * @param {String} [unit] The unit (Day, Week etc)
     */
    shift(amount, unit) {
        this.timeAxis.shift(amount, unit);
    }

    /**
     * Moves the time axis forward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement`
     * config of the current view preset.
     *
     * NOTE: If using a filtered time axis, see {@link Scheduler.data.TimeAxis#function-shiftNext} for more information.
     *
     * @param {Number} [amount] The number of units to jump forward
     */
    shiftNext(amount) {
        this.timeAxis.shiftNext(amount);
    }

    /**
     * Moves the time axis backward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement` config of the current view preset.
     *
     * NOTE: If using a filtered time axis, see {@link Scheduler.data.TimeAxis#function-shiftPrevious} for more information.
     *
     * @param {Number} [amount] The number of units to jump backward
     */
    shiftPrevious(amount) {
        this.timeAxis.shiftPrevious(amount);
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

/**
 * @module Scheduler/view/mixin/TimelineEventRendering
 */

/**
 * Functions to handle event rendering (EventModel -> dom elements).
 *
 * @mixin
 */
var TimelineEventRendering = Target => class TimelineEventRendering extends (Target || Base) {
    //region Default config

    static get defaultConfig() {
        return {
            /**
             * Controls how much space to leave between stacked event bars in px
             * @config {Number}
             * @default
             * @category Scheduled events
             */
            barMargin : 10,

            resourceMargin : null,

            /**
             * True to size events based on the rowHeight and barMargin settings. Set this to false if you want to
             * control height and top properties via CSS instead.
             * @config {Boolean}
             * @default
             * @category Scheduled events
             */
            managedEventSizing : true,

            /**
             * The CSS class added to an event/assignment when it is newly created
             * in the UI and unsynced with the server.
             * @config {String}
             * @default
             * @private
             * @category CSS
             */
            generatedIdCls : 'b-sch-dirty-new',

            /**
             * The CSS class added to an event when it has unsaved modifications
             * @config {String}
             * @default
             * @private
             * @category CSS
             */
            dirtyCls : 'b-sch-dirty',

            /**
             * The CSS class added to an event when it is currently committing changes
             * @config {String}
             * @default
             * @private
             * @category CSS
             */
            committingCls : 'b-sch-committing',

            /**
             * The CSS class added to an event/assignment when it ends outside of the visible time range.
             * @config {String}
             * @default
             * @private
             * @category CSS
             */
            endsOutsideViewCls : 'b-sch-event-endsoutside',

            /**
             * The CSS class added to an event/assignment when it starts outside of the visible time range.
             * @config {String}
             * @default
             * @private
             * @category CSS
             */
            startsOutsideViewCls : 'b-sch-event-startsoutside',

            /**
             * The CSS class added to an event/assignment when it is not draggable.
             * @config {String}
             * @default
             * @private
             * @category CSS
             */
            fixedEventCls : 'b-sch-event-fixed',

            /**
             * Event style used by default. Events and resources can specify their own style, with priority order being:
             * Event -> Resource -> Scheduler default. Determines the appearance of the event by assigning a CSS class
             * to it. Available styles are:
             * * plain (default), flat look
             * * border, has border in darker shade of events color
             * * colored, has colored text and wide left border in same color
             * * hollow, only border + text until hovered
             * * line, as a line with the text below it
             * * dashed, as a dashed line with the text below it
             * * minimal, as a thin line with small text above it
             *
             * Specify `null` to not apply a default style and take control using custom CSS (easily overridden basic
             * styling will be used).
             *
             * @config {String}
             * @default
             * @category Scheduled events
             */
            eventStyle : 'plain',

            /**
             * Event color used by default. Events and resources can specify their own color, with priority order being:
             * Event -> Resource -> Scheduler default. Available colors are:
             * * red
             * * pink
             * * purple
             * * violet
             * * indigo
             * * blue
             * * cyan
             * * teal
             * * green
             * * lime
             * * yellow
             * * orange
             * * gray
             *
             * Specify `null` to not apply a default color and take control using custom CSS (an easily overridden color
             * will be used to make sure events are still visible).
             *
             * @config {String}
             * @default
             * @category Scheduled events
             */
            eventColor : 'green'
        };
    }

    //endregion

    //region Settings

    /**
     * Control how much space to leave between stacked event bars in px. Value will be constrained by half the row height.
     * @property {Number}
     * @category Scheduled events
     */
    get barMargin() {
        return this._barMargin;
    }

    set barMargin(margin) {
        const me = this;

        ObjectHelper.assertNumber(margin, 'barMargin');

        // bar margin should not exceed half of the row height
        if (me.isHorizontal && me.rowHeight) {
            margin = Math.min(Math.ceil(me.rowHeight / 2), margin);
        }

        if (me._barMargin !== margin) {
            me._barMargin = margin;
            if (me.rendered) {
                me.currentOrientation.onBeforeRowHeightChange();
                me.refreshWithTransition();
            }
        }
    }

    // Documented in SchedulerEventRendering to not show up in Gantt docs
    get resourceMargin() {
        return this._resourceMargin == null ? this.barMargin : this._resourceMargin;
    }

    set resourceMargin(margin) {
        const me = this;

        ObjectHelper.assertNumber(margin, 'resourceMargin');

        // bar margin should not exceed half of the row height
        if (me.isHorizontal && me.rowHeight) {
            margin = Math.min(Math.ceil(me.rowHeight / 2), margin);
        }

        if (me._resourceMargin !== margin) {
            me._resourceMargin = margin;
            if (me.rendered) {
                me.currentOrientation.onBeforeRowHeightChange();
                me.refreshWithTransition();
            }
        }
    }

    // /**
    //  * Distance between bars when using eventLayout pack
    //  * @property {Number}
    //  */
    // get barPackMargin() {
    //     return this._barPackMargin;
    // }
    //
    // set barPackMargin(margin) {
    //     if (this._barPackMargin !== margin) {
    //         this._barPackMargin = margin;
    //         this.refresh();
    //     }
    // }

    /**
     * Get/set the widths of all the time columns to the supplied value. Only applicable when {@link Scheduler.view.TimelineBase#config-forceFit} is set to false.
     * Deprecated in favor of {@link #property-tickSize}
     * @property {Number}
     * @deprecated 2.2
     * @category Scheduled events
     */
    set tickWidth(width) {
        this.tickSize = width;
    }

    get tickWidth() {
        return this.tickSize;
    }

    /**
     * Get/set the width/height (depending on mode) of all the time columns to the supplied value. Only applicable when
     * {@link Scheduler.view.TimelineBase#config-forceFit} is set to false.
     * @property {Number}
     * @category Scheduled events
     */
    set tickSize(width) {
        ObjectHelper.assertNumber(width, 'tickSize');

        this.timeAxisViewModel.tickSize = width;
    }

    get tickSize() {
        return this.timeAxisViewModel.tickSize;
    }

    /**
     * Predefined event colors, useful in combos etc.
     * @type {String}
     * @category Scheduled events
     */
    static get eventColors() {
        return ['red', 'pink', 'purple', 'violet', 'indigo', 'blue', 'cyan', 'teal', 'green', 'lime', 'yellow', 'orange', 'gray'];
    }

    /**
     * Predefined event styles , useful in combos etc.
     * @type {String}
     * @category Scheduled events
     */
    static get eventStyles() {
        return ['plain', 'border', 'hollow', 'colored', 'line', 'dashed', 'minimal'];
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

/**
 * @module Scheduler/view/mixin/TimelineScroll
 */

/**
 * Functions for scrolling to events, dates etc.
 *
 * @mixin
 */
var TimelineScroll = Target => class TimelineScroll extends (Target || Base) {
    //region Scroll to date

    /**
     * Scrolls the time line "tick" encapsulating the passed `Date` into view according to the passed options.
     * @param {Date} date The date to which to scroll the time line
     * @param {Object} [options] How to scroll.
     * @param {String} [options.block=nearest] How far to scroll the tick: `start/end/center/nearest`.
     * @param {Number} [options.edgeOffset=20] edgeOffset A margin *in pixels* around the tick to bring into view.
     * @param {Boolean|Number} [options.animate] Set to `true` to animate the scroll, or the number of milliseconds to animate over.
     * @returns {Promise} A Promise which resolves when the scrolling is complete.
     */
    scrollToDate(date, options = {}) {
        const
            me               = this,
            scroller         = me.timeAxisSubGrid.scrollable,
            scrollerViewport = scroller.viewport,
            localCoordinate  = me.getCoordinateFromDate(date, true),
            target           = me.isHorizontal
                ? new Rectangle(me.getCoordinateFromDate(date, false), scrollerViewport.y, me.timeAxisViewModel.tickSize, scrollerViewport.height)
                : new Rectangle(scrollerViewport.x, me.getCoordinateFromDate(date, false), scrollerViewport.width, me.timeAxisViewModel.tickSize);

        return me.scrollToCoordinate(localCoordinate, target, date, options);
    }

    /**
     * Scrolls to current time.
     * @param {Object} [options] How to scroll.
     * @param {String} [options.block=nearest] How far to scroll the tick: `start/end/center/nearest`.
     * @param {Number} [options.edgeOffset=20] edgeOffset A margin *in pixels* around the tick to bring into view.
     * @param {Boolean|Number} [options.animate] Set to `true` to animate the scroll, or the number of milliseconds to animate over.
     * @returns {Promise} A Promise which resolves when the scrolling is complete.
     */
    scrollToNow(options = {}) {
        return this.scrollToDate(new Date(), options);
    }

    /**
     * Used by {@link #function-scrollToDate} to scroll to correct coordinate.
     * @param {Number} localCoordinate Coordinate to scroll to
     * @param {Date} date Date to scroll to, used for reconfiguring the time axis
     * @param {Object} [options] How to scroll.
     * @param {String} [options.block=nearest] How far to scroll the tick: `start/end/center/nearest`.
     * @param {Number} [options.edgeOffset] edgeOffset A margin *in pixels* around the tick to bring into view.
     * @param {Boolean|Number} [options.animate] Set to `true` to animate the scroll, or the number of milliseconds to animate over.
     * @returns {Promise} A Promise which resolves when the scrolling is complete.
     * @private
     */
    scrollToCoordinate(localCoordinate, target, date, options = {}) {
        const me = this;

        // Not currently have this date in a timeaxis. Ignore negative scroll in weekview, it can be just 'filtered' with
        // startTime/endTime config
        if (localCoordinate < 0) {
            // adjust the timeaxis first
            const halfVisibleSpan = (me.timeAxis.endDate - me.timeAxis.startDate) / 2,
                newStartDate    = new Date(date.getTime() - halfVisibleSpan),
                newEndDate      = new Date(date.getTime() + halfVisibleSpan);

            // We're trying to reconfigure time span to current dates, which means we are as close to center as it
            // could be. Do nothing then.
            // covered by 1102_panel_api
            if (newStartDate - me.startDate !== 0 && newEndDate - me.endDate !== 0) {
                me.setTimeSpan(newStartDate, newEndDate);

                return me.scrollToDate(date, options);
            }

            return;
        }

        return me.timeAxisSubGrid.scrollable.scrollIntoView(target, options);
    }

    //endregion

    //region Relative scrolling
    // These methods are important to users because although they are mixed into the top level Grid/Scheduler,
    // for X scrolling the explicitly target the SubGrid that holds the scheduler.

    /**
     * Get/set horizontal scroll. Applies to the SubGrid that holds the scheduler
     * @property {Number}
     * @category Scrolling
     */
    set scrollLeft(left) {
        this.timeAxisSubGrid.scrollable.x = left;
    }

    /**
     * Get/set vertical scroll
     * @property {Number}
     * @category Scrolling
     */
    set scrollTop(top) {
        this.scrollable.y = top;
    }

    get scrollLeft() {
        return this.timeAxisSubGrid.scrollable.x;
    }

    get scrollTop() {
        return this.scrollable.y;
    }

    /**
     * Horizontal scrolling. Applies to the SubGrid that holds the scheduler
     * @param {Number} x
     * @param {Object|Boolean} [options] How to scroll. May be passed as `true` to animate.
     * @param {Object|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
     * or the number of milliseconds to animate over, or an animation config object.
     * @param {Number} [options.animate.duration] The number of milliseconds to animate over.
     * @param {String} [options.animate.easing] The name of an easing function.
     * @returns {Promise} A promise which is resolved when the scrolling has finished.
     */
    scrollHorizontallyTo(coordinate, options = true) {
        return this.timeAxisSubGrid.scrollable.scrollTo(coordinate, null, options);
    }

    /**
     * Vertical scrolling
     * @param {Number} y
     * @param {Object|Boolean} [options] How to scroll. May be passed as `true` to animate.
     * @param {Object|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
     * or the number of milliseconds to animate over, or an animation config object.
     * @param {Number} [options.animate.duration] The number of milliseconds to animate over.
     * @param {String} [options.animate.easing] The name of an easing function.
     * @returns {Promise} A promise which is resolved when the scrolling has finished.
     */
    scrollVerticallyTo(y, options = true) {
        return this.scrollable.scrollTo(null, y, options);
    }

    /**
     * Scrolls the subgrid that contains the scheduler
     * @param {Number} x
     * @param {Object|Boolean} [options] How to scroll. May be passed as `true` to animate.
     * @param {Object|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
     * or the number of milliseconds to animate over, or an animation config object.
     * @param {Number} [options.animate.duration] The number of milliseconds to animate over.
     * @param {String} [options.animate.easing] The name of an easing function.
     * @returns {Promise} A promise which is resolved when the scrolling has finished.
     */
    scrollTo(x, options = true) {
        return this.timeAxisSubGrid.scrollable.scrollTo(x, null, options);
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

const
    timeAxisColumnConfigs = [
        'viewPreset',
        'eventBarTextField',
        'eventRenderer',
        'eventRendererThisObj',
        'eventBodyTemplate'
    ],
    exitTransition = {
        fn                : 'exitTransition',
        delay             : 0,
        cancelOutstanding : true
    };

/**
 * @module Scheduler/view/TimelineBase
 */

/**
 * Abstract base class used by timeline based components such as Scheduler and Gantt. Based on Grid, supplies a "locked"
 * region for columns and a "normal" for rendering of events etc.
 * @abstract
 *
 * @mixes Scheduler/view/mixin/TimelineDateMapper
 * @mixes Scheduler/view/mixin/TimelineDomEvents
 * @mixes Scheduler/view/mixin/TimelineEventRendering
 * @mixes Scheduler/view/mixin/TimelineScroll
 * @mixes Scheduler/view/mixin/TimelineViewPresets
 * @mixes Scheduler/view/mixin/TimelineZoomable
 *
 * @extends Grid/view/Grid
 */
class TimelineBase extends base(GridBase).mixes(
    TimelineDateMapper,
    TimelineDomEvents,
    TimelineEventRendering,
    TimelineScroll,
    TimelineViewPresets,
    TimelineZoomable
) {
    //region Config

    static get $name() {
        return 'TimelineBase';
    }

    static get defaultConfig() {
        return {
            /**
             * A valid JS day index between 0-6 (0: Sunday, 1: Monday etc.) to be considered the start day of the week.
             * When omitted, the week start day is retrieved from the active locale class.
             * @config {Number} weekStartDay
             * @category Time axis
             */

            /**
             * An object with format `{ fromDay, toDay, fromHour, toHour }` that describes the working days and hours.
             * This object will be used to populate TimeAxis {@link Scheduler.data.TimeAxis#config-include} property.
             *
             * Using it results in a non-continuous time axis. Any ticks not covered by the working days and hours will
             * be excluded. Events within larger ticks (for example if using week as the unit for ticks) will be
             * stretched to fill the gap otherwise left by the non working hours.
             *
             * As with end dates, `toDay` and `toHour` are exclusive. Thus `toDay : 6` means that day 6 (saturday) will
             * not be included.
             *
             *
             * **NOTE:** When this feature is enabled {@link Scheduler.view.mixin.TimelineZoomable Zooming feature} is
             * not supported. It's recommended to disable zooming controls:
             *
             * ```javascript
             * new Scheduler({
             *     zoomOnMouseWheel          : false,
             *     zoomOnTimeAxisDoubleClick : false,
             *     ...
             * });
             * ```
             *
             * @config {Object}
             * @category Time axis
             */
            workingTime : null,

            /**
             * The backing store providing the input date data for the timeline panel. Created automatically if none
             * supplied.
             * @config {Scheduler.data.TimeAxis}
             * @category Time axis
             */
            timeAxis : null,

            /**
             * The backing view model for the visual representation of the time axis.
             * Either a real instance or a simple config object.
             * @private
             * @config {Scheduler.view.model.TimeAxisViewModel|Object}
             * @category Time axis
             */
            timeAxisViewModel : null,

            /**
             * You can set this option to `false` to make the timeline panel start and end on the exact provided
             * {@link #config-startDate}/{@link #config-endDate} w/o adjusting them.
             * @config {Boolean}
             * @default
             * @category Time axis
             */
            autoAdjustTimeAxis : true,

            /**
             * The start date of the timeline. If omitted, and a TimeAxis has been set, the start date of the provided
             * {@link Scheduler.data.TimeAxis} will be used. If no TimeAxis has been configured, it'll use the start/end
             * dates of the loaded event dataset. If no date information exists in the event data set, it defaults to
             * the current date and time.
             *
             * If a string is supplied, it will be parsed using
             * {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat}
             *
             * **Note:** If you need to set start and end date at the same time, use
             * {@link Scheduler.view.mixin.TimelineZoomable#function-setTimeSpan} method.
             * @config {Date|String}
             * @category Common
             */
            startDate : null,

            /**
             * The end date of the timeline. If omitted, it will be calculated based on the {@link #config-startDate}
             * setting and the 'defaultSpan' property of the current
             * {@link Scheduler.view.mixin.TimelineViewPresets#config-viewPreset}.
             *
             * If a string is supplied, it will be parsed using
             * {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat}
             *
             * **Note:** If you need to set start and end date at the same time, use
             * {@link Scheduler.view.mixin.TimelineZoomable#function-setTimeSpan} method.
             * @config {Date|String}
             * @category Common
             */
            endDate : null,

            /**
             * true to snap to resolution increment while interacting with scheduled events.
             * @config {Boolean}
             * @default
             * @category Scheduled events
             */
            snap : false,

            /**
             * Affects drag drop and resizing of events when {@link #config-snap} is enabled. If set to `true`, dates
             * will be snapped relative to event start. e.g. for a zoom level with timeResolution = { unit: "s",
             * increment: "20" }, an event that starts at 10:00:03 and is dragged would snap its start date to 10:00:23,
             * 10:00:43 etc. When set to `false`, dates will be snapped relative to the timeAxis startDate (tick start)
             * - 10:00:03, 10:00:20, 10:00:40 etc.
             * @config {Boolean}
             * @default
             * @category Scheduled events
             */
            snapRelativeToEventStartDate : false,

            /**
             * Set to true to force the time columns to fit to the available horizontal space.
             * @config {Boolean}
             * @default
             * @category Time axis
             */
            forceFit : false,

            /**
             * CSS class to add to rendered events
             * @config {String}
             * @category CSS
             * @private
             */
            eventCls : null,

            /**
             * Returns dates that will constrain resize and drag operations. The method will be called with the
             * Resource, and for operations on existing events - the event. For drag create operation, the mousedown
             * date will be passed as the second parameter
             * @return {Object} Constraining object containing `start` and `end` constraints. Omitting either
             * will mean that end is not constrained. So you can prevent a resize or move from moving *before*
             * a certain time while not constraininhg the end date.
             * @return {Date} [return.start] Start date
             * @return {Date} [return.end] End date
             * @config {Function}
             * @category Scheduled events
             */
            getDateConstraints : null,

            /**
             * CSS class to add to cells in the timeaxis column
             * @config {String}
             * @category CSS
             * @private
             */
            timeCellCls : null,

            timeCellSelector : null,

            scheduledEventName : null,

            /**
             * Create event on double click if scheduler is not in read only mode.
             * Set to false to turn creating off.
             * @config {Boolean}
             * @default
             * @category Scheduled events
             */
            createEventOnDblClick : true,

            //dblClickTime : 200,

            /**
             * A CSS class to apply to each event in the view on mouseover.
             * @config {String}
             * @category CSS
             * @private
             */
            overScheduledEventClass : null,

            // allow the panel to prevent adding the hover CSS class in some cases - during drag drop operations
            preventOverCls : false,

            // The last hovered over event bar HTML node
            hoveredEventNode : null,

            // This setting is set to true by features that need it
            useBackgroundCanvas : false,

            /**
             * Set to `false` if you don't want event bar DOM updates to animate. Animations are disabled in IE11 by default.
             * @config {Boolean}
             * @default true
             * @category Scheduled events
             */
            enableEventAnimations : !BrowserHelper.isIE11,

            disableGridRowModelWarning : true,

            // does not look good with locked columns and also interferes with event animations
            animateRemovingRows : false,

            /**
             * Partners this Timeline panel with another Timeline in order to sync their region sizes (sub-grids like locked, normal will get the same width),
             * start and end dates, view preset, zoom level and scrolling position. All these values will be synced with the timeline defined as the `partner`.
             * @config {Scheduler.view.TimelineBase}
             * @category Time axis
             */
            partner : null,

            schedulerRegion : 'normal',

            transitionDuration : 200,
            // internal timer id reference
            animationTimeout   : null,

            /**
             * How to handle milestones during event layout. Options are:
             * * default - Milestones do not affect event layout
             * * estimate - Milestone width is estimated by multiplying text length with Scheduler#milestoneCharWidth
             * * data - Milestone width is determined by checking EventModel#milestoneWidth
             * * measure - Milestone width is determined by measuring label width
             * Please note that currently text width is always determined using EventModel#name.
             * Also note that only 'default' is supported by eventStyles line, dashed and minimal.
             * @config {String}
             * @default
             * @category Scheduled events
             */
            milestoneLayoutMode : 'default',

            /**
             * Region to which columns are added when they have none specified
             * @config {string}
             * @default
             * @category Misc
             */
            defaultRegion : 'locked'
        };
    }

    //endregion

    //region Init

    construct(config = {}) {
        const me = this,
            region = config.schedulerRegion || 'normal', // Cannot rely on default value, too early
            { subGridConfigs = {} } = config;

        config.subGridConfigs = subGridConfigs;

        subGridConfigs[region] = subGridConfigs[region] || {};
        subGridConfigs[region].headerClass = Header$1;

        // If user have not specified a width or flex for scheduler region, default to flex=1
        if (!('flex' in subGridConfigs[region] || 'width' in subGridConfigs[region])) {
            subGridConfigs[region].flex = 1;
        }

        // Zooming falls back on config.startDate/endDate, make sure they are dates
        if (config.startDate) {
            config.startDate = DateHelper.parse(config.startDate);
        }
        if (config.endDate) {
            config.endDate = DateHelper.parse(config.endDate);
        }

        super.construct(config);

        // Buffer resize, since resize does full redraw it is costly
        me.onSchedulerViewportResize = me.throttle(me.onSchedulerViewportResize, 250);

        me.initDomEvents();

        me.currentOrientation.init();

        me.rowManager.on('refresh', () => {
            me.forceLayout = false;
        });
    }

    doDestroy() {
        const me = this,
            { currentOrientation } = this;

        if (currentOrientation) {
            currentOrientation.destroy();
        }

        // Break links between this TimeLine and any partners.
        if (me.partneredWith) {
            me.partneredWith.forEach(p => {
                me.removePartner(p);
            });
            me.partneredWith.destroy();
        }
        super.doDestroy();
    }

    startConfigure(config) {
        super.startConfigure(config);

        // partner needs to be initialized first so that the various shared
        // configs are assigned first before we default them in.
        this._thisIsAUsedExpression(this.partner);
    }

    onPaint({ firstPaint }) {
        // Upon first paint we need to pass the forceUpdate flag in case we are sharing the TimAxisViewModel
        // with another Timeline which will already have done this.
        if (firstPaint) {
            // subGrid in IE11 doesn't have height at this point, but container element does so we take it from there
            // TODO: make flex element inherit height from parent (min-height: 100% doesn't work)
            const
                { timeAxisSubGrid } = this,
                availableSpace      = this.isVertical ? (BrowserHelper.isIE11 ? timeAxisSubGrid.element.parentElement.offsetHeight : timeAxisSubGrid.height) : timeAxisSubGrid.width;

            this.timeAxisViewModel.update(availableSpace, false, true);
        }

        super.onPaint([...arguments]);
    }

    initSubGrids() {
        super.initSubGrids();

        const
            me              = this,
            timeAxisSubGrid = me.timeAxisSubGrid = me.subGrids[me.timeAxisColumn.region];

        // Scheduler SubGrid doesn't accept external columns moving in
        timeAxisSubGrid.sealedColumns = true;

        timeAxisSubGrid.on({
            resize  : me.onTimeAxisSubGridResize,
            thisObj : me
        });
    }

    onSchedulerHorizontalScroll(subGrid, scrollLeft) {
        // rerender cells in scheduler column on horizontal scroll to display events in view
        this.currentOrientation.updateFromHorizontalScroll(scrollLeft);

        super.onSchedulerHorizontalScroll(subGrid, scrollLeft);
    }

    /**
     * Overrides initScroll from Grid, listens for horizontal scroll to do virtual event rendering
     * @private
     */
    initScroll() {
        let me         = this,
            frameCount = 0;

        super.initScroll();

        // Fixes scroll freezing bug on iPad by putting scheduler scroller in its own layer
        if (BrowserHelper.isMobileSafari) {
            me.scrollable.element.style.transform = 'translate3d(0, 0, 0)';
        }
        
        me.on('horizontalscroll', ({ subGrid, scrollLeft }) => {
            if (me.isPainted && subGrid === me.timeAxisSubGrid && !me.isDestroying) {
                me.onSchedulerHorizontalScroll(subGrid, scrollLeft);
            }
            frameCount++;
        });

        if (me.testPerformance === 'horizontal') {
            me.setTimeout(() => {
                let start       = performance.now(), // eslint-disable-line no-undef
                    scrollSpeed = 5,
                    direction   = 1;

                let scrollInterval = me.setInterval(() => {
                    scrollSpeed = scrollSpeed + 5;

                    me.scrollLeft += (10 + Math.floor(scrollSpeed)) * direction;

                    if (direction === 1 && me.scrollLeft > 5500) {
                        direction = -1;
                        scrollSpeed = 5;
                    }

                    if (direction === -1 && me.scrollLeft <= 0) {
                        let done    = performance.now(), // eslint-disable-line no-undef
                            elapsed = done - start;

                        let timePerFrame = elapsed / frameCount,
                            fps          = 1000 / timePerFrame;

                        fps = Math.round(fps * 10) / 10;

                        clearInterval(scrollInterval);

                        console.log(me.eventPositionMode, me.eventScrollMode, fps + 'fps');
                    }
                }, 0);
            }, 500);
        }
    }

    //endregion

    //region Config getters/setters

    /**
     * Returns `true` if any of the events/tasks or feature injected elements (such as ResourceTimeRanges) are within
     * the {@link #config-timeAxis}
     * @property {Boolean}
     * @readonly
     */
    get hasVisibleEvents() {
        return !this.noFeatureElementsInAxis() || this.eventStore.storage.values.some(t => this.timeAxis.isTimeSpanInAxis(t));
    }

    // Template function to be chained in features to determine if any elements are in time axis (needed since we cannot
    // currently chain getters). Negated to not break chain. First feature that has elements visible returns false,
    // which prevents other features from being queried.
    noFeatureElementsInAxis() { }

    // Private getter used to piece togheter event names such as beforeEventDrag / beforeTaskDrag. Could also be used
    // in templates.
    get capitalizedEventName() {
        if (!this._capitalizedEventName) {
            this._capitalizedEventName = StringHelper.capitalizeFirstLetter(this.scheduledEventName);
        }

        return this._capitalizedEventName;
    }

    set partner(partner) {
        const me = this,
            partneredWith = me.partneredWith || (me.partneredWith = new Collection());

        me._partner = partner;

        if (!partneredWith.includes(partner)) {
            // Each must know about the other so that they can sync others upon region resize
            partneredWith.add(partner);

            (partner.partneredWith || (partner.partneredWith = new Collection())).add(me);

            partner.on({
                presetchange : 'onPartnerPresetChange',
                thisObj      : me
            });
            me.on({
                presetchange : 'onPartnerPresetChange',
                thisObj      : partner
            });

            me.setConfig({
                viewPreset        : partner.viewPreset,
                timeAxis          : partner.timeAxis,
                timeAxisViewModel : partner.timeAxisViewModel
            });

            // When initScroll comes round, make sure it syncs with the partner
            me.initScroll = FunctionHelper.createSequence(me.initScroll, () => {
                me.scrollable.addPartner(partner.scrollable, 'x');
            }, me);
        }
    }

    removePartner(partner) {
        const me = this,
            partneredWith = me.partneredWith;

        if (partneredWith && partneredWith.includes(partner)) {
            partneredWith.remove(partner);
            partner.partneredWith.remove(me);
            partner.scrollable.removePartner(me.scrollable);
            partner.un({
                presetchange : 'onPartnerPresetChange',
                thisObj      : me
            });
            me.un({
                presetchange : 'onPartnerPresetChange',
                thisObj      : partner
            });
        }
    }

    onPartnerPresetChange({ preset, startDate, endDate, centerDate }) {
        if (!this._viewPresetChanging && this.viewPreset !== preset) {
            // Passing more params directly to make zoom behave identically. See #8764
            this.setViewPreset(preset, startDate, endDate, false, { centerDate });
        }
    }

    get partner() {
        return this._partner;
    }

    get timeAxisColumn() {
        return this.columns && this._timeAxisColumn;
    }

    get columns() {
        // Maintainer. If we do not implement a getter to go along with our setter, this
        // property becomes unreadable at this class level.
        return super.columns;
    }

    set columns(columns) {
        const me = this;

        let timeAxisColumnIndex, timeAxisColumnConfig, timeAxisColumn, value;

        // No columns means destroy
        if (columns) {
            const isArray = Array.isArray(columns);

            let cols = columns;

            if (!isArray) {
                cols = columns.data;
            }

            timeAxisColumnIndex = cols && cols.length;

            cols.forEach((col, index) => {
                if (col.type === 'timeAxis') {
                    timeAxisColumnIndex = index;
                    timeAxisColumnConfig = col;
                }
            });

            // TODO : This is scheduler specific, override `set columns` instead
            // No additional columns allowed in vertical mode, but store the specified set in case we toggle mode later
            if (me.isVertical) {
                me._horizontalColumns = columns;

                cols = [
                    {
                        type     : 'verticalTimeAxis',
                        locked   : true,
                        timeline : me
                    },
                    // Make space for a regular TimeAxisColumn after the VerticalTimeAxisColumn
                    cols[timeAxisColumnIndex]
                ];

                timeAxisColumnIndex = 1;
            }
            else {
                // We're going to mutate this array which we do not own, so copy it first.
                cols = cols.slice();
            }

            // Fix up the timeAxisColumn config in place
            timeAxisColumnConfig = cols[timeAxisColumnIndex] = Object.assign({
                type     : 'timeAxis',
                locked   : false,
                timeline : me,
                cellCls  : me.timeCellCls,
                mode     : me.mode
            }, timeAxisColumnConfig);

            // Pass these configs into the timeAxisColumnConfig
            timeAxisColumnConfigs.forEach(configName => {
                value = me[configName];
                if (value != null) {
                    timeAxisColumnConfig[configName] = value;
                }
            });

            if (isArray) {
                columns = cols;
            }
            else {
                columns.data = cols;
            }
        }

        // Invoke Grid's setter. Will create a ColumnStore which is returned by the columns setter.
        super.columns = columns;

        if (columns) {
            timeAxisColumn = me._timeAxisColumn = me.columns.getAt(timeAxisColumnIndex);

            if (me.isVertical) {
                me.verticalTimeAxisColumn = me.columns.getAt(timeAxisColumnIndex - 1);
            }

            // Set up event relaying early
            timeAxisColumn.relayAll(me);
        }
    }

    get timeView() {
        const me = this;
        // Maintainer, we need to ensure that the columns property is initialized
        // if this getter is called at configuration time before columns have been ingested.
        return me.columns && me.isVertical
            ? (me.verticalTimeAxisColumn && me.verticalTimeAxisColumn.view)
            : (me.timeAxisColumn && me.timeAxisColumn.timeAxisView);
    }

    set eventCls(eventCls) {
        const me = this;

        me._eventCls = eventCls;
        if (!me.eventSelector) {
            me.eventSelector = `.${eventCls}-wrap`;
            me.unreleasedEventSelector = `${me.eventSelector}:not(.b-sch-released)`;
        }
        if (!me.eventInnerSelector) {
            me.eventInnerSelector = '.' + eventCls;
        }
    }

    get eventCls() {
        return this._eventCls;
    }

    set timeAxisViewModel(timeAxisViewModel) {
        const me = this,
            tavmListeners = {
                update  : 'onTimeAxisViewModelUpdate',
                prio    : 100,
                thisObj : me
            };

        if (me.partner && !timeAxisViewModel) {
            return;
        }

        // Getting rid of instanceof check to allow using code from different bundles
        if (timeAxisViewModel && timeAxisViewModel.isTimeAxisViewModel) {
            timeAxisViewModel.on(tavmListeners);
        }
        else {
            timeAxisViewModel = Object.assign({
                mode      : me._mode,
                snap      : me.snap,
                forceFit  : me.forceFit,
                timeAxis  : me.timeAxis,
                listeners : tavmListeners
            }, timeAxisViewModel);

            timeAxisViewModel = new TimeAxisViewModel(timeAxisViewModel);
        }

        me._timeAxisViewModel = timeAxisViewModel;
    }

    /**
     * The internal view model, describing the visual representation of the time axis.
     * @property {Scheduler.view.model.TimeAxisViewModel}
     * @readonly
     */
    get timeAxisViewModel() {
        if (!this._timeAxisViewModel) {
            this.timeAxisViewModel = null;
        }
        return this._timeAxisViewModel;
    }

    set timeAxis(timeAxis) {
        const me = this;

        if (me.partner && !timeAxis) {
            return;
        }

        me.timeAxisDetacher && me.timeAxisDetacher();

        // Getting rid of instanceof check to allow using code from different bundles
        if (!(timeAxis && timeAxis.isTimeAxis)) {
            timeAxis = ObjectHelper.assign({
                viewPreset   : me.viewPreset,
                autoAdjust   : me.autoAdjustTimeAxis,
                mode         : 'plain',
                weekStartDay : me.weekStartDay
            }, timeAxis);

            if (me.startDate) {
                timeAxis.startDate = me.startDate;
            }
            if (me.endDate) {
                timeAxis.endDate = me.endDate;
            }

            if (me.workingTime) {
                me.applyWorkingTime(timeAxis);
            }

            timeAxis = new TimeAxis(timeAxis);
        }

        // Inform about reconfiguring the timeaxis, to allow users to react to start & end date changes
        me.timeAxisDetacher = timeAxis.on({
            thisObj : me,
            reconfigure({ config }) {
                /**
                 * Fired when the timeaxis has changed, for example by zooming or configuring a new time span.
                 * @event timeAxisChange
                 * @param {Scheduler.view.Scheduler} source - This Scheduler
                 * @param {Object} config Config object used to reconfigure the time axis.
                 * @param {Date} config.start New start date (if supplied)
                 * @param {Date} config.end New end date (if supplied)
                 */
                me.trigger('timeAxisChange', { config });
            }
        });

        me._timeAxis = timeAxis;
    }

    get timeAxis() {
        if (!this._timeAxis) {
            this.timeAxis = null;
        }
        return this._timeAxis;
    }

    /**
     * Get/set working time. Assign `null` to stop using working time. See {@link #config-workingTime} config for details.
     * @property {Object}
     */
    set workingTime(config) {
        this._workingTime = config;

        if (!this.isConfiguring) {
            this.applyWorkingTime(this.timeAxis);
        }
    }

    get workingTime() {
        return this._workingTime;
    }

    // Translates the workingTime configs into TimeAxis#include rules, applies them and then refreshes the header and
    // redraws the events
    applyWorkingTime(timeAxis) {
        const me = this,
            config = me._workingTime;

        if (config) {
            let hour = null;
            // Only use valid values
            if (config.fromHour >= 0 && config.fromHour < 24 && config.toHour > config.fromHour && config.toHour <= 24 && config.toHour - config.fromHour < 24) {
                hour = { from : config.fromHour, to : config.toHour };
            }

            let day = null;
            // Only use valid values
            if (config.fromDay >= 0 && config.fromDay < 7 && config.toDay > config.fromDay && config.toDay <= 7 && config.toDay - config.fromDay < 7) {
                day = { from : config.fromDay, to : config.toDay };
            }

            if (hour || day) {
                timeAxis.include = {
                    hour,
                    day
                };
            }
            else {
                // No valid rules, restore timeAxis
                timeAxis.include = null;
            }
        }
        else {
            // No rules, restore timeAxis
            timeAxis.include = null;
        }

        if (me.isPainted) {
            // Refreshing header, which also recalculate tickSize and header data
            me.timeAxisColumn.refreshHeader();
            // Update column lines
            if (me.features.columnLines) {
                me.features.columnLines.drawLines();
            }

            // Animate event changes
            me.refreshWithTransition();
        }
    }

    /**
     * Get/set startDate. Defaults to current date if none specified.
     *
     * **Note:** If you need to set start and end date at the same time, use {@link Scheduler.view.mixin.TimelineZoomable#function-setTimeSpan} method.
     * @property {Date}
     * @category Common
     */
    set startDate(date) {
        this.setStartDate(date);
    }

    /**
     * Sets the timeline start date.
     *
     * **Note:**
     * - If you need to set start and end date at the same time, use {@link Scheduler.view.mixin.TimelineZoomable#function-setTimeSpan} method.
     * - If keepDuration is false and new start date is greater than end date, it will throw an exception.
     *
     * @param {Date} date The new start date
     * @param {Boolean} keepDuration Pass `true` to keep the duration of the timeline ("move" the timeline),
     * `false` to change the duration ("resize" the timeline). Defaults to `true`.
     */
    setStartDate(date, keepDuration = true) {
        const
            me = this,
            ta = me._timeAxis || {},
            {
                startDate,
                endDate,
                mainUnit
            } = ta;

        if (typeof date === 'string') {
            date = DateHelper.parse(date);
        }

        if (me._timeAxis && endDate) {
            if (date) {
                let calcEndDate = endDate;

                if (keepDuration && startDate) {
                    const diff = DateHelper.diff(startDate, endDate, mainUnit, true);
                    calcEndDate = DateHelper.add(date, diff, mainUnit);
                }

                ta.setTimeSpan(date, calcEndDate);
            }
        }
        else {
            me._tempStartDate = date;
        }
    }

    get startDate() {
        const me = this;

        if (me._timeAxis) {
            return me._timeAxis.startDate;
        }

        return me._tempStartDate || new Date();
    }

    /**
     * Get/set endDate. Defaults to startDate + default span of the used ViewPreset.
     *
     * **Note:** If you need to set start and end date at the same time, use {@link Scheduler.view.mixin.TimelineZoomable#function-setTimeSpan} method.
     * @property {Date}
     * @category Common
     */
    set endDate(date) {
        this.setEndDate(date);
    }

    /**
     * Sets the timeline end date
     *
     * **Note:**
     * - If you need to set start and end date at the same time, use {@link Scheduler.view.mixin.TimelineZoomable#function-setTimeSpan} method.
     * - If keepDuration is false and new end date is less than start date, it will throw an exception.
     *
     * @param {Date} date The new end date
     * @param {Boolean} keepDuration Pass `true` to keep the duration of the timeline ("move" the timeline),
     * `false` to change the duration ("resize" the timeline). Defaults to `false`.
     */
    setEndDate(date, keepDuration = false) {
        const
            me = this,
            ta = me._timeAxis || {},
            {
                startDate,
                endDate,
                mainUnit
            } = ta;

        if (typeof date === 'string') {
            date = DateHelper.parse(date);
        }

        if (me._timeAxis && startDate) {
            if (date) {
                let calcStartDate = startDate;

                if (keepDuration && endDate) {
                    const diff = DateHelper.diff(startDate, endDate, mainUnit, true);
                    calcStartDate = DateHelper.add(date, -diff, mainUnit);
                }

                ta.setTimeSpan(calcStartDate, date);
            }
        }
        else {
            me._tempEndDate = date;
        }
    }

    get endDate() {
        const me = this;

        if (me._timeAxis) {
            return me._timeAxis.endDate;
        }

        return me._tempEndDate || DateHelper.add(me.startDate, me.viewPreset.defaultSpan, me.viewPreset.mainHeader.unit);
    }

    get features() {
        return super.features;
    }

    // add region resize by default
    set features(features) {
        features = features === true ? {} : features;

        if (!('regionResize' in features)) {
            features.regionResize = true;
        }

        super.features = features;
    }

    get eventStyle() {
        return this._eventStyle;
    }

    set eventStyle(style) {
        const me = this;

        me._eventStyle = style;

        if (me.isPainted) {
            me.refreshWithTransition();
        }
    }

    get eventColor() {
        return this._eventColor;
    }

    set eventColor(color) {
        const me = this;

        me._eventColor = color;

        if (me.isPainted) {
            me.refreshWithTransition();
        }
    }

    //endregion

    //region Event handlers

    onLocaleChange() {
        // Clear events in case they use date as part of displayed info
        //        this.currentOrientation.cache.clear();

        super.onLocaleChange();
        this.timeAxisColumn.refreshHeader();
    }

    /**
     * This is a template method called by Widget when the encapsulating Scheduler SubGrid size.
     * Width changes *might* affect the Scheduler SubGrid, and *that* will trigger its
     * handler below, if that is the case. Here, we are only interested in the height changing because the
     * encapsulating grid is what dictates the scrolling viewport height.
     * @param {HTMLElement} element
     * @param {Number} width
     * @param {Number} height
     * @param {Number} oldWidth
     * @param {Number} oldHeight
     * @private
     */
    onInternalResize(element, width, height, oldWidth, oldHeight) {
        // Cache before its updated by super call.
        const oldSchedulerBodyRect = this._bodyRectangle;

        super.onInternalResize(element, width, height, oldWidth, oldHeight);

        // The Scheduler (The Grid) dictates the viewport height.
        if (oldSchedulerBodyRect && height !== oldHeight) {
            this.onSchedulerViewportResize(oldSchedulerBodyRect.width, this.bodyContainer.offsetHeight, oldSchedulerBodyRect.width, oldSchedulerBodyRect.height);
        }
    }

    /**
     * This is an event handler triggered when the Scheduler SubGrid changes size.
     * Its height changes when content height changes, and that is not what we are
     * interested in here. If the *width* changes, that means the visible viewport
     * has changed size.
     * @param {HTMLElement} element
     * @param {Number} width
     * @param {Number} height
     * @param {Number} oldWidth
     * @param {Number} oldHeight
     * @private
     */
    onTimeAxisSubGridResize({ width, height, oldWidth, oldHeight }) {
        // The timeAxisSubGrid dictates the viewport width.
        if (this.isPainted && width !== oldWidth) {
            const schedulerBodyRect = this._bodyRectangle;

            this.onSchedulerViewportResize(width, schedulerBodyRect.height, oldWidth, schedulerBodyRect.height);
        }
    }

    // Note: This function is throttled in construct(), since it will do a full redraw per call
    onSchedulerViewportResize(width, height, oldWidth, oldHeight) {
        if (this.isPainted) {
            const
                me      = this,
                subGrid = me.timeAxisSubGrid;

            me.currentOrientation.onViewportResize(width, height, oldWidth, oldHeight);

            // Ignore resize caused by toggling vertical scrollbar visibility, since those might otherwise lead to an
            // infinite loop when the difference between on/off causes horizontal scrolling to also toggle
            if (me._lastOverflow == null || me._lastOverflow === subGrid.overflowingHorizontally) {
                // Responding by triggering a layout in the same frame seems to trigger an infinite resize
                // loop when using ResizeObserver, so push the response out into the next frame.
                me.setTimeout(() => {
                    me.timeAxisViewModel.availableSpace = me.isHorizontal ? subGrid.width : subGrid.height;
                }, 0);

                me.partneredWith && !me.isSyncingFromPartner && me.partneredWith.forEach(p => {
                    if (!p.isSyncingFromPartner) {
                        p.isSyncingFromPartner = true;
                        me.eachSubGrid(subGrid => {
                            const partnerSubGrid = p.subGrids[subGrid.region];

                            // If there is a difference, sync the partner SubGrid state
                            if (partnerSubGrid.width !== subGrid.width) {
                                if (subGrid.collapsed) {
                                    partnerSubGrid.collapse();
                                }
                                else {
                                    if (partnerSubGrid.collapsed) {
                                        partnerSubGrid.expand();
                                    }
                                    // When using flexed subgrid, make sure flex values has prio over width
                                    if (subGrid.flex) {
                                        // If flex values match, resize should be fine without changing anything
                                        if (subGrid.flex !== partnerSubGrid.flex) {
                                            partnerSubGrid.flex = subGrid.flex;
                                        }
                                    }
                                    else {
                                        partnerSubGrid.width = subGrid.width;
                                    }
                                }
                            }
                        });
                        p.isSyncingFromPartner = false;
                    }
                });
            }

            // NOTE: Moved out of the if-statement above since that prevented event from being triggered in all
            // scenarios where size has changed

            /**
             * Fired when the *scheduler* viewport (not the overall Scheduler element) changes size.
             * This happens when the grid changes height, or when the subgrid which encapsulates the
             * scheduler column changes width.
             * @event timelineViewportResize
             * @param {Core.widget.Widget} source - This Scheduler
             * @param {Number} width The new width
             * @param {Number} height The new height
             * @param {Number} oldWidth The old width
             * @param {Number} oldHeight The old height
             */
            me.trigger('timelineViewportResize', { width, height, oldWidth, oldHeight });

            me._lastOverflow = subGrid.overflowingHorizontally;
        }
    }

    onTimeAxisViewModelUpdate() {
        this.updateCanvasSize();

        if (this.isHorizontal) {
            // might also have changed total width of timeaxiscolumn, make sure scrollers are in sync
            // TODO: should this be detected by resizeobserver instead? but it is the actual column changing size and not the subgrid so might not make sense
            this.callEachSubGrid('refreshFakeScroll');
            this.refreshVirtualScrollbars();
        }

        this.currentOrientation.onTimeAxisViewModelUpdate();
    }

    //endregion

    //region Mode

    get currentOrientation() {
        throw new Error('Implement in subclass');
    }

    // Horizontal is the default, overridden in scheduler
    get isHorizontal() {
        return true;
    }

    //endregion

    //region Canvases and elements

    get backgroundCanvas() {
        return this._backgroundCanvas;
    }

    get foregroundCanvas() {
        return this._foregroundCanvas;
    }

    get svgCanvas() {
        const me = this;
        if (!me._svgCanvas) {
            const svg = me._svgCanvas = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('id', IdHelper.generateId('svg'));
            // To not be recycled by DomSync
            svg.retainElement = true;
            me.foregroundCanvas.appendChild(svg);
            me.trigger('svgCanvasCreated');
        }
        return me._svgCanvas;
    }

    /**
     * Returns the subGrid containing the time axis
     * @property {Grid.view.SubGrid}
     * @readonly
     */

    get timeAxisSubGridElement() {
        return this.timeAxisColumn && this.timeAxisColumn.subGridElement;
    }

    updateCanvasSize() {
        const me = this;

        if (me.isHorizontal) {
            if (me.backgroundCanvas) {
                me.backgroundCanvas.style.width = `${me.timeAxisViewModel.totalSize}px`;
            }

            me.foregroundCanvas.style.width = `${me.timeAxisViewModel.totalSize}px`;
        }
        else {
            if (me.backgroundCanvas) {
                me.backgroundCanvas.style.width = DomHelper.setLength(me.timeAxisColumn.width);
            }

            me.foregroundCanvas.style.width = DomHelper.setLength(me.timeAxisColumn.width);
        }
    }

    /**
     * A chainable function which Features may hook to add their own content to the timeaxis header.
     * @param {Array} configs An array of domConfigs, append to it to have the config applied to the header
     */
    getHeaderDomConfigs(configs) {}

    /**
     * A chainable function which Features may hook to add their own content to the foreground canvas
     * @param {Array} configs An array of domConfigs, append to it to have the config applied to the foreground canvas
     */
    getForegroundDomConfigs(configs) {}

    //endregion

    //region Grid overrides

    refresh(forceLayout = true, refreshMoreFn = null) {
        const me = this;

        if (me.isPainted && !me.refreshSuspended) {
            if (me.hasVisibleEvents) {
                me.refreshRows(false, forceLayout);
                if (refreshMoreFn) {
                    refreshMoreFn();
                }
            }
            // Even if there are no events in our timeline, Features
            // assume there will be a refresh event from the RowManager
            // after a refresh request so fire it here.
            else {
                me.rowManager.trigger('refresh');
            }
        }
    }

    render() {
        const me          = this,
            schedulerEl = me.timeAxisSubGridElement;

        if (me.useBackgroundCanvas) {
            me._backgroundCanvas = DomHelper.createElement({
                className   : 'b-sch-background-canvas',
                parent      : schedulerEl,
                nextSibling : schedulerEl.firstElementChild
            });
        }

        const fgCanvas = me._foregroundCanvas = DomHelper.createElement({
            className : 'b-sch-foreground-canvas',
            style     : `font-size:${(me.rowHeight - me.resourceMargin * 2)}px`,
            parent    : schedulerEl
        });

        me.timeAxisSubGrid.insertRowsBefore = fgCanvas;

        super.render(...arguments);
    }

    // TODO: refreshRows -> refresh in grid?
    refreshRows(returnToTop = false, reLayoutEvents = true) {
        const me = this;

        if (me.isConfiguring) {
            return;
        }

        me.currentOrientation.refreshRows(reLayoutEvents);

        super.refreshRows(returnToTop);
    }

    //endregion

    //region Other

    getDateConstraints() {}

    // duration = false prevents transition
    runWithTransition(fn, duration) {
        const me = this;

        // Do not attempt to enter animating state if we are not visible
        if (me.isVisible) {
            // Allow calling with true/false to keep code simpler in other places
            if (duration == null || duration === true) {
                duration = me.transitionDuration;
            }

            // Ask Grid superclass to enter the animated state if requested and enabled.
            if (duration && me.enableEventAnimations) {
                me.isAnimating = true;

                // Exit animating state in duration milliseconds.
                // Cancel any previous outstanding exit timer.
                exitTransition.delay = duration;
                me.setTimeout(exitTransition);
            }
        }

        fn();
    }

    exitTransition() {
        this.isAnimating = false;
        this.trigger('transitionend');
    }

    /**
     * Refreshes the grid with transitions enabled.
     */
    refreshWithTransition(forceLayout) {
        this.runWithTransition(() => this.refresh(forceLayout));
    }

    /**
     * Returns an object representing the visible date range, with `startDate` and `endDate` properties
     * @return {Object} The date range
     * @return {Date} return.startDate Start date
     * @return {Date} return.endDate End date
     */
    getVisibleDateRange() {
        return this.currentOrientation.getVisibleDateRange();
    }
    //endregion
}
TimelineBase._$name = 'TimelineBase';

// extends locale from grid
//const locale = Object.assign(gridLocale, {
const locale$3 = {

    SchedulerCommon : {
        // SS              : 'SS',
        // SF              : 'SF',
        // FS              : 'FS',
        // FF              : 'FF',
        // StartToStart    : 'Start-to-Start',
        // StartToEnd      : 'Start-to-End',
        // EndToStart      : 'End-to-Start',
        // EndToEnd        : 'End-to-End',
        // dependencyTypes : [
        //     'SS',
        //     'SF',
        //     'FS',
        //     'FF'
        // ],
        // dependencyTypesLong : [
        //     'Start-to-Start',
        //     'Start-to-End',
        //     'End-to-Start',
        //     'End-to-End'
        // ]
    },

    ExcelExporter : {
        'No resource assigned' : 'No resource assigned'
    },

    ResourceInfoColumn : {
        eventCountText : function(data) {
            return data + ' event' + (data !== 1 ? 's' : '');
        }
    },

    Dependencies : {
        from     : 'From',
        to       : 'To',
        valid    : 'Valid',
        invalid  : 'Invalid',
        Checking : 'Checking…'
    },

    DependencyEdit : {
        From              : 'From',
        To                : 'To',
        Type              : 'Type',
        Lag               : 'Lag',
        'Edit dependency' : 'Edit dependency',
        Save              : 'Save',
        Delete            : 'Delete',
        Cancel            : 'Cancel',
        StartToStart      : 'Start to Start',
        StartToEnd        : 'Start to End',
        EndToStart        : 'End to Start',
        EndToEnd          : 'End to End'
    },

    EventEdit : {
        Name         : 'Name',
        Resource     : 'Resource',
        Start        : 'Start',
        End          : 'End',
        Save         : 'Save',
        Delete       : 'Delete',
        Cancel       : 'Cancel',
        'Edit Event' : 'Edit event',
        Repeat       : 'Repeat'
    },

    EventDrag : {
        eventOverlapsExisting : 'Event overlaps existing event for this resource',
        noDropOutsideTimeline : 'Event may not be dropped completely outside the timeline'
    },

    Scheduler : {
        'Add event'      : 'Add event',
        'Delete event'   : 'Delete event',
        'Unassign event' : 'Unassign event'
    },

    HeaderContextMenu : {
        pickZoomLevel   : 'Zoom',
        activeDateRange : 'Date range',
        startText       : 'Start date',
        endText         : 'End date',
        todayText       : 'Today'
    },

    EventFilter : {
        filterEvents : 'Filter tasks',
        byName       : 'By name'
    },

    TimeRanges : {
        showCurrentTimeLine : 'Show current timeline'
    },

    PresetManager : {
        minuteAndHour : {
            topDateFormat : 'ddd MM/DD, hA'
        },
        hourAndDay : {
            topDateFormat : 'ddd MM/DD'
        },
        weekAndDay : {
            displayDateFormat : 'hh:mm A'
        }
    },

    RecurrenceConfirmationPopup : {
        'delete-title'              : 'You’re deleting an event',
        'delete-all-message'        : 'Do you want to delete all occurrences of this event?',
        'delete-further-message'    : 'Do you want to delete this and all future occurrences of this event, or only the selected occurrence?',
        'delete-further-btn-text'   : 'Delete All Future Events',
        'delete-only-this-btn-text' : 'Delete Only This Event',

        'update-title'              : 'You’re changing a repeating event',
        'update-all-message'        : 'Do you want to change all occurrences of this event?',
        'update-further-message'    : 'Do you want to change only this occurrence of the event, or this and all future occurrences?',
        'update-further-btn-text'   : 'All Future Events',
        'update-only-this-btn-text' : 'Only This Event',

        'Yes'    : 'Yes',
        'Cancel' : 'Cancel',

        width : 600
    },

    RecurrenceLegend : {
        ' and ' : ' and ',
        // frequency patterns
        'Daily' : 'Daily',

        // Weekly on Sunday
        // Weekly on Sun, Mon and Tue
        'Weekly on {1}' : ({ days }) => `Weekly on ${days}`,

        // Monthly on 16
        // Monthly on the last weekday
        'Monthly on {1}' : ({ days }) => `Monthly on ${days}`,

        // Yearly on 16 of January
        // Yearly on the last weekday of January and February
        'Yearly on {1} of {2}' : ({ days, months }) => `Yearly on ${days} of ${months}`,

        // Every 11 days
        'Every {0} days' : ({ interval }) => `Every ${interval} days`,

        // Every 2 weeks on Sunday
        // Every 2 weeks on Sun, Mon and Tue
        'Every {0} weeks on {1}' : ({ interval, days }) => `Every ${interval} weeks on ${days}`,

        // Every 2 months on 16
        // Every 2 months on the last weekday
        'Every {0} months on {1}' : ({ interval, days }) => `Every ${interval} months on ${days}`,

        // Every 2 years on 16 of January
        // Every 2 years on the last weekday of January and February
        'Every {0} years on {1} of {2}' : ({ interval, days, months }) => `Every ${interval} years on ${days} of ${months}`,

        // day position translations
        'position1'   : 'the first',
        'position2'   : 'the second',
        'position3'   : 'the third',
        'position4'   : 'the fourth',
        'position5'   : 'the fifth',
        'position-1'  : 'the last',
        // day options
        'day'         : 'day',
        'weekday'     : 'weekday',
        'weekend day' : 'weekend day',
        // {0} - day position info ("the last"/"the first"/...)
        // {1} - day info ("Sunday"/"Monday"/.../"day"/"weekday"/"weekend day")
        // For example:
        //  "the last Sunday"
        //  "the first weekday"
        //  "the second weekend day"
        'daysFormat'  : ({ position, days }) => `${position} ${days}`
    },

    RecurrenceEditor : {
        'Repeat event'        : 'Repeat event',
        'Cancel'              : 'Cancel',
        'Save'                : 'Save',
        'Frequency'           : 'Frequency',
        'Every'               : 'Every',
        'DAILYintervalUnit'   : 'day(s)',
        'WEEKLYintervalUnit'  : 'week(s) on:',
        'MONTHLYintervalUnit' : 'month(s)',
        'YEARLYintervalUnit'  : 'year(s) in:',
        'Each'                : 'Each',
        'On the'              : 'On the',
        'End repeat'          : 'End repeat',
        'time(s)'             : 'time(s)'
    },

    RecurrenceDaysCombo : {
        'day'         : 'day',
        'weekday'     : 'weekday',
        'weekend day' : 'weekend day'
    },

    RecurrencePositionsCombo : {
        'position1'  : 'first',
        'position2'  : 'second',
        'position3'  : 'third',
        'position4'  : 'fourth',
        'position5'  : 'fifth',
        'position-1' : 'last'
    },

    RecurrenceStopConditionCombo : {
        'Never'   : 'Never',
        'After'   : 'After',
        'On date' : 'On date'
    },

    RecurrenceFrequencyCombo : {
        'Daily'   : 'Daily',
        'Weekly'  : 'Weekly',
        'Monthly' : 'Monthly',
        'Yearly'  : 'Yearly'
    },

    RecurrenceCombo : {
        'None'      : 'None',
        'Custom...' : 'Custom...'
    },

    //region Export

    ScheduleRangeCombo : {
        completeview : 'Complete schedule',
        currentview  : 'Visible schedule',
        daterange    : 'Date range',
        completedata : 'Complete schedule (for all events)'
    },

    SchedulerExportDialog : {
        'Schedule range' : 'Schedule range',
        'Export from'    : 'From',
        'Export to'      : 'To'
    }

    //endregion
};

// cannot use Object.assign above in IE11. also dont want to have polyfill in locale
for (let i in locale$2) {
    locale$3[i] = locale$2[i];
}

LocaleManagerSingelton.registerLocale('En', { desc : 'English', locale : locale$3 });

/**
 * @module Scheduler/view/mixin/SchedulerDom
 */

/**
 * Mixin with EventModel and ResourceModel <-> HTMLElement mapping functions
 *
 * @mixin
 */
var SchedulerDom = Target => class SchedulerDom extends (Target || Base) {
    //region Get

    /**
     * Returns a single HTMLElement representing an event record assigned to a specific resource.
     * @param {Scheduler.model.AssignmentModel} assignmentRecord An assignment record
     * @return {HTMLElement} The element representing the event record
     */
    getElementFromAssignmentRecord(assignmentRecord) {
        return this.currentOrientation.getElementFromEventRecord(assignmentRecord.event, assignmentRecord.resource);
    }

    /**
     * Returns a single HTMLElement representing an event record assigned to a specific resource.
     * @param {Scheduler.model.EventModel} eventRecord An event record
     * @param {Scheduler.model.ResourceModel} resourceRecord A resource record
     * @return {HTMLElement} The element representing the event record
     */
    getElementFromEventRecord(eventRecord, resourceRecord) {
        return this.currentOrientation.getElementFromEventRecord(eventRecord, resourceRecord);
    }

    /**
     * Returns all the HTMLElements representing an event record.
     *
     * @param {Scheduler.model.EventModel} eventRecord An event record
     * @param {Scheduler.model.ResourceModel} [resourceRecord] A resource record
     *
     * @return {HTMLElement[]} The element(s) representing the event record
     */
    getElementsFromEventRecord(eventRecord, resourceRecord) {
        return this.currentOrientation.getElementsFromEventRecord(eventRecord, resourceRecord);
    }

    /**
     * Returns the event id for a DOM id
     * @private
     * @param {String} id The id of the DOM node
     * @return {String} An event record (internal) id
     */
    getEventIdFromDomNodeId(id) {
        const eventId = id.substring(this.eventPrefix.length).split('-')[0];

        // id format is "PREFIX"-eventid-resourceid[-part]
        // do not want - from other sources in it, replace with ._.
        // TODO: come up with something risk free
        return eventId && eventId.replace(/\._\./g, '-');
    }

    /**
     * Returns the event record for a DOM id
     * @param {String} id The id of the DOM node
     * @return {Scheduler.model.EventModel} The event record
     */
    getEventRecordFromDomId(id) {
        id = this.getEventIdFromDomNodeId(id);
        return this.eventStore.getById(id);
    }

    /**
     * Returns a resource id for a DOM id
     * @private
     * @param {String} id An id of an event DOM node
     * @return {String} A resource record (internal) id
     */
    getResourceIdFromDomNodeId(id) {
        const resourceId = id.substring(this.eventPrefix.length).split('-')[1];

        // id format is "PREFIX"-eventid-resourceid[-part]
        // do not want - from other sources in it, replace with ._.
        // TODO: come up with something risk free
        return resourceId && resourceId.replace(/\._\./g, '-');
    }

    /**
     * Returns a resource record for a DOM id
     * @param {String} id An id of an event DOM node
     * @return {Scheduler.model.ResourceModel} A resource record
     */
    getResourceRecordFromDomId(id) {
        id = this.getResourceIdFromDomNodeId(id);
        return this.resourceStore.getById(id);
    }

    //endregion

    //region Resolve

    /**
     * Resolves the resource based on a dom element or event. In vertical mode, if resolving from an element higher up in
     * the hierarchy than event elements, then it is required to supply an coordinates since resources are virtual
     * columns.
     * @param {HTMLElement|Event} elementOrEvent The HTML element or DOM event to resolve a resource from
     * @param {Number[]} [xy] X and Y coordinates, required in some cases in vertical mode, disregarded in horizontal
     * @return {Scheduler.model.ResourceModel} The resource corresponding to the element, or null if not found.
     */
    resolveResourceRecord(elementOrEvent, xy) {
        return this.currentOrientation.resolveRowRecord(elementOrEvent, xy);
    }

    /**
     * Returns the event record for a DOM element
     * @param {HTMLElement} element The DOM node to lookup
     * @return {Scheduler.model.EventModel} The event record
     */
    resolveEventRecord(element) {
        element = DomHelper.up(element, this.eventSelector);

        if (element) {
            if (element.dataset.eventId) {
                return this.eventStore.getById(element.dataset.eventId);
            }

            if (element.dataset.assignmentId) {
                return this.assignmentStore.getById(element.dataset.assignmentId).event;
            }
        }

        return null;
    }

    // Used by shared features to resolve an event or task
    resolveTimeSpanRecord(element) {
        return this.resolveEventRecord(element);
    }

    /**
     * Returns an assignment record for a DOM element
     * @param {HTMLElement} element The DOM node to lookup
     * @return {Scheduler.model.AssignmentModel} The assignment record
     */
    resolveAssignmentRecord(element) {
        const { assignmentStore } = this.eventStore;

        let assignment = null;

        if (assignmentStore) {
            const
                eventElement = DomHelper.up(element, this.eventSelector),
                event        = this.resolveEventRecord(eventElement),
                resource     = this.resolveResourceRecord(eventElement);

            if (event && resource) {
                assignment = assignmentStore.getAssignmentForEventAndResource(event, resource);
            }
        }

        return assignment;
    }

    //endregion

    // Decide if a record is inside a collapsed tree node, or inside a collapsed group (using grouping feature)
    isRowVisible(resourceRecord) {
        // records in collapsed groups/brances etc are removed from processedRecords
        return this.store.indexOf(resourceRecord) >= 0;
    }

    /**
     * Determines width of a milestones label. How width is determined is decided by configuring Scheduler#milestoneLayoutMode.
     * Please note that currently text width is always determined using EventModel#name.
     * @param {Scheduler.model.EventModel} eventRecord
     * @returns {Number}
     */
    getMilestoneLabelWidth(eventRecord) {
        const me = this,
            mode = me.milestoneLayoutMode;

        if (mode === 'measure') {
            const element = me.milestoneMeasureElement || (me.milestoneMeasureElement = DomHelper.createElement({
                className : 'b-sch-event-wrap b-milestone-wrap b-measure',
                children  : [{
                    className : 'b-sch-event b-milestone',
                    html      : `<label></label>`
                }],
                parent : me.foregroundCanvas
            }));

            element.firstElementChild.firstElementChild.innerHTML = eventRecord.name;

            return element.offsetWidth;
        }

        if (mode === 'estimate') {
            return Math.max(eventRecord.name.length * me.milestoneCharWidth, me.milestoneMinWidth);
        }

        if (mode === 'data') {
            return Math.max(eventRecord.milestoneWidth, me.milestoneMinWidth);
        }

        return 0;
    }

    set milestoneLayoutMode(mode) {
        const me = this;

        me._milestoneLayoutMode = mode;

        me.element.classList[mode !== 'default' ? 'add' : 'remove']('b-sch-layout-milestones');
        me.refresh();
    }

    get milestoneLayoutMode() {
        return this._milestoneLayoutMode;
    }

    set milestoneAlign(align) {
        this._milestoneAlign = align;

        this.refresh();
    }

    get milestoneAlign() {
        return this._milestoneAlign;
    }

    set milestoneCharWidth(width) {
        this._milestoneCharWidth = width;

        this.refresh();
    }

    get milestoneCharWidth() {
        return this._milestoneCharWidth;
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

/**
 * @module Scheduler/view/mixin/SchedulerDomEvents
 */

/**
 * Mixin that handles dom events (click etc) for scheduler and rendered events.
 *
 * @mixin
 */
var SchedulerDomEvents = Target => class SchedulerDomEvents extends (Target || Base) {
    //region Events

    /**
     * Triggered when user moves mouse over an empty area in the schedule.
     * @event scheduleMouseMove
     * @param {Scheduler.view.TimelineBase} source This TimelineBase
     * @param {Date} date Date at mouse position
     * @param {Date} tickStartDate The start date of the current time axis tick
     * @param {Date} tickEndDate The end date of the current time axis tick
     * @param {Grid.row.Row} row Clicked row (in horizontal mode only)
     * @param {Number} index Index of clicked resource
     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
     * @param {MouseEvent} event Browser event
     */

    /**
     * Triggered when user clicks an empty area in the schedule.
     * @event scheduleClick
     * @param {Scheduler.view.TimelineBase} source This TimelineBase
     * @param {Date} date Date at mouse position
     * @param {Date} tickStartDate The start date of the current time axis tick
     * @param {Date} tickEndDate The end date of the current time axis tick
     * @param {Grid.row.Row} row Clicked row (in horizontal mode only)
     * @param {Number} index Index of clicked resource
     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
     * @param {MouseEvent} event Browser event
     */

    /**
     * Triggered when user clicks an empty area in the schedule.
     * @event scheduleDblClick
     * @param {Scheduler.view.TimelineBase} source This TimelineBase
     * @param {Date} date Date at mouse position
     * @param {Date} tickStartDate The start date of the current time axis tick
     * @param {Date} tickEndDate The end date of the current time axis tick
     * @param {Grid.row.Row} row Double clicked row (in horizontal mode only)
     * @param {Number} index Index of double clicked resource
     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
     * @param {MouseEvent} event Browser event
     */

    /**
     * Triggered when user right clicks an empty area in the schedule.
     * @event scheduleContextMenu
     * @param {Scheduler.view.TimelineBase} source This TimelineBase
     * @param {Date} date Date at mouse position
     * @param {Date} tickStartDate The start date of the current time axis tick
     * @param {Date} tickEndDate The end date of the current time axis tick
     * @param {Grid.row.Row} row Clicked row (in horizontal mode only)
     * @param {Number} index Index of clicked resource
     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
     * @param {MouseEvent} event Browser event
     */

    /**
     * Triggered for mouse down on an event.
     * @event eventMouseDown
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.model.EventModel} eventRecord Event record
     * @param {MouseEvent} event Browser event
     */

    /**
     * Triggered for mouse up on an event.
     * @event eventMouseUp
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.model.EventModel} eventRecord Event record
     * @param {MouseEvent} event Browser event
     */

    /**
     * Triggered for click on an event.
     * @event eventClick
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.model.EventModel} eventRecord Event record
     * @param {MouseEvent} event Browser event
     */

    /**
     * Triggered for double click on an event.
     * @event eventDblClick
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.model.EventModel} eventRecord Event record
     * @param {MouseEvent} event Browser event
     */

    /**
     * Triggered for right click on an event.
     * @event eventContextMenu
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.model.EventModel} eventRecord Event record
     * @param {MouseEvent} event Browser event
     */

    /**
     * Triggered for mouse over on an event.
     * @event eventMouseOver
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.model.EventModel} eventRecord Event record
     * @param {MouseEvent} event Browser event
     */

    /**
     * Triggered for mouse out from an event.
     * @event eventMouseOut
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.model.EventModel} eventRecord Event record
     * @param {MouseEvent} event Browser event
     */

    //endregion

    //region Event handling

    getTimeSpanMouseEventParams(eventElement, event) {
        return {
            eventRecord      : this.resolveEventRecord(eventElement),
            resourceRecord   : this.resolveResourceRecord(eventElement),
            assignmentRecord : this.resolveAssignmentRecord(eventElement),
            eventElement,
            event
        };
    }

    getScheduleMouseEventParams(cellData, event) {
        const resourceRecord = this.isVertical ? this.resolveResourceRecord(event) : this.store.getById(cellData.id);

        return {
            resourceRecord
        };
    }

    /**
     * Relays keydown events as eventkeydown if we have a selected task.
     * @private
     */
    onElementKeyDown(event) {
        super.onElementKeyDown(event);

        const me = this;

        if (me.selectedEvents.length) {
            me.trigger(me.scheduledEventName + 'KeyDown', { eventRecord : me.selectedEvents });
        }
    }

    /**
     * Relays keyup events as eventkeyup if we have a selected task.
     * @private
     */
    onElementKeyUp(event) {
        super.onElementKeyUp(event);

        const me = this;

        if (me.selectedEvents.length) {
            me.trigger(me.scheduledEventName + 'KeyUp', { eventRecord : me.selectedEvents });
        }
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

/**
 * @module Scheduler/view/mixin/SchedulerDragResize
 */

/**
 * Mixin for triggering event editor on drag creation etc.
 * @private
 * @mixin
 */
var SchedulerDragResize = Target => class SchedulerDragResize extends (Target || Base) {
    construct(config) {
        const me = this;

        super.construct(config);

        if (me.hasFeature('eventDragCreate')) {
            me.on({
                dragcreateend : me.internalOnDragCreateEnd,
                thisObj       : me
            });
        }
    }

    internalOnDragCreateEnd({ newEventRecord : eventRecord, resourceRecord }) {
        const me = this;

        // If an event editor is defined and enabled, it has to manage how/if/when the event is added to the event store

        if (!me.hasFeature('eventEdit') || me.features.eventEdit.disabled) {
            const resources = resourceRecord ? [resourceRecord] : [];

            // resources **Deprecated** Use `resourceRecords` instead
            if (me.trigger('beforeEventAdd', { eventRecord, resources, resourceRecords : resources }) !== false) {
                me.onEventCreated(eventRecord);
                me.eventStore.add(eventRecord);

                eventRecord.assign(resourceRecord);
            }
        }
    }

    get eventEditor() {
        return this._eventEditor;
    }

    set eventEditor(editor) {
        this._eventEditor = editor;
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

/**
 * @module Scheduler/eventlayout/HorizontalLayout
 */

/**
 * Base class for HorizontalLayoutPack & HorizontalLayoutStack. Should not be used directly, instead specify
 * {@link Scheduler.view.mixin.SchedulerEventRendering#config-eventLayout} in Scheduler config (stack, pack or none):
 * @example
 * let scheduler = new Scheduler({
 *   eventLayout: 'stack'
 * });
 * @abstract
 * @private
 */
class HorizontalLayout extends Base {
    static get defaultConfig() {
        return {
            nbrOfBandsByResource        : {},
            bandIndexToPxConvertFn      : null,
            bandIndexToPxConvertThisObj : null
        };
    }

    clearCache(resource) {
        if (resource) {
            delete this.nbrOfBandsByResource[resource.id];
        }
        else {
            this.nbrOfBandsByResource = {};
        }
    }

    // Input:
    // 1. Resource record
    // 2. Array of Event models, or a function to call to receive such event records lazily
    getNumberOfBands(resource, resourceEventsOrFn) {
        const nbrOfBandsByResource = this.nbrOfBandsByResource;

        if (nbrOfBandsByResource.hasOwnProperty(resource.id)) {
            return nbrOfBandsByResource[resource.id];
        }

        const
            resourceEvents = typeof resourceEventsOrFn === 'function' ? resourceEventsOrFn() : resourceEventsOrFn,
            eventsData     = resourceEvents.map(event => ({
                start : event.startDate,
                end   : event.endDate,
                event : event
            }));

        return this.applyLayout(eventsData, resource);
    }

    // TODO DOC
    applyLayout(events, resource) {
        const
            rowEvents = events.slice(),
            // return a number of bands required
            newNbrBands = this.layoutEventsInBands(rowEvents);

        return this.nbrOfBandsByResource[resource.id] = newNbrBands;
    }
}
HorizontalLayout._$name = 'HorizontalLayout';

/**
 * @module Scheduler/eventlayout/HorizontalLayoutStack
 */

/**
 * Handles layout of events within a row (resource) in horizontal mode. Stacks events, increasing row height when to fit
 * all overlapping events.
 *
 * This layout is used by default in horizontal mode.
 *
 * @extends Scheduler/eventlayout/HorizontalLayout
 * @private
 */
class HorizontalLayoutStack extends HorizontalLayout {
    // Input: Array of event layout data
    layoutEventsInBands(events) {
        let verticalPosition = 0;

        do {
            let event = events[0];

            while (event) {
                // Apply band height to the event cfg
                event.top = this.bandIndexToPxConvertFn.call(
                    this.bandIndexToPxConvertThisObj || this,
                    verticalPosition,
                    event.event
                );

                // Remove it from the array and continue searching
                events.splice(events.indexOf(event), 1);

                event = this.findClosestSuccessor(event, events);
            }

            verticalPosition++;
        } while (events.length > 0);

        // Done!
        return verticalPosition;
    }

    // TODO: optimize this for better performance with many events per resource
    findClosestSuccessor(eventRenderData, events) {
        let minGap      = Infinity,
            closest,
            eventEnd    = eventRenderData.endMs,
            gap,
            isMilestone = eventRenderData.event.duration === 0,
            evt;

        for (let i = 0, l = events.length; i < l; i++) {
            evt = events[i];
            gap = evt.startMs - eventEnd;

            if (
                gap >= 0 && gap < minGap &&
                // Two milestones should not overlap
                (gap > 0 || evt.endMs - evt.startMs > 0 || !isMilestone)
            ) {
                closest = evt;
                minGap  = gap;
            }
        }

        return closest;
    }
}
HorizontalLayoutStack._$name = 'HorizontalLayoutStack';

/**
 * @module Scheduler/eventlayout/PackMixin
 */

/**
 * Mixin holding functionality shared between HorizontalLayoutPack and VerticalLayout.
 *
 * @mixin
 * @private
 */
var PackMixin = Target => class PackMixin extends (Target || Base) {

    static get defaultConfig() {
        return {
            coordProp : 'top',
            sizeProp  : 'height'
        };
    }

    // Packs the events to consume as little space as possible
    applyLayout(events, applyClusterFn) {
        const
            me = this,
            { coordProp, sizeProp } = me;

        let slot,
            firstInCluster,
            cluster,
            j;

        for (let i = 0, l = events.length; i < l; i++) {
            firstInCluster = events[i];

            slot = me.findStartSlot(events, firstInCluster);

            cluster = me.getCluster(events, i);

            if (cluster.length > 1) {
                firstInCluster[coordProp] = slot.start;
                firstInCluster[sizeProp]  = slot.end - slot.start;

                // If there are multiple slots and events in the cluster have multiple start dates, group all same-start events into first slot
                j = 1;

                while (j < (cluster.length - 1) && cluster[j + 1].start - firstInCluster.start === 0) {
                    j++;
                }

                // See if there's more than 1 slot available for this cluster, if so - first group in cluster consumes the entire first slot
                const nextSlot = me.findStartSlot(events, cluster[j]);

                if (nextSlot && nextSlot.start < 0.8) {
                    cluster.length = j;
                }
            }

            const
                clusterSize = cluster.length,
                slotSize    = (slot.end - slot.start) / clusterSize;

            // Apply fraction values
            for (j = 0; j < clusterSize; j++) {
                applyClusterFn(cluster[j], j, slot, slotSize);
            }

            i += clusterSize - 1;
        }
    }

    findStartSlot(events, event) {
        const
            { sizeProp, coordProp } = this,
            priorOverlappers = this.getPriorOverlappingEvents(events, event);

        let i;

        if (priorOverlappers.length === 0) {
            return {
                start : 0,
                end   : 1
            };
        }

        for (i = 0; i < priorOverlappers.length; i++) {
            if (i === 0 && priorOverlappers[0][coordProp] > 0) {
                return {
                    start : 0,
                    end   : priorOverlappers[0][coordProp]
                };
            }
            else if (priorOverlappers[i][coordProp] + priorOverlappers[i][sizeProp] < (i < priorOverlappers.length - 1 ? priorOverlappers[i + 1][coordProp] : 1)) {
                return {
                    start : priorOverlappers[i][coordProp] + priorOverlappers[i][sizeProp],
                    end   : i < priorOverlappers.length - 1 ? priorOverlappers[i + 1][coordProp] : 1
                };
            }
        }

        return false;
    }

    getPriorOverlappingEvents(events, event) {
        const
            start       = event.start,
            end         = event.end,
            overlappers = [];

        for (let i = 0, l = events.indexOf(event); i < l; i++) {
            if (DateHelper.intersectSpans(start, end, events[i].start, events[i].end)) {
                overlappers.push(events[i]);
            }
        }

        overlappers.sort(this.sortOverlappers.bind(this));

        return overlappers;
    }

    sortOverlappers(e1, e2) {
        return e1[this.coordProp] < e2[this.coordProp] ? -1 : 1;
    }

    getCluster(events, startIndex) {
        const startEvent = events[startIndex];

        if (startIndex >= events.length - 1) {
            return [startEvent];
        }

        const
            evts = [startEvent],
            l    = events.length;

        let { start, end } = startEvent,
            i              = startIndex + 1;

        while (i < l && DateHelper.intersectSpans(start, end, events[i].start, events[i].end)) {
            evts.push(events[i]);
            start = DateHelper.max(start, events[i].start);
            end   = DateHelper.min(events[i].end, end);
            i++;
        }

        return evts;
    }
};

/**
 * @module Scheduler/eventlayout/HorizontalLayoutPack
 */

/**
 * Handles layout of events within a row (resource) in horizontal mode. Packs events (adjusts their height) to fit
 * available row height
 *
 * @extends Scheduler/eventlayout/HorizontalLayout
 * @mixes Scheduler/eventlayout/PackMixin
 * @private
 */
class HorizontalLayoutPack extends PackMixin(HorizontalLayout) {
    // Packs the events to consume as little space as possible
    applyLayout(events) {
        super.applyLayout(events, (event, j, slot, slotSize) => {
            event.height = slotSize;
            event.top    = slot.start + (j * slotSize);
        });

        events.forEach(event => {
            Object.assign(
                event,
                this.bandIndexToPxConvertFn.call(
                    this.bandIndexToPxConvertThisObj || this,
                    event.top,
                    event.height,
                    null,
                    event.event
                )
            );
        });
    }
}
HorizontalLayoutPack._$name = 'HorizontalLayoutPack';

/**
 * @module Scheduler/view/mixin/SchedulerEventRendering
 */

const hyphenRe = /-/g;

/**
 * Functions to handle event rendering (EventModel -> dom elements).
 *
 * @mixin
 */
var SchedulerEventRendering = Target => class SchedulerEventRendering extends (Target || Base) {
    //region Default config

    static get defaultConfig() {
        return {
            /**
             * An empty function by default, but provided so that you can override it. This function is called each time
             * an event is rendered into the schedule to render the contents of the event. It's called with the event,
             * its resource and a tplData object which allows you to populate data placeholders inside the event
             * template. **IMPORTANT** You should never modify any data on the EventModel inside this method.
             * By default, the DOM markup of an event bar includes placeholders for 'cls' and 'style'. The cls property is a
             * {@link Core.helper.util.DomClassList} which will be added to the event element. The style property is an inline style declaration for
             * the event element.
             *
             * ```javascript
             * eventRenderer({eventRecord, resourceRecord, tplData}) {
             *   tplData.style = 'color:white';                 // You can use inline styles too.
             *
             *   // Property names with truthy values are added to the resulting elements CSS class.
             *   tplData.cls.isImportant = this.isImportant(eventRecord);
             *   tplData.cls.isModified = eventRecord.isModified;
             *
             *   // Remove a class name by setting the property to false
             *   tplData.cls[scheduler.generatedIdCls] = false;
             *
             *   // Or, you can treat it as a string, but this is less efficient, especially
             *   // if your renderer wants to *remove* classes that may be there.
             *   tplData.cls += ' extra-class'
             *
             *   return DateHelper.format(eventRecord.startDate, 'YYYY-MM-DD') + ': ' + eventRecord.name;
             * }
             * ```
             *
             * @param {Object} detail An object containing the information needed to render an Event.
             * @param {Scheduler.model.EventModel} detail.eventRecord The event record.
             * @param {Scheduler.model.ResourceModel} detail.resourceRecord The resource record.
             * @param {Scheduler.model.AssignmentModel} detail.assignmentRecord The assignment record, if using an AssignmentStore.
             * @param {Object} detail.tplData An object containing details about the event rendering.
             * @param {Scheduler.model.EventModel} detail.tplData.event The event record.
             * @param {Core.helper.util.DomClassList|String} detail.tplData.cls An object whose property names represent the CSS class names
             * to be added to the event bar element. Set a property's value to truthy or falsy to add or remove the class
             * name based on the property name. Using this technique, you do not have to know whether the class is already
             * there, or deal with concatenation.
             * @param {Core.helper.util.DomClassList|String} detail.tplData.wrapperCls An object whose property names represent the CSS class names
             * to be added to the event wrapper element. Set a property's value to truthy or falsy to add or remove the class
             * name based on the property name. Using this technique, you do not have to know whether the class is already
             * there, or deal with concatenation.
             * @param {Core.helper.util.DomClassList|String} detail.tplData.iconCls An object whose property names represent the CSS class
             * names to be added to an event icon element.
             * @param {Number} detail.tplData.left Vertical offset position (in pixels) on the time axis.
             * @param {Number} detail.tplData.width Width in pixels of the event element.
             * @param {Number} detail.tplData.height Height in pixels of the event element.
             * @param {String} detail.tplData.eventStyle The `eventStyle` of the event. Use this to apply custom styles to the event DOM element
             * @param {String} detail.tplData.eventColor The `eventColor` of the event. Use this to set a custom color for the rendererd event
             * @returns {String|Object} A simple string, or a custom object which will be applied to the {@link #config-eventBodyTemplate}, creating the actual HTML
             * @config {function}
             * @category Scheduled events
             */
            eventRenderer : null,

            /**
             * `this` reference for the {@link #config-eventRenderer} function
             * @config {Object}
             * @category Scheduled events
             */
            eventRendererThisObj : null,

            eventPrefix : '',

            /**
             * How to handle overlapping events. Valid values are:
             * - stack, adjusts row height (only horizontal)
             * - pack, adjusts event height
             * - mixed, allows two events to overlap, more packs (only vertical)
             * - none, allows events to overlap
             * @config {String}
             * @default
             * @category Scheduled events
             */
            eventLayout : 'stack',

            /**
             * The class responsible for the packing horizontal event layout process.
             * Override this to take control over the layout process.
             * @config {Scheduler.eventlayout.HorizontalLayout}
             * @default
             * @private
             * @category Misc
             */
            horizontalLayoutPackClass : HorizontalLayoutPack,

            /**
             * The class name responsible for the stacking horizontal event layout process.
             * Override this to take control over the layout process.
             * @config {Scheduler.eventlayout.HorizontalLayout}
             * @default
             * @private
             * @category Misc
             */
            horizontalLayoutStackClass : HorizontalLayoutStack,

            /**
             * Override this method to provide a custom sort function to sort any overlapping events. By default,
             * overlapping events are laid out based on the start date. If the start date is equal, events with earlier
             * end date go first.
             *
             * Here's a sample sort function, sorting on start- and end date. If this function returns -1, then event a
             * is placed above event b.
             * ```javascript
             * horizontalEventSorterFn(a, b) {
             *
             *   const startA = a.startDate, endA = a.endDate;
             *   const startB = b.startDate, endB = b.endDate;
             *
             *   const sameStart = (startA - startB === 0);
             *
             *   if (sameStart) {
             *     return endA > endB ? -1 : 1;
             *   } else {
             *     return (startA < startB) ? -1 : 1;
             *   }
             * }
             * ```
             * @param  {Scheduler.model.EventModel} a First event
             * @param  {Scheduler.model.EventModel} b Second event
             * @return {Number} Return -1 to display a above b, 1 for b above a
             * @config {function}
             * @category Misc
             */
            horizontalEventSorterFn : null,

            /**
             * Field from EventModel displayed as text in the bar when rendering
             * @config {String}
             * @default
             * @category Scheduled events
             */
            eventBarTextField : 'name',

            /**
             * The template used to generate the markup of your events in the scheduler. To 'populate' the
             * eventBodyTemplate with data, use the {@link #config-eventRenderer} method
             * @config {Function}
             * @category Scheduled events
             */
            eventBodyTemplate : null,

            eventPositionMode : 'translate',
            eventScrollMode   : 'move',

            /**
             * Specify `true` to force rendered events to fill entire ticks. This only affects rendering, events retain
             * their set start and end dates on the data level. When enabling this config you should probably also
             * disable EventDrag and EventResize, otherwise their behaviour will not be what a user expects.
             * @config {Boolean}
             * @default
             * @category Scheduled events
             */
            fillTicks : false,

            /**
             * By default scheduler fades events in on load. Specify `false` to prevent this animation or specify one
             * of the available animation types to use it (`true` equals `'fade-in'`):
             * * fade-in (default)
             * * slide-from-left
             * * slide-from-top
             * ```
             * // Slide events in from the left on load
             * scheduler = new Scheduler({
             *     useInitialAnimation : 'slide-from-left'
             * });
             * ```
             * @config {Boolean|String}
             * @default
             * @category Misc
             */
            useInitialAnimation : true,

            /**
             * A config object used to configure the resource columns in vertical mode.
             * See {@link Scheduler.view.ResourceHeader} for more details on available properties.
             *
             * ```
             * new Scheduler({
             *   resourceColumns : {
             *     columnWidth    : 100,
             *     headerRenderer : ({ resourceRecord }) => `${resourceRecord.id} - ${resourceRecord.name}`
             *   }
             * })
             * ```
             * @config {Object}
             * @category Resources
             */
            resourceColumns : null,

            /**
             * Path to load resource images from. Used by the resource header in vertical mode and the
             * {@link Scheduler.column.ResourceInfoColumn} in horizontal mode. Set this to display miniature
             * images for each resource using their `image` or `imageUrl` fields.
             *
             * * `image` represents image name inside the specified `resourceImagePath`,
             * * `imageUrl` represents fully qualified image URL.
             *
             *  If set and a resource has no `imageUrl` or `image` specified it will try show miniature using
             *  the resource's name with {@link #config-resourceImageExtension} appended.
             *
             * **NOTE**: The path should end with a `/`:
             *
             * ```
             * new Scheduler({
             *   resourceImagePath : 'images/resources/'
             * });
             * ```
             * @config {String}
             * @category Resources
             */
            resourceImagePath : null,

            /**
             * Generic resource image, used when provided `imageUrl` or `image` fields or path calculated from resource name are all invalid.
             * @default
             * @config {String}
             * @category Resources
             */
            defaultResourceImageName : 'none.png',

            /**
             * Resource image extension, used when creating image path from resource name.
             * @default
             * @config {String}
             * @category Resources
             */
            resourceImageExtension : '.jpg',

            /**
             * Control how much space to leave between the first event/last event and the resources edge (top/bottom
             * margin within the resource row in horizontal mode, left/right margin within the resource column in
             * vertical mode), in px. Defaults to the value of {@link Scheduler.view.mixin.TimelineEventRendering#config-barMargin}.
             * @config {Number}
             * @category Scheduled events
             */
            resourceMargin : null,

            // Used to animate events on first render
            isFirstRender : true
        };
    }

    //endregion

    //region Properties

    /**
     * Property for {@link #config-useInitialAnimation useInitialAnimation}
     * @property {Boolean|String}
     * @name useInitialAnimation
     */

    //endregion

    //region Init

    get eventPrefix() {
        return this._eventPrefix;
    }

    set eventPrefix(eventPrefix) {
        this._eventPrefix = eventPrefix || this.id + '-';
    }

    //endregion

    //region Settings

    get layouts() {
        const me = this;

        if (!me._eventLayout) {
            me._eventLayout = {};

            // pack, fit all events in available height by adjusting their height
            if (me.horizontalLayoutPackClass) {
                me._eventLayout.horizontalPack = new me.horizontalLayoutPackClass(
                    Object.assign(
                        // this is required for table layout
                        {
                            scheduler                   : me,
                            timeAxisViewModel           : me.timeAxisViewModel,
                            bandIndexToPxConvertFn      : me.horizontal.layoutEventVerticallyPack,
                            bandIndexToPxConvertThisObj : me.horizontal
                        }
                    )
                );
            }

            // stack, adjust row height to fit all events
            if (me.horizontalLayoutStackClass) {
                me._eventLayout.horizontalStack = new me.horizontalLayoutStackClass(
                    Object.assign(
                        // this is required for table layout
                        {
                            scheduler                   : me,
                            timeAxisViewModel           : me.timeAxisViewModel,
                            bandIndexToPxConvertFn      : me.horizontal.layoutEventVerticallyStack,
                            bandIndexToPxConvertThisObj : me.horizontal
                        }
                    )
                );
            }
        }

        return me._eventLayout;
    }

    /**
     * Get/set overlap mode. See config, valid values are stack (horizontal), pack, mixed (vertical) and none
     * @property {String}
     * @category Scheduled events
     */
    get eventLayout() {
        return this._overlapMode;
    }

    set eventLayout(eventLayout) {
        const me = this;

        if (eventLayout != me._overlapMode) {
            me.element.classList.remove(`b-eventlayout-${me._overlapMode}`);
            me._overlapMode = eventLayout;

            me.runWithTransition(() => {
                me.element.classList.add(`b-eventlayout-${me._overlapMode}`);
                me.refresh();
            });
        }
    }

    /**
     * Get/set fillTicks setting. If set to true it forces the rendered events to fill entire ticks.
     * @property {String}
     * @category Scheduled events
     */
    get fillTicks() {
        return this._fillTicks;
    }

    set fillTicks(fill) {
        const me = this;

        if (fill != me._fillTicks) {
            me._fillTicks = fill;
            me.refreshWithTransition();
        }
    }

    /**
     * Control how much space to leave between the first event/last event and the resources edge (top/bottom margin within
     * the resource row in horizontal mode, left/right margin within the resource column in vertical mode),
     * in px. Defaults to the value of {@link Scheduler.view.mixin.TimelineEventRendering#config-barMargin}.
     * @member {Number} resourceMargin
     * @category Scheduled events
     */

    /**
     * Gets currently used event layout class. The event layout class decides the vertical placement of the events
     * within a resource. Returns null if no eventLayout is used (if Scheduler#eventLayout is set to "none")
     * @internal
     * @returns {*}
     * @readonly
     * @category Scheduled events
     */
    get currentEventLayout() {
        const me = this;

        if (!me.isHorizontal) return null;

        switch (me.eventLayout) {
            case 'stack':
                return me.layouts.horizontalStack;
            case 'pack':
                return me.layouts.horizontalPack;
            default:
                return null;
        }
    }

    get useInitialAnimation() {
        return this._useInitialAnimation;
    }

    set useInitialAnimation(name) {
        const me = this;

        if (me._useInitialAnimation) {
            me.element.classList.remove(`b-initial-${me._useInitialAnimation}`);
        }

        me._useInitialAnimation = (name === true ? 'fade-in' : name);

        if (name) {
            me.element.classList.add(`b-initial-${me._useInitialAnimation}`);
        }
    }

    set isFirstRender(value) {
        const me = this;

        me._isFirstRender = value;

        if (!me._firstRenderDone && value) {
            me._firstRenderDone = me.createOnFrame(() => {
                me._isFirstRender = false;
                me._firstRenderDone = null;
            });
        }
    }

    get isFirstRender() {
        return this._isFirstRender;
    }

    set horizontalEventSorterFn(fn) {
        // Wrap sorter to work on events instead of template data
        this._horizontalEventSorterFn = fn ? (a, b) => fn(a.event, b.event) : fn;

        if (this.rendered) {
            this.refreshWithTransition();
        }
    }

    get horizontalEventSorterFn() {
        return this._horizontalEventSorterFn;
    }

    //endregion

    //region Resource header/columns

    // NOTE: The configs below are initially applied to the resource header in `TimeAxisColumn#set mode`

    set resourceColumns(config) {
        this._resourceColumns = config;
    }

    /**
     * Use it to manipulate resource column properties at runtime.
     * @property {Scheduler.view.ResourceHeader}
     * @readonly
     */
    get resourceColumns() {
        return this.timeAxisColumn && this.timeAxisColumn.resourceColumns || this._resourceColumns;
    }

    /**
     * Get resource column width. Only applies to vertical mode. To set it, assign to
     * `scheduler.resourceColumns.columnWidth`.
     * @property {Number}
     * @readonly
     */
    get resourceColumnWidth() {
        return this.resourceColumns ? this.resourceColumns.columnWidth : null;
    }

    //endregion

    //region Event rendering

    // Chainable function called with the events to render for a specific resource. Allows features to add/remove.
    // Chained by ResourceTimeRanges
    getEventsToRender(resource, events) {
        return events;
    }

    /**
     * Rerenders events for specified resource (by rerendering the entire row).
     * @param {Scheduler.model.ResourceModel} resourceRecord
     */
    repaintEventsForResource(resourceRecord/*, refreshSelections*/) {
        const me           = this;

        if (me.isHorizontal) {
            me.currentOrientation.cache.clearRow(resourceRecord.id);

            const row = me.getRowFor(resourceRecord);
            if (row) {
                // Update the affected row, if it changes height RowManger will take care of translating the rest of the rows
                row.render();
            }
        }

        // TODO: PORT selection model not ported yet
        // if (refreshSelections) {
        //     const sm     = me.getEventSelectionModel(),
        //           events = me.getEventStore().getEventsForResource(resourceRecord);
        //
        //     events.forEach(ev =>
        //         sm.forEachEventRelatedSelection(ev, selectedRecord =>
        //             me.onEventBarSelect(selectedRecord, true)
        //         )
        //     );
        // }
    }

    /**
     * Rerenders the events for all resources connected to the specified event
     * @param {Scheduler.model.EventModel} eventRecord
     * @private
     */
    repaintEvent(eventRecord) {
        const resources = this.eventStore.getResourcesForEvent(eventRecord);
        resources.forEach(resourceRecord => this.repaintEventsForResource(resourceRecord));
    }

    //endregion

    //region Template

    /**
     * Generates data used in the template when rendering an event. For example which css classes to use. Also applies
     * #eventBodyTemplate and calls the {@link #config-eventRenderer}.
     * @private
     * @param {Scheduler.model.EventModel} eventRecord Event to generate data for
     * @param {Scheduler.model.ResourceModel} resourceRecord Events resource
     * @param {Boolean|Object} includeOutside Specify true to get boxes for timespans outside of the rendered zone in both
     * dimensions. This option is used when calculating dependency lines, and we need to include routes from timespans
     * which may be outside the rendered zone.
     * @param {Boolean} includeOutside.timeAxis Pass as `true` to include timespans outside of the TimeAxis's bounds
     * @param {Boolean} includeOutside.viewport Pass as `true` to include timespans outside of the vertical timespan viewport's bounds.
     * @returns {Object} Data to use in event template, or `undefined` if the event is outside of the rendered zone.
     */
    generateTplData(eventRecord, resourceRecord, includeOutside = { viewport : true }) {
        const
            me         = this,
            // generateTplData calculates layout for events which are outside of the vertical viewport
            // because the RowManager needs to know a row height.
            renderData = me.currentOrientation.getTimeSpanRenderData(eventRecord, resourceRecord, includeOutside);

        let eventContent = '';

        if (renderData) {
            let resizable = eventRecord.isResizable;
            if (renderData.startsOutsideView) {
                if (resizable === true) resizable = 'end';
                else if (resizable === 'start') resizable = false;
            }
            if (renderData.endsOutsideView) {
                if (resizable === true) resizable = 'start';
                else if (resizable === 'end') resizable = false;
            }

            // Event record cls properties are now DomClassList instances, so clone them
            // so that they can be manipulated here and by renderers.
            // Truthy value means the key will be added as a class name.
            // ResourceTimeRanges applies custom cls to wrapper.
            const
                clsList = eventRecord.isResourceTimeRange ? new DomClassList() : eventRecord.cls.clone(),
                wrapperClsList = eventRecord.isResourceTimeRange ? eventRecord.cls.clone() : new DomClassList();

            Object.assign(clsList, {
                [resourceRecord.cls]      : resourceRecord.cls,
                [me.generatedIdCls]       : eventRecord.hasGeneratedId,
                [me.dirtyCls]             : eventRecord.isPersistable && eventRecord.modifications,
                [me.committingCls]        : eventRecord.isCommitting,
                [me.endsOutsideViewCls]   : renderData.endsOutsideView,
                [me.startsOutsideViewCls] : renderData.startsOutsideView,
                'b-clipped-start'         : renderData.clippedStart,
                'b-clipped-end'           : renderData.clippedEnd
            });
            Object.assign(wrapperClsList, {
                [`${me.eventCls}-parent`] : resourceRecord.isParent
            });

            // Event specifics, things that do not apply to ResourceTimeRanges
            if (eventRecord.isEvent || eventRecord.isTask) {
                Object.assign(clsList, {
                    [me.eventCls]                          : 1,
                    'b-milestone'                          : eventRecord.isMilestone,
                    'b-sch-event-narrow'                   : renderData.width < 10,
                    [me.fixedEventCls]                     : eventRecord.isDraggable === false,
                    [`b-sch-event-resizable-${resizable}`] : Boolean(me.features.eventResize),
                    [me.eventSelectedCls]                  : me.isEventSelected(eventRecord),
                    'b-recurring'                          : eventRecord.isRecurring,
                    'b-occurrence'                         : eventRecord.isOccurrence
                });

                renderData.eventId  = eventRecord.id;
                // this is important for getElement(s)FromEventRecord()
                renderData.id = me.getEventRenderId(eventRecord, resourceRecord);

                // If id has changed we want to reuse the element for the old id, to not steal some other events element
                // and to allow any other changes from the server to be animated
                if ('id' in eventRecord.meta.modified) {
                    renderData.oldId = me.getEventRenderId(eventRecord.meta.modified.id, resourceRecord);
                }

                Object.assign(wrapperClsList, {
                    [`${me.eventCls}-wrap`] : 1,
                    'b-milestone-wrap'      : eventRecord.isMilestone
                });

                const
                    eventStyle = eventRecord.eventStyle || resourceRecord.eventStyle || me.eventStyle,
                    eventColor = eventRecord.eventColor || resourceRecord.eventColor || me.eventColor;

                renderData.eventColor = eventColor;
                renderData.eventStyle = eventStyle;

                // Using multi assignment? Supply AssignmentModel to rendering process also. Might not be available
                // if adding a new event and using EventEdit, since it might be converting a dragproxy prior to adding
                // to store. Not needed in that case anyway
                if (me.assignmentStore && eventRecord.assignments) {
                    renderData.assignment = eventRecord.assignments.find(a => a.resourceId === resourceRecord.id);
                }
            }

            // If not using a wrapping div, this cls will be added to event div for correct rendering
            renderData.wrapperCls = wrapperClsList;

            renderData.cls = clsList;
            renderData.iconCls = new DomClassList(eventRecord.get(me.eventBarIconClsField) || eventRecord.iconCls);

            // ResourceTimeRanges applies custom style to the wrapper
            if (eventRecord.isResourceTimeRange) {
                renderData.style = '';
                renderData.wrapperStyle = eventRecord.style || '';
            }
            // Others to inner
            else {
                renderData.style = eventRecord.style || '';
            }

            renderData.resource = resourceRecord;
            renderData.resourceId = renderData.rowId;

            if (eventRecord.isEvent || eventRecord.isTask) {
                if (me.eventRenderer) {
                    // User has specified a renderer fn, either to return a simple string, or an object intended for the eventBodyTemplate
                    const
                        value = me.eventRenderer.call(me.eventRendererThisObj || me, {
                            eventRecord,
                            resourceRecord,
                            assignmentRecord : renderData.assignment,
                            tplData          : renderData
                        });

                    // If the user's renderer coerced it into a string, recreate a DomClassList.
                    if (typeof renderData.cls === 'string') {
                        renderData.cls = new DomClassList(renderData.cls);
                    }

                    if (typeof renderData.wrapperCls === 'string') {
                        renderData.wrapperCls = new DomClassList(renderData.wrapperCls);
                    }

                    // Same goes for iconCls
                    if (typeof renderData.iconCls === 'string') {
                        renderData.iconCls = new DomClassList(renderData.iconCls);
                    }

                    eventContent = (me.eventBodyTemplate && me.eventBodyTemplate(value)) || (value == null ? '' : String(value));
                }
                else if (me.eventBodyTemplate) {
                    // User has specified an eventBodyTemplate, but no renderer - just apply the entire event record data.
                    eventContent = me.eventBodyTemplate(eventRecord);
                }
                else if (me.eventBarTextField) {
                    // User has specified a field in the data model to read from
                    eventContent = eventRecord.data[me.eventBarTextField] || '';
                }

                if (!me.eventBodyTemplate) {
                    // Give milestone a dedicated label element so we can use padding
                    if (eventRecord.isMilestone && eventContent) {
                        eventContent = `<label>${eventContent}</label>`;
                    }

                    if (renderData.iconCls && renderData.iconCls.length) {
                        eventContent = `<i class="${renderData.iconCls}"></i>${eventContent}`;
                    }
                }

                // renderers have last say on style & color
                renderData.wrapperCls[`b-sch-style-${renderData.eventStyle}`] = renderData.eventStyle;

                if (renderData.eventColor && renderData.eventColor.startsWith('#')) {
                    renderData.style = `background-color:${renderData.eventColor};` + renderData.style;
                }
                else {
                    renderData.wrapperCls[`b-sch-color-${renderData.eventColor}`] = renderData.eventColor;
                }
            }

            // If there are any iconCls entries...
            renderData.cls['b-sch-event-withicon'] = renderData.iconCls.length;

            // html, use templates fragment
            if (eventContent.includes('<')) {
                // Create content as a DocumentFragment which may now be exposed to Features.
                renderData.body = DomHelper.createElementFromTemplate(eventContent, {
                    fragment : true
                });
            }
            // plain text, create fragment with the text in it
            else {
                renderData.body = document.createDocumentFragment();
                renderData.body.textContent = eventContent;
            }

            // For comparison in sync, cheaper than comparing DocumentFragments
            renderData.eventContent = eventContent;

            // Method which features may chain in to
            me.onEventDataGenerated(renderData);
        }

        return renderData;
    }

    /**
     * A method which may be chained by features. It is called when an event's render
     * data is calculated so that features may update the style, class list or body.
     * @param {Object} eventData
     */
    onEventDataGenerated(eventData) {

    }

    /**
     * Generates the element `id` for an event element. This is used when
     * recycling an event div which has been moved from one resource to
     * another. The event is assigned its new render id *before* being
     * returned to the free pool, so that when the render engine requests
     * a div from the free pool, the same div will be returned.
     * @param {Scheduler.model.EventModel|String|Number} eventRecord Event record or id
     * @param {Scheduler.model.ResourceModel|String|Number} resourceRecord Resource record or id
     * @private
     */
    getEventRenderId(eventRecord, resourceRecord) {
        // Replacing and - in the id with ._. to not break `getResourceIdFromDomNodeId()`
        const
            eventId               = eventRecord instanceof TimeSpan ? eventRecord.id : eventRecord,
            eventIdWithoutDash    = eventId.toString().replace(hyphenRe, '._.'),
            resourceId            = resourceRecord instanceof ResourceModel ? resourceRecord.id : resourceRecord,
            resourceIdWithoutDash = resourceId.toString().replace(hyphenRe, '._.');
        return this.eventPrefix + `${eventIdWithoutDash}-${resourceIdWithoutDash}-x`;
    }

    //endregion

    //region Animation

    /**
     * Restarts initial events animation with new value {@link #config-useInitialAnimation}.
     * @param {Boolean|String} initialAnimation new initial animation value
     */
    restartInitialAnimation(initialAnimation) {
        const
            me = this;
        me.useInitialAnimation = initialAnimation;
        me._firstRenderDone = null;
        me.isFirstRender = true;
        me.refresh();
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

/**
 * @module Scheduler/view/mixin/SchedulerStores
 */

const
    MAX_VALUE      = Math.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1,
    checkResources = {
        add    : 1,
        update : 1,
        remove : 1,
        filter : 1
    };

/**
 * Functions for store assignment and store event listeners.
 *
 * @mixin
 */
var SchedulerStores = Target => class SchedulerStores extends (Target || Base) {

    //region Default config

    static get defaultConfig() {
        return {
            /**
             * Inline events, will be loaded into an internally created EventStore.
             * @config {Scheduler.model.EventModel[]|Object[]}
             * @category Data
             */
            events : null,

            /**
             * The {@link Scheduler.data.EventStore} holding the events to be rendered into the scheduler (required).
             * @config {Scheduler.data.EventStore}
             * @category Data
             */
            eventStore : null,

            /**
             * Inline resources, will be loaded into an internally created ResourceStore.
             * @config {Scheduler.model.ResourceModel[]|Object[]}
             * @category Data
             */
            resources : null,

            /**
             * The {@link Scheduler.data.ResourceStore} holding the resources to be rendered into the scheduler (required).
             * @config {Scheduler.data.ResourceStore}
             * @category Data
             */
            resourceStore : null,

            /**
             * Inline assignments, will be loaded into an internally created AssignmentStore.
             * @config {Scheduler.model.AssignmentModel[]|Object[]}
             * @category Data
             */
            assignments : null,

            /**
             * The optional {@link Scheduler.data.AssignmentStore}, holding assignments between resources and events.
             * Required for multi assignments.
             * @config {Scheduler.data.AssignmentStore}
             * @category Data
             */
            assignmentStore : null,

            /**
             * Inline dependencies, will be loaded into an internally created DependencyStore.
             * @config {Scheduler.model.DependencyModel[]|Object[]}
             * @category Data
             */
            dependencies : null,

            /**
             * The optional {@link Scheduler.data.DependencyStore}.
             * @config {Scheduler.data.DependencyStore}
             * @category Data
             */
            dependencyStore : null,

            /**
             * Inline time ranges, will be loaded into an internally created store if {@link Scheduler.feature.TimeRanges} is enabled.
             * @config {Scheduler.model.TimeSpan[]|Object[]}
             * @category Data
             */
            timeRanges : null,

            /**
             * Inline resource time ranges, will be loaded into an internally created store if {@link Scheduler.feature.ResourceTimeRanges} is enabled.
             * @config {Scheduler.model.ResourceTimeRangeModel[]|Object[]}
             * @category Data
             */
            resourceTimeRanges : null,

            /**
             * Overridden to *not* auto create a store at the Scheduler level.
             * The store is the {@link #config-resourceStore} which is either configured in
             * or acquired from the {@link Scheduler.crud.mixin.CrudManagerView#config-crudManager}.
             * @config {Core.data.Store}
             * @private
             */
            store : null,

            /**
             * The name of the start date parameter that will be passed to in every `eventStore` load request.
             * @config {String}
             * @category Data
             */
            startParamName : 'startDate',

            /**
             * The name of the end date parameter that will be passed to in every `eventStore` load request.
             * @config {String}
             * @category Data
             */
            endParamName : 'endDate',

            /**
             * true to apply start and end dates of the current view to any `eventStore` load requests.
             * @config {Boolean}
             * @category Data
             */
            passStartEndParameters : false,

            /**
             * Configure with `true` to also remove the event when removing the last assignment.
             * @config {Boolean}
             * @default
             * @category Misc
             */
            removeUnassignedEvent : true
        };
    }

    //endregion

    //region Store update

    onStoreDataChange({ source : store, action }) {
        this.currentOrientation.clearEvents();

        super.onStoreDataChange(...arguments);
    }

    // Wrap w/ transition refreshFromRowOnStoreAdd() inherited from Grid
    refreshFromRowOnStoreAdd(row, { isExpand }) {
        const args = arguments;

        this.runWithTransition(() => super.refreshFromRowOnStoreAdd(row, ...args), !isExpand);
    }

    onStoreAdd({ source : store, records, isChild }) {
        const me             = this,
            { rowManager } = me;

        // If it was an appendChild to a parent that is not expanded,
        // do nothing
        if (isChild && !records[0].ancestorsExpanded(store)) {
            return;
        }

        rowManager.calculateRowCount(false, true, true);

        const endIndex = Math.max(rowManager.topIndex + rowManager.rowCount, Math.min(rowManager.visibleRowCount, store.count));

        // Need to find topmost resource because we have to update from there downwards
        records = records.sort((lhs, rhs) => {
            return store.indexOf(lhs) - store.indexOf(rhs);
        });
        let firstUpdatedIndex = store.indexOf(records[0]);

        // If the update is below the rendered block, ignore it
        if (firstUpdatedIndex < endIndex) {
            // Start updating from the first affected record, or the rendered block
            // top if the record is above the rendered block.
            firstUpdatedIndex = Math.max(firstUpdatedIndex, rowManager.topIndex);

            // Clear events on every row below the first record
            for (let i = firstUpdatedIndex; i < endIndex; i++) {
                me.currentOrientation.onRowRecordUpdate({ record : store.getAt(i) });
            }
        }
        else {
            // Still might have changed total height
            rowManager.estimateTotalHeight();
        }

        super.onStoreAdd(...arguments);
    }

    /**
     * Overrides event handler in Grid, to pass on to current orientation class.
     * @private
     */
    onStoreUpdateRecord() {
        // need to update events when resource changes (might use data in renderers, templates)
        this.currentOrientation.onRowRecordUpdate(...arguments);
        super.onStoreUpdateRecord(...arguments);
    }

    onStoreRemove() {
        this.currentOrientation.onRowRecordRemove(...arguments);
        super.onStoreRemove(...arguments);
    }

    onStoreRemoveAll() {
        this.currentOrientation.clearEvents();
        super.onStoreRemoveAll();
    }

    //endregion

    //region destroy

    // Cleanup, destroys stores if Scheduler.destroyStores is true.
    doDestroy() {
        super.doDestroy();

        const me = this;
        if (me.destroyStores) {
            me.constructor.destroy(
                me.assignmentStore,
                me.resourceStore,
                me.dependencyStore,
                me.eventStore
            );
        }
    }

    //endregion

    //region Row store

    get store() {
        const me = this;
        // Spin up the resourceStore if possible.
        // If there are configured resources, this will load them too.
        me._thisIsAUsedExpression(me.resources);

        // Vertical uses a dummy store
        if (!me._store && me.isVertical) {
            // TODO: Make this store readonly, since we are using single cell approach
            me._store = new Store({
                data : [
                    { id : 'verticalTimeAxisRow' }
                ]
            });
        }

        return super.store;
    }

    set store(store) {
        super.store = store;
    }

    //endregion

    //region ResourceStore

    /**
     * Get/set resources, applies to the assigned ResourceStore.
     * @property {Scheduler.model.ResourceModel[]|Object[]}
     * @category Data
     */
    get resources() {
        const resourceStore = this.resourceStore;

        return resourceStore && resourceStore.records;
    }

    set resources(resources) {
        this.resourceStore.data = resources;
    }

    /**
     * Get/set the resource store instance.
     * @property {Scheduler.data.ResourceStore}
     * @category Data
     */
    get resourceStore() {
        const me = this;

        // If there's a CrudManager, it injects its resourceStore.
        // If not, we create our own instance.
        if (!me._resourceStore) {
            if (!me.crudManager || !me.crudManager.resourceStore) {
                me.resourceStore = new ResourceStore();
            }
        }

        return me._resourceStore;
    }

    set resourceStore(newResourceStore) {
        const
            me               = this,
            oldResourceStore = me._resourceStore;

        if (newResourceStore === oldResourceStore) {
            return;
        }

        if (!(newResourceStore instanceof ResourceStore)) {
            newResourceStore = new ResourceStore(newResourceStore);
        }

        if (oldResourceStore) {
            const isBackingRowStore = oldResourceStore === me.store;

            me._resourceStore = newResourceStore;

            // Reconfigure grid if resourceStore is backing the rows
            if (newResourceStore && me.isHorizontal) {
                if (isBackingRowStore) {
                    me.store = me.resourceStore;
                    me.store.metaMapId = me.id;
                }
                else {
                    me.refresh();
                }
            }
        }
        else {
            me._resourceStore = newResourceStore;
        }

        if (newResourceStore) {
            // In vertical, resource store is not the row store but should toggle the load mask
            if (me.isVertical) {
                newResourceStore.on('load', () => me.unmaskBody());
            }

            me.trigger('resourceStoreChange', { newResourceStore, oldResourceStore });
        }

        if (me.isHorizontal && !me._store) {
            me.store = newResourceStore;
        }
    }

    getResourceStoreListenerConfig() {
        return {};
    }

    //endregion

    //region EventStore

    /**
     * Get/set events, applies to the assigned EventStore.
     * @property {Scheduler.model.EventModel[]|Object[]}
     * @category Data
     */
    get events() {
        return this._eventStore.records;
    }

    set events(events) {
        this.eventStore.data = events;
    }

    /**
     * Get/set the event store instance.
     * @property {Scheduler.data.EventStore}
     * @category Data
     */
    get eventStore() {
        const me = this;

        // If there's a CrudManager, we use its eventStore.
        // If not, we create our own instance.
        if (!me._eventStore) {
            if (!me.crudManager || !me.crudManager.eventStore) {
                me.eventStore = new EventStore({
                    resourceStore : me.resourceStore
                });
            }
        }

        return this._eventStore;
    }

    set eventStore(newEventStore) {
        const me            = this,
            oldEventStore = me._eventStore;

        let triggerLoad = false;

        if (newEventStore === oldEventStore) {
            return;
        }

        const resourceStore = me.resourceStore;

        // Reconfiguring
        if (oldEventStore) {
            const
                oldEventStore                        = me.eventStore,
                { assignmentStore, dependencyStore } = me;

            if (newEventStore === oldEventStore) {
                return;
            }

            me.eventStoreDetacher && me.eventStoreDetacher();

            me._eventStore = newEventStore;

            me.timeAxisViewModel.eventStore = newEventStore;

            if (newEventStore) {
                if (resourceStore && !newEventStore.resourceStore) {
                    newEventStore.resourceStore = resourceStore;
                }

                if (assignmentStore && !newEventStore.assignmentStore) {
                    newEventStore.assignmentStore = assignmentStore;
                }

                if (dependencyStore && !newEventStore.dependencyStore) {
                    newEventStore.dependencyStore = dependencyStore;
                }

                me.trigger('eventStoreChange', { newEventStore, oldEventStore });

                me.refresh();
            }
        }
        else {
            if (newEventStore.isEventStore) {
                if (resourceStore && newEventStore.resourceStore !== resourceStore) {
                    // Sanity check.
                    // An eventStore cannot be shared between two Schedulers with different
                    // resourceStores. Prevent this Scheduler being handed an eventStore that
                    // is already attached to another resourceStore
                    if (newEventStore.resourceStore) {
                        throw new Error(`eventStore ${newEventStore.id} is already linked to resourceStore ${newEventStore.resourceStore.id}`);
                    }
                    newEventStore.resourceStore = resourceStore;
                }
            }
            else {
                triggerLoad = newEventStore.autoLoad;
                newEventStore.autoLoad = false;

                newEventStore = new EventStore(Object.assign({
                    resourceStore : me.resourceStore
                }, newEventStore));
            }
            me._eventStore = newEventStore;
        }

        if (newEventStore) {
            const listenerCfg = this.getEventStoreListenerConfig();

            if (me.passStartEndParameters) {
                listenerCfg.beforeload = me.applyStartEndParameters;
            }

            me.eventStoreDetacher && me.eventStoreDetacher();

            // TODO: PORT don't have autoDestroy yet
            /*if (me.eventStore) {
             if (eventStore !== me.eventStore && me.eventStore.autoDestroy) {
             me.eventStore.destroy();
             }
             }*/

            me.eventStoreDetacher = newEventStore.on(listenerCfg);

            if (newEventStore.assignmentStore) {
                me.assignmentStore = newEventStore.assignmentStore;
            }

            if (triggerLoad) {
                newEventStore.load().catch(() => {});
            }
        }

        // flag checked when adding events, to trigger full render first time
        if (me.eventStore.count > 0) {
            me.eventsRendered = true;
        }
    }

    getEventStoreListenerConfig() {
        return {
            thisObj    : this,
            detachable : true,

            // There is no separate dataset event any more.
            // It's a refresh event with action: 'dataset'
            change       : 'onInternalEventStoreChange',
            clearchanges : 'onEventClearChanges',
            beforecommit : 'onEventBeforeCommit',
            commit       : 'onEventCommit',
            beforeRemove : 'onEventStoreBeforeRemove',
            refresh      : 'onEventStoreRefresh',
            exception    : 'onEventException',
            idchange     : 'onEventIdChange'

            // TODO: PORT saving tree for later
            // If the eventStore is a TreeStore
            //nodeinsert : me.onEventAdd,
            //nodeappend : me.onEventAdd
        };
    }

    //endregion

    //region AssignmentStore

    /**
     * Get/set assignments, applies to the assigned AssignmentStore.
     * @property {Scheduler.model.AssignmentModel[]|Object[]}
     * @category Data
     */
    get assignments() {
        return this.assignmentStore && this.assignmentStore.records;
    }

    set assignments(assignments) {
        // Creating AssignmentStore here and not in `get assignmentStore` since it is optional, but if user assigns
        // assignments we can be sure one is needed.
        if (!this.assignmentStore) {
            this.eventStore.assignmentStore = this.assignmentStore = new AssignmentStore();
        }

        this.assignmentStore.data = assignments;
    }

    /**
     * Get/set the assignment store instance.
     * @property {Scheduler.data.AssignmentStore}
     * @category Data
     */
    get assignmentStore() {
        const me          = this,
            eventStore  = me.eventStore,
            crudManager = me.crudManager;

        return crudManager && crudManager.assignmentStore || eventStore && eventStore.assignmentStore;
    }

    set assignmentStore(newAssignmentStore) {
        const
            me                 = this,
            oldAssignmentStore = me.assignmentStore;

        if (me.eventStore.assignmentStore !== newAssignmentStore) {
            me.eventStore.assignmentStore = newAssignmentStore;
        }

        me.assignmentStoreDetacher && me.assignmentStoreDetacher();

        if (newAssignmentStore) {
            // In case there is an assignment store used
            me.assignmentStoreDetacher = newAssignmentStore.on(
                me.getAssignmentStoreListenerConfig()
            );

            me.trigger('assignmentStoreChange', { newAssignmentStore, oldAssignmentStore });
            me.refresh();
        }
    }

    getAssignmentStoreListenerConfig() {
        const me = this;

        return {
            thisObj      : me,
            //refresh    : me.onEventDataRefresh,
            refresh      : me.onAssignmentRefresh,
            update       : me.onAssignmentUpdate,
            add          : me.onAssignmentAdd,
            beforeRemove : {
                fn   : me.onBeforeAssignmentRemove,
                // We must go last in case an app vetoes a remove
                // by returning false from a handler.
                prio : -1000
            },
            remove    : me.onAssignmentRemove,
            filter    : me.onAssignmentFilter,
            removeall : me.onAssignmentRemoveAll
        };
    }

    //endregion

    //region DependencyStore

    /**
     * Get/set the dependency store instance.
     * @property {Scheduler.data.DependencyStore}
     * @category Data
     */
    get dependencyStore() {
        const me          = this,
            eventStore  = me.eventStore,
            crudManager = me.crudManager;

        return crudManager && crudManager.dependencyStore || eventStore && eventStore.dependencyStore || me._dependencyStore;
    }

    set dependencyStore(newDependencyStore) {
        const me = this;

        if (!me.isConfigured) {
            me._dependencyStore = newDependencyStore;
        }
        else {
            const oldDependencyStore = me.dependencyStore;

            me.eventStore.dependencyStore = newDependencyStore;

            if (newDependencyStore) {
                me.trigger('dependencyStoreChange', { newDependencyStore, oldDependencyStore });
                me.refresh();
            }
        }
    }

    getDependencyStoreListenerConfig() {
        return {};
    }

    //endregion

    //region Events

    onEventIdChange(params) {
        this.currentOrientation.onEventStoreIdChange && this.currentOrientation.onEventStoreIdChange(params);
    }

    /**
     * Calls appropriate functions for current event layout when the event store is modified.
     * @private
     */
    // Named as Internal to avoid naming collision with wrappers that relay events
    onInternalEventStoreChange(params) {
        const me = this;

        // Too early, bail out
        if (!me._mode) {
            return;
        }

        if (me.isVertical) {
            me.currentOrientation.onEventStoreChange(params);
        }
        else {
            // TODO: Move this to horizontal

            const
                layout     = me.currentOrientation,
                // ResourceTimeRanges also calls this fn, using its store as source. It is "compatible" with eventStore
                eventStore = params.source,
                {
                    rowManager,
                    resourceStore
                }          = me,
                {
                    action,
                    changes,
                    isCollapse
                }          = params,
                events     = params.records || (params.record ? [params.record] : null),
                resources  = [];

            let rows          = new Set(),
                useTransition = false,
                len, i;

            if (!me.isPainted) {
                return;
            }

            // Ignore update caused by collapse or removing associated resource, will be handled by resource removal code
            if (isCollapse || (action === 'update' && events.length && events[0].meta.removingResource)) {
                return;
            }

            // resource timeranges feature embeds into regular events drawing procedure
            // which means in some cases we should repaint all rows
            const skipRows = action === 'filter' && me.hasFeature('resourceTimeRanges');

            // If events were changed
            if (!skipRows && checkResources[action] && events) {
                // For event resource change, the "from" resource is part of the changed resource set.
                if (changes && ('resourceId' in changes) && changes.resourceId.oldValue != null) {
                    const
                        prevResource = resourceStore.getById(changes.resourceId.oldValue),
                        prevRow      = prevResource && rowManager.getRowFor(prevResource);

                    // Old resource might not exist in store, https://app.assembla.com/spaces/bryntum/tickets/7070.
                    // Happens for example when dropping from another scheduler.
                    if (prevRow) {
                        resources.push(prevResource);
                        rows.add(prevRow);
                    }
                }

                // We are only interested in associated resources which exist in the store and are in the rendered block.
                for (i = 0, len = events.length; i < len; i++) {
                    resources.push(...eventStore.getResourcesForEvent(events[i]).filter(resource => {
                        // Skip row if the resource is in a collapsed node and it's not available
                        // Note: Use `resource.id` since resource is associated record and it can be a placeHolder object
                        // ({ id : keyValue, placeHolder : true }) in case it's missing in the store, see Model.initRelation
                        if (resource && me.resourceStore.isAvailable(resource.id)) {
                            const row = rowManager.getRowFor(resource);
                            if (row) {
                                rows.add(row);
                                return true;
                            }
                        }
                        return false;
                    }));
                }

                if (resources.length) {
                    // Sort rows if more than one
                    if (rows.size > 1) {
                        rows = new Set([...rows].sort((a, b) => a.dataIndex - b.dataIndex));
                    }
                    // If all affected rows are outside of the rendered range, do nothing
                    else if (!rows.size) {
                        return;
                    }
                }
                // No resources in the rendered block were visible (or all events filtered out, in which case a full redraw
                // is performed). Nothing to update in the UI, but the dataset height might have changed.
                else if (!(action === 'filter' && !events.length)) {
                    rowManager.estimateTotalHeight();
                    return;
                }
                params.resources = resources;
            }

            switch (action) {
                case 'dataset':
                    layout.onEventDataset();
                    if (!eventStore.count) {
                        return;
                    }
                    break;
                case 'add':
                    layout.onEventAdd(params);
                    useTransition = true;
                    break;
                case  'update':
                    layout.onEventUpdate(params);
                    useTransition = true;
                    break;
                case 'remove':
                    layout.onEventRemove(params);
                    useTransition = true;
                    break;
                case 'removeall':
                    layout.onEventRemoveAll();
                    break;
                case 'filter':
                    layout.onEventFilter(params);
                    break;
                case 'clearchanges':
                    layout.onEventClearChanges(params);
                    break;
            }

            me.runWithTransition(() => {
                if (rows.size) {

                    // Render the affected rows.
                    rowManager.renderRows(rows);
                }
                // No specific rows affected, for example a dataset. Draw all
                else {
                    // TODO: change to refresh() when merged to master
                    rowManager.renderFromRow();
                }
            }, useTransition);
        }
    }

    /**
     * If events are changed in batch, endBatch fires refresh, so we must refresh the view.
     * @private
     */
    onEventStoreRefresh({ action }) {
        if (action === 'batch' && this.rowManager.rowCount) {
            this.currentOrientation.onEventDataset && this.currentOrientation.onEventDataset();
            // TODO: Run with transition?
            this.refresh();
        }
    }

    /**
     * Moves focus before the currently active event is removed.
     * @private
     */
    onEventStoreBeforeRemove({ records }) {
        const me = this;

        // Active event is being removed.
        if (me.activeEvent && records.includes(me.activeEvent)) {
            let moveTo;

            // If being done by a keyboard gesture then look for a close target
            // until we find an existing record, not scheduled for removal.
            // Otherwise, per Mats, push focus outside of the Scheduler.
            if (GlobalEvents.lastInteractionType === 'key') {
                for (let i = 0, l = records.length; i < l && (!moveTo || records.includes(moveTo)); i++) {
                    if (me.eventStore.getResourcesForEvent(records[i]).length) {
                        const event = records[i],
                            from  = event.assignments && event.assignments.length ? event.assignments[0] : event;
                        moveTo = me.getNext(from, true) || me.getPrevious(from, true);
                    }
                }
            }

            // Move focus away from the element which will soon have no
            // backing data.
            if (moveTo) {
                me.navigateTo(moveTo);
            }
            // Focus must exit the Scheduler's subgrid, otherwise, if a navigation
            // key gesture is delivered before the outgoing event's element has faded
            // out and been removed, navigation will be attempted from a deleted
            // event. Animated hiding is problematic.
            //
            // We cannot just revertFocus() because that might move focus back to an
            // element in a floating EventEditor which is not yet faded out and
            // been removed. Animated hiding is problematic.
            //
            // We cannot focus scheduler.timeAxisColumn.element because the browser
            // would scroll it in some way if we have horizontal overflow.
            //
            // The only thing we can know about to focus here is the Scheduler itself.
            else {
                me.element.focus();
            }
        }
    }

    /**
     * Refreshes committed events, to remove dirty/committing flag.
     * CSS is added
     * @private
     */
    onEventCommit({ changes }) {
        let resourcesToRepaint = [...changes.added, ...changes.modified].map(eventRecord => this.eventStore.getResourcesForEvent(eventRecord));

        // flatten
        resourcesToRepaint = Array.prototype.concat.apply([], resourcesToRepaint);

        // repaint relevant resource rows
        new Set(resourcesToRepaint).forEach(resourceRecord => this.repaintEventsForResource(resourceRecord));
    }

    /**
     * Adds the committing flag to changed events before commit.
     * @private
     */
    onEventBeforeCommit({ changes }) {
        // Committing sets a flag in meta that during event rendering applies a CSS class. But to not mess up drag and
        // drop between resources no redraw is performed before committing, so class is never applied to the element(s).
        // Applying here instead
        [...changes.added, ...changes.modified].forEach(eventRecord =>
            this.getElementsFromEventRecord(eventRecord).forEach(element => element.classList.add(this.committingCls))
        );
    }

    // Clear committing flag
    onEventException({ action }) {
        if (action === 'commit') {
            const { changes } = this.eventStore;
            [...changes.added, ...changes.modified, ...changes.removed].forEach(eventRecord =>
                this.repaintEvent(eventRecord)
            );
        }
    }

    /**
     * Refreshes scheduler when event changes are cleared.
     * @private
     */
    onEventClearChanges() {
        this.refresh();
    }

    /**
     * Refreshes scheduler when data is assigned to the assigment store.
     * @private
     */
    onAssignmentRefresh(event) {
        if (this.isHorizontal && (event.action === 'dataset' || event.action === 'batch')) {
            this.refresh();
        }
    }

    /**
     * Repaints affected resources when assignments are added.
     * @private
     */
    onAssignmentAdd({ records }) {
        if (this.isHorizontal) {
            records.forEach(assignment => {
                const resource = assignment.resource;
                resource && this.repaintEventsForResource(resource);
            });
        }
    }

    /**
     * Repaints affected resources when assignments are updated.
     * @private
     */
    onAssignmentUpdate({ record, changes }) {
        if (this.isHorizontal) {
            // TODO: Move to HorizontalEventMapper
            const
                { rowManager } = this,
                layoutCache    = this.currentOrientation.cache,
                oldResourceId  = 'resourceId' in changes && changes.resourceId.oldValue,
                newResourceId  = record.resourceId;

            let row,
                fromRow = MAX_VALUE;

            if (oldResourceId != null && (row = rowManager.getRowFor(oldResourceId))) {
                layoutCache.clearRow(oldResourceId);
                fromRow = Math.min(fromRow, row.index);
            }

            if (newResourceId && (row = rowManager.getRowFor(newResourceId))) {
                layoutCache.clearRow(newResourceId);
                fromRow = Math.min(fromRow, row.index);
            }

            // Render from the first mutated row in the rendered block;
            if (fromRow !== MAX_VALUE) {
                rowManager.renderFromRow(rowManager.rows[fromRow]);
            }
        }
    }

    onBeforeAssignmentRemove({ source, records, doRemoveLastEvent }) {
        // Bail out if caused by the remove below
        if (source.isRemovingEvent) {
            return;
        }

        const
            me     = this,
            events = records.reduce((result, assignment) => {
                const event = assignment.event;

                if (event && !event.placeHolder && !result.includes(event)) {
                    result.push(event);
                }

                return result;
            }, []);

        let moveTo;

        // Deassigning the active assignment
        if (me.activeEvent && events.includes(me.activeEvent)) {
            // If being done by a keyboard gesture then look for a close target
            // until we find an existing record, not scheduled for removal.
            // Otherwise, per Mats, push focus outside of the Scheduler.
            if (GlobalEvents.lastInteractionType === 'key') {
                // Look for a close target until we find an existing record, not scheduled for removal
                for (let i = 0, l = records.length; i < l && (!moveTo || records.includes(moveTo)); i++) {
                    if (me.eventStore.getResourcesForEvent(records[i].event).length) {
                        const event = records[i],
                            from  = event.assignments && event.assignments.length ? event.assignments[0] : event;

                        moveTo = me.getNext(from) || me.getPrevious(from);
                    }
                }
            }

            // Move focus away from the element which will soon have no
            // backing data.
            if (moveTo) {
                me.navigateTo(moveTo);
            }
            // Focus must exit the Scheduler's subgrid, otherwise, if a navigation
            // key gesture is delivered before the outgoing event's element has faded
            // out and been removed, navigation will be attempted from a deleted
            // event. Animated hiding is problematic.
            //
            // We cannot just revertFocus() because that might move focus back to an
            // element in a floating EventEditor which is not yet faded out and
            // been removed. Animated hiding is problematic.
            //
            // We cannot focus scheduler.timeAxisColumn.element because the browser
            // would scroll it in some way if we have horizontal overflow.
            //
            // The only thing we can know about to focus here is the Scheduler itself.
            else {
                me.element.focus();
            }
        }

        if (me.removeUnassignedEvent && !me.isRemoving && doRemoveLastEvent !== false && (!source.stm || !source.stm.isRestoring)) {
            // Collect all events that will unassigned after the remove
            const toRemove = events.reduce((result, eventRecord) => {
                let assignmentCount = eventRecord.assignments ? eventRecord.assignments.length : 0;

                assignmentCount -= records.filter(r => r.event === eventRecord).length;

                if (!assignmentCount) {
                    result.push(eventRecord);
                }

                return result;
            }, []);

            // And remove them
            me.eventStore.remove(toRemove);
        }
    }

    /**
     * Repaints affected resources when assignments are removed.
     * @private
     */
    onAssignmentRemove({ records }) {
        if (this.isHorizontal) {
            records.forEach(assignment => {
                const resource = assignment.resource;
                resource && this.repaintEventsForResource(resource);
            });
        }
    }

    /**
     * Repaints resources when all assignments are removed.
     * @private
     */
    onAssignmentRemoveAll() {
        if (this.isHorizontal) {
            this.refresh();
        }
    }

    /**
     * Refreshes scheduler when assignment store is filtered.
     */
    onAssignmentFilter() {
        if (this.isHorizontal) {
            this.refresh();
        }
    }

    //endregion

    //region TimeRangeStore

    /**
     * Get/set the time ranges store instance for {@link Scheduler.feature.TimeRanges} feature.
     * @property {Core.data.Store}
     * @category Data
     * @name timeRangeStore
     */

    //endregion

    //region ResourceTimeRangeStore

    /**
     * Get/set the resource time ranges store instance for {@link Scheduler.feature.ResourceTimeRanges} feature.
     * @property {Scheduler.data.ResourceTimeRangeStore}
     * @category Data
     * @name resourceTimeRangeStore
     */

    //endregion

    //region Other functions

    /**
     * Applies the start and end date to each event store request (formatted in the same way as the start date, defined in the EventStore Model class).
     * @category Data
     */
    applyStartEndParameters({ source : eventStore, params }) {
        const
            me         = this,
            dateFormat = eventStore.modelClass.fieldMap.startDate.dateFormat;

        params[me.startParamName] = DateHelper.format(me.startDate, dateFormat);
        params[me.endParamName] = DateHelper.format(me.endDate, dateFormat);
    }

    //endregion

    //region WidgetClass

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}

    //endregion
};

/**
 * @module Scheduler/view/mixin/SchedulerScroll
 */

const
    immediatePromise$5 = new Promise((resolve) => resolve()),
    defaultScrollOptions$3 = {
        block      : 'nearest',
        edgeOffset : 20
    },
    unrenderedScrollOptions = {
        highlight : false,
        focus     : false
    };

/**
 * Functions for scrolling to events, dates etc.
 *
 * @mixin
 */
var SchedulerScroll = Target => class SchedulerScroll extends (Target || Base) {
    //region Scroll to event

    /**
     * Scrolls an event record into the viewport.
     * If the resource store is a tree store, this method will also expand all relevant parent nodes to locate the event.
     *
     * @param {Scheduler.model.EventModel} eventRec the event record to scroll into view
     * @param {Object} [options] How to scroll.
     * @param {String} [options.block=nearest] How far to scroll the event: `start/end/center/nearest`.
     * @param {Number} [options.edgeOffset=20] edgeOffset A margin *in pixels* around the event to bring into view.
     * @param {Boolean|Number} [options.animate] Set to `true` to animate the scroll, or the number of milliseconds to animate over.
     * @param {Boolean} [options.highlight] Set to `true` to highlight the event element when it is in view.
     * @param {Boolean} [options.focus] Set to `true` to focus the event element when it is in view.
     * @returns {Promise} A Promise which resolves when the scrolling is complete.
     *
     * This function is not applicable for events with multiple assignments, please use #scrollResourceEventIntoView instead.
     */
    scrollEventIntoView(eventRec, options = defaultScrollOptions$3) {
        const
            me        = this,
            resources = eventRec.resources || [eventRec];

        if (resources.length > 1) {
            throw new Error('scrollEventIntoView() is not applicable for events with multiple assignments, please use scrollResourceEventIntoView() instead.');
        }

        if (!resources.length) {
            console.warn('You have asked to scroll to an event which is not assigned to a resource');
            return immediatePromise$5;
        }

        return me.scrollResourceEventIntoView(resources[0], eventRec, null, options);
    }

    /**
     * Scrolls a resource event record into the viewport.
     *
     * If the resource store is a tree store, this method will also expand all relevant parent nodes
     * to locate the event.
     *
     * @param {Scheduler.model.ResourceModel} resourceRec A resource record an event record is assigned to
     * @param {Scheduler.model.EventModel} eventRec An event record to scroll into view
     * @param {Number} index DOM node index, applicable only for weekview
     * @param {Object} [options] How to scroll.
     * @param {String} [options.block=nearest] How far to scroll the event: `start/end/center/nearest`.
     * @param {Number} [options.edgeOffset=20] edgeOffset A margin *in pixels* around the event to bring into view.
     * @param {Boolean|Number} [options.animate] Set to `true` to animate the scroll, or the number of milliseconds to animate over.
     * @param {Boolean} [options.extendTimeAxis=true] By default, if the requested event is outside the time axis, the time axis is extended.
     * @param {Boolean} [options.highlight] Set to `true` to highlight the event element when it is in view.
     * @param {Boolean} [options.focus] Set to `true` to focus the event element when it is in view.
     * @returns {Promise} A Promise which resolves when the scrolling is complete.
     */
    scrollResourceEventIntoView(resourceRec, eventRec, index, options = defaultScrollOptions$3) {
        const
            me             = this,
            eventStart     = eventRec.startDate,
            eventEnd       = eventRec.endDate,
            eventIsOutside = eventStart < me.timeAxis.startDate | ((eventEnd > me.timeAxis.endDate) << 1);

        let el;

        if (options.edgeOffset == null) {
            options.edgeOffset = 20;
        }

        // Make sure event is within TimeAxis time span unless extendTimeAxis passed as false.
        // The EventEdit feature passes false because it must not mutate the TimeAxis.
        // Bitwise flag:
        //  1 === start is before TimeAxis start.
        //  2 === end is after TimeAxis end.
        if (eventIsOutside && options.extendTimeAxis !== false) {
            let currentTimeSpanRange = me.timeAxis.endDate - me.timeAxis.startDate,
                startAnchorPoint,
                endAnchorPoint;

            // Event is too wide, expand the range to encompass it.
            if (eventIsOutside === 3) {
                me.timeAxis.setTimeSpan(
                    new Date(eventStart.valueOf() - currentTimeSpanRange / 2),
                    new Date(eventEnd.getTime() + currentTimeSpanRange / 2)
                );
            }
            // Event is partially or wholly outside but will fit.
            // Move the TimeAxis to include it. Attempt to maintain visual position.
            else {
                startAnchorPoint = (eventIsOutside & 1)
                    ? me.getCoordinateFromDate(eventRec.endDate)
                    : me.getCoordinateFromDate(eventRec.startDate);

                // Event starts before
                if (eventIsOutside & 1) {
                    me.timeAxis.setTimeSpan(
                        new Date(eventStart),
                        new Date(eventStart.valueOf() + currentTimeSpanRange)
                    );
                }
                // Event ends after
                else {
                    me.timeAxis.setTimeSpan(
                        new Date(eventEnd.valueOf() - currentTimeSpanRange),
                        new Date(eventEnd)
                    );
                }
                // Restore view to same relative scroll position.
                endAnchorPoint = (eventIsOutside & 1)
                    ? me.getCoordinateFromDate(eventRec.endDate)
                    : me.getCoordinateFromDate(eventRec.startDate);

                me.timeAxisSubGrid.scrollable.scrollBy(endAnchorPoint - startAnchorPoint);
            }
        }

        // Establishing element to scroll to
        el = me.getElementFromEventRecord(eventRec, resourceRec);

        if (el) {
            // It's usually the event wrapper that holds focus
            if (!DomHelper.isFocusable(el)) {
                el = el.parentNode;
            }

            const scroller = me.timeAxisSubGrid.scrollable;

            // Force horizontalscroll to be triggered directly on scroll instead of on next frame, to have events
            // already drawn when promise resolves
            me.timeAxisSubGrid.forceScrollUpdate = true;
            // Scroll into view with animation and highlighting if needed.
            return scroller.scrollIntoView(el, options);
        }
        else if (eventIsOutside && options.extendTimeAxis === false) {
            console.warn('You have asked to scroll to an event which is outside the current view and extending timeaxis is disabled');
            return immediatePromise$5;
        }
        else if (!me.eventStore.isAvailable(eventRec)) {
            console.warn('You have asked to scroll to an event which is not available');
            return immediatePromise$5;
        }
        else {
            // Event not rendered, scroll to calculated location
            return me.scrollUnrenderedEventIntoView(resourceRec, eventRec, options);
        }
    }

    /**
     * Scrolls an unrendered event into view. Internal function used from #scrollResourceEventIntoView.
     * @private
     */
    scrollUnrenderedEventIntoView(resourceRec, eventRec, options = defaultScrollOptions$3) {
        // We must only resolve when the event's element has been painted
        // *and* the scroll has fully completed.
        return new Promise(resolve => {
            const
                me               = this,
                // Knock out highlight and focus options. They must be applied after the scroll
                // has fully completed and we have an element. Use a default edgeOffset of 20.
                modifiedOptions  = Object.assign({ edgeOffset : 20 }, options, unrenderedScrollOptions),
                scroller         = me.timeAxisSubGrid.scrollable,
                box              = me.getResourceEventBox(eventRec, resourceRec), // TODO: have all "box" type objects use Rectangle
                scrollerViewport = scroller.viewport;

            if (!scrollerViewport) {
                resolve();
                return;
            }

            const
                targetRect   = new Rectangle(box.start, box.top, box.end - box.start, box.bottom - box.top).translate(scrollerViewport.x - scroller.x, scrollerViewport.y - scroller.y),
                delta        = scroller.getDeltaTo(targetRect, modifiedOptions)[me.isHorizontal ? 'xDelta' : 'yDelta'],
                onEventPaint = ({ scheduler, eventRecord, resourceRecord, element }) => {
                    if (eventRecord === eventRec) {
                        detatcher();

                        // Don't resolve until the scroll has fully completed.
                        initialScrollPromise.then(() => {
                            // If we were scrolling rightwards, then because the rectangle was only *estimated*
                            // we must now ensure that the scroll position is fully correct for the *element*.
                            if (delta > 0) {
                                scroller.scrollIntoView(element, { edgeOffset : options.edgeOffset });
                            }
                            options.highlight && DomHelper.highlight(element);
                            options.focus && element.focus();
                            resolve();
                        });
                    }
                },
                // On either paint or repaint of the event, resolve the scroll promise and detach the listeners.
                detatcher = me.on({
                    eventrepaint : onEventPaint,
                    eventpaint   : onEventPaint
                }),
                initialScrollPromise = scroller.scrollIntoView(targetRect, modifiedOptions);
        });
    }

    /**
     * Scrolls the specified resource into view, works for both horizontal and vertical modes.
     * @param {Scheduler.model.ResourceModel} resourceRecord A resource record an event record is assigned to
     * @param {Object} [options] How to scroll.
     * @param {String} [options.column] Field name or ID of the column, or the Column instance to scroll to (in horizontal mode).
     * @param {String} [options.block] How far to scroll the element: `start/end/center/nearest`.
     * @param {Number} [options.edgeOffset] edgeOffset A margin around the element or rectangle to bring into view.
     * @param {Boolean|Number} [options.animate] Set to `true` to animate the scroll, or the number of milliseconds to animate over.
     * @param {Boolean} [options.highlight] Set to `true` to highlight the element when it is in view.
     * @returns {Promise} A promise which is resolved when the scrolling has finished.
     */
    scrollResourceIntoView(resourceRecord, options = defaultScrollOptions$3) {
        if (this.isVertical) {
            return this.currentOrientation.scrollResourceIntoView(resourceRecord, options);
        }
        else {
            return this.scrollRowIntoView(resourceRecord, options);
        }
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

/**
 * @module Scheduler/view/mixin/SchedulerRegions
 */

/**
 * Functions to get regions (bounding boxes) for scheduler, events etc.
 *
 * @mixin
 */
var SchedulerRegions = Target => class SchedulerRegions extends (Target || Base) {
    //region Orientation depended regions

    /**
     * Gets the region represented by the schedule and optionally only for a single resource. The view will ask the scheduler for
     * the resource availability by calling getResourceAvailability. By overriding that method you can constrain events differently for
     * different resources.
     * @param {Scheduler.model.ResourceModel} resourceRecord (optional) The resource record
     * @param {Scheduler.model.EventModel} eventRecord (optional) The event record
     * @return {Object} The region of the schedule
     */
    getScheduleRegion(resourceRecord, eventRecord, local = true) {
        return this.currentOrientation.getScheduleRegion(resourceRecord, eventRecord, local);
    }

    /**
     * Gets the region representing the passed resource and optionally just for a certain date interval.
     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record
     * @param {Date} startDate A start date constraining the region
     * @param {Date} endDate An end date constraining the region
     * @return {Core.helper.util.Rectangle} A Rectangle which encapsulates the resource time span
     */
    getResourceRegion(resourceRecord, startDate, endDate) {
        return this.currentOrientation.getRowRegion(resourceRecord, startDate, endDate);
    }

    //endregion

    //region ResourceEventBox

    /**
     * Get the region for a specified resources specified event.
     * @param {Scheduler.model.EventModel} eventRecord
     * @param {Scheduler.model.ResourceModel} resourceRecord
     * @param {Boolean} includeOutside Specify true to get boxes for events outside of the rendered zone in both dimensions. This option is used when calculating
     * dependency lines, and we need to include routes from events which may be outside the rendered zone.
     * @returns {*}
     */
    getResourceEventBox(eventRecord, resourceRecord, includeOutside = false) {
        // event caches its position when rendered, return it if available
        const
            me = this,
            // Vertical always returns a box here
            cached = me.currentOrientation.getResourceEventBox(eventRecord.id, resourceRecord.id);

        if (cached) {
            return cached;
        }

        // TODO: Move to HorizontalEventMapper
        const
            viewStartDate  = me.timeAxis.startDate,
            viewEndDate    = me.timeAxis.endDate,
            eventStartDate = eventRecord.startDate,
            eventEndDate   = eventRecord.endDate;

        /* eslint-disable */
        let result         = null,
            eventLayout, rowEventsLayoutData, eventRecordData,
            rowElement, rowTop, eventElements, eventElement, eventElOffsets, eventElBox;
        /* eslint-enable */

        // Checking if event record is within current time axis timespan and is visible, i.e. it's not rendered
        // within a collapsed row (scheduler supports resource tree store as well as flat resource store).
        if (
            eventStartDate && eventEndDate && (includeOutside || DateHelper.intersectSpans(eventStartDate, eventEndDate, viewStartDate, viewEndDate)) &&
            this.isRowVisible(resourceRecord)
        ) {
            rowElement = me.getRowFor(resourceRecord);

            // If resource row is rendered and displayed
            if (rowElement) {
                // Managed event sizing means that the view is responsible for event height setting, the oposite case
                // is when event height is controlled by CSS's top and height properties.

                // Fast case: managed event sizing on, querying the view for box position and dimensions
                if (me.managedEventSizing) {
                    eventLayout = me.currentEventLayout;

                    // Preparing events layout data for event layout instance to process
                    rowEventsLayoutData = me.eventStore.getEventsForResource(resourceRecord).reduce((result, event) => {
                        const eventBox =  me[me.mode].getTimeSpanRenderData(event, resourceRecord, includeOutside);

                        if (eventBox) {
                            result.push(eventBox);
                        }
                        return result;
                    }, []);

                    // Processing event layout data injecting event vertical position into each item of `rowEventsLayoutData`
                    // This layout application takes into account view's `dynamicRowHeight` property
                    eventLayout && eventLayout.applyLayout(rowEventsLayoutData, resourceRecord);

                    // Now we are to find our particular event data inside all events data for the given row record
                    eventRecordData = rowEventsLayoutData.find(eventData => eventData.event == eventRecord);

                    // We must find our event record corresponding layout data object here, but just to make sure
                    if (eventRecordData) {
                        // We have event record data with coordinates within the row node, but we need
                        // those coordinates to be translated relative to view's viewport top.

                        rowTop = me.getRecordCoords(resourceRecord, true).y;

                        // Finally we have all the data needed to calculated the event record box
                        result = {
                            layout : true,
                            start  : (eventRecordData.hasOwnProperty('left') ? eventRecordData.left : eventRecordData.right), // it depends on view's `rtl` configuration
                            end    : (eventRecordData.hasOwnProperty('left') ? eventRecordData.left : eventRecordData.right) + eventRecordData.width,
                            top    : rowTop + eventRecordData.top,
                            bottom : rowTop + eventRecordData.top + eventRecordData.height
                        };
                    }
                }
                // Slow case: managed event sizing off, querying the DOM for box position and dimensions
                else {
                    eventElements = me.getElementsFromEventRecord(eventRecord, eventRecord !== resourceRecord && resourceRecord);

                    // We must have at one and only one element here, but just to make sure
                    if (eventElements.length) {
                        eventElement        = eventElements[0];
                        // TODO: PORT getOffsetsTo and getBox
                        eventElOffsets = eventElement.getOffsetsTo(me.getEl());
                        eventElBox     = eventElement.getBox();

                        result = {
                            layout : true,
                            start  : eventElOffsets[0],
                            end    : eventElOffsets[0] + eventElBox.width,
                            top    : eventElOffsets[1],
                            bottom : eventElOffsets[1] + eventElBox.height
                        };
                    }
                }
            }
            // Resource row is not rendered, and it's not collapsed. We are to calculate event record box approximately.
            else {
                result = {
                    layout : false,
                    start  : me.getCoordinateFromDate(Math.max(eventRecord.startDateMS, me.timeAxis.startMS)),
                    end    : me.getCoordinateFromDate(Math.min(eventRecord.endDateMS, me.timeAxis.endMS))
                    // top and bottom to go
                };

                // Request local record coordinates within the scroll range.
                const recordCoords = me.rowManager.getRecordCoords(resourceRecord, true);
                // faster than Object.assign...
                result.top       = recordCoords.y + me.barMargin;
                result.height    = Math.max(me.rowManager.rowHeight - (2 * me.barMargin), 1);
                result.bottom    = result.top + result.height;
            }

            // Some boxes might need special adjustments
            if (result) {
                result = me.adjustItemBox(eventRecord, result);
            }
        }

        return result;
    }

    //endregion

    //region Item box

    /**
     * Gets box for displayed item designated by the record. If several boxes are displayed for the given item
     * then the method returns all of them. Box coordinates are in view coordinate system.
     *
     * Boxes outside scheduling view timeaxis timespan and inside collapsed rows (if row defining store is a tree store)
     * will not be returned. Boxes outside scheduling view vertical visible area (i.e. boxes above currently visible
     * top row or below currently visible bottom row) will be calculated approximately.
     *
     * @param {Scheduler.model.EventModel} event
     * @return {Object|Object[]}
     * @return {Boolean} return.isPainted Whether the box was calculated for the rendered scheduled record or was
     *                                   approximatelly calculated for the scheduled record outside of the current
     *                                   vertical view area.
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @return {String} return.relPos if the item is not rendered then provides a view relative position one of 'before', 'after'
     * @internal
     */
    getItemBox(event, includeOutside = false) {
        return event.resources.map(resource => this.getResourceEventBox(event, resource, includeOutside));
    }

    /**
     * Adjusts event record box if needed
     *
     * @param {Scheduler.model.EventModel} eventRecord
     * @param {Object} eventRecordBox
     * @return {Number} eventRecordBox.top
     * @return {Number} eventRecordBox.bottom
     * @return {Number} eventRecordBox.start
     * @return {Number} eventRecordBox.end
     * @return {Object}
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @internal
     */
    adjustItemBox(eventRecord, eventRecordBox) {
        const
            viewStartMS         = this.timeAxis.startMS,
            viewEndMS           = this.timeAxis.endMS,
            eventStartMS        = eventRecord.startDateMS,
            eventEndMS          = eventRecord.endDateMS,
            width               = this.timeAxisViewModel.totalSize,
            OUTSIDE_VIEW_OFFSET = 40; // To make sure non-relevant dependency lines aren't seen

        // adjust event box to render dependency lines for events that are outside of the view
        if (viewStartMS > eventStartMS) eventRecordBox.start = -OUTSIDE_VIEW_OFFSET;
        if (viewStartMS > eventEndMS)   eventRecordBox.end   = -OUTSIDE_VIEW_OFFSET;
        if (viewEndMS   < eventStartMS) eventRecordBox.start = width + OUTSIDE_VIEW_OFFSET;
        if (viewEndMS   < eventEndMS)   eventRecordBox.end   = width + OUTSIDE_VIEW_OFFSET;

        return eventRecordBox;
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

/**
 * @module Scheduler/view/mixin/SchedulerState
 */

const copyProperties = [
    'eventLayout',
    'barMargin',
    'mode',
    'tickSize',
    'zoomLevel',
    'eventColor',
    'eventStyle',
    'fillTicks',
    'startDate',
    'endDate'
];

/**
 * Mixin for Scheduler that handles state. It serializes the following scheduler properties:
 *
 * * eventLayout
 * * barMargin
 * * mode
 * * tickSize
 * * zoomLevel
 * * eventColor
 * * eventStyle
 *
 * See {@link Grid.view.mixin.GridState} and {@link Core.mixin.State} for more information on state.
 *
 * @mixin
 */
var SchedulerState = Target => class SchedulerState extends (Target || Base) {
    /**
     * Get schedulers current state for serialization. State includes rowHeight, headerHeight, readOnly, selectedCell,
     * selectedRecordId, column states and store state.
     * @returns {Object} State object to be serialized
     * @private
     */
    getState() {
        return ObjectHelper.copyProperties(super.getState(), this, copyProperties);
    }

    /**
     * Apply previously stored state.
     * @param {Object} state
     * @private
     */
    applyState(state) {
        ObjectHelper.copyProperties(this, state, copyProperties);

        super.applyState(state);
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

/**
 * @module Scheduler/view/mixin/EventSelection
 */

/**
 * Mixin that tracks event or assignment selection by clicking on one or more events in the scheduler.
 * @mixin
 */
var EventSelection = Target => class EventSelection extends (Target || Base) {
    //region Default config

    static get defaultConfig() {
        return {
            /**
             * Configure as `true` to allow `CTRL+click` to select multiple events in the scheduler.
             * @config {Boolean}
             * @category Selection
             */
            multiEventSelect : false,

            /**
             * Configure as `true`, or set property to `true` to disable event selection.
             * @config {Boolean}
             * @default
             * @category Selection
             */
            eventSelectionDisabled : false,

            /**
             * CSS class to add to selected events.
             * @config {String}
             * @default
             * @category CSS
             * @private
             */
            eventSelectedCls : 'b-sch-event-selected',

            /**
             * Configure as `true` to trigger `selectionChange` when removing a selected event/assignment.
             * @config {Boolean}
             * @default
             * @category Selection
             */
            triggerSelectionChangeOnRemove : false,

            /**
             * This flag controls whether Scheduler should maintain its selection of events when loading a new dataset (if selected event ids are included in the newly loaded dataset).
             * @config {Boolean}
             * @default
             * @category Selection
             */
            maintainSelectionOnDatasetChange : true,

            /**
             * CSS class to add to other instances of a selected event, to highlight them.
             * @config {String}
             * @default
             * @category CSS
             * @private
             */
            eventAssignHighlightCls : 'b-sch-event-assign-selected',

            /**
             * Collection to store selection.
             * @config {Core.util.Collection}
             * @private
             */
            selectedCollection : {}
        };
    }

    //endregion

    //region Events

    /**
     * Fired any time there is a change to the events selected in the Scheduler.
     * @event eventSelectionChange
     * @param {String} action One of the actions 'select', 'deselect', 'update', 'clear'
     * @param {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]} selected An array of the Events or Assignments added to the selection.
     * @param {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]} deselected An array of the Events or Assignments removed from the selection.
     * @param {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]} selection The new selection.
     */

    //endregion

    //region Init

    afterConstruct() {
        super.afterConstruct();

        this.navigator.on({
            navigate : 'onEventNavigate',
            thisObj  : this
        });
    }

    //endregion

    //region Selected Collection

    set selectedCollection(selectedCollection) {
        if (!(selectedCollection instanceof Collection)) {
            selectedCollection = new Collection(selectedCollection);
        }
        this._selectedCollection = selectedCollection;

        // Fire row change events from onSelectedCollectionChange
        selectedCollection.on({
            change  : 'onSelectedCollectionChange',
            thisObj : this
        });
    }

    get selectedCollection() {
        return this._selectedCollection;
    }

    //endregion

    //region Modify selection

    /**
     * The {@link Scheduler.model.EventModel events} or {@link Scheduler.model.AssignmentModel assignments} which are selected.
     * @returns {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]}
     * @category Selection
     */
    get selectedEvents() {
        return this.selectedCollection.values;
    }

    set selectedEvents(events) {
        // Replace the entire selected collection with the new record set
        this.selectedCollection.splice(0, this.selectedCollection.count, events || []);
    }

    /**
     * Returns `true` if the {@link Scheduler.model.EventModel event} or {@link Scheduler.model.AssignmentModel assignment} is selected.
     * @param {Scheduler.model.EventModel|Scheduler.model.AssignmentModel} event The event or assignment
     * @category Selection
     */
    isEventSelected(event) {
        return this.selectedCollection.includes(event);
    }

    /**
     * Selects the passed {@link Scheduler.model.EventModel event} or {@link Scheduler.model.AssignmentModel assignment}
     * *if it is not selected*.
     * @param {Scheduler.model.EventModel|Scheduler.model.AssignmentModel} event The event or assignment to select. When using multi assignment, supply an AssignmentModel
     * @param {Boolean} [preserveSelection=false] Pass `true` to preserve any other selected events or assignments
     * @category Selection
     */
    selectEvent(event, preserveSelection = false) {
        // If there event is already selected, this is a no-op.
        // In this case, selection must not be cleared even in the absence of preserveSelection
        if (!this.isEventSelected(event)) {
            preserveSelection ? this.selectedCollection.add(event) : this.selectedEvents = event;
        }
    }

    /**
     * Deselects the passed {@link Scheduler.model.EventModel event} or {@link Scheduler.model.AssignmentModel assignment}
     * *if it is selected*.
     * @param {Scheduler.model.EventModel|Scheduler.model.AssignmentModel} event The event or assignment to deselect. When using multi assignment, supply an AssignmentModel
     * @category Selection
     */
    deselectEvent(event, preserveSelection = false) {
        if (this.isEventSelected(event)) {
            this.selectedCollection.remove(event);
        }
    }

    /**
     * Adds {@link Scheduler.model.EventModel events} or {@link Scheduler.model.AssignmentModel assignments} to the selection.
     * @param {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]} events Events or assignments to be deselected
     * @category Selection
     */
    selectEvents(events) {
        this.selectedCollection.add(events);
    }

    /**
     * Removes {@link Scheduler.model.EventModel events} or {@link Scheduler.model.AssignmentModel assignments} from the selection.
     * @param {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]} events Events or assignments  to be deselected
     * @category Selection
     */
    deselectEvents(events) {
        this.selectedCollection.remove(events);
    }

    /**
     * Deselects all {@link Scheduler.model.EventModel events} or {@link Scheduler.model.AssignmentModel assignments}.
     * @category Selection
     */
    clearEventSelection() {
        this.selectedEvents = [];
    }

    //endregion

    //region Events

    /**
     * Responds to mutations of the underlying selection Collection.
     * Keeps the UI synced, eventSelectionChange event is fired when `me.silent` is falsy.
     * @private
     */
    onSelectedCollectionChange({ added, removed }) {
        const
            me           = this,
            selection    = me.selectedEvents,
            selected     = added || [],
            deselected   = removed || [];

        function updateSelection(record, select) {
            const
                resourceRecord = record.isTask ? record : record.resource,
                eventRecord    = record.isAssignment ? record.event : record;

            if (eventRecord) {
                const element = me.getElementFromEventRecord(eventRecord, resourceRecord);

                me.currentOrientation.toggleCls(eventRecord, resourceRecord, me.eventSelectedCls, select);

                if (record.isAssignment) {
                    me.getElementsFromEventRecord(eventRecord).forEach(el => {
                        if (el !== element) {
                            el.classList[select ? 'add' : 'remove'](me.eventAssignHighlightCls);
                        }
                    });
                }
            }
        }

        selected.forEach(record => updateSelection(record, true));
        deselected.forEach(record => updateSelection(record, false));

        if (!me.silent) {
            me.trigger('eventSelectionChange', {
                action : (selection.length > 0) ? ((selected.length > 0 && deselected.length > 0)
                    ? 'update' : (selected.length > 0 ? 'select' : 'deselect')) : 'clear',
                selection,
                selected,
                deselected
            });
        }
    }

    /**
     * Store data change listener to remove events from selection which are no longer in the store.
     * @private
     */
    onInternalEventStoreChange({ action, records : events, source : eventStore }) {
        super.onInternalEventStoreChange(...arguments);

        const me = this;
        me.silent = !me.triggerSelectionChangeOnRemove;

        if (action === 'remove') {
            me.deselectEvents(events);
        }
        else if (action === 'dataset') {
            if (!me.maintainSelectionOnDatasetChange) {
                me.clearEventSelection();
            }
            else {
                me.selectedEvents = me.selectedEvents.filter(event => eventStore.includes(event));
            }
        }
        me.silent = false;
    }

    /**
     * Assignment change listener to remove events from selection which are no longer in the assignments.
     * @private
     */
    onAssignmentRemove({ records : assignments }) {
        super.onAssignmentRemove(...arguments);

        const me = this;
        me.silent = !me.triggerSelectionChangeOnRemove;
        me.deselectEvents(assignments);
        me.silent = false;
    }

    /**
     * Mouse listener to update selection.
     * @private
     */
    onEventSelectionClick(event, clickedRecord) {
        const me = this;

        // Multi selection: CTRL means preserve selection, just add or remove the event.
        // Single selection: CTRL deselects already selected event
        if (me.isEventSelected(clickedRecord)) {
            event.ctrlKey && me.deselectEvent(clickedRecord, me.multiEventSelect);
        }
        else {
            me.selectEvent(clickedRecord, event.ctrlKey && me.multiEventSelect);
        }
    }

    /**
     * Navigation listener to update selection.
     * @private
     */
    onEventNavigate({ event, item }) {
        if (!this.eventSelectionDisabled) {
            const
                me     = this,
                record = item && (item.nodeType === 1
                    ? (me.assignmentStore ? me.resolveAssignmentRecord(item) : me.resolveEventRecord(item)) : item);
            if (record) {
                me.onEventSelectionClick(event, record);
            }
            // Click outside of an event/assignment;
            else {
                me.clearEventSelection();
            }
        }
    }

    //endregion

    //region Getters/Setters

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}

    //endregion
};

/**
 * @module Scheduler/view/mixin/EventNavigation
 */

const
    sortByStartDate = (l, r) => l.startDate - r.startDate,
    preventDefault = e => e.preventDefault();

/**
 * Mixin that tracks event or assignment selection by clicking on one or more events in the scheduler.
 * @mixin
 */
var EventNavigation = Target => class EventNavigation extends Delayable(Target || Base) {
    //region Default config

    static get defaultConfig() {
        return {
            /**
             * A config object to use when creating the {@link Core.helper.util.Navigator}
             * to use to perform keyboard navigation in the timeline.
             * @config {Object}
             * @default
             * @category Misc
             * @internal
             */
            navigator : null,

            /**
             * A CSS class name to add to focused events.
             * @config {String}
             * @default
             * @category CSS
             * @private
             */
            focusCls : 'b-active',

            /**
             * Allow using [Delete] and [Backspace] to remove events/assignments
             * @config {Boolean}
             * @default
             * @category Misc
             */
            enableDeleteKey : true,

            // Number in milliseconds to buffer handlers execution. See `Delayable.throttle` function docs.
            onDeleteKeyBuffer      : 500,
            navigatePreviousBuffer : 200,
            navigateNextBuffer     : 200,

            testConfig : {
                onDeleteKeyBuffer : 1
            }
        };
    }

    //endregion

    //region Events

    //endregion

    construct(config) {
        const me = this;

        me.isInTimeAxis = me.isInTimeAxis.bind(me);

        super.construct(config);

        const
            onDeleteKey = me.onDeleteKey = me.throttle(me.onDeleteKey, me.onDeleteKeyBuffer, me),
            navigatorConfig = ObjectHelper.merge({
                ownerCmp         : me,
                target           : me.timeAxisSubGridElement,
                processEvent     : me.processEvent,
                itemSelector     : `.${me.eventCls}-wrap`,
                focusCls         : me.focusCls,
                navigatePrevious : me.throttle(me.navigatePrevious, me.navigatePreviousBuffer, me, null, preventDefault),
                navigateNext     : me.throttle(me.navigateNext, me.navigateNextBuffer, me, null, preventDefault),
                allowCtrlKey     : true,
                scrollSilently   : true,
                keys             : {
                    Space     : 'onEventSpaceKey',
                    Enter     : 'onEventEnterKey',
                    Delete    : onDeleteKey,
                    Backspace : onDeleteKey
                }
            }, me.navigator);

        me.navigator = new Navigator(navigatorConfig);
    }

    doDestroy() {
        this.navigator.destroy();
        super.doDestroy();
    }

    isInTimeAxis(record) {
        // If event is hidden by workingTime configs, horizontal mapper would raise a flag on instance meta
        // We still need to check if time span is included in axis
        return !record.instanceMeta(this).excluded && this.timeAxis.isTimeSpanInAxis(record);
    }

    /*
     * Override of GridNavigation#focusCell method to handle the TimeAxisColumn.
     * Not needed until we implement full keyboard accessibiliy.
     */
    accessibleFocusCell(cellSelector, options) {
        const me                     = this;

        cellSelector = me.normalizeCellContext(cellSelector);

        if (cellSelector.columnId === me.timeAxisColumn.id) ;
        else {
            return super.focusCell(cellSelector, options);
        }
    }

    getPrevious(eventOrAssignmentRecord, isDelete) {
        const me = this,
            resourceStore = me.resourceStore,
            isAssignment = eventOrAssignmentRecord.isAssignment;

        // TODO: https://app.assembla.com/spaces/bryntum/tickets/6526 this class should not know about Gantt.
        if (eventOrAssignmentRecord.isTask) {
            return me.eventStore.getAt(me.eventStore.indexOf(eventOrAssignmentRecord) - 1);
        }

        let resourceRecord = eventOrAssignmentRecord.resource || me.eventStore.getResourcesForEvent(eventOrAssignmentRecord)[0],
            resourceEvents = resourceRecord.getEvents().filter(me.isInTimeAxis).sort(sortByStartDate),
            eventRecord = isAssignment ? eventOrAssignmentRecord.event : eventOrAssignmentRecord,
            previousEvent = resourceEvents[resourceEvents.indexOf(eventRecord) - 1];

        // At first event for resource, traverse up the resource store.
        if (!previousEvent) {
            // If we are deleting an event, skip other instances of the event which we may encounter
            // due to multi-assignment.
            for (let rowIdx = resourceStore.indexOf(resourceRecord) - 1; (!previousEvent || (isDelete && previousEvent === eventRecord)) && rowIdx >= 0; rowIdx--) {
                resourceRecord = resourceStore.getAt(rowIdx);
                let events = resourceRecord.getEvents().filter(me.isInTimeAxis).sort(sortByStartDate);
                previousEvent = events.length && events[events.length - 1];
            }
        }

        // If an assignment was passed, return one
        return isAssignment
            ? me.assignmentStore.getAssignmentForEventAndResource(previousEvent, resourceRecord)
            : previousEvent;
    }

    navigatePrevious(keyEvent) {
        const me = this,
            previousEvent = me.getPrevious(keyEvent.assignmentRecord || keyEvent.eventRecord);

        keyEvent.preventDefault();
        if (previousEvent) {
            if (!keyEvent.ctrlKey) {
                me.clearEventSelection();
            }
            me.navigateTo(previousEvent, keyEvent);
        }
    }

    getNext(eventOrAssignmentRecord, isDelete) {
        const me = this,
            resourceStore = me.resourceStore,
            isAssignment = eventOrAssignmentRecord.isAssignment;

        // TODO: https://app.assembla.com/spaces/bryntum/tickets/6526 this class should not know about Gantt.
        if (eventOrAssignmentRecord.isTask) {
            return me.eventStore.getAt(me.eventStore.indexOf(eventOrAssignmentRecord) + 1);
        }

        let resourceRecord = isAssignment ? eventOrAssignmentRecord.resource : eventOrAssignmentRecord.resources[0], //|| me.eventStore.getResourcesForEvent(eventOrAssignmentRecord)[0],
            resourceEvents = resourceRecord.getEvents().filter(me.isInTimeAxis).sort(sortByStartDate),
            eventRecord = isAssignment ? eventOrAssignmentRecord.event : eventOrAssignmentRecord,
            nextEvent = resourceEvents[resourceEvents.indexOf(eventRecord) + 1];

        // At last event for resource, traverse down the resource store
        if (!nextEvent) {
            // If we are deleting an event, skip other instances of the event which we may encounter
            // due to multi-assignment.
            for (let rowIdx = resourceStore.indexOf(resourceRecord) + 1; (!nextEvent || (isDelete && nextEvent === eventRecord)) && rowIdx < resourceStore.count; rowIdx++) {
                resourceRecord = resourceStore.getAt(rowIdx);
                nextEvent = resourceRecord.getEvents().filter(me.isInTimeAxis).sort(sortByStartDate)[0];
            }
        }

        // If an assignment was passed, return one
        return isAssignment
            ? me.assignmentStore.getAssignmentForEventAndResource(nextEvent, resourceRecord)
            : nextEvent;
    }

    navigateNext(keyEvent) {
        const me = this,
            nextEvent = me.getNext(keyEvent.assignmentRecord || keyEvent.eventRecord);

        keyEvent.preventDefault();
        if (nextEvent) {
            if (!keyEvent.ctrlKey) {
                me.clearEventSelection();
            }
            me.navigateTo(nextEvent, keyEvent);
        }
    }

    navigateTo(targetEvent, uiEvent = {}) {
        const me = this;

        if (targetEvent) {
            // No key processing during scroll
            me.navigator.disabled = true;

            const resource = targetEvent.resource;
            me.scrollResourceEventIntoView(
                resource,
                targetEvent.isAssignment ? targetEvent.event : targetEvent,
                null,
                {
                    animate : 100
                }
            ).then(() => {
                // Panel can be destroyed before promise is resolved
                if (!me.isDestroyed) {
                    me.navigator.disabled = false;
                    me.activeEvent = targetEvent;
                    me.navigator.trigger('navigate', {
                        event : uiEvent,
                        item  : DomHelper.up(me.getElementFromEventRecord(targetEvent, resource), me.navigator.itemSelector)
                    });
                }
            });
        }
    }

    set activeEvent(eventOrAssignmentRec) {
        const eventEl = this.getElementFromEventRecord(
            eventOrAssignmentRec.isAssignment ? eventOrAssignmentRec.event : eventOrAssignmentRec,
            eventOrAssignmentRec.resource
        );

        this.navigator.activeItem = eventEl.parentNode;
    }

    get activeEvent() {
        const { activeItem } = this.navigator;

        if (activeItem) {
            return this.resolveEventRecord(activeItem);
        }
    }

    get previousActiveEvent() {
        const { previousActiveItem } = this.navigator;

        if (previousActiveItem) {
            return this.resolveEventRecord(previousActiveItem);
        }
    }

    processEvent(keyEvent) {
        const me = this,
            eventElement = DomHelper.up(keyEvent.target, me.eventSelector);

        if (!me.navigator.disabled && eventElement) {
            keyEvent.assignmentRecord = me.resolveAssignmentRecord(eventElement);
            keyEvent.eventRecord = me.resolveEventRecord(eventElement);
            keyEvent.resourceRecord = me.resolveResourceRecord(eventElement);
        }
        return keyEvent;
    }

    onDeleteKey(keyEvent) {
        const record = keyEvent.assignmentRecord || keyEvent.eventRecord;

        if (!this.readOnly && this.enableDeleteKey && record) {
            this.removeRecords([record]);
        }
    }

    /**
     * Internal utility function to remove events. Used when pressing [DELETE] or [BACKSPACE] or when clicking the
     * delete button in the event editor. Triggers a preventable `beforeEventDelete` event.
     * @param {Scheduler.model.EventModel[]} eventRecords Records to remove
     * @param {Function} [callback] Optional callback executed after triggering the event but before deletion
     * @returns {Boolean} Returns `false` if the operation was prevented, otherwise `true`
     * @internal
     * @fires beforeEventDelete
     */
    removeRecords(eventRecords, callback = null) {
        if (!this.readOnly && eventRecords.length) {
            const context = {
                finalize(removeRecord = true) {
                    if (callback) {
                        callback(removeRecord);
                    }
                    if (removeRecord !== false) {
                        eventRecords.forEach(r => r.remove());
                    }
                }
            };
            /**
             * Fires before an event is removed. Can be triggered by user pressing [DELETE] or [BACKSPACE] or by the
             * event editor. Can for example be used to display a custom dialog to confirm deletion, in which case
             * records should be "manually" removed after confirmation:
             *
             * ```javascript
             * scheduler.on({
             *    beforeEventDelete({ eventRecords, context }) {
             *        // Show custom confirmation dialog (pseudo code)
             *        confirm.show({
             *            listeners : {
             *                onOk() {
             *                    // Remove the events on confirmation
             *                    context.finalize(true);
             *                },
             *                onCancel() {
             *                    // do not remove the events if "Cancel" clicked
             *                    context.finalize(false);
             *                }
             *            }
             *        });
             *
             *        // Prevent default behaviour
             *        return false;
             *    }
             * });
             * ```
             *
             * @event beforeEventDelete
             * @param {Scheduler.view.Scheduler}     source                                  The Scheduler instance
             * @param {Scheduler.model.EventModel[]} eventRecords                            The records about to be deleted
             * @param {Object}                       context                                 Additional removal context:
             * @param {Function}                     context.finalize                        Function to call to finalize the removal.
             *      Used to asynchronously decide to remove the records or not. Provide `false` to the function to prevent the removal.
             * @param {Boolean}                      [context.finalize.removeRecords = true] Provide `false` to the function to prevent the removal.
             * @preventable
             */
            if (this.trigger('beforeEventDelete', { eventRecords, context }) !== false) {
                context.finalize();
                return true;
            }
        }

        return false;
    }

    onEventSpaceKey(keyEvent) {
        // Empty, to be chained by features (used by TimeSpanRecordContextMenuBase)
    }

    onEventEnterKey(keyEvent) {
        // Empty, to be chained by features (used by EventEdit)
    }

    get isActionableLocation() {
        // Override from grid if the Navigator's location is an event (or task if we're in Gantt)
        // Being focused on a task/event means that it's *not* actionable. It's not valid to report
        // that we're "inside" the cell in a TimeLine, so ESC must not attempt to focus the cell.
        if (!this.navigator.activeItem) {
            return super.isActionableLocation;
        }
    }

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
};

/**
 * @module Scheduler/view/orientation/BaseHorizontalMapper
 */

const
    emptyObject$3 = {},
    elRange     = document.createRange(),
    MAX_WIDTH   = 9999999;

function isEventElAvailable(element) {
    return !(element.classList.contains('b-dragging') || element.classList.contains('b-resizing'));
}

/**
 * Base class for task & event rendering in horizontal mode, used by Scheduler and Gantt
 * @private
 * @abstract
 */
class BaseHorizontalMapper extends Delayable(Base) {
    //region Init

    construct(view) {
        const me = this;

        me.view = view;
        me.innerElCls = `${view.eventCls}`;

        me.availableDivs = new Bag();
        me.reservedIds = {};
        me.divCount = 0;
    }

    init() {
        const me = this;

        me.view.rowManager.on({
            beforetranslaterow : me.onBeforeTranslateRow,
            translaterow       : me.onTranslateRow,
            beforerowheight    : me.onBeforeRowHeightChange,
            thisObj            : me
        });

        me.view.on({
            beforetogglenode     : me.onBeforeToggleNode,
            beforetoggleallnodes : me.onBeforeToggleAllNodes,
            thisObj              : me
        });
    }

    //endregion

    //region Helpers

    get column() {
        return this.view.timeAxisColumn;
    }

    get timeAxis() {
        return this.view.timeAxis;
    }

    get timeAxisViewModel() {
        return this.view.timeAxisViewModel;
    }

    translateToPageCoordinate(x) {
        const element = this.column.subGridElement;
        return x + element.getBoundingClientRect().left - element.scrollLeft;
    }

    //endregion

    //Region View hooks

    refreshRows(reLayoutEvents) {
        if (reLayoutEvents) {
            this.cache.clear(this.refreshFromRerender);
            this.view.refreshFromRerender = false;
        }
    }

    // If we dragged an event outside of its rendered block, it will have been released
    // but releaseTimeSpanDiv won't hide it if it has b-dragging, so we have to
    // hide it now.
    onDragAbort(context) {
        if (this.view.currentOrientation.availableDivs.includes(context.element)) {
            context.element.classList.add('b-sch-released');
        }
    }

    onLocaleChange() {
        // Clear events in case they use date as part of displayed info
        this.cache.clear();
    }

    //endregion

    //region Layout & render

    /**
     * Converts a start/endDate into a MS value used when rendering the timeSpan
     * @private
     * @abstract
     */
    calculateMS(timespanRecord) {
        throw new Error('Implement in subclass');
    }

    /**
     * Gets timespan coordinates etc. Relative to containing row. If the timespan is outside of the zone in
     * which timespans are rendered, that is outside of the TimeAxis, or outside of the vertical zone in which timespans
     * are rendered, then `undefined` is returned.
     * @private
     * @param {Scheduler.model.TimeSpan} timeSpan TimeSpan record
     * @param {Core.data.Model} rowRecord Row record
     * @param {Boolean|Object} includeOutside Specify true to get boxes for timespans outside of the rendered zone in both
     * dimensions. This option is used when calculating dependency lines, and we need to include routes from timespans
     * which may be outside the rendered zone.
     * @param {Boolean} includeOutside.timeAxis Pass as `true` to include timespans outside of the TimeAxis's bounds
     * @param {Boolean} includeOutside.viewport Pass as `true` to include timespans outside of the vertical timespan viewport's bounds.
     * @returns {Object} {{event/task: *, left: number, width: number, start: (Date), end: (Date), startMs: number, endMs: number, startsOutsideView: boolean, endsOutsideView: boolean}}
     */
    getTimeSpanRenderData(timeSpan, rowRecord, includeOutside = false) {
        const
            me                     = this,
            { timeAxis }           = me,
            includeOutsideTimeAxis = includeOutside === true || includeOutside.timeAxis,
            includeOutsideViewport = includeOutside === true || includeOutside.viewport;

        // If timespan is outside the TimeAxis, give up trying to calculate a layout (Unless we're including timespans
        // outside our zone)
        if (includeOutsideTimeAxis || timeAxis.isTimeSpanInAxis(timeSpan)) {
            const view = me.view,
                row  = view.getRowById(rowRecord);

            // If row is outside the rendered block, we cannot compute a timespan layout.
            if (row || includeOutsideViewport) {
                // TODO: buffer size as config
                const
                    scrollTop      = view.scrollable.y,
                    viewportTop    = Math.max(scrollTop - 50, 0),
                    viewportBottom = Math.min(scrollTop + view._bodyRectangle.height + 50, view.virtualScrollHeight);

                // If the row is outside the zone in which we render timespans, give up trying to calculate a
                // layout (Unless we're including timespans outside our zone)
                if (includeOutsideViewport || (row.top < viewportBottom && (row.top + (row.height || row.lastHeight)) >= viewportTop)) {
                    const
                        pxPerMinute                    = me.timeAxisViewModel.getSingleUnitInPixels('minute'),
                        timespanStart                  = timeSpan.startDate,
                        timespanEnd                    = timeSpan.endDate || timespanStart, // Allow timespans to be rendered even when they are missing an end date
                        viewStartMS                    = timeAxis.startMS,
                        viewEndMS                      = timeAxis.endMS,
                        { startMS, endMS, durationMS } = me.calculateMS(timeSpan),
                        // These flags have two components because includeOutsideViewport
                        // means that we can be calculating data for events either side of
                        // the TimeAxis.
                        // The start is outside of the view if it's before *or after* the TimeAxis range.
                        // 1 set means the start is before the TimeAxis
                        // 2 set means the start is after the TimeAxis
                        // Either way, a truthy value means that the start is outside of the TimeAxis.
                        startsOutsideView              = startMS < viewStartMS  | ((startMS >  viewEndMS)   << 1),
                        // The end is outside of the view if it's before *or after* the TimeAxis range.
                        // 1 set means the end is after the TimeAxis
                        // 2 set means the end is before the TimeAxis
                        // Either way, a truthy value means that the end is outside of the TimeAxis.
                        endsOutsideView                = endMS   > viewEndMS    | ((endMS   <= viewStartMS) << 1),
                        durationMinutes                = durationMS / (1000 * 60),
                        width                          = endsOutsideView ? pxPerMinute * durationMinutes : null; //view.getCoordinateFromDate(viewStartMS + durationMS),

                    let endX = view.getCoordinateFromDate(endMS, {
                            local            : true,
                            respectExclusion : true,
                            isEnd            : true
                        }), startX, clippedStart = false, clippedEnd = false;

                    // If event starts outside of view, estimate where.
                    if (startsOutsideView) {
                        startX = (startMS - viewStartMS) / (1000 * 60) * pxPerMinute;
                    }
                    // Starts in view, calculate exactly
                    else {
                        // If end date is included in time axis but start date is not (when using time axis exclusions), snap start date to next included data
                        startX = view.getCoordinateFromDate(startMS, {
                            local              : true,
                            respectExclusion   : true,
                            isEnd              : false,
                            snapToNextIncluded : endX !== -1
                        });

                        clippedStart = startX === -1;
                    }

                    if (endsOutsideView) {
                        endX = startX + width;
                    }
                    else {
                        clippedEnd = endX === -1;
                    }

                    if (clippedEnd && !clippedStart) {
                        // We know where to start but not where to end, snap it (the opposite is already handled by the
                        // snapToNextIncluded flag when calculating startX above)
                        endX = view.getCoordinateFromDate(endMS, {
                            local              : true,
                            respectExclusion   : true,
                            isEnd              : true,
                            snapToNextIncluded : true
                        });
                    }

                    // If the element is very wide there's no point in displaying it all.
                    // Indeed the element may not be displayable at extremely large widths.
                    if (width > MAX_WIDTH) {
                        // The start is before the TimeAxis start
                        if (startsOutsideView === 1) {
                            // Both ends outside - spans TimeAxis
                            if (endsOutsideView === 1) {
                                startX = -100;
                                endX = view.timeAxisColumn.width + 100;
                            }
                            // End is in view
                            else {
                                startX = endX - MAX_WIDTH;
                            }
                        }
                        // The end is after, but the start is in view
                        else if (endsOutsideView === 1) {
                            endX = startX + MAX_WIDTH;
                        }
                    }

                    if (clippedStart && clippedEnd) {
                        // Both ends excluded, but there might be some part in between that should be displayed...
                        startX = view.getCoordinateFromDate(startMS, {
                            local              : true,
                            respectExclusion   : true,
                            isEnd              : false,
                            snapToNextIncluded : true,
                            max                : endMS
                        });

                        endX = view.getCoordinateFromDate(endMS, {
                            local              : true,
                            respectExclusion   : true,
                            isEnd              : true,
                            snapToNextIncluded : true,
                            min                : startMS
                        });

                        if (startX === endX) {
                            // Raise flag on instance meta to avoid duplicating this logic
                            timeSpan.instanceMeta(view).excluded = true;
                            // Excluded by time axis exclusion rules, render nothing
                            return null;
                        }
                    }

                    const data                           = {
                        [me.view.scheduledEventName] : timeSpan,
                        left                         : Math.min(startX, endX),
                        width                        : Math.abs(endX - startX),
                        start                        : timespanStart,
                        end                          : timespanEnd,
                        startMs                      : startMS,
                        endMs                        : endMS,
                        rowId                        : rowRecord.id,
                        startsOutsideView,
                        endsOutsideView,
                        clippedStart,
                        clippedEnd,
                        row
                    };

                    // If filling ticks we need to also keep datas MS values, since they are used for sorting timespans
                    if (me.view.fillTicks) {
                        data.dataStartMs = data.start.getTime();
                        data.dataEndMs = data.end.getTime();
                    }

                    // in ExtScheduler this is only checked when managedEventSizing is true, but we need top because of positioning
                    data.top = Math.max(0, view.resourceMargin);

                    if (view.managedEventSizing) {
                        // Timespan height should be at least 1px
                        data.height = Math.max(view.rowManager.rowHeight - (2 * view.resourceMargin), 1);
                    }

                    return data;
                }
            }
        }
    }

    onTranslateRow({ source : row }) {

    }

    onBeforeRowHeightChange(event) {
        const
            view      = this.view,
            newHeight = event ? event.height : view.rowHeight;

        this.cache.clear();

        // TODO: should move out of here to scheduler
        if (view.foregroundCanvas) {
            view.element.classList.add('b-notransition');
            view.foregroundCanvas.style.fontSize = `${newHeight - view.resourceMargin * 2}px`;

            // We must force a style recalculation so that the next measurement of milestoneWidth
            // gets the new value.
            this._thisIsAUsedExpression(window.getComputedStyle(view.foregroundCanvas).fontSize);
            view.element.classList.remove('b-notransition');
        }

        // The Dependencies feature will have to recalculate its milestoneWidth when it is refreshed next.
        view.milestoneWidth = null;
    }

    onBeforeTranslateRow({ row }) {
        // Triggered before row is repurposed with new record on scroll.
        // Clear layout for the outgoing record.
        this.cache.clearRow(row.id);
    }

    onViewportResize() {
        // Force layout even if scroll positions have not changed.
        this.lastUpdateScrollPos = null;

        // Update the layout.
        this.update();
    }

    // /**
    //  * Called when all rows are rerendered, following a sort operation etc.
    //  * @private
    //  */
    // onBeforeFullRender() {
    //     this.cache.clear();
    // }

    positionTimeSpan(el, x, y) {
        const mode = this.view.eventPositionMode || 'translate';

        switch (mode) {
            case 'position':
                el.style.left = `${x}px`;
                el.style.top = `${y}px`;
                return;
            case 'translate':
                el.style.transform = `translate(${x}px,${y}px)`;
                return;
            case 'translate3d':
                el.style.transform = `translate3d(${x}px,${y}px,0)`;
        }
    }

    getTimeSpanDiv(timeSpanData) {
        const
            me                = this,
            { availableDivs } = me,
            { id, oldId }     = timeSpanData;

        if (me.view.eventScrollMode === 'move') {
            let wrapperElement;

            // Allow a TimeSpan to reuse the last div that was assigned to it so that transitions may be used when
            // editing an event. Will fallback to old id, to cover cases where id has changed since last update
            if (id) {
                wrapperElement = availableDivs.get(id) || availableDivs.get(oldId);
            }

            // Do not return it if it's in use by drag/drop or resize
            if (wrapperElement && !isEventElAvailable(wrapperElement)) {
                wrapperElement = null;
            }

            // No element which matches the requested element id available.
            // Just allocate one from the cache which is not being dragged or resized.
            if (!wrapperElement) {
                wrapperElement = availableDivs.find(isEventElAvailable);
            }

            if (wrapperElement) {
                availableDivs.remove(wrapperElement);
                wrapperElement.classList.remove('b-sch-released');
            }
            return wrapperElement;
        }
        return null;
    }

    releaseTimeSpanDiv(div, remainVisible = false) {
        const me = this,
            divStyle = div.style;

        // Some browsers do not blur on set to display:none, so releasing the active element
        // must *explicitly* move focus outwards to the view.
        if (!remainVisible && div === document.activeElement) {
            me.view.focusElement.focus();
        }

        if (me.view.eventScrollMode === 'move') {
            me.availableDivs.add(div);
            if (!remainVisible && isEventElAvailable(div)) {
                div.classList.add('b-sch-released');
            }
        }
        else {
            if (!remainVisible) {
                divStyle.opacity = 0;
                divStyle.pointerEvents = 'none';
                me.setTimeout(() => {
                    div.remove();
                    divStyle.opacity = 1;
                    divStyle.pointerEvents = '';
                }, 200);
            }
        }
    }

    updateElementId(element, newId) {
        const { availableDivs } = this;

        // Change the id, and move it to the end so that it won't be immediately
        // be consumed by the next request for an element, but is more likely to
        // remain to be found by its original owner TimeSpan
        if (availableDivs.includes(element)) {
            availableDivs.changeId(element, newId);
            // Used to be Collection.move(). Deleting and adding to end of Bags Set to mimic
            availableDivs.items.delete(element);
            availableDivs.items.add(element);
        }
    }

    triggerPaint(data, element) {
        throw new Error('Implement in subclass');
    }

    // forceNewElement is true for newly added events, to not "steal" an element that might be needed later on in the
    // same row (which triggers a transition from that location to the new)
    renderTimeSpan(data, cache, renderedTimeSpan, forceNewElement = false) {
        const
            me   = this,
            view = me.view,
            {
                cls,
                id
            }    = data;

        let wrapperElement = cache && cache.div,
            changedDiv     = false,
            trigger        = false,
            isRepaint      = false,
            innerElement;

        // TODO: this fn should not need to be called for events already in view, unless there is some update. might give a little better performance

        // No div assigned, reuse one if possible and such mode is used
        if (!forceNewElement && !wrapperElement && (wrapperElement = me.getTimeSpanDiv(data))) {
            // changedDiv means that we're using somebody else's element.
            changedDiv = wrapperElement.id !== id;
        }

        const isDragCreateProxy = wrapperElement && wrapperElement.classList.contains('b-sch-dragcreator-proxy');

        // No div assigned or reusing some other TimeSpan's released div
        if (!wrapperElement || changedDiv) {
            // Reusing another TimeSpan's released element.
            // It needs to be emptied.
            if (changedDiv) {
                // If there's no .b-sch-event, then it could be a resourceTimeRange element
                // so just use firstElementChild.
                innerElement =  wrapperElement.innerElement || wrapperElement.firstElementChild;
                innerElement.innerHTML = '';
                innerElement.style.cssText = '';
                if (innerElement.nextSibling) {
                    elRange.setStartAfter(innerElement);
                    elRange.setEndAfter(wrapperElement.lastChild);
                    elRange.deleteContents();
                }
            }
            // New element needed
            else {
                [wrapperElement, innerElement] = DomHelper.createElement({
                    tabIndex : 0,

                    // adding inner div which will be rendered as the event
                    children : [{
                        className : `${me.innerElCls}`
                    }]
                }, true);
                // To not have to retrieve it from DOM later
                wrapperElement.innerElement = innerElement;
            }

            wrapperElement.id = id;
            // Add event/task id to wrappers dataset
            if (data[view.scheduledEventName + 'Id']) {
                wrapperElement.dataset[view.scheduledEventName + 'Id'] = data[view.scheduledEventName + 'Id'];
            }

            DomHelper.syncClassList(wrapperElement, data.wrapperCls);

            if (wrapperElement.parentNode !== view.foregroundCanvas) {
                view.foregroundCanvas.appendChild(wrapperElement);
            }

            // set all attributes
            DomHelper.syncClassList(innerElement, cls);
            if (data.style || data.internalStyle) {
                innerElement.style.cssText = (data.internalStyle || '') + (data.style || '');
            }

            // Only update content if the data block has new content in it
            if (data.body) {
                // Clone because this operation has to be repeatable
                innerElement.appendChild(data.body.cloneNode(true));
            }

            // positioning and sizing wrapper
            wrapperElement.style.cssText = `width:${data.width}px;height:${data.height}px;${data.wrapperStyle || ''}`;
            me.positionTimeSpan(wrapperElement, data.left, data.top);

            trigger = true;
        }
        // Reusing TimeSpan's own div - it's a repaint
        else {
            // has div, update attributes if needed.
            const old = (renderedTimeSpan && cache.div) ? renderedTimeSpan : emptyObject$3;

            innerElement = wrapperElement.querySelector(`.${me.innerElCls}`) || wrapperElement.firstElementChild;

            // We are updating an existing event here, it may have lifecycle classes
            // such as resizing, or terminals visible etc.
            // Surgically update the class list of the elements.
            DomHelper.syncClassList(wrapperElement, data.wrapperCls);
            DomHelper.syncClassList(innerElement, data.cls);

            // TODO: have to apply style on each update when specified, or store it and check if changed
            if (data.style) {
                innerElement.style.cssText = data.style;
            }
            // Clear style, might have changed from having a style to not having
            else {
                innerElement.style.cssText = '';
            }

            // Only update content if the data block has new content in it
            if (data.body) {
                const
                    oldInnerHTML = innerElement.innerHTML,
                    // TODO: Not in use? Should be used by labels? Percent bar in gantt? Store them in an array to avoid QSA
                    featureEls = innerElement.featureEls; //innerElement.querySelectorAll('[data-feature]');

                if (featureEls) {
                    featureEls.forEach(featureEl => data.body.appendChild(featureEl));
                }
                innerElement.innerHTML = '';

                // Clone because this operation has to be repeatable
                innerElement.appendChild(data.body.cloneNode(true));

                // trigger only if content changed
                trigger = innerElement.innerHTML !== oldInnerHTML;
            }

            // Wrapper element gets the focus class.
            if (document.activeElement && document.activeElement.id === data.id) {
                wrapperElement.classList.add(view.focusCls);
            }

            // updates to wrapper
            isRepaint = true;

            if (data.wrapperStyle) {
                wrapperElement.style.cssText += data.wrapperStyle;
            }

            if (old.left !== data.left || old.top !== data.top || data.style) {
                me.positionTimeSpan(wrapperElement, data.left, data.top);
                trigger = true;
            }
            if (old.width !== data.width || data.style) {
                wrapperElement.style.width = `${data.width}px`;
                trigger = true;
            }
            if (old.height !== data.height || data.style) {
                wrapperElement.style.height = `${data.height}px`;
                trigger = true;
            }
        }

        cache.div = wrapperElement;
        cache.eventEl = innerElement;

        if (trigger) {
            // If we are rendering to a drag-create proxy, it's not a repaint
            if (isRepaint && isDragCreateProxy) {
                isRepaint = false;
                wrapperElement.classList.remove('b-sch-dragcreator-proxy');
            }
            // trigger paint or repaint, for features to hook into
            me.triggerPaint(data, wrapperElement, isRepaint);
        }

        return wrapperElement;
    }

    /**
     * Adds an element for recycling to the event element recycling cache for the passed Event/Task if
     * there is no cache entry. Use this to prevent cache misses and the re-use by
     * event rendering of elements for other events which means that the element would have to be heavily
     * modified.
     * @param {Scheduler.model.TimeSpan} timeSpanRecord The event/task to create an element recycling cache entry for.
     * @param {Scheduler.model.ResourceModel} [resourceRecord] The associated resource record.
     * @param {HTMLElement} [element] The element to add to the element recycling cache under that id.
     */
    cacheTimeSpanElement(timeSpanRecord, resourceRecord, element) {
        const
            me                      = this,
            { availableDivs, view } = me,
            timeSpanRecordId        = view.getEventRenderId(timeSpanRecord, resourceRecord);

        if (!availableDivs.includes(timeSpanRecordId)) {
            if (element) {
                element.id = timeSpanRecordId;
                view.foregroundCanvas.appendChild(element);
            }
            else {
                element = DomHelper.createElement({
                    id       : timeSpanRecordId,
                    tabIndex : 0,

                    // adding inner div which will be rendered as the event
                    children : [{
                        className : `${me.innerElCls}`
                    }]
                });
            }
            availableDivs.add(element);
        }
    }

    updateRowTimeSpans(row, rowRecord, forceLayout = false, fromHorizontalScroll = false) {}

    renderer(renderData) {}

    updateFromHorizontalScroll(scrollLeft) {
        const
            scrollBuffer        = 100,
            me                  = this,
            view                = me.view,
            width               = view.timeAxisSubGrid.width,
            startDate           = view.getDateFromX(Math.max(0, scrollLeft - scrollBuffer)),
            endDate             = view.getDateFromX(scrollLeft + width + scrollBuffer) || view.timeAxis.endDate,
            x                   = me.view.timeAxisSubGrid.scrollable.x,
            lastUpdateScrollPos = me.lastUpdateScrollPos;

        // TODO: make buffer width a config, add in correct unit
        me.viewportStart = (startDate && startDate.getTime());
        me.viewportEnd = (endDate && endDate.getTime());

        // Only rerender all events if we have scrolled horizontally by at least half
        // of the buffer zone above which is 100 pixels.
        if (!lastUpdateScrollPos || Math.abs(x - lastUpdateScrollPos.x) > scrollBuffer / 2) {
            me.update();
        }

        // Update timeaxis header making it display the new dates
        view.timeView.range = { startDate, endDate };
    }

    update() {
        const
            me   = this,
            view = me.view;

        me.lastUpdateScrollPos = {
            x : view.timeAxisSubGrid.scrollable.x,
            y : view.scrollable.y
        };

        for (const row of view.rowManager) {
            const cell   = row.getCell(view.timeAxisColumn.id),
                cellData = DomDataStore.get(cell),
                record   = view.store.getById(cellData.id);

            if (record) {
                me.updateRowTimeSpans(cellData.row, record, false, true);
            }
        }
    }

    //endregion

    //region Dates

    getDateFromXY(xy, roundingMethod, local, allowOutOfRange = false) {
        let coord = xy[0];

        if (!local) {
            coord = this.translateToScheduleCoordinate(coord);
        }

        return this.timeAxisViewModel.getDateFromPosition(coord, roundingMethod, allowOutOfRange);
    }

    translateToScheduleCoordinate(x) {
        const pos = x - this.column.subGridElement.getBoundingClientRect().left;

        return pos + this.view.scrollLeft;
    }

    //endregion

    //region Store events

    /**
     * User toggled a node in a tree grid, events needs to be redrawn since they might appear/disappear
     * @private
     */
    onBeforeToggleNode({ record }) {
        const
            me         = this,
            childCount = record.children && record.children.length;

        // If there are no children to toggle, we must not clear below the
        // toggling line because there's going to be no upcoming data change to fix it.
        if (childCount) {
            // The node being toggled doesn't need events clearing.
            // It just has its expand/collapse icon toggled.
            let currentRowRecord = me.view.store.getNext(record);

            while (currentRowRecord && me.view.getRowFor(currentRowRecord)) {
                me.cache.clearRow(currentRowRecord.id);
                currentRowRecord = me.view.store.getNext(currentRowRecord.id);
            }
        }
    }
    
    onBeforeToggleAllNodes() {
        this.cache.clear();
    }

    // Row updated, clear cache keeping div to animate changes
    onRowRecordUpdate({ record, changes = {} }) {
        // If id was changed need to clear cache for old id
        // https://github.com/bryntum/support/issues/385
        if ('id' in changes) {
            this.cache.clearRow(changes.id.oldValue, false, true);
        }
        
        this.cache.clearRow(record.id, false, true);
    }

    // Row removed (resource/task), clear cache
    onRowRecordRemove({ records }) {
        // Records might be parents, always traversing makes sure children are also cleared. For leafs, traverse only
        // affects the node itself. If a parent and its children are removed at once, it will still work since clearing
        // cache again has no side effects
        records.forEach(record =>
            record.traverse(r => this.cache.clearRow(r.id))
        );
    }

    //endregion

    //region Region

    /**
     * Gets the Region, relative to the timeline view element, representing the passed row and optionally just for a
     * certain date interval.
     * @param {Core.data.Model} rowRecord The row record
     * @param {Date} startDate A start date constraining the region
     * @param {Date} endDate An end date constraining the region
     * @return {Core.helper.util.Rectangle} The Rectangle which encapsulates the row
     */
    getRowRegion(rowRecord, startDate, endDate) {
        const
            { view, column } = this,
            row              = view.getRowById(rowRecord.id);

        // might not be rendered
        if (!row) {
            return null;
        }

        const
            rowElement = row.getElement(column.region),
            taStart    = this.timeAxis.startDate,
            taEnd      = this.timeAxis.endDate,
            start      = startDate ? DateHelper.max(taStart, startDate) : taStart,
            end        = endDate ? DateHelper.min(taEnd, endDate) : taEnd,
            startX     = view.getCoordinateFromDate(start),
            endX       = view.getCoordinateFromDate(end, true, true),
            y          = row.top + view.verticalScroller.scrollTop,
            x          = Math.min(startX, endX),
            bottom     = y + rowElement.offsetHeight;

        return new Rectangle(x, y, Math.max(startX, endX) - x, bottom - y);
    }

    getVisibleDateRange() {
        const view        = this.view,
            scrollPos = view.timeAxisSubGrid.scrollable.x,
            width     = view.timeAxisSubGrid.width;

        return {
            startDate : view.getDateFromX(scrollPos),
            endDate   : view.getDateFromX(scrollPos + width) || view.timeAxis.endDate
        };
    }

    //endregion

    //region Dependency connectors

    /**
     * Gets displaying item start side
     *
     * @param {Scheduler.model.EventModel} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorStartSide(eventRecord) {}

    /**
     * Gets displaying item end side
     *
     * @param {Scheduler.model.EventModel} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorEndSide(eventRecord) {}

    //endregion
}
BaseHorizontalMapper._$name = 'BaseHorizontalMapper';

class HorizontalEventMapperCache {
    constructor(mapper) {
        const me = this;

        me.mapper = mapper;

        // caching layout calculations
        me.renderedEventsMap = {};
        me.rowLayoutCache = {};
    }

    /**
     * Clear event & row layout cache (removes cached layout for all resources and events)
     * @internal
     */
    clear(removeDivs = false) {
        const me = this;

        me.renderedEventsMap = {};
        Object.keys(me.rowLayoutCache).forEach(resourceId => me.clearRow(resourceId, removeDivs ? 'immediate' : false));
    }

    //region Render data

    addRenderedEvents(resourceId, data) {
        this.renderedEventsMap[resourceId] = data;
    }

    addRenderedEvent(eventData) {
        // If the resource is not layed out (outside of rendered block)
        // then this is a no-op.
        if (eventData.resourceId in this.renderedEventsMap) {
            const resourceRenderedEvents = this.renderedEventsMap[eventData.resourceId] || (this.renderedEventsMap[eventData.resourceId] = {});

            resourceRenderedEvents[eventData.id] = eventData;
        }
    }

    getRenderedTimeSpan(resourceId, eventElementId) {
        const resourceRenderedEvents = this.renderedEventsMap[resourceId];

        return resourceRenderedEvents && resourceRenderedEvents[eventElementId];
    }

    clearRenderedTimeSpan(resourceId, eventElementId) {
        const resourceRenderedEvents = this.renderedEventsMap[resourceId];

        if (resourceRenderedEvents) {
            const result = this.renderedEventsMap[resourceId][eventElementId];

            delete this.renderedEventsMap[resourceId][eventElementId];
            return result;
        }
    }

    getRenderedEvents(resourceId) {
        return this.renderedEventsMap[resourceId];
    }

    clearRenderedEvents(resourceId) {
        this.renderedEventsMap[resourceId] = null;
    }

    //endregion

    //region TimeSpans

    getTimeSpan(timeSpanId, rowId) {
        const timeSpanCache = this.getTimeSpanCache(timeSpanId, rowId);

        if (!timeSpanCache) return null;

        return timeSpanCache.layoutCache;
    }
    
    getTimeSpanCache(timeSpanId, rowId) {
        const resourceCache = this.rowLayoutCache[rowId];
        
        return resourceCache && resourceCache[timeSpanId];
    }

    /**
     * Clears the event layout for the passed event and resource. Will usually preserve
     * the event DIVs for recycling unless `removeDiv` is passed. If preserving them,
     * it will hide the div unless `remainVisible` is passed.
     * @param {*} eventId ID of event
     * @param {*} resourceId ID of resource
     * @param {*} removeDiv Defaults to false
     * @param {*} remainVisible Defaults to false
     * @private
     */
    clearEvent(eventId, resourceId, removeDiv = false, remainVisible = false) {
        const me = this,
            eventCache = me.getTimeSpan(eventId, resourceId);

        if (!eventCache) return null;

        if (eventCache.div) {
            me.mapper.clearDiv(eventCache.div, removeDiv, remainVisible);
        }

        me.rowLayoutCache[resourceId][eventId].layoutCache = null;
    }

    //endregion

    //region Row

    getRow(resourceId) {
        return this.rowLayoutCache[resourceId];
    }

    addRow(resourceId, data) {
        this.rowLayoutCache[resourceId] = data;
    }

    clearRow(resourceId, removeDivs = false, remainVisible = false) {
        const me            = this,
            resourceCache = me.rowLayoutCache[resourceId];

        if (!resourceCache) return;

        if (me.renderedEventsMap[resourceId]) delete me.renderedEventsMap[resourceId];

        Object.keys(resourceCache).forEach(eventId => {
            if (eventId !== '_allEvents' && eventId !== '_rowHeight') {
                me.clearEvent(eventId, resourceId, removeDivs, remainVisible);
            }
        });
        delete me.rowLayoutCache[resourceId];
    }

    //endregion
}
HorizontalEventMapperCache._$name = 'HorizontalEventMapperCache';

/**
 * @module Scheduler/view/orientation/HorizontalEventMapper
 */

const getStartEnd = (view, timeAxis, date, dateMS, useEnd) => {
    if (view.fillTicks) {
        let tick = timeAxis.getTickFromDate(date);

        if (tick >= 0) {
            // If date matches a tick start/end, use the earlier tick
            if (useEnd && tick === Math.round(tick) && tick > 0) {
                tick--;
            }

            const
                tickIndex  = Math.floor(tick),
                tickRecord = timeAxis.getAt(tickIndex);

            return tickRecord[useEnd ? 'endDate' : 'startDate'].getTime();
        }
    }

    return dateMS;
};

/**
 * Handles rendering of events when scheduler uses horizontal mode. The need to interact with this class should be
 * minimal, most functions are called from Scheduler or its mixins.
 * @private
 */
class HorizontalEventMapper extends BaseHorizontalMapper {
    //region Init

    construct(scheduler) {
        this.scheduler = scheduler;

        super.construct(scheduler);

        this.cache = new HorizontalEventMapperCache(this);
    }

    init() {
        const me = this;

        super.init();

        this.scheduler.on({
            togglegroup : me.onToggleGroup,
            rowremove   : me.onRowRemove,
            prio        : 2,
            thisObj     : me
        });
    }

    //endregion

    //region Div reusage

    // called from cache when removing events
    clearDiv(div, remove, remainVisible) {
        const me = this,
            divStyle = div.style;

        if (!remove || remainVisible) {
            me.releaseTimeSpanDiv(div, remainVisible);
        }
        // For example when adding events we remove all existing immediately to not have the new event transition into
        // place by from reusing an existing element. Also want to remove right away when not using event animations.
        else if (remove === 'immediate' || !me.scheduler.enableEventAnimations) {
            div.remove();
        }
        else {
            // The div doesn't get removed until the opacity transition has done.
            // Avoid id collisions if the event is rerendered immediately.
            // Can't set it to "" because of test requirements.
            div.id = IdHelper.generateId('obsolete-event');
            divStyle.opacity = 0;
            divStyle.pointerEvents = 'none';
            me.setTimeout(() => {
                div.remove();
                divStyle.opacity = 1;
                divStyle.pointerEvents = '';
            }, 200);
        }
    }

    // called from cache when removing events
    clearAllDivs() {
        const me = this;
        me.availableDivs.forEach(div => div.remove());
        me.availableDivs.clear();
    }

    clearEvents() {
        this.cache.clear(true);
    }

    /**
     * Releases elements for events no longer in view.
     */
    releaseEvent(rowId, timeSpanElementId, remainVisible = false) {
        const me         = this,
            timeSpanData = me.cache.getRenderedTimeSpan(rowId, timeSpanElementId),
            cache        = timeSpanData && me.cache.getTimeSpan(timeSpanData.eventId, rowId);

        if (cache && cache.div) {
            // release div. remember for reuse, if such mode is used
            me.releaseTimeSpanDiv(cache.div, remainVisible);
            cache.div = cache.eventEl = null;
        }
        return me.cache.clearRenderedTimeSpan(rowId, timeSpanElementId);
    }
    //endregion

    //region Elements

    getElementFromEventRecord(eventRecord, resourceRecord = this.scheduler.eventStore.getResourcesForEvent(eventRecord)[0]) {
        if (resourceRecord) {
            const renderedRowEvents = this.cache.getRenderedEvents(resourceRecord.id);

            if (renderedRowEvents) {
                const layoutId = this.scheduler.getEventRenderId(eventRecord, resourceRecord),
                    layout = renderedRowEvents[layoutId],
                    layoutCache = layout && layout.layoutCache;

                return layoutCache && layoutCache.eventEl;
            }
        }
    }

    getElementsFromEventRecord(eventRecord, resourceRecord) {
        const me = this;

        // Single event instance, as array
        if (resourceRecord) {
            return [me.getElementFromEventRecord(eventRecord, resourceRecord)];
        }
        // All instances
        else {
            return me.scheduler.eventStore.getResourcesForEvent(eventRecord).reduce((result, resourceRecord) => {
                const el = me.getElementFromEventRecord(eventRecord, resourceRecord);
                if (el) {
                    result.push(el);
                }
                return result;
            }, []);
        }
    }

    resolveRowRecord(elementOrEvent) {
        const
            me        = this,
            { view }  = me,
            element   = elementOrEvent instanceof Event ? elementOrEvent.target : elementOrEvent,
            // Fix for FF on Linux having text nodes as event.target
            el        = element.nodeType === 3 ? element.parentElement : element,
            eventNode = el.matches(view.eventSelector) && el || DomHelper.up(el, view.eventSelector);

        if (eventNode) {
            return view.getResourceRecordFromDomId(eventNode.id);
        }

        return view.getRecordFromElement(el);
    }

    toggleCls(eventRecord, resourceRecord, cls, add = true) {
        if (!resourceRecord) {
            return;
        }

        const
            eventLayout = this.cache.getTimeSpanCache(eventRecord.id, resourceRecord.id),
            element     = this.getElementFromEventRecord(eventRecord, resourceRecord);

        if (eventLayout) {
            eventLayout.cls[cls] = add ? 1 : 0;
        }

        if (element) {
            element.classList[add ? 'add' : 'remove'](cls);
        }
    }

    //endregion

    //region Region

    getResourceEventBox(eventId, resourceId) {
        const cached = this.cache.getTimeSpan(eventId, resourceId);
        if (cached) {
            return cached;
        }
    }

    /**
     * Gets the region, relative to the page, represented by the schedule and optionally only for a single resource. This method will call getDateConstraints to
     * allow for additional resource/event based constraints. By overriding that method you can constrain events differently for
     * different resources.
     * @param {Core.data.Model} rowRecord (optional) The row record
     * @param {Scheduler.model.EventModel} eventRecord (optional) The event record
     * @return {Object} The region of the schedule
     */
    getScheduleRegion(rowRecord, eventRecord, local = true) {
        const
            me     = this,
            view   = me.view,
            column = me.column;
        
        let region;

        if (rowRecord) {
            const eventElement = eventRecord && me.getElementsFromEventRecord(eventRecord, rowRecord)[0];

            region = Rectangle.from(view.getRowById(rowRecord.id).getElement('locked'));

            if (eventElement) {
                const eventRegion = Rectangle.from(eventElement, column.subGridElement);

                region.y = eventRegion.y;
                region.bottom = eventRegion.bottom;
            }
            else {
                region.y = region.y + view.resourceMargin;
                region.bottom = region.bottom - view.resourceMargin;
            }
        }
        else {
            // TODO: This is what the bizarre function that was removed here did.
            // The coordinate space needs to be sorted out here!
            region = Rectangle.from(column.subGridElement).moveTo(null, 0);
            region.width = column.subGridElement.scrollWidth;

            region.y = region.y + view.resourceMargin;
            region.bottom = region.bottom - view.resourceMargin;
        }
    
        const
            taStart         = me.timeAxis.startDate,
            taEnd           = me.timeAxis.endDate,
            dateConstraints = view.getDateConstraints(rowRecord, eventRecord) || {
                start : taStart,
                end   : taEnd
            },
            top             = region.y,
            bottom          = region.bottom;
    
        let startX = view.getCoordinateFromDate(DateHelper.max(taStart, dateConstraints.start)),
            endX   = view.getCoordinateFromDate(DateHelper.min(taEnd, dateConstraints.end));
        
        if (!local) {
            startX = me.translateToPageCoordinate(startX);
            endX = me.translateToPageCoordinate(endX);
        }

        return { top, right : Math.max(startX, endX), bottom, left : Math.min(startX, endX) };
    }

    getResoureEventBox(eventId, resourceId) {
        return this.cache.getTimeSpan(eventId, resourceId);
    }

    //endregion

    //region Layout & render

    //region Stack & pack

    layoutEventVerticallyStack(bandIndex) {
        const { resourceMargin, rowHeight, barMargin } = this.scheduler;
        return bandIndex === 0
            ? resourceMargin
            : resourceMargin + bandIndex * (rowHeight - resourceMargin * 2) + bandIndex * barMargin;
    }

    layoutEventVerticallyPack(topFraction, heightFraction) {
        const
            { resourceMargin, rowHeight, barMargin } = this.scheduler,
            // TODO reduce grid row borders when available, https://app.assembla.com/spaces/bryntum/tickets/5840-measure-grid-row-border-at-first-render/details#
            availableHeight = rowHeight - (2 * resourceMargin),
            count           = 1 / heightFraction,
            bandIndex       = topFraction * count, // "y" within row
            height          = (availableHeight - ((count - 1) * barMargin)) * heightFraction,
            top             = resourceMargin + bandIndex * height + bandIndex * barMargin;

        return {
            top, height
        };
    }

    //endregion

    /**
     * Converts a start/endDate into a MS value used when rendering the event. If scheduler is configured with
     * `fillTicks: true` the value returned will be snapped to tick start/end.
     * @private
     * @param {Scheduler.model.EventModel} eventRecord
     * @returns {Object} Object of format { startMS, endMS, durationMS }
     */
    calculateMS(eventRecord) {
        const me   = this,
            view = me.view;

        let startMS    = getStartEnd(view, me.timeAxis, eventRecord.startDate, eventRecord.startDateMS, false),
            endMS      = getStartEnd(view, me.timeAxis, eventRecord.endDate, eventRecord.endDateMS, true),
            durationMS = endMS - startMS;

        if (view.milestoneLayoutMode !== 'default' && durationMS === 0) {
            const pxPerMinute = me.timeAxisViewModel.getSingleUnitInPixels('minute'),
                lengthInPx  = view.getMilestoneLabelWidth(eventRecord),
                duration    = lengthInPx * (1 / pxPerMinute);

            durationMS = duration * 60 * 1000;

            switch (view.milestoneAlign) {
                case 'start':
                case 'left':
                    endMS = startMS + durationMS;
                    break;
                case 'end':
                case 'right':
                    endMS = startMS;
                    startMS = endMS - durationMS;
                    break;
                default: // using center as default
                    endMS = startMS + durationMS / 2;
                    startMS = endMS - durationMS;
                    break;
            }
        }

        return {
            startMS,
            endMS,
            durationMS
        };
    }

    /**
     * Layouts events on a row, caching on each event and the entire result on the resource
     * @private
     * @param {Scheduler.view.Scheduler} scheduler
     * @param {Scheduler.model.ResourceModel} resource
     * @param {Grid.row.Row} row
     * @returns {Boolean} Returns false if no events on row, otherwise true
     */
    layoutEvents(scheduler, resource, row) {
        const
            me             = this,
            { timeAxis }   = me,
            { eventStore } = scheduler,
            resourceId     = resource.id,
            resourceEvents = eventStore.getEventsForResource(resourceId),
            // When using an AssignmentStore we will get all events for the resource even if the EventStore is filtered,
            // handle this be excluding "invisible" events here
            availableEvents = eventStore.isFiltered ? resourceEvents.filter(eventRecord =>
                eventStore.indexOf(eventRecord) > -1
            ) : resourceEvents,
            // Call a chainable template function on scheduler to allow features to add additional "events" to render
            // Currently used by ResourceZones
            allEvents     = scheduler.getEventsToRender(resource, availableEvents) || [],
            events        = allEvents.filter(e => timeAxis.isTimeSpanInAxis(e)),
            // Generate layout data for events belonging to current row which are within the TimeAxis
            eventsTplData = events.reduce((result, event) => {
                const eventBox = scheduler.generateTplData(event, resource);

                // Collect layouts of visible events
                if (eventBox) {
                    result.push(eventBox);
                }
                // Release events that are no longer visible
                else if (me.cache.getRenderedEvents(resourceId)) {
                    me.releaseEvent(resourceId, scheduler.getEventRenderId(event, resource));
                }

                return result;
            }, []);

        // If there are no events within the rendering zone, clear the resource layout cache.
        // Return false to indicate that there's nothing to render.
        if (!eventsTplData.length) {
            me.cache.clearRenderedEvents(resourceId);
            return false;
        }

        // Ensure the events are rendered in natural order so that navigation works.
        eventsTplData.sort(scheduler.horizontalEventSorterFn || me.eventSorter);

        let rowHeight = scheduler.rowHeight;

        const
            layout = scheduler.currentEventLayout,
            // Only events and tasks should be considered during layout (not resource time ranges if any)
            layoutEventData = eventsTplData.filter(d => d.event.isEvent || d.event.isTask);

        // Event data is now gathered, calculate layout properties for each event
        if (scheduler.eventLayout === 'stack') {
            const
                nbrOfBandsRequired = layout.applyLayout(layoutEventData, resource),
                heightPerEvent     = scheduler.rowHeight - scheduler.resourceMargin * 2;

            rowHeight = (nbrOfBandsRequired * heightPerEvent) + ((nbrOfBandsRequired - 1) * scheduler.barMargin) + scheduler.resourceMargin * 2;
        }
        else if (scheduler.eventLayout === 'pack') {
            layout.applyLayout(layoutEventData, resource);
        }

        let absoluteTop = row.top;

        // adjust row top, when it is rendered on top (since in that case top is not known until height is set)
        if (rowHeight !== row.height && row.estimatedTop) {
            absoluteTop = row.top + row.height - rowHeight;
        }

        const cache = {
            _allEvents : eventsTplData,
            _rowHeight : rowHeight
        };

        // cache boxes
        eventsTplData.forEach(data => {
            const layout      = me.cache.getTimeSpan(data.eventId, resourceId),
                relativeTop = data.top;

            data.top += absoluteTop;
            data.rowTop = absoluteTop;

            // ResourceTimeRanges sets this flag to fill the entire row (can't use 100% since it is not actually in the row).
            // Also cant set it in ResourceTimeRanges#onEventDataGenerated since it is called prior to laying out
            if (data.fillSize) {
                data.height = rowHeight;
            }

            // TODO: Include directly in data instead, to simplify cache a wee bit
            // cache layout to not have to recalculate every time
            data.layoutCache = {
                layout         : true,
                // reuse div if already assigned (for example when resizing an event)
                div            : layout && layout.div,
                eventEl        : layout && layout.eventEl,
                width          : data.width,
                height         : data.height,
                start          : data.left,
                end            : data.left + data.width,
                relativeTop    : relativeTop,
                top            : data.top,
                relativeBottom : relativeTop + data.height,
                bottom         : data.top + data.height
            };

            cache[data.eventId] = data;
        });

        me.cache.addRow(resourceId, cache);
        //me.resourceLayoutCache[resourceId] = eventsTplData;

        return true;
    }

    // Earlier start dates are above later tasks
    // If same start date, longer tasks float to top
    // If same start + duration, sort by name
    eventSorter(a, b) {
        const
            startA    = a.dataStartMs || a.startMs, // dataXX are used if configured with fillTicks
            endA      = a.dataEndMs || a.endMs,
            startB    = b.dataStartMs || b.startMs,
            endB      = b.dataEndMs || b.endMs,
            sameStart = (startA === startB);

        if (sameStart) {
            if (endA - endB === 0) {
                return a.event.name < b.event.name ? -1 : 1;
            }
            return endA > endB ? -1 : 1;
        }

        return (startA < startB) ? -1 : 1;
    }

    /**
     * Called when rows are translated. Since events "float" on top of everything they must be adjusted if translation
     * changes.
     * @private
     */
    onTranslateRow({ row }) {
        this.matchRowTranslation(row);
    }

    /**
     * Renders a single event, creating a div for it if needed or updates an existing div.
     * @private
     * @param data
     */
    renderEvent(data) {
        const me            = this,
            eventIdProperty = me.view.scheduledEventName + 'Id',
            eventId         = data[eventIdProperty],
            layoutCache     = me.cache.getTimeSpan(eventId, data.resourceId),
            renderedEvents  = me.cache.getRenderedEvents(data.resourceId),
            meta            = data.event.instanceMeta(me.scheduler),
            // Event might be flagged to require a new element in onEventAdd, but if it is a drag proxy it should still
            // reuse an existing element (it will be correctly linked to the drag proxy element)
            wrapperElement  = me.renderTimeSpan(data, layoutCache, renderedEvents[data.id], meta.requireElement && !meta.fromDragProxy);

        if (data.assignment) {
            wrapperElement.dataset.assignmentId = data.assignment.id;
        }

        // Add event/task id to wrappers dataset
        // Otherwise event element won't have event id property in it's dataset and scheduler
        // won't be able to resolve event by element reference (#8943)
        if (eventId) {
            wrapperElement.dataset[eventIdProperty] = eventId;
        }

        renderedEvents[data.id] = data;

        if (meta.requireElement) {
            delete meta.requireElement;
            delete meta.fromDragProxy;
        }

        // This event is documented on Scheduler
        me.scheduler.trigger('renderEvent', {
            eventRecord      : data.event,
            resourceRecord   : data.resource,
            assignmentRecord : data.assignment,
            element          : wrapperElement,
            tplData          : data
        });
    }

    // Overrides fn from baseclass to trigger a paint event with correct params
    triggerPaint(data, element, isRepaint = false) {
        const { scheduler } = this;

        scheduler.trigger(isRepaint ? 'eventRepaint' : 'eventPaint', {
            scheduler,
            eventRecord    : data.event,
            resourceRecord : data.resource,
            element
        });
    }

    // We only have to ask this question in the horizontal axis.
    // Vertical rendering is driven fully by the Grid's RowManager
    // rendering and derendering rows.
    isEventInView(eventLayout) {
        

        // Milestones need to be visible at start & end
        if (eventLayout.startMs === eventLayout.endMs) {
            return eventLayout.startMs <= this.viewportEnd && eventLayout.endMs > this.viewportStart;
        }

        // But normal events do not
        return eventLayout.startMs < this.viewportEnd && eventLayout.endMs > this.viewportStart;
    }

    // Displays events that are in view, hides/recycles those that are no longer
    updateRowTimeSpans(row, resource, forceLayout = false, fromHorizontalScroll = false) {
        const
            me         = this,
            scheduler  = me.scheduler,
            resourceId = resource.id;

        let renderedEvents      = me.cache.getRenderedEvents(resourceId),
            resourceLayoutCache = me.cache.getRow(resourceId);

        // no need to relayout events if only scrolling horizontally
        if ((scheduler.forceLayout || forceLayout || !resourceLayoutCache) && !me.layoutEvents(scheduler, resource, row)) {
            return (resourceLayoutCache && resourceLayoutCache._rowHeight) || 0;
        }

        // might have been updated above
        resourceLayoutCache = me.cache.getRow(resourceId);

        if (!resourceLayoutCache) return 0;

        const eventsInView = resourceLayoutCache._allEvents.filter(evt =>
            // Keep events flagged by for example EventDrag
            evt.event.instanceMeta(scheduler).retainElement ||
            // Assignment might also be flagged if used
            (evt.assignment &&  evt.assignment.instanceMeta(scheduler).retainElement) ||
            // And keep events actually in view :)
            me.isEventInView(evt)
        );

        if (!renderedEvents) {
            renderedEvents = {};
            me.cache.addRenderedEvents(resourceId, renderedEvents);
        }

        // Add events not already in dom or refresh those that are
        for (let i = 0; i < eventsInView.length; i++) {
            const data = eventsInView[i];

            // There are multiple pathways that might lead to the first render of events. This is the first reliable
            // place were we can determine that something will be rendered
            scheduler._firstRenderDone && scheduler._firstRenderDone();

            // Do not render events whose element is retained, or if scrolling horizontally already has an element
            if ((!fromHorizontalScroll && !data.event.instanceMeta(scheduler).retainElement) ||
                (fromHorizontalScroll && !data.layoutCache.div)) {

                const animation = scheduler.isFirstRender && data.top < scheduler.bodyHeight && scheduler.useInitialAnimation;

                if (animation) {
                    data.wrapperCls.add('b-first-render');
                    data.internalStyle = `animation-delay: ${data.row.index / 20}s;`;
                }

                me.renderEvent(data);

                data.wrapperCls['b-first-render'] = null;
            }
        }

        // Remove already rendered events that are now outside of view
        const renderedEventIds = Object.keys(renderedEvents);
        for (let i = 0; i < renderedEventIds.length; i++) {
            const eventId = renderedEventIds[i];
            if (!eventsInView.some(e => e.id === eventId)) {
                me.releaseEvent(resourceId, eventId);
            }
        }

        return resourceLayoutCache._rowHeight;
    }

    renderer(renderData) {
        // Render the resource's events.
        renderData.size.height = this.updateRowTimeSpans(renderData.row, renderData.record);
    }

    //endregion

    //region Store events

    matchRowTranslation(row) {
        const me            = this,
            // Cannot check row.id because translation happens before render, id might not be updated.
            recordId      = me.scheduler.store.getAt(row.dataIndex).id,
            resourceCache = me.cache.getRow(recordId),
            first         = resourceCache && resourceCache._allEvents.length > 0 && resourceCache._allEvents[0];

        // only update events whose resource has changed top
        if (first && first.rowTop !== row.top) {
            const deltaY = row.top - first.rowTop;
            resourceCache._allEvents.forEach(data => {
                const eventLayout = data.layoutCache;
                eventLayout.top += deltaY;
                eventLayout.bottom += deltaY;
                if (eventLayout.div) {
                    me.positionTimeSpan(eventLayout.div, eventLayout.start, eventLayout.top);
                }

                data.top += deltaY;
                data.rowTop = row.top;
            });
        }
    }

    onTimeAxisViewModelUpdate() {
        // if we do not clear cache, refresh will happen and will use older cache
        // caught by test 012_dragdrop
        this.cache.clear();

        // TODO: this always happen, unnecessary to perform layout prior to this?

        // always update view bounds and redraw events
        this.updateFromHorizontalScroll(this.scheduler.timeAxisSubGrid.scrollable.x);
    }

    // resource removed, move all affected events up
    onRowRemove({ isCollapse }) {
        const { scheduler } = this;

        if (!isCollapse) {
            scheduler.runWithTransition(() => {
                scheduler.rowManager.forEach(row => this.matchRowTranslation(row));
            });
        }
    }

    /**
     * User toggled a group in a grouped grid, events needs to be redrawn since they might appear/disappear
     * @private
     */
    onToggleGroup({ groupRecord, collapse }) {
        const store       = this.scheduler.store;
        // First record in next group
        let recordIndex = store.indexOf(groupRecord) + (collapse ? 1 : groupRecord.groupChildren.length);

        // Handle this group
        if (collapse) {
            // Collapsing -> events in the group will be hidden, remove them from cache
            groupRecord.groupChildren.forEach(child => {
                this.cache.clearRow(child.id);
            });
        }

        // TODO: this should not need to loop til the end, since only events in view are drawn. will be costly with large amount of resources
        // Loop starting at the next group
        for (; recordIndex < store.count; recordIndex++) {
            this.cache.clearRow(store.getAt(recordIndex).id);
        }
    }

    onEventDataset() {
        // Previously dataset would use onEventAdd, but if we get fewer events than we had some will stick around
        // just for the fun of it. Better clear all
        this.cache.clear(true);
    }

    onEventAdd({ records, resources }) {
        const me = this;

        records.forEach(event => {
            const { startDate, endDate } = event;

            if (startDate && endDate && me.timeAxis.timeSpanInAxis(startDate, endDate)) {
                const eventResources = event.resources;
                // Flag that this event needs a new element, it should not steal some other released events element because
                // that might lead to a transition. Only set if event will be in view
                if (eventResources && eventResources.some(resource => me.scheduler.getRowFor(resource))) {
                    event.instanceMeta(me.scheduler).requireElement = true;
                }

                // TODO: this does not make sense when adding multiple events, resources are then not tied to the event
                // repaint row only if event is in time axis
                resources.forEach(resource => {
                    this.cache.clearRow(resource.id, false, true);
                });
            }
        });
    }

    onEventRemove({ records, resources }) {
        const me = this;

        // Remove the divs fully since creation now adopts the proxy to use as the event div
        resources.forEach(resource =>
            me.cache.clearRow(resource.id, true)
            //scheduler.store.getIndex(resource) >= 0 && scheduler.repaintEventsForResource(resource)
        );
    }

    onEventUpdate({ source : eventStore, record : eventRecord, changes = {}, resources }) {
        const me                 = this,
            resourceWasChanged = 'resourceId' in changes;

        // A change happened to an event missing a resource, do nothing
        if (!resourceWasChanged && !resources.length) return;

        // Moved to another resource, invalidate both old and new (only applies when not using an AssignmentStore)
        if (resourceWasChanged) {
            const oldResource              = eventStore.resourceStore.getById(changes.resourceId.oldValue),
                newResource              = eventRecord.resource,
                eventRenderedAfterUpdate = newResource && eventStore.resourceStore.isAvailable(newResource),
                isVisible = eventRecord.resource && Boolean(me.getTimeSpanRenderData(eventRecord, eventRecord.resource));

            // invalidate old and new resource event layouts
            if (oldResource) {
                const oldLayout = me.cache.getTimeSpan(eventRecord.id, oldResource.id);

                // If the event is layed out for oldResource, that resources needs to be redrawn
                if (oldLayout) {
                    // If it's to be rerendered after the change, set the div's
                    // id so that after it's returned to the cache, it will be plucked
                    // out by the renderer to be reused.
                    if (eventRenderedAfterUpdate) {
                        // If it has an element, release the div, but release it under the id for
                        // which it *will* be used when the cleared resource rows are rerendered.
                        if (oldLayout.div && newResource) {
                            oldLayout.div.id = me.scheduler.getEventRenderId(eventRecord, newResource);
                        }
                        me.cache.clearRow(oldResource.id, false, eventRenderedAfterUpdate);
                    }
                    // If it's not going to be rerendered, dump the div completely
                    else {
                        me.cache.clearEvent(eventRecord.id, changes.resourceId.oldValue, true);
                    }
                }
            }
            // Event was added first and then assigned to a resource (or similar scenario). There will be no div tied to
            // the event and it might reuse an element reserved for some other event (which will transition in to place)
            // TODO: Rework element reusage to always process events with existing elements first and then "new",
            //   when done this workaround and the one in onEventAdd() can be removed
            else if (eventRenderedAfterUpdate) {
                eventRecord.instanceMeta(me.scheduler).requireElement = true;
            }

            eventRenderedAfterUpdate && me.cache.clearRow(newResource.id, false, isVisible);

            // TODO: Not so sure we should throw the average away on account of a single row that might change height,
            //  check if it works good without this/make gradual adjustment
            me.scheduler.rowManager.resetAverageRowHeight(); // force recalculation, since moving events might have affected row height
        }
        // start or end date changed, need to update layout
        else if (('startDate' in changes || 'endDate' in changes)) {
            resources.forEach(resourceRecord => {
                // Moving events on a row with multiple events might affect those other events, or the height of the row
                // which affects everything below
                if (me.scheduler.eventStore.getEventsForResource(resourceRecord).length > 1) {
                    // TODO: Not so sure we should throw the average away on account of a single row that might change height,
                    //  check if it works good without this/make gradual adjustment
                    me.scheduler.rowManager.resetAverageRowHeight();
                }
            });
        }

        resources.forEach(resourceRecord => {
            const eventLayoutData = me.getTimeSpanRenderData(eventRecord, resourceRecord),
                isVisible = Boolean(eventLayoutData && me.isEventInView(eventLayoutData));

            // Clear cache, avoiding to hide the element if visible
            me.cache.clearRow(resourceRecord.id, false, isVisible);
        });
    }

    // Event id changed, change elements id to have it reused correctly on redraw
    onEventStoreIdChange({ oldValue, value }) {
        const { view } = this;

        DomHelper.forEachSelector(view.element, `[data-event-id="${oldValue}"]`, el => {
            el.id = view.getEventRenderId(value, view.getResourceIdFromDomNodeId(el.id));
        });
    }

    onEventClearChanges() {
        this.cache.clear();
    }

    onEventFilter() {
        this.cache.clear();
    }

    onEventRemoveAll() {
        this.view.rowManager.resetAverageRowHeight(); // force recalculation, since moving events might have affected row height
        this.cache.clear(true);
    }

    //endregion

    //region Dependency connectors

    /**
     * Gets displaying item start side
     *
     * @param {Scheduler.model.EventModel} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorStartSide(eventRecord) {
        return 'left';
    }

    /**
     * Gets displaying item end side
     *
     * @param {Scheduler.model.EventModel} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorEndSide(eventRecord) {
        return 'right';
    }

    //endregion
}
HorizontalEventMapper._$name = 'HorizontalEventMapper';

/**
 * @module Scheduler/eventlayout/VerticalLayout
 */

/**
 * Assists with event layout in vertical mode, handles `eventLayout: none|pack|mixed`
 * @private
 * @mixes Scheduler/eventlayout/PackMixin
 */
class VerticalLayout extends PackMixin() {

    static get defaultConfig() {
        return {
            coordProp : 'leftFactor',
            sizeProp  : 'widthFactor'
        };
    }

    // Try to pack the events to consume as little space as possible
    applyLayout(events, columnWidth, resourceMargin, barMargin, columnIndex) {
        super.applyLayout(events, (tplData, clusterIndex, slot, slotSize) => {
            // Stretch events to fill available width
            if (this.scheduler.eventLayout === 'none') {
                tplData.width = columnWidth - resourceMargin * 2;
                tplData.left += resourceMargin;
            }
            else {
                // Fractions of resource column
                tplData.widthFactor = slotSize;

                const
                    leftFactor      = tplData.leftFactor = slot.start + (clusterIndex * slotSize),
                    // Number of "columns" in the current slot
                    packColumnCount = Math.round(1 / slotSize),
                    // Index among those columns for current event
                    packColumnIndex = leftFactor / slotSize,
                    // Width with all bar margins subtracted
                    availableWidth  = columnWidth - resourceMargin * 2 - barMargin * (packColumnCount - 1);

                // Allowing two events to overlap? Slightly offset the second
                if (this.scheduler.eventLayout === 'mixed' && packColumnCount === 2) {
                    tplData.left += leftFactor * columnWidth / 5 + barMargin;
                    tplData.width = columnWidth - leftFactor * columnWidth / 5 - barMargin * 2;
                    tplData.zIndex = 5 + packColumnIndex;
                }
                // Pack by default
                else {
                    // Fractional width
                    tplData.width = slotSize * availableWidth;
                    // Translate to absolute position
                    tplData.left += leftFactor * availableWidth + resourceMargin + barMargin * packColumnIndex;
                }
            }
        });
    }
}
VerticalLayout._$name = 'VerticalLayout';

const
    releaseEventActions = {
        'releaseElement' : 1, // Not used at all at the moment
        'reuseElement'   : 1  // Used by some other element
    },
    renderEventActions = {
        'newElement'      : 1,
        'reuseOwnElement' : 1,
        'reuseElement'    : 1
    },
    emptyArray$4 = Object.freeze([]);

class VerticalEventMapper extends Delayable(Base) {

    //region Config & Init

    static get properties() {
        return {
            eventMap         : {},
            resourceMap      : {},
            releasedElements : {}
        };
    }

    construct(scheduler) {
        this.scheduler = scheduler;
        this.timeAxisViewModel = scheduler.timeAxisViewModel;
        this.verticalLayout = new VerticalLayout({ scheduler });

        super.construct({});
    }

    init() {
        const
            me = this,
            { scheduler } = me;

        // Resource header/columns
        me.resourceColumns = scheduler.timeAxisColumn.resourceColumns;

        scheduler.element.classList.add('b-sch-vertical');

        scheduler.on({
            assignmentstorechange : me.onChangeAssignmentStore,
            resourcestorechange   : me.onChangeResourceStore,
            thisObj               : me
        });

        me.resourceColumns.on({
            columnWidthChange : me.onResourceColumnWidthChange,
            thisObj           : me
        });

        me.resourceStore = scheduler.resourceStore;
        me.assignmentStore = scheduler.assignmentStore;

        me.initialized = true;

        if (scheduler.isPainted) {
            me.renderer();
        }

        me.resourceColumns.availableWidth = scheduler.timeAxisSubGrid.width;
    }

    //endregion

    //region Elements <-> Records

    resolveRowRecord(elementOrEvent, xy) {
        const
            me            = this,
            { scheduler } = me,
            event         = elementOrEvent instanceof Event ? elementOrEvent : null,
            element       = event ? event.target : elementOrEvent,
            coords        = event ? [event.offsetX, event.offsetY] : xy,
            // Fix for FF on Linux having text nodes as event.target
            el            = element.nodeType === 3 ? element.parentElement : element,
            eventElement  = DomHelper.up(el, scheduler.eventSelector);

        if (eventElement) {
            return scheduler.resourceStore.getById(eventElement.dataset.resourceId);
        }

        // Need to be inside schedule at least
        if (!DomHelper.up(element, '.b-sch-timeaxis-cell')) {
            return null;
        }

        if (!coords) {
            throw new Error(`Vertical mode needs coordinates to resolve this element. Can also be called with a browser 
                event instead of element to extract element and coordinates from`);
        }

        const index = Math.floor(coords[0] / me.resourceColumns.columnWidth);

        return scheduler.resourceStore.getAt(index);
    }

    getElementFromEventRecord(eventRecord, resourceRecord) {
        // All elements for event + optionally assigned resource
        const elements = this.getElementsFromEventRecord(eventRecord, resourceRecord);
        // Return first one
        return elements.length ? elements[0] : null;
    }

    getElementsFromEventRecord(eventRecord) {
        // Holds resources for which the event is drawn
        const map = this.eventMap[eventRecord.id];
        // Return the elements for those.
        // Important: getElement(s)FromEventRecord returns the event bar, not the positioning wrapper
        // which may house labels, baseline elements, dependency terminals etc.
        return map ? Object.values(map).map(data => data.element && data.element.querySelector(this.scheduler.eventInnerSelector)) : emptyArray$4;
    }

    toggleCls(eventRecord, resourceRecord, cls, add = true) {
        const eventData = ObjectHelper.getPath(this.eventMap, `${eventRecord.id}.${resourceRecord.id}`);

        if (eventData) {
            eventData.tplData.cls[cls] = add ? 1 : 0;

            if (eventData.element) {
                eventData.element.querySelector(this.scheduler.eventInnerSelector).classList[add ? 'add' : 'remove'](cls);
            }
        }
    }

    //endregion

    //region Coordinate <-> Date

    getDateFromXY(xy, roundingMethod, local, allowOutOfRange = false) {
        let coord = xy[1];

        if (!local) {
            coord = this.translateToScheduleCoordinate(coord);
        }

        return this.timeAxisViewModel.getDateFromPosition(coord, roundingMethod, allowOutOfRange);
    }

    translateToScheduleCoordinate(y) {
        return y - this.scheduler._bodyRectangle.y + this.scheduler.scrollTop;
    }

    translateToPageCoordinate(y) {
        return y + this.scheduler._bodyRectangle.y - this.scheduler.scrollTop;
    }

    //endregion

    //region Regions

    getResourceEventBox(eventId, resourceId) {
        let { tplData } = ObjectHelper.getPath(this.eventMap, `${eventId}.${resourceId}`) || {};

        if (!tplData) {
            // Never been in view, lay it out
            this.layoutResource(this.scheduler.resourceStore.getById(resourceId));

            // Have another go at getting the layout data
            tplData = ObjectHelper.getPath(this.eventMap, `${eventId}.${resourceId}`).tplData;
        }

        return tplData ? {
            start  : tplData.left,
            end    : tplData.left + tplData.width,
            top    : tplData.top,
            bottom : tplData.bottom
        } : null;
    }

    getScheduleRegion(resourceRecord, eventRecord, local) {
        const
            me            = this,
            { scheduler } = me;

        let region = Rectangle.from(scheduler.timeAxisSubGridElement);

        if (resourceRecord) {
            // TODO: How to account for eventRecord here?
            region.left  = me.resourceStore.indexOf(resourceRecord) * scheduler.resourceColumnWidth;
            region.right = region.left + scheduler.resourceColumnWidth;
        }

        const
            start           = scheduler.timeAxis.startDate,
            end             = scheduler.timeAxis.endDate,
            dateConstraints = scheduler.getDateConstraints(resourceRecord, eventRecord) || {
                start,
                end
            },
            startY          = scheduler.getCoordinateFromDate(DateHelper.max(start, dateConstraints.start)),
            endY            = scheduler.getCoordinateFromDate(DateHelper.min(end, dateConstraints.end));

        if (!local) {
            region.top = me.translateToPageCoordinate(startY);
            region.bottom = me.translateToPageCoordinate(endY);
        }
        else {
            region.top = startY;
            region.bottom = endY;
        }

        return region;
    }

    getRowRegion(resourceRecord, startDate, endDate) {
        const
            me            = this,
            { scheduler } = me,
            x             = me.resourceStore.indexOf(resourceRecord) * scheduler.resourceColumnWidth,
            taStart       = scheduler.timeAxis.startDate,
            taEnd         = scheduler.timeAxis.endDate,
            start         = startDate ? DateHelper.max(taStart, startDate) : taStart,
            end           = endDate ? DateHelper.min(taEnd, endDate) : taEnd,
            startY        = scheduler.getCoordinateFromDate(start),
            endY          = scheduler.getCoordinateFromDate(end, true, true),
            y             = Math.min(startY, endY),
            height        = Math.abs(startY - endY);

        return new Rectangle(x, y, scheduler.resourceColumnWidth, height);
    }

    getVisibleDateRange() {
        const
            scheduler = this.scheduler,
            scrollPos = scheduler.scrollable.y,
            height    = scheduler.scrollable.clientHeight;

        return {
            startDate : scheduler.getDateFromCoordinate(scrollPos),
            endDate   : scheduler.getDateFromCoordinate(scrollPos + height) || scheduler.timeAxis.endDate
        };
    }
    //endregion

    //region Events

    // Column width changed, rerender fully
    onResourceColumnWidthChange({ width, oldWidth }) {
        const
            me = this,
            { scheduler } = me;

        // Fix width of column & header
        me.resourceColumns.width = scheduler.timeAxisColumn.width = me.resourceStore.count * width;
        me.clearAll();

        // Only transition large changes, otherwise it is janky when dragging slider in demo
        scheduler.runWithTransition(() => me.renderer(), Math.abs(width - oldWidth) > 30);

        // Not detected by resizeobserver? Need to call this for virtual scrolling to react to update
        //        scheduler.callEachSubGrid('refreshFakeScroll');
        //        scheduler.refreshVirtualScrollbars();
    }

    //endregion

    //region EventStore

    onEventStoreChange({ action, records, record, replaced, changes, fromRelationUpdate }) {
        const
            me = this,
            eventRecords = records || (record ? [record] : []),
            resourceIds = new Set();

        let transition = true;

        eventRecords.forEach(eventRecord => {
            eventRecord.resources.forEach(resourceRecord => resourceIds.add(resourceRecord.id));
        });

        switch (action) {
            // No-ops
            case 'sort':
            case 'group':
            case 'move':
                // Order in EventStore does not matter, so these actions are no-ops
                return;

            case 'dataset':
                me.clearAll();
                transition = false;
                break;

            case 'add':
            case 'remove':
            case 'updateMultiple':
                // Clear all affected resources
                me.clearResources(resourceIds);
                break;

            case 'replace':
                // Gather resources from both the old record and the new one
                replaced.forEach(([oldEvent, newEvent]) => {
                    oldEvent.resources.map(resourceRecord => resourceIds.add(resourceRecord.id));
                    newEvent.resources.map(resourceRecord => resourceIds.add(resourceRecord.id));
                });
                // And clear them
                me.clearResources(resourceIds);
                break;

            case 'removeall':
            case 'filter':
                // Clear all when filtering for simplicity. If that turns out to give bad performance, one would need to
                // figure out which events was filtered out and only clear their resources.
                me.clearAll();
                break;

            case 'update':
                // Removing a resource will unassign events, triggering an update. Ignore this case, since it will be
                // handled by the resource store listener
                if (record.meta.removingResource) {
                    return;
                }

                let processed = false;

                // Potentially affecting more elements in the same resource
                if ('startDate' in changes || 'endDate' in changes || 'duration' in changes || 'id' in changes) {
                    me.clearResources(resourceIds);
                    processed = true;
                }

                // Moved between resources, redraw both ends (new value already extracted above)
                if ('resourceId' in changes) {
                    // unless if caused by a relation update (changed resources id), in which case it will be handled
                    // by onResourceStoreChange()
                    if (fromRelationUpdate) {
                        return;
                    }

                    resourceIds.add(changes.resourceId.oldValue);
                    me.clearResources(resourceIds);
                    processed = true;
                }

                // "Internal" change, not affecting layout
                if (!processed) {
                    const eventDatas = Object.values(me.eventMap[record.id]);
                    eventDatas.forEach(eventData => {
                        // Update layout/contents
                        const { tplData } = eventData;
                        eventData.tplData = me.scheduler.generateTplData(tplData.eventRecord, tplData.resourceRecord);
                        eventData.tplData.left = tplData.left;
                        eventData.tplData.width = tplData.width;
                    });
                }
                break;
        }

        me.scheduler.runWithTransition(() => me.renderer(), transition);
    }

    //endregion

    //region ResourceStore

    // Hook up resource store for the mapper and the resource header
    set resourceStore(store) {
        const me = this;

        me.resourceStoreDetacher && me.resourceStoreDetacher();

        me.resourceColumns.resourceStore = me._resourceStore = store;

        me.resourceStoreDetacher = store.on({
            change  : me.onResourceStoreChange,
            refresh : me.onResourceStoreRefresh,
            thisObj : me,
            prio    : 1 // Call before others to clear cache before redraw
        });
    }

    get timeView() {
        return this.scheduler.timeView;
    }

    get resourceStore() {
        return this._resourceStore;
    }

    onChangeResourceStore({ newResourceStore }) {
        const me = this;

        // Invalidate resource range and events
        me.firstResource = me.lastResource = null;
        me.clearAll();

        me.resourceStore = newResourceStore;

        me.renderer();
    }

    onResourceStoreChange({ source : resourceStore, action, records, record }) {
        const
            me = this,
            resourceRecords = records || (record ? [record] : []);

        let transition = true;

        // Invalidate resource range
        me.firstResource = me.lastResource = null;

        switch (action) {
            case 'add':
                // Make sure all existing events following added resources are offset correctly
                const firstIndex = resourceRecords.reduce(
                    (index, record) => Math.min(index, resourceStore.indexOf(record)),
                    resourceStore.count
                );

                for (let i = firstIndex; i < resourceStore.count; i++) {
                    me.clearResources([resourceStore.getAt(i).id]);
                }

                return; // Will be redrawn from column width change

            case 'remove':
            case 'removeall':
                // Cannot tell from which index a record was removed, update all.
                me.clearAll();
                return; // Will be redrawn from column width change

            case 'replace':
            case 'update':
                // Only the invalidation above needed
                break;

            case 'filter':
                // All filtered out resources needs clearing and so does those not filtered out since they might have
                // moved horizontally when others hide
                me.clearAll();
                break;
        }

        me.scheduler.runWithTransition(() => me.renderer(), transition);
    }

    onResourceStoreRefresh({ action }) {
        const me = this;

        if (action === 'group') {
            throw new Error('Grouping of resources not supported in vertical mode');
        }

        if (action === 'sort') {
            // Invalidate resource range
            me.firstResource = me.lastResource = null;
            me.clearAll();
            me.scheduler.runWithTransition(() => me.renderer());
        }
    }

    //endregion

    //region AssignmentStore

    // Hook up assignment store for the mapper
    set assignmentStore(store) {
        const me = this;

        me.assignmentStoreDetacher && me.assignmentStoreDetacher();

        me._assignmentStore = store;

        if (store) {
            me.assignmentStoreDetacher = store.on({
                change  : me.onAssignmentStoreChange,
                thisObj : me
            });
        }
    }

    get assignmentStore() {
        return this._assignmentStore;
    }

    onChangeAssignmentStore({ newAssignmentStore }) {
        this.assignmentStore = newAssignmentStore;
    }

    onAssignmentStoreChange({ action, records, replaced, record, changes }) {
        const
            me                = this,
            assignmentRecords = records || (record ? [record] : []),
            resourceIds       = new Set(assignmentRecords.map(assignmentRecord => assignmentRecord.resourceId));

        let transition = true;

        switch (action) {
            case 'add':
            case 'remove':
            case 'updateMultiple':
                me.clearResources(resourceIds);
                break;

            case 'filter':
            case 'removeall':
                me.clearAll();
                break;

            case 'replace':
                // Gather resources from both the old record and the new one
                replaced.forEach(([oldAssignment, newAssignment]) => {
                    resourceIds.add(oldAssignment.resourceId);
                    resourceIds.add(newAssignment.resourceId);
                });
                // And clear them
                me.clearResources(resourceIds);
                break;

            case 'update':
                // When reassigning, clear old resource also
                if ('resourceId' in changes) {
                    resourceIds.add(changes.resourceId.oldValue);
                }
                me.clearResources(resourceIds);
                break;
        }

        me.scheduler.runWithTransition(() => me.renderer(), transition);
    }

    //endregion

    //region View hooks

    refreshRows(reLayoutEvents) {
        if (reLayoutEvents) {
            this.clearAll();
            this.scheduler.refreshFromRerender = false;
        }
    }
    updateFromHorizontalScroll(scrollLeft) {
        if (scrollLeft !== this.prevScrollLeft) {
            this.renderer();
            this.prevScrollLeft = scrollLeft;
        }
    }

    updateFromVerticalScroll() {
        this.renderer();
    }

    scrollResourceIntoView(resourceRecord, options) {
        const
            { scheduler } = this,
            x = scheduler.resourceStore.indexOf(resourceRecord) * scheduler.resourceColumnWidth;

        return scheduler.scrollHorizontallyTo(x, options);
    }

    // Called when viewport size changes
    onViewportResize(width) {
        this.resourceColumns.availableWidth = width;
        this.renderer();
    }

    // Clear events in case they use date as part of displayed info
    onLocaleChange() {
        this.clearAll();
    }

    // No need to do anything special
    onDragAbort() {}

    onBeforeRowHeightChange() {}

    onTimeAxisViewModelUpdate() {}

    clearEvents() {}

    updateElementId() {}

    releaseTimeSpanDiv() {}

    //endregion

    //region Rendering

    // Resources in view + buffer
    get resourceRange() {
        const { scheduler, resourceStore } = this;

        if (!resourceStore || !resourceStore.count) {
            return { firstResource : -1, lastResource : -1 };
        }

        return {
            firstResource : Math.max(Math.floor(scheduler.scrollLeft / scheduler.resourceColumnWidth) - 1, 0),
            lastResource  : Math.min(
                Math.floor((scheduler.scrollLeft + scheduler.timeAxisSubGrid.width) /  scheduler.resourceColumnWidth) + 1,
                resourceStore.count - 1
            )
        };
    }

    // Dates in view + buffer
    get dateRange() {
        const
            { scheduler } = this;

        let bottomDate = scheduler.getDateFromCoordinate(Math.min(
            scheduler.scrollTop + scheduler.bodyHeight + scheduler.tickSize - 1,
            (scheduler.virtualScrollHeight || scheduler.scrollable.scrollHeight) - 1)
        );

        // Might end up below time axis (out of ticks)
        // TODO: Change call order on refresh to make sure this is not needed?
        if (!bottomDate) {
            bottomDate = scheduler.timeAxis.last.endDate;
        }

        return {
            topDate : scheduler.getDateFromCoordinate(Math.max(scheduler.scrollTop - scheduler.tickSize, 0)),
            bottomDate
        };
    }

    getTimeSpanRenderData(eventRecord, resourceRecord, includeOutside = false) {
        const
            me            = this,
            { scheduler } = me,
            { startDate, endDate } = eventRecord,
            top           = scheduler.getCoordinateFromDate(startDate),
            // Preliminary values for left & width, used for proxy. Will be changed on layout
            left          = me.resourceStore.indexOf(resourceRecord) * scheduler.resourceColumnWidth,
            width         = scheduler.resourceColumnWidth - scheduler.resourceMargin * 2,
            startDateMS   = startDate.getTime(),
            endDateMS     = endDate.getTime();

        let bottom = scheduler.getCoordinateFromDate(endDate),
            height = bottom - top;

        // Below, estimate height
        if (bottom === -1) {
            height = Math.round((endDateMS - startDateMS) * scheduler.timeAxisViewModel.getSingleUnitInPixels('ms'));
            bottom = top + height;
        }

        return {
            eventRecord,
            resourceRecord,
            left,
            top,
            bottom,
            width,
            height,
            startDate,
            endDate,
            startDateMS,
            endDateMS,

            // to match horizontal, TODO: should change there
            start   : startDate,
            end     : endDate,
            startMs : startDateMS,
            endMs   : endDateMS
        };
    }

    // Earlier start dates are above later tasks
    // If same start date, longer tasks float to top
    // If same start + duration, sort by name
    eventSorter(a, b) {
        const
            startA    = a.dataStartMs || a.startDateMS, // dataXX are used if configured with fillTicks
            endA      = a.dataEndMs || a.endDateMS,
            startB    = b.dataStartMs || b.startDateMS,
            endB      = b.dataEndMs || b.endDateMS,
            sameStart = (startA === startB);

        if (sameStart) {
            if (endA - endB === 0) {
                return a.eventRecord.name < b.eventRecord.name ? -1 : 1;
            }
            return endA > endB ? -1 : 1;
        }

        return (startA < startB) ? -1 : 1;
    }

    // Calculate the layout for all events assigned to a resource. Since we are never stacking, the layout of one
    // resource will never affect the others
    layoutResource(resourceRecord) {
        const
            me = this,
            { scheduler } = me,
            // Cache per resource
            cache = me.resourceMap[resourceRecord.id] = {},
            // Resource "column"
            resourceIndex = scheduler.resourceStore.indexOf(resourceRecord);

        // All events for the resource
        let events = scheduler.eventStore.getEventsForResource(resourceRecord);

        // Hook for features to inject additional timespans to render
        events = scheduler.getEventsToRender(resourceRecord, events);

        // Generate template data for all events, used for rendering and layout
        const layoutData = events.reduce((toLayout, eventRecord) => {
            const
                tplData = scheduler.generateTplData(eventRecord, resourceRecord),
                // Elements will be appended to eventData during syncing
                eventData = { tplData };

            // Cache per event, { e1 : { r1 : { xxx }, r2 : ... }, e2 : ... }
            // Uses tplData.eventId in favor of eventRecord.id to work with ResourceTimeRanges
            ObjectHelper.setPath(me.eventMap, `${tplData.eventId}.${resourceRecord.id}`, eventData);

            // Cache per resource
            cache[tplData.eventId] = eventData;

            // Position ResourceTimeRanges directly, they do not affect the layout of others
            if (tplData.fillSize) {
                tplData.left  = resourceIndex * scheduler.resourceColumnWidth;
                tplData.width = scheduler.resourceColumnWidth;
            }
            // Anything not flagged with `fillSize` should take part in layout
            else {
                toLayout.push(tplData);
            }

            return toLayout;
        }, []);

        // Ensure the events are rendered in natural order so that navigation works.
        layoutData.sort(me.eventSorter);

        // Apply per resource event layout (pack, overlap or mixed)
        me.verticalLayout.applyLayout(
            layoutData,
            scheduler.resourceColumnWidth,
            scheduler.resourceMargin,
            scheduler.barMargin,
            resourceIndex
        );

        return cache;
    }

    // Render a single event, aborting if already in DOM. To update an event, first release its element and then render
    // it again. The element will be reused and updated. Keeps code simpler
    renderEvent(eventData) {
        // No point in rendering event that already has an element
        const
            data = eventData.tplData,
            { resourceRecord, eventRecord } = data,
            // Event element config, applied to existing element or used to create a new one below
            elementConfig = {
                className : data.wrapperCls,
                tabIndex  : '0',
                children  : [
                    {
                        className   : data.cls,
                        style       : (data.internalStyle || '') + (data.style || ''),
                        // Clone to be repeatable
                        html        : data.body.cloneNode(true),
                        // Used for comparison, cheaper than comparing fragment from above
                        compareHtml : data.eventContent
                    }
                ],
                style : {
                    transform : `translate(${data.left}px, ${data.top}px)`,
                    // DomHelper appends px to dimensions when using numbers
                    height    : data.height,
                    width     : data.width,
                    zIndex    : data.zIndex
                },
                dataset : {
                    resourceId : resourceRecord.id,
                    eventId    : data.eventId, // Not using eventRecord.id to distinguish between Event and ResourceTimeRange
                    // Sync using assignment id in multi assignment mode or event id in single assignment mode
                    syncId     : data.assignment ? data.assignment.id : data.eventId

                },
                // Will not be part of DOM, but attached to the element
                elementData   : eventData,
                // Dragging etc. flags element as retained, to not reuse/release it during that operation
                retainElement : eventRecord.instanceMeta(this.scheduler).retainElement
            };

        // Do not want to spam dataset with empty prop when not using assignments
        if (data.assignment) {
            elementConfig.dataset.assignmentId = data.assignment.id;
        }

        return elementConfig;
    }

    renderResource(resourceRecord) {
        const
            me                          = this,
            // Date at top and bottom for determining which events to include
            { topDateMS, bottomDateMS } = me,
            // Will hold element configs
            syncConfigs                 = [];

        let resourceEntry = me.resourceMap[resourceRecord.id];

        // Layout all events for the resource unless already done
        if (!resourceEntry) {
            resourceEntry = me.layoutResource(resourceRecord);
        }

        // Iterate over all events for the resource
        for (let eventId in resourceEntry) {
            const eventData = resourceEntry[eventId];
            // Only collect configs for those actually in view
            if (eventData.tplData.endDateMS >= topDateMS && eventData.tplData.startDateMS <= bottomDateMS) {
                syncConfigs.push(me.renderEvent(eventData));
            }
        }

        return syncConfigs;
    }

    // Single cell so only one call to this renderer, determine which events are in view and draw them.
    // Drawing on scroll is triggered by `updateFromVerticalScroll()` and `updateFromHorizontalScroll()`
    renderer() {
        const
            me                              = this,
            { scheduler }                   = me,
            { resourceStore }               = scheduler,
            // Determine resource range to draw events for
            { firstResource, lastResource } = me.resourceRange,
            // Date at top and bottom for determining which events to include
            { topDate, bottomDate }         = me.dateRange,
            syncConfigs                     = [],
            featureDomConfigs               = [];

        if (!me.initialized) {
            return;
        }

        

        // Update current time range, reflecting the change on the vertical time axis header
        if (!DateHelper.isEqual(topDate, me.topDate) || !DateHelper.isEqual(bottomDate, me.bottomDate)) {
            // Calculated values used by `renderResource()`
            me.topDate = topDate;
            me.bottomDate = bottomDate;
            me.topDateMS = topDate.getTime();
            me.bottomDateMS = bottomDate.getTime();

            me.timeView.range = { startDate : topDate, endDate : bottomDate };
        }

        if (firstResource !== -1 && lastResource !== -1) {
            // Collect all events for resources in view
            for (let i = firstResource; i <= lastResource; i++) {
                syncConfigs.push.apply(syncConfigs, me.renderResource(resourceStore.getAt(i)));
            }
        }

        scheduler.getForegroundDomConfigs(featureDomConfigs);

        syncConfigs.push.apply(syncConfigs, featureDomConfigs);

        DomSync.sync({
            domConfig : {
                onlyChildren : true,
                children     : syncConfigs
            },
            targetElement : scheduler.foregroundCanvas,
            syncIdField   : 'syncId',

            // Called by DomHelper when it creates, releases or reuses elements
            callback({ action, domConfig, lastDomConfig, targetElement }) {
                // If element is an event wrap, trigger appropriate events
                if (domConfig && domConfig.className && domConfig.className[scheduler.eventCls + '-wrap']) {
                    const
                        // Some actions are considered first a release and then a render (reusing another element).
                        // This gives clients code a chance to clean up before reusing an element
                        isRelease = releaseEventActions[action],
                        isRender  = renderEventActions[action];

                    // If we are reusing an element that was previously released we should not trigger again
                    if (isRelease && lastDomConfig && !lastDomConfig.isReleased) {
                        const
                            data  = lastDomConfig.elementData.tplData,
                            event = {
                                tplData          : data,
                                assignmentRecord : data.assignment,
                                eventRecord      : data.eventRecord,
                                resourceRecord   : data.resourceRecord,
                                targetElement
                            };
                        // This event is documented on Scheduler
                        scheduler.trigger('releaseEvent', event);
                    }

                    if (isRender) {
                        const
                            data  = domConfig.elementData.tplData,
                            event = {
                                tplData          : data,
                                assignmentRecord : data.assignment,
                                eventRecord      : data.eventRecord,
                                resourceRecord   : data.resourceRecord,
                                targetElement
                            };

                        // Store element to allow easy mapping from record
                        targetElement.elementData.element = targetElement;

                        event.reusingElement = action === 'reuseElement';
                        // This event is documented on Scheduler
                        scheduler.trigger('renderEvent', event);
                    }

                    // No changes during sync, but might need to hook up element again in case cache was cleared
                    if (action === 'none') {
                        domConfig.elementData.element = targetElement;
                    }
                }
            }
        });

        // Change in displayed resources?
        if (me.firstResource !== firstResource || me.lastResource !== lastResource) {
            // Update header to match
            me.resourceColumns.range = { firstResource, lastResource };

            // Store which resources are currently in view
            me.firstResource = firstResource;
            me.lastResource = lastResource;
        }
    }

    //endregion

    //region Cache

    // Clears cached resource layout
    clearResources(resourceIds) {
        

        resourceIds.forEach(resourceId => {
            if (this.resourceMap[resourceId]) {
                Object.keys(this.resourceMap[resourceId]).forEach(eventId => {
                    delete this.eventMap[eventId][resourceId];
                });

                delete this.resourceMap[resourceId];
            }
        });
    }

    clearAll() {
        

        this.resourceMap = {};
        this.eventMap = {};
    }

    //endregion
}
VerticalEventMapper._$name = 'VerticalEventMapper';

/**
 * @module Scheduler/view/TimeAxisBase
 */

function isLastLevel(level, levels) {
    return level === levels.length - 1;
}

function isLastCell(level, cell) {
    return cell === level.cells[level.cells.length - 1];
}

/**
 * Base class for HorizontalTimeAxis and VerticalTimeAxis. Contains shared functionality to only render ticks in view,
 * should not be used directly.
 *
 * @extends Core/widget/Widget
 * @private
 * @abstract
 */
class TimeAxisBase extends Widget {

    //region Config

    static get defaultConfig() {
        return {
            /**
             * The minimum width for a bottom row header cell to be considered 'compact', which adds a special CSS class
             * to the row (for special styling). Copied from Scheduler/Gantt.
             * @config {Number}
             * @default
             */
            compactCellWidthThreshold : 15,

            // TimeAxisViewModel
            model : null,

            cls : null,

            /**
             * Style property to use as cell size. Either width or height depending on orientation
             * @config {String}
             * @private
             */
            sizeProperty : null,

            /**
             * Style property to use as cells position. Either left or top depending on orientation
             * @config {String}
             * @private
             */
            positionProperty : null,

            /**
             * Specify `true` to wrap header text in `.b-sch-header-text`
             * @config {String}
             * @private
             */
            wrapText : null
        };
    }

    static get properties() {
        return {
            startDate : null,
            endDate   : null,
            levels    : [],
            size      : null
        };
    }

    // Set visible date range
    set range(range) {
        this.startDate = range.startDate;
        this.endDate = range.endDate;

        this.refresh();

        this.trigger('rangeChange', { startDate : range.startDate, endDate : range.endDate });
    }

    //endregion

    //region Html & rendering

    // Generates element configs for all levels defined by the current ViewPreset
    buildCells() {
        const
            me                   = this,
            { sizeProperty }     = me,
            featureHeaderConfigs = [],
            cellConfigs          = me.levels.map((level, i) => (
                {
                    className : {
                        'b-sch-header-row'                     : 1,
                        [`b-sch-header-row-${level.position}`] : 1,
                        'b-sch-header-row-main'                : i === me.model.viewPreset.mainHeaderLevel,
                        'b-lowest'                             : isLastLevel(i, me.levels)
                    },
                    syncOptions : {
                        // Keep a maximum of 5 released cells. Might be fine with fewer since ticks are fixed width.
                        // Prevents an unnecessary amount of cells from sticking around when switching from narrow to
                        // wide tickSizes
                        releaseThreshold : 5,
                        syncIdField      : 'tickIndex'
                    },
                    dataset : {
                        headerFeature  : `headerRow${i}`,
                        headerPosition : level.position
                    },
                    // Only include cells in view
                    children : level.cells.filter(cell => cell.start < me.endDate && cell.end > me.startDate).map(cell => ({
                        className : {
                            'b-sch-header-timeaxis-cell' : 1,
                            [cell.headerCellCls]         : cell.headerCellCls,
                            [`b-align-${cell.align}`]    : cell.align,
                            'b-last'                     : isLastCell(level, cell)
                        },
                        dataset : {
                            tickIndex : cell.index,
                            // Used in export tests to resolve dates from tick elements
                            ...window.DEBUG && { date : cell.start.getTime() }
                        },
                        style : {
                            // DomHelper appends px to numeric dimensions
                            [me.positionProperty]   : cell.coord,
                            [sizeProperty]          : cell.width,
                            [`min-${sizeProperty}`] : cell.width
                        },
                        children : me.wrapText ? [
                            {
                                className : 'b-sch-header-text',
                                html      : cell.value
                            }
                        ] : null,
                        html : me.wrapText ? null : cell.value
                    }))
                }
            ));

        // When tested in isolation there is no client
        me.client && me.client.getHeaderDomConfigs(featureHeaderConfigs);

        cellConfigs.push(...featureHeaderConfigs);

        // noinspection JSSuspiciousNameCombination
        return {
            className   : `b-widget ${me.cls}`,
            syncOptions : {
                // Do not keep entire levels no longer used, for example after switching view preset
                releaseThreshold : 0
            },
            style : {
                [sizeProperty] : me.size
            },
            children : cellConfigs
        };
    }

    render(targetElement) {
        super.render(targetElement);

        this.refresh(true);
    }

    /**
     * Refresh the UI
     * @param {Boolean} [rebuild] Specify `true` to force a rebuild of the underlying header level definitions
     */
    refresh(rebuild = !this.levels.length) {
        const
            me               = this,
            { columnConfig } = me.model,
            { levels }       = me,
            oldLevelsCount   = levels.length;

        if (rebuild) {
            levels.length = 0;

            columnConfig.forEach((cells, position) => levels[position] = {
                position,
                cells
            });

            me.size = levels[0].cells.reduce((sum, cell) => sum += cell.width, 0);

            // TODO clean up when this is fixed: https://app.assembla.com/spaces/bryntum/tickets/8413-horizontaltimeaxis-should-not-completely-overwrite-contents-of-column-el/details#
            const parentEl = me.element.parentElement;

            if (parentEl) {
                parentEl.classList.remove(`b-sch-timeaxiscolumn-levels-${oldLevelsCount}`);
                parentEl.classList.add(`b-sch-timeaxiscolumn-levels-${levels.length}`);
            }
        }

        if (!me.startDate || !me.endDate) {
            return;
        }

        // Boil down levels to only show what is in view
        DomSync.sync({
            domConfig     : me.buildCells(),
            targetElement : me.element,
            syncIdField   : 'headerFeature'
        });
        
        me.trigger('refresh');
    }

    //endregion

    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
}
TimeAxisBase._$name = 'TimeAxisBase';

/**
 * @module Scheduler/view/HorizontalTimeAxis
 */

/**
 * A visual horizontal representation of the time axis described in the
 * {@link Scheduler.preset.ViewPreset#field-headers headers}.
 * Normally you should not interact with this class directly.
 *
 * @extends Scheduler/view/TimeAxisBase
 * @private
 */
class HorizontalTimeAxis extends TimeAxisBase {

    static get $name() {
        return 'HorizontalTimeAxis';
    }

    static get defaultConfig() {
        return {
            cls : 'b-horizontaltimeaxis',

            sizeProperty : 'width',

            positionProperty : 'left',

            wrapText : false
        };
    }

    construct() {
        super.construct(...arguments);

        this.model.on({
            update  : this.onModelUpdate,
            thisObj : this
        });
    }

    get width() {
        return this.size;
    }

    onModelUpdate() {
        // Force rebuild when availableSpace has changed, to recalculate width and maybe apply compact styling
        if (this.model.availableSpace !== this.width) {
            this.refresh(true);
        }
    }
}
HorizontalTimeAxis._$name = 'HorizontalTimeAxis';

/**
 * @module Scheduler/view/ResourceHeader
 */

/**
 * Header widget that renders resource column headers and acts as the interaction point for resource columns in vertical
 * mode. Note that it uses virtual rendering and element reusage to gain performance, only headers in view are available
 * in DOM. Because of this you should avoid direct element manipulation, any such changes can be discarded at any time.
 *
 * By default it displays resources `name` and also applies its `iconCls` if any, like this:
 *
 * ```
 * <i class="iconCls">name</i>
 * ```
 *
 * If Scheduler is configured with a {@link Scheduler.view.mixin.SchedulerEventRendering#config-resourceImagePath} the
 * header will render miniatures for the resources, using {@link Scheduler.model.ResourceModel#field-imageUrl} or {@link Scheduler.model.ResourceModel#field-image} with
 * fallback to {@link Scheduler.model.ResourceModel#field-name} + {@link Scheduler.view.mixin.SchedulerEventRendering#config-resourceImageExtension} for unset values.
 *
 * The contents and styling of the resource cells in the header can be customized using {@link #config-headerRenderer}:
 *
 * ```
 * new Scheduler({
 *     mode            : 'vertical',
 *     resourceColumns : {
 *         headerRenderer : ({ resourceRecord }) => `Hello ${resourceRecord.name}`
 *     }
 * }
 *```
 *
 * The width of the resource columns is determined by the {@link #config-columnWidth} config.
 *
 * @extends Core/widget/Widget
 */
class ResourceHeader extends Widget {

    //region Config

    static get $name() {
        return 'ResourceHeader';
    }

    static get defaultConfig() {
        return {
            /**
             * Resource store used to render resource headers. Assigned from Scheduler.
             * @config {Scheduler.data.ResourceStore}
             * @private
             */
            resourceStore : null,

            // TODO: Read this value from CSS as we do with rowHeight?
            /**
             * Width for each resource column
             * @config {Number}
             */
            columnWidth : 150,

            /**
             * Custom header renderer function. Can be used to manipulate the element config used to create the element
             * for the header:
             *
             * ```
             * new Scheduler({
             *   resourceColumns : {
             *     headerRenderer({ elementConfig, resourceRecord }) {
             *       elementConfig.dataset.myExtraData = 'extra';
             *       elementConfig.style.fontWeight = 'bold';
             *     }
             *   }
             * });
             * ```
             *
             * See {@link Core.helper.DomHelper#function-createElement-static DomHelper#createElement()} for more information.
             * Please take care to not break the default configs :)
             *
             * Or as a template by returning HTML from the function:
             *
             * ```
             * new Scheduler({
             *   resourceColumns : {
             *     headerRenderer : ({ resourceRecord }) => `
             *       <div class="my-custom-template">
             *       ${resourceRecord.firstName} {resourceRecord.surname}
             *       </div>
             *     `
             *   }
             * });
             * ```
             *
             * NOTE: When using `headerRenderer` no default internal markup is applied to the resource header cell,
             * `iconCls` and {@link Scheduler.model.ResourceModel#field-imageUrl} or {@link Scheduler.model.ResourceModel#field-image}
             * will have no effect unless you supply custom markup for them.
             *
             * @config {Function}
             * @param {Object} params Object containing the params below
             * @param {Scheduler.model.ResourceModel} resourceRecord Resource whose header is being rendered
             * @param {Object} elementConfig A {@link Core.helper.DomHelper#function-createElement-static} config object used to create the element for the resource
             */
            headerRenderer : null,

            /**
             * Automatically resize resource columns to **fill** available width. Set to `false` to always respect the
             * configured `columnWidth`
             * @config {Boolean}
             * @default
             */
            fillWidth : true,

            /**
             * Automatically resize resource columns to always **fit** available width
             * @config {Boolean}
             * @default
             */
            fitWidth : false,

            // Copied from Scheduler#resourceImagePath on creation in TimeAxisColumn.js
            imagePath : null,

            // Copied from Scheduler#resourceImageExtension on creation in TimeAxisColumn.js
            imageExtension : null,

            // Copied from Scheduler#defaultResourceImageName on creation in TimeAxisColumn.js
            defaultImageName : null
        };
    }

    static get properties() {
        return {
            firstResource : -1,
            lastResource  : -1
        };
    }

    //endregion

    //region Init

    construct(config) {
        super.construct(config);

        const me = this;

        if (me.imagePath != null) {
            // Apply default image on load errors
            EventHelper.on({
                element  : me.element,
                delegate : '.b-resource-image',
                capture  : true,
                error    : event => this.setDefaultResourceImage(event.target)
            });

            // Need to gain some height when displaying images
            me.element.classList.add('b-has-images');
        }

        EventHelper.on({
            element     : me.element,
            delegate    : '.b-resourceheader-cell',
            capture     : true,
            click       : 'onResourceMouseEvent',
            dblclick    : 'onResourceMouseEvent',
            contextmenu : 'onResourceMouseEvent',
            thisObj     : me
        });
    }

    //endregion

    //region ResourceStore

    set resourceStore(store) {
        const me = this;

        if (store !== me._resourceStore) {
            me.resourceStoreDetacher && me.resourceStoreDetacher();

            me._resourceStore = store;

            me.resourceStoreDetacher = store.on({
                change  : 'onResourceStoreDataChange',
                thisObj : me
            });

            // Already have data? Update width etc
            if (store.count) {
                me.onResourceStoreDataChange({});
            }
        }
    }

    get resourceStore() {
        return this._resourceStore;
    }

    // Redraw resource headers on any data change
    onResourceStoreDataChange({ action }) {
        const
            me    = this,
            width = me.resourceStore.count * me.columnWidth;

        if (width !== me.width) {
            me.element.style.width = width + 'px';
            // During setup, silently set the width. It will then render correctly. After setup, let the world know...
            me.column.set('width', width, me.column.grid.isConfiguring);
        }

        if (action === 'removeall') {
            // Keep nothing
            me.element.innerHTML = '';
        }

        if (action === 'remove' || action === 'add' || action === 'filter') {
            me.refreshWidths();
        }
    }

    //endregion

    //region Properties

    get columnWidth() {
        return this._columnWidth;
    }

    set columnWidth(width) {
        const me = this;

        if (width !== me._columnWidth) {
            const oldWidth = me._columnWidth;
            me._columnWidth = width;

            // Flag set in refreshWidths, do not want to create a loop
            if (!me.refreshingWidths) {
                me._originalColumnWidth = width;

                me.refreshWidths();
            }

            if (!me.isConfiguring) {
                me.refresh();
                // Cannot trigger with requested width, might have changed because of fit/fill
                me.trigger('columnWidthChange', { width : me._columnWidth, oldWidth });
            }
        }
    }

    /**
     * Assign to toggle resource columns **fill* mode. `true` means they will stretch (grow) to fill viewport, `false`
     * that they will respect their configured `columnWidth`.
     * @property {Boolean}
     */
    get fillWidth() {
        return this._fillWidth;
    }

    set fillWidth(fill) {
        this._fillWidth = fill;

        this.refreshWidths();
    }

    /**
     * Assign to toggle resource columns **fit* mode. `true` means they will grow or shrink to always fit viewport,
     * `false` that they will respect their configured `columnWidth`.
     * @property {Boolean}
     */
    get fitWidth() {
        return this._fitWidth;
    }

    set fitWidth(fit) {
        this._fitWidth = fit;

        this.refreshWidths();
    }

    setDefaultResourceImage(target) {
        if (this.defaultImageName) {
            const defaultURL = this.getImageURL(this.defaultImageName);
            // Set image to defaultURL if it is not already set
            if (target.src && !target.src.endsWith(defaultURL.replace(/^[./]*/gm, ''))) {
                target.src = defaultURL;
            }
        }
    }

    getImageURL(imageName) {
        return StringHelper.joinPaths([this.imagePath || '', imageName || '']);
    }

    get imagePath() {
        return this._imagePath;
    }

    set imagePath(path) {
        this._imagePath = path;

        this.refresh();
    }

    //endregion

    //region Fit to width

    get availableWidth() {
        return this._availableWidth;
    }

    set availableWidth(width) {
        this._availableWidth = width;

        this.refreshWidths();
    }

    // Updates the column widths according to fill and fit settings
    refreshWidths() {
        const
            me    = this,
            {
                availableWidth,
                _originalColumnWidth
            }     = me,
            count = me.resourceStore && me.resourceStore.count;

        // Bail out if availableWidth not yet set or resource store not assigned/loaded
        if (!availableWidth || !count) {
            return;
        }

        me.refreshingWidths = true;

        const
            // Fit width if configured to do so or if configured to fill and used width is less than available width
            fit           = me.fitWidth || me.fillWidth && _originalColumnWidth * count < availableWidth,
            useWidth      = fit ? Math.floor(availableWidth / count) : _originalColumnWidth,
            shouldAnimate = me.column.grid.enableEventAnimations && Math.abs(me._columnWidth - useWidth) > 30;

        DomHelper.addTemporaryClass(me.element, 'b-animating', shouldAnimate ? 300 : 0, me);

        me.columnWidth = useWidth;

        me.refreshingWidths = false;
    }

    //endregion

    //region Rendering

    // Visual resource range, set by VerticalEventMapper
    set range(range) {
        const me = this;

        me.firstResource = range.firstResource;
        me.lastResource = range.lastResource;

        me.refresh();
    }

    /**
     * Refreshes the visible headers
     */
    refresh() {
        const
            me                              = this,
            { firstResource, lastResource } = me;

        // Bail out if we are configuring or have no resources to show
        if (me.column.grid.isConfiguring || firstResource === -1 || lastResource === -1 || lastResource >= me.resourceStore.count) {
            return;
        }

        const configs = [];

        // Gather element configs for resource headers in view
        for (let i = firstResource; i <= lastResource; i++) {
            const
                resourceRecord = me.resourceStore.getAt(i),
                elementConfig  = {
                    // Might look like overkill to use DomClassList here, but can be used in headerRenderer
                    className : new DomClassList({
                        'b-resourceheader-cell' : 1
                    }),
                    dataset : {
                        resourceId : resourceRecord.id
                    },
                    style : {
                        left  : i * me.columnWidth,
                        width : me.columnWidth
                    },
                    children : []
                };

            // Let a configured headerRenderer have a go at it before applying
            if (me.headerRenderer) {
                const value = me.headerRenderer({ elementConfig, resourceRecord });
                if (value != null) {
                    elementConfig.html = value;
                }
            }
            // No headerRenderer, apply default markup
            else {
                let imageUrl;
                if (resourceRecord.imageUrl) {
                    imageUrl = resourceRecord.imageUrl;
                }
                else {
                    if (me.imagePath != null) {
                        const
                            imageName = resourceRecord.image || resourceRecord.name && resourceRecord.name.toLowerCase() + me.imageExtension || me.defaultImageName;
                        imageUrl = me.getImageURL(imageName);
                    }
                }

                // Optionally displaying a miniature image
                if (imageUrl != null) {
                    elementConfig.children.push({
                        tag       : 'img',
                        className : 'b-resource-image',
                        src       : imageUrl
                    });
                }

                // Optionally displaying an icon
                if (resourceRecord.iconCls) {
                    elementConfig.children.push({
                        tag       : 'i',
                        className : resourceRecord.iconCls
                    });
                }

                // By default showing resource name
                elementConfig.children.push({
                    tag       : 'span',
                    className : 'b-resource-name',
                    html      : resourceRecord.name
                });
            }

            configs.push(elementConfig);
        }

        // Sync changes to the header
        DomSync.sync({
            domConfig : {
                onlyChildren : true,
                children     : configs
            },
            targetElement : me.element,
            syncIdField : 'resourceId'
            // TODO: Add callback here to trigger events when rendering/derendering header cells. Sooner or later
            //  someone is going to ask for a way to render JSX or what not to the header
        });
    }

    //endregion

    onResourceMouseEvent(event) {
        const
            resourceCell = event.target.closest('.b-resourceheader-cell'),
            resourceRecord     = this.resourceStore.getById(resourceCell.dataset.resourceId);

        this.trigger('resourceHeader' + StringHelper.capitalizeFirstLetter(event.type), {
            resourceRecord,
            event
        });
    }
}
ResourceHeader._$name = 'ResourceHeader';

/**
 * @module Scheduler/column/TimeAxisColumn
 */

/**
 * A column containing the timeline "viewport", in which events, dependencies etc are drawn. Normally you do not need
 * to interact with or create this column, it is handled by Scheduler/Gantt.
 *
 * @extends Grid/column/Column
 */
class TimeAxisColumn extends Events(Column) {
    // region Events
    /**
     * Fires after a click on a time axis cell
     * @event timeAxisHeaderClick
     * @param {Scheduler.column.TimeAxisColumn} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The start date of the header cell
     * @param {Event} event The event object
     */

    /**
     * Fires after a double click on a time axis cell
     * @event timeAxisHeaderDblClick
     * @param {Scheduler.column.TimeAxisColumn} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The end date of the header cell
     * @param {Event} event The event object
     */

    /**
     * Fires after a right click on a time axis cell
     * @event timeAxisHeaderContextMenu
     * @param {Scheduler.column.TimeAxisColumn} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The start date of the header cell
     * @param {Event} event The event object
     */
    //endregion

    //region Init

    construct() {
        const me = this;

        super.construct(...arguments);

        me.initialRender           = true;
        me.thisObj                 = me;
        me.timeAxisViewModel       = me.timeline.timeAxisViewModel;
        // A bit hacky, because mode is a field and not a config
        // eslint-disable-next-line no-self-assign
        me.mode                    = me.mode;

        me.grid.on({
            paint   : 'onTimelinePaint',
            thisObj : me,
            once    : true
        });

        me.timeAxisViewModel.on({
            update  : me.onViewModelUpdate,
            thisObj : me
        });
    }

    static get autoExposeFields() {
        return true;
    }

    // endregion

    //region Config

    static get fields() {
        return [
            'mode'
        ];
    }

    static get defaults() {
        return {
            /**
             * Set to false to prevent this column header from being dragged.
             * @config {Boolean} draggable
             * @category Interaction
             * @default false
             */
            draggable : false,

            /**
             * Set to false to prevent grouping by this column.
             * @config {Boolean} groupable
             * @category Interaction
             * @default false
             */
            groupable : false,

            /**
             * Allow column visibility to be toggled through UI.
             * @config {Boolean} hideable
             * @default false
             * @category Interaction
             */
            hideable : false,

            /**
             * Show column picker for the column.
             * @config {Boolean} showColumnPicker
             * @default false
             * @category Menu
             */
            showColumnPicker : false,

            /**
             * Allow filtering data in the column (if Filter feature is enabled)
             * @config {Boolean} filterable
             * @default false
             * @category Interaction
             */
            filterable : false,

            /**
             * Allow sorting of data in the column
             * @config {Boolean} sortable
             * @category Interaction
             * @default false
             */
            sortable : false,

            /**
             * Set to `false` to prevent the column from being drag-resized when the ColumnResize plugin is enabled.
             * @config {Boolean} resizable
             * @default false
             * @category Interaction
             */
            resizable : false,

            /**
             * Allow searching in the column (respected by QuickFind and Search features)
             * @config {Boolean} searchable
             * @default false
             * @category Interaction
             */
            searchable : false,

            /**
             * Specifies if this column should be editable, and define which editor to use for editing cells in the column (if CellEdit feature is enabled)
             * @config {String} editor
             * @default false
             * @category Interaction
             */
            editor : false,

            /**
             * false to prevent showing a context menu on the cell elements in this column
             * @config {Boolean} enableCellContextMenu
             * @default false
             * @category Menu
             */
            enableCellContextMenu : false,

            /**
             * Renderer function for cell tooltips header (used with CellTooltip feature). Specify false to prevent
             * tooltip for that column.
             * @param {HTMLElement} cellElement Cell element
             * @param {Core.data.Model} record Record for cell row
             * @param {Grid.column.Column} column Cell column
             * @param {CellTooltip} cellTooltip Feature instance, used to set tooltip content async
             * @param {MouseEvent} event The event that triggered the tooltip
             * @config {Function} tooltipRenderer
             * @category Rendering
             * @default false
             */
            tooltipRenderer : false,

            /**
             * CSS class added to the header of this column
             * @config {String} cls
             * @category Rendering
             * @default 'b-sch-timeaxiscolumn'
             */
            cls : 'b-sch-timeaxiscolumn',

            // needs to have width specified, flex-basis messes measurements up
            needWidth : true,

            mode : null,

            region : 'normal',

            exportable : false
        };
    }

    static get type() {
        return 'timeAxis';
    }

    set mode(mode) {
        const
            me           = this,
            { timeline } = me;

        me.set('mode', mode);

        // In horizontal mode this column has a time axis header on top, with timeline ticks
        if (mode === 'horizontal') {
            me.timeAxisView = new HorizontalTimeAxis({
                model                     : me.timeAxisViewModel,
                compactCellWidthThreshold : me.compactCellWidthThreshold,
                owner                     : me.grid,
                client                    : me.grid
            });
        }
        // In vertical mode, it instead displays resources at top
        else if (mode === 'vertical') {
            // TODO: Most other vertical stuff is handled in VerticalEventMapper, move there?
            me.resourceColumns = new ResourceHeader(ObjectHelper.assign({
                column           : me,
                resourceStore    : timeline.resourceStore,
                imagePath        : timeline.resourceImagePath,
                imageExtension   : timeline.resourceImageExtension,
                defaultImageName : timeline.defaultResourceImageName
            }, timeline.resourceColumns || {}));

            me.relayEvents(me.resourceColumns, [
                'resourceheaderclick',
                'resourceheaderdblclick',
                'resourceheadercontextmenu'
            ]);
        }
    }

    get mode() {
        return this.get('mode');
    }

    // TODO: define all configs as fields and set below to false...

    //region Events

    onViewModelUpdate({ source : viewModel }) {
        const me = this;

        if (me.mode === 'horizontal') {
            // render the time axis view into the column header element
            me.refreshHeader(true);

            me.width = viewModel.totalSize;

            me.timeline.refresh();
        }
        else if (me.mode === 'vertical') {
            // Refresh to rerender cells, in the process updating the vertical timeaxis to reflect view model changes
            me.timeline.refreshRows();
        }
    }

    // Called on paint. SubGrid has its width so this is the earliest time to configure the TimeAxisViewModel with
    // correct width
    onTimelinePaint({ firstPaint }) {
        const me = this;

        if (!me.subGrid.insertRowsBefore) {
            return;
        }

        if (firstPaint) {
            me.subGridElement.classList.add('b-timeline-subgrid');

            // If the owning Scheduler has hideHeaders: true, element won't be available.
            if (me.element) {
                EventHelper.on({
                    element     : me.element,
                    thisObj     : me,
                    click       : 'onContainerElementClick',
                    dblclick    : 'onContainerElementClick',
                    contextmenu : 'onContainerElementClick'
                });
            }

            if (me.mode === 'vertical') {
                me.refreshHeader();
            }
        }
    }

    //endregion

    //region Rendering

    /**
     * Refreshes the columns header contents (which is either a HorizontalTimeAxis or a ResourceHeader). Useful if you
     * have rendered some extra meta data that depends on external data such as the EventStore or ResourceStore.
     */
    refreshHeader(internal) {
        const me = this,
            { element } = me;

        if (element) {

            if (me.mode === 'horizontal') {
                // Force timeAxisViewModel to regenerate its column config, which calls header renderers etc.
                !internal && me.timeAxisViewModel.update(null, true);

                if (!me.timeAxisView.rendered) {
                    // Do not need the normal header markup
                    element.innerHTML = '';

                    me.timeAxisView.render(element);
                }
                else {
                    // Force rebuild of cells in case external data has changed (cheap since it still syncs to DOM)
                    me.timeAxisView.refresh(true);
                }
            }
            else if (me.mode === 'vertical') {
                if (!me.resourceColumns.currentElement) {
                    // Do not need the normal header markup
                    element.innerHTML = '';

                    me.resourceColumns.render(element);
                }

                // Vertical's resourceColumns is redrawn with the events, no need here
            }
        }
    }

    renderer(renderData) {
        return this.timeline.currentOrientation.renderer(renderData);
    }

    //endregion

    // region DOM events
    onContainerElementClick(event) {
        const target = DomHelper.up(event.target, '.b-sch-header-timeaxis-cell');

        if (target) {
            const
                index        = target.dataset.tickIndex,
                position     = target.parentElement.dataset.headerPosition,
                columnConfig = this.timeAxisViewModel.columnConfig[position][index];

            // Skip same events with Grid context menu triggerEvent
            const contextMenu = this.grid.features.contextMenu;
            if (!contextMenu || event.type !== contextMenu.triggerEvent) {
                this.trigger('timeAxisHeader' + StringHelper.capitalizeFirstLetter(event.type), {
                    startDate : columnConfig.start,
                    endDate   : columnConfig.end,
                    event
                });
            }
        }
    }
    // endregion
}

ColumnStore.registerColumnType(TimeAxisColumn);
TimeAxisColumn._$name = 'TimeAxisColumn';

/**
 * @module Scheduler/view/VerticalTimeAxis
 */

/**
 * Widget that renders a vertical time axis. Only renders ticks in view. Used in vertical mode.
 * @extends Core/widget/Widget
 * @private
 */
class VerticalTimeAxis extends TimeAxisBase {

    static get $name() {
        return 'VerticalTimeAxis';
    }

    static get defaultConfig() {
        return {
            cls : 'b-verticaltimeaxis',

            sizeProperty : 'height',

            positionProperty : 'top',

            wrapText : true
        };
    }

    get height() {
        return this.size;
    }
}
VerticalTimeAxis._$name = 'VerticalTimeAxis';

class VerticalTimeAxisColumn extends Column {
    static get type() {
        return 'verticalTimeAxis';
    }

    static get defaults() {
        return {
            /**
             * Set to false to prevent this column header from being dragged.
             * @config {Boolean} draggable
             * @category Interaction
             * @default false
             * @hide
             */
            draggable : false,

            /**
             * Set to false to prevent grouping by this column.
             * @config {Boolean} groupable
             * @category Interaction
             * @default false
             * @hide
             */
            groupable : false,

            /**
             * Allow column visibility to be toggled through UI.
             * @config {Boolean} hideable
             * @default false
             * @category Interaction
             * @hide
             */
            hideable : false,

            /**
             * Show column picker for the column.
             * @config {Boolean} showColumnPicker
             * @default false
             * @category Menu
             * @hide
             */
            showColumnPicker : false,

            /**
             * Allow filtering data in the column (if Filter feature is enabled)
             * @config {Boolean} filterable
             * @default false
             * @category Interaction
             * @hide
             */
            filterable : false,

            /**
             * Allow sorting of data in the column
             * @config {Boolean} sortable
             * @category Interaction
             * @default false
             * @hide
             */
            sortable : false,

            // /**
            //  * Set to `false` to prevent the column from being drag-resized when the ColumnResize plugin is enabled.
            //  * @config {Boolean} resizable
            //  * @default false
            //  * @category Interaction
            //  * @hide
            //  */
            // resizable : false,

            /**
             * Allow searching in the column (respected by QuickFind and Search features)
             * @config {Boolean} searchable
             * @default false
             * @category Interaction
             * @hide
             */
            searchable : false,

            /**
             * Specifies if this column should be editable, and define which editor to use for editing cells in the column (if CellEdit feature is enabled)
             * @config {String} editor
             * @default false
             * @category Interaction
             * @hide
             */
            editor : false,

            /**
             * false to prevent showing a context menu on the cell elements in this column
             * @config {Boolean} enableCellContextMenu
             * @default false
             * @category Menu
             * @hide
             */
            enableCellContextMenu : false,

            /**
             * Renderer function for cell tooltips header (used with CellTooltip feature). Specify false to prevent
             * tooltip for that column.
             * @param {HTMLElement} cellElement Cell element
             * @param {Core.data.Model} record Record for cell row
             * @param {Grid.column.Column} column Cell column
             * @param {CellTooltip} cellTooltip Feature instance, used to set tooltip content async
             * @param {MouseEvent} event The event that triggered the tooltip
             * @config {Function} tooltipRenderer
             * @category Rendering
             * @default false
             * @hide
             */
            tooltipRenderer : false,

            cellCls : 'b-verticaltimeaxiscolumn'
        };
    }

    construct(data) {
        const me = this;

        super.construct(...arguments);

        me.timeAxisViewModel = data.timeline.timeAxisViewModel;

        me.view = new VerticalTimeAxis({
            model  : me.timeAxisViewModel,
            client : data.timeline
        });
    }

    renderer({ cellElement, size }) {
        this.view.render(cellElement);

        size.height = this.view.height;
    }
}

ColumnStore.registerColumnType(VerticalTimeAxisColumn);
VerticalTimeAxisColumn._$name = 'VerticalTimeAxisColumn';

/**
 * @module Scheduler/view/SchedulerBase
 */

/**
 * A thin base class for {@link Scheduler.view.Scheduler}. Does not include any features by default, allowing smaller
 * custom built bundles if used in place of {@link Scheduler.view.Scheduler}.
 *
 * **NOTE:** In most scenarios you do probably want to use Scheduler instead of SchedulerBase.
 *
 * @mixes Scheduler/view/mixin/EventNavigation
 * @mixes Scheduler/view/mixin/EventSelection
 * @mixes Scheduler/view/mixin/SchedulerDom
 * @mixes Scheduler/view/mixin/SchedulerDomEvents
 * @mixes Scheduler/view/mixin/SchedulerEventRendering
 * @mixes Scheduler/view/mixin/SchedulerRegions
 * @mixes Scheduler/view/mixin/SchedulerScroll
 * @mixes Scheduler/view/mixin/SchedulerState
 * @mixes Scheduler/view/mixin/SchedulerStores
 * @mixes Scheduler/view/mixin/TimelineDateMapper
 * @mixes Scheduler/view/mixin/TimelineDomEvents
 * @mixes Scheduler/view/mixin/TimelineEventRendering
 * @mixes Scheduler/view/mixin/TimelineScroll
 * @mixes Scheduler/view/mixin/TimelineViewPresets
 * @mixes Scheduler/view/mixin/TimelineZoomable
 * @mixes Scheduler/crud/mixin/CrudManagerView
 *
 * @extends Scheduler/view/TimelineBase
 */
// SchedulerDragResize not included as @mixes above on purpose, since it is private
class SchedulerBase extends base(TimelineBase).mixes(
    CrudManagerView,
    SchedulerDom,
    SchedulerDomEvents,
    SchedulerDragResize,
    SchedulerStores,
    SchedulerScroll,
    SchedulerState,
    SchedulerEventRendering,
    SchedulerRegions,
    EventSelection,
    EventNavigation
) {
    //region Config

    static get $name() {
        return 'SchedulerBase';
    }

    static get defaultConfig() {
        return {
            /**
             * Scheduler mode. Supported values: horizontal, vertical
             * @config {String} mode
             * @default
             */
            mode : 'horizontal',

            /**
             * CSS class to add to rendered events
             * @config {String}
             * @category CSS
             * @private
             * @default
             */
            eventCls : 'b-sch-event',

            /**
             * CSS class to add to cells in the timeaxis column
             * @config {String}
             * @category CSS
             * @private
             * @default
             */
            timeCellCls : 'b-sch-timeaxis-cell',

            timeCellSelector : '.b-sch-timeaxis-cell',

            scheduledEventName : 'event',

            /**
             * A CSS class to apply to each event in the view on mouseover (defaults to 'b-sch-event-hover').
             * @config {String}
             * @default
             * @category CSS
             * @private
             */
            overScheduledEventClass : 'b-sch-event-hover',

            /**
             * Set to false if you don't want to allow events overlapping (defaults to true).
             * @config {Boolean}
             * @default
             * @category Scheduled events
             */
            allowOverlap : true,

            /**
             * The height in pixels of Scheduler rows.
             * @config {Number}
             * @default
             */
            rowHeight : 60,

            /**
             * Factor representing the average char width in pixels used to determine milestone width when configured
             * with `milestoneLayoutMode: 'estimate'`.
             * @config {Number}
             * @default
             */
            milestoneCharWidth : 10,

            /**
             * How to align milestones in relation to their startDate. Only applies when using a `milestoneLayoutMode`
             * other than `default`. Valid values are:
             * * start
             * * center (default)
             * * end
             */
            milestoneAlign : 'center',

            // This is determined by styling, in the future it should be measured
            milestoneMinWidth : 40,

            crudManagerClass : CrudManager
        };
    }

    //endregion

    //region Events

    /**
     * Fired after rendering an event, when its element is available in DOM.
     * @event renderEvent
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.model.EventModel} eventRecord The event record
     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record
     * @param {Scheduler.model.AssignmentModel} assignmentRecord The assignment record, if using an AssignmentStore
     * @param {Object} tplData An object containing details about the event rendering, see {@link Scheduler.view.mixin.SchedulerEventRendering#config-eventRenderer} for details
     * @param {HTMLElement} element The events element
     */

    /**
     * Fired when clicking a resource header cell
     * @event resourceHeaderClick
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record
     * @param {Event} event The event
     */

    /**
     * Fired when doublc clicking a resource header cell
     * @event resourceHeaderDblclick
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record
     * @param {Event} event The event
     */

    /**
     * Fired when activating context menu on a resource header cell
     * @event resourceHeaderContextmenu
     * @param {Scheduler.view.Scheduler} source This Scheduler
     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record
     * @param {Event} event The event
     */

    //endregion

    //region Functions injected by features

    // For documentation & typings purposes

    /**
     * Opens an editor UI to edit the passed event.
     *
     * *NOTE: Only available when the {@link Scheduler/feature/EventEdit EventEdit} feature is enabled.*
     *
     * @function editEvent
     * @param {Scheduler.model.EventModel} eventRecord Event to edit
     * @param {Scheduler.model.ResourceModel} [resourceRecord] The Resource record for the event.
     * This parameter is needed if the event is newly created for a resource and has not been assigned, or when using
     * multi assignment.
     * @param {HTMLElement} [element] Element to anchor editor to (defaults to events element)
     * @category Feature shortcuts
     */

    //endregion

    //region Init

    construct(config = {}) {
        const me = this;

        super.construct(config);

        if (me.createEventOnDblClick) {
            me.on('scheduledblclick', me.onSchedulerDblClick);
        }
    }

    //endregion

    //region Config getters/setters

    // Overrides TimelineBase to supply eventStore as its store (which is only used in passed events)
    set timeAxisViewModel(timeAxisViewModel) {
        super.timeAxisViewModel = timeAxisViewModel;

        if (this.eventStore) {
            this.timeAxisViewModel.eventStore = this.eventStore;
        }
    }

    get timeAxisViewModel() {
        return super.timeAxisViewModel;
    }

    // Placeholder getter/setter for mixins, please make any changes needed to SchedulerStores#store instead
    get store() {
        return super.store;
    }

    set store(store) {
        super.store = store;
    }

    //endregion

    //region Event handlers

    onLocaleChange() {
        this.currentOrientation.onLocaleChange();

        super.onLocaleChange();
    }

    onSchedulerDblClick({ date : startDate, resourceRecord, row }) {
        const me = this;

        if (me.readOnly || resourceRecord.meta.specialRow) {
            return;
        }

        me.internalAddEvent(startDate, resourceRecord, row);
    }

    onColumnsChanged({ action, changes, record : column }) {
        // TODO: Have ResourceHeader call this directly instead of relying on event?
        if (column === this.timeAxisColumn && 'width' in changes) {
            this.updateCanvasSize();
        }

        super.onColumnsChanged(...arguments);
    }

    // Only used in vertical mode
    onVerticalScroll({ scrollTop }) {
        this.currentOrientation.updateFromVerticalScroll(scrollTop);
    }

    /**
     * Called when new event is created.
     * Сan be overriden to supply default record values etc.
     * @param {Scheduler.model.EventModel} eventRecord Newly created event
    */
    onEventCreated(eventRecord) {
    }

    //endregion

    //region Mode

    /**
     * Checks if scheduler is in horizontal mode
     * @returns {Boolean}
     * @readonly
     * @category Common
     * @private
     */
    get isHorizontal() {
        return this.mode === 'horizontal';
    }

    /**
     * Checks if scheduler is in vertical mode
     * @returns {Boolean}
     * @readonly
     * @category Common
     * @private
     */
    get isVertical() {
        return this.mode === 'vertical';
    }

    /**
     * Get/set mode (horizontal/vertical)
     * @property {String}
     * @private
     * @category Common
     */
    get mode() {
        return this._mode;
    }

    set mode(mode) {
        const me = this;

        me._mode = mode;

        if (!me[mode]) {
            if (mode === 'horizontal') {
                me.horizontal = new HorizontalEventMapper(me);
                if (me.isPainted) {
                    me.horizontal.init();
                }

                me.un('scroll', me.onVerticalScroll, me);
            }
            else if (mode === 'vertical') {
                // Zooming is not yet supported in vertical mode, disable it
                me.zoomOnTimeAxisDoubleClick = me.zoomOnMouseWheel = false;

                me.vertical = new VerticalEventMapper(me);
                if (me.rendered) {
                    me.vertical.init();
                }

                me.on('scroll', me.onVerticalScroll, me);
            }
        }
    }

    get currentOrientation() {
        return this[this.mode];
    }

    //endregion

    //region Dom event dummies

    // this is ugly, but needed since super cannot be called from SchedulerDomEvents mixin...

    onElementKeyDown(event) {
        super.onElementKeyDown(event);
    }

    onElementKeyUp(event) {
        super.onElementKeyUp(event);
    }

    onElementMouseOver(event) {
        super.onElementMouseOver(event);
    }

    onElementMouseOut(event) {
        super.onElementMouseOut(event);
    }

    //endregion

    //region Feature hooks

    /**
     * A chainable function which Features may hook to add their own event context menu items
     * when context menu is invoked on an event.
     * @param {Object} params An object containing the available contextual information.
     * @param {Scheduler.model.EventModel} params.eventRecord The context event.
     * @param {Scheduler.model.ResourceModel} params.resourceRecord The context resource
     * @param {Scheduler.model.AssignmentModel} params.assignmentRecord The context assignment if any.
     * @param {HTMLElement} params.eventElement The context event's DOM element.
     * @param {Event} params.event The triggering DOM `contextmenu` event.
     */
    getEventMenuItems() {}

    /**
     * A chainable function which Features may hook to add their own Scheduler context menu items
     * when context menu is invoked on the scheduler, but not on an event.
     * @param {Object} params An object containing the available contextual information.
     * @param {Scheduler.model.ResourceModel} params.resourceRecord The context resource
     * @param {Date} params.date The Date corresponding to the mouse position in the time axis.
     * @param {HTMLElement} params.eventElement The context event's DOM element.
     * @param {Event} params.event The triggering DOM `contextmenu` event.
     */
    getScheduleMenuItems() {}

    //endregion

    //region Scheduler specific date mapping functions

    internalAddEvent(startDate, resourceRecord, row) {
        const
            me              = this,
            resourceRecords = [resourceRecord],
            eventRecord     = new me.eventStore.modelClass({
                startDate,
                endDate : DateHelper.add(startDate, 1, me.timeAxis.unit)
            });

        me.onEventCreated(eventRecord);

        if (me.eventEdit) {
            const
                eventData = me.currentOrientation.getTimeSpanRenderData(eventRecord, resourceRecord),
                proxyEl   = DomHelper.createElement({
                    parent    : me.foregroundCanvas,
                    className : 'b-sch-dragcreator-proxy',
                    style     : `width:${eventData.width}px;height:${eventData.height}px`
                });

            DomHelper.setTranslateXY(proxyEl, eventData.left, (row && row.top || 0) + eventData.top);

            me.editEvent(eventRecord, resourceRecord, proxyEl);
            return;
        }

        /**
         * Fires before an event is added. Can be triggered by schedule double click, drag create action, or by the event editor.
         * @event beforeEventAdd
         * @param {Scheduler.view.Scheduler} source The Scheduler instance
         * @param {Scheduler.model.EventModel} eventRecord The record about to be added
         * @param {Scheduler.model.ResourceModel[]} resources **Deprecated** Use `resourceRecords` instead
         * @param {Scheduler.model.ResourceModel[]} resourceRecords Resources that the record is assigned to
         * @preventable
         */
        if (me.trigger('beforeEventAdd', { eventRecord, resourceRecords, resources : resourceRecords }) !== false) {
            me.eventStore.add(eventRecord);
            me.eventStore.assignEventToResource(eventRecord, resourceRecord);
        }
    }

    /**
     * Checks if a date range is allocated or not for a given resource.
     * @param {Date} start The start date
     * @param {Date} end The end date
     * @param {Scheduler.model.EventModel} excludeEvent An event to exclude from the check (or null)
     * @param {Scheduler.model.ResourceModel} resource The resource
     * @return {Boolean} True if the timespan is available for the resource
     * @category Dates
     */
    isDateRangeAvailable(start, end, excludeEvent, resource) {
        return this.eventStore.isDateRangeAvailable(start, end, excludeEvent, resource);
    }

    //endregion
}

SchedulerBase.localeClass = 'Scheduler';

SchedulerBase._$name = 'SchedulerBase'; BryntumWidgetAdapterRegister.register('schedulerbase', SchedulerBase);

/**
 * @module Scheduler/feature/HeaderContextMenu
 */

/**
 * Adds scheduler specific menu items to the timeline header context menu.
 * By default the menu has the following items:
 * * Filter tasks (if {@link Scheduler.feature.EventFilter EventFilter} is enabled)
 * * Zoom
 * * Date range
 * Can be populated by other features.
 *
 *  * To add extra items to the menu:
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         headerContextMenu : {
 *             // Extra items
 *             extraItems : [
 *                 {
 *                     text : 'Extra',
 *                     icon : 'b-fa b-fa-fw b-fa-flag',
 *                     onItem() {
 *                         ...
 *                     }
 *                 }
 *             ]
 *         }
 *     }
 * });
 * ```
 *
 * Manipulate existing menu items in the timeaxis header menu:
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         headerContextMenu : {
 *             // Process items before menu is shown
 *             processItems({ items }) {
 *                  // Push an extra item
 *                 items.push({
 *                     text : 'Cool action',
 *                     onItem() {
 *                           // ...
 *                     }
 *                  }
 *             }
 *         }
 *     }
 * });
 * ```
 *
 * To disable header context menu for locked grid, but leave it for normal grid:
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         contextMenu : {
 *             // to disable menu for headers except timeline header
 *             processHeaderItems : ({ column }) => column instanceof TimeAxisColumn,
 *             // to disable menu for cells
 *             processCellItems   : () => false
 *         }
 *     }
 * });
 * ```
 *
 * This feature is **enabled** by default
 *
 * @extends Core/mixin/InstancePlugin
 * @externalexample scheduler/HeaderContextMenu.js
 * @demo Scheduler/basic
 */
class HeaderContextMenu extends InstancePlugin {

    static get $name() {
        return 'HeaderContextMenu';
    }

    static get defaultConfig() {
        return {
            /**
             * An array of additional items to add to the menu
             * @config {Object[]}
             * @default
             */
            extraItems : null,

            /**
             * A function called before displaying the menu that allows manipulations of its items. Called with a
             * single parameter with format { eventRecord, resourceRecord, eventElement, items }.
             *
             * ```javascript
             * features : {
             *     headerContextMenu : {
             *         processItems({ items }) {
             *             // Add or remove items here as needed
             *             items.push({ text: 'Some action', icon : 'b-fa b-fa-fw b-fa-ban' })
             *         }
             *     }
             * }
             * ```
             *
             * @config {Function}
             */
            processItems : null
        };
    }

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            chain : ['getHeaderMenuItems']
        };
    }

    construct(scheduler, config) {
        super.construct(scheduler, config);

        this.scheduler = scheduler;
    }

    /**
     * Populates the header context menu items.
     * @param column Column for which the menu will be shown
     * @param items Array of menu items
     * @internal
     */
    getHeaderMenuItems(column, items) {
        const
            me            = this,
            { scheduler, processItems } = me,
            { timeAxis }  = scheduler,
            dateStep      = {
                magnitude : timeAxis.shiftIncrement,
                unit      : timeAxis.shiftUnit
            };

        if (column.type !== 'timeAxis')  {
            return;
        }

        items.push({
            text     : me.L('pickZoomLevel'),
            icon     : 'b-fw-icon b-icon-search-plus',
            disabled : !scheduler.presets.count || me.disabled,
            menu     : {
                type  : 'popup',
                items : [{
                    type      : 'slider',
                    showValue : false,
                    listeners : {
                        input   : me.onZoomSliderChange,
                        thisObj : me
                    },
                    // set width for IE11
                    minWidth : 130
                }],
                onBeforeShow({ source : menu }) {
                    const [zoom] = menu.items;

                    zoom.min   = scheduler.minZoomLevel;
                    zoom.max   = scheduler.maxZoomLevel;
                    zoom.value = scheduler.zoomLevel;
                }
            }
        });

        me.startDateField = new DateField({
            label      : me.L('startText'),
            labelWidth : '6em',
            required   : true,
            step       : dateStep,
            listeners  : {
                change  : me.onRangeDateFieldChange,
                thisObj : me
            }
        });

        me.endDateField = new DateField({
            label      : me.L('endText'),
            labelWidth : '6em',
            required   : true,
            step       : dateStep,
            listeners  : {
                change  : me.onRangeDateFieldChange,
                thisObj : me
            }
        });

        items.push({
            text     : me.L('activeDateRange'),
            icon     : 'b-fw-icon b-icon-calendar',
            disabled : me.disabled,
            menu     : {
                type  : 'popup',
                width : '20em',
                items : [
                    me.startDateField,
                    me.endDateField,
                    {
                        type      : 'button',
                        cls       : 'b-left-nav-btn',
                        icon      : 'b-icon b-icon-prev',
                        color     : 'b-blue b-raised',
                        flex      : 1,
                        margin    : 0,
                        listeners : {
                            click   : me.onLeftShiftBtnClick,
                            thisObj : me
                        }
                    },
                    {
                        type      : 'button',
                        cls       : 'b-today-nav-btn',
                        color     : 'b-blue b-raised',
                        text      : me.L('todayText'),
                        flex      : 4,
                        margin    : '0 8',
                        listeners : {
                            click   : me.onTodayBtnClick,
                            thisObj : me
                        }
                    },
                    {
                        type      : 'button',
                        cls       : 'b-right-nav-btn',
                        icon      : 'b-icon b-icon-next',
                        color     : 'b-blue b-raised',
                        flex      : 1,
                        listeners : {
                            click   : me.onRightShiftBtnClick,
                            thisObj : me
                        }
                    }
                ],
                onBeforeShow : () => me.initDates()
            }
        });

        if (me.extraItems) {
            items.push.apply(items, me.extraItems);
        }

        // Allow user to process the items
        if (processItems) {
            processItems({ items });
        }
    }

    onZoomSliderChange({ value }) {
        const menu = this.client.features.contextMenu.currentMenu;

        // Zooming maintains timeline center point by scrolling the newly rerendered timeline to the
        // correct point to maintain the visual center. Temporarily inhibit context menu hide on scroll
        // of its context element.
        menu.scrollAction = 'realign';
        this.scheduler.zoomLevel = value;
        menu.setTimeout({
            fn                : () => menu.scrollAction = 'hide',
            delay             : 100,
            cancelOutstanding : true
        });
    }

    initDates() {
        const me = this;

        me.startDateField.suspendEvents();
        me.endDateField.suspendEvents();

        // The actual scheduler start dates may include time, but our Date field cannot currently handle
        // a time portion and throws it away, so when we need the value from an unchanged field, we need
        // to use the initialValue set from the timeAxis values.
        // Until our DateField can optionally include a time value, this is the solution.
        me.startDateField.value = me.startDateFieldInitialValue = me.scheduler.startDate;
        me.endDateField.value   = me.endDateFieldInitialValue = me.scheduler.endDate;

        me.startDateField.resumeEvents();
        me.endDateField.resumeEvents();
    }

    onRangeDateFieldChange({ source }) {
        const
            me                 = this,
            startDateChanged   = (source === me.startDateField),
            { client }         = me,
            { timeResolution } = client,
            { scrollable }     = client.timeAxisSubGrid,
            startDate          = me.startDateFieldInitialValue && !startDateChanged ? me.startDateFieldInitialValue : me.startDateField.value,
            viewportStartDate  = client.getDateFromX(scrollable.x);

        let endDate = me.endDateFieldInitialValue && startDateChanged ? me.endDateFieldInitialValue : me.endDateField.value;

        // When either of the fields is changed, we no longer use its initialValue from the timeAxis start or end
        // so that gets nulled to indicate that it's unavailable and the real field value is to be used.
        if (startDateChanged) {
            me.startDateFieldInitialValue = null;
        }
        else {
            me.endDateFieldInitialValue = null;
        }

        // Because the start and end dates are exclusive, avoid a zero
        // length time axis by incrementing the end by one tick unit
        // if they are the same.
        if (!(endDate - startDate)) {
            endDate = DateHelper.add(endDate, timeResolution.increment, timeResolution.unit);
        }
        // if start date got bigger than end date set end date to start date plus one tick
        else if (endDate < startDate) {
            endDate = DateHelper.add(startDate, timeResolution.increment, timeResolution.unit);
        }

        me.scheduler.timeAxis.setTimeSpan(startDate, endDate);

        // Keep the visual start time the same
        scrollable.x = client.getCoordinateFromDate(viewportStartDate, true);

        me.initDates();
    }

    onLeftShiftBtnClick() {
        const me = this;

        me.scheduler.timeAxis.shiftPrevious();
        me.initDates();
    }

    onTodayBtnClick() {
        const me = this,
            today = DateHelper.clearTime(new Date());

        me.scheduler.timeAxis.setTimeSpan(today, DateHelper.add(today, 1, 'day'));
        me.initDates();
    }

    onRightShiftBtnClick() {
        const me = this;

        me.scheduler.timeAxis.shiftNext();
        me.initDates();
    }
}

HeaderContextMenu.featureClass = '';

HeaderContextMenu._$name = 'HeaderContextMenu'; GridFeatureManager.registerFeature(HeaderContextMenu, true, ['Scheduler', 'Gantt']);

/**
 * @module Scheduler/feature/ScheduleContextMenu
 */

/**
 * Displays a context menu for empty parts of the schedule. Items are populated in the first place
 * by configurations of this Feature, then by other features and/or application code.
 *
 * To add extra items (Array notation):
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         scheduleContextMenu : {
 *             // Extra items for all events
 *             items : [
 *                 {
 *                     text : 'Extra',
 *                     icon : 'b-fa b-fa-fw b-fa-flag',
 *                     onItem({date, resourceRecord, items}) {
 *                         // Custom date based action
 *                     }
 *                 }
 *             ]
 *         }
 *     }
 * });
 * ```
 *
 * To add extra items (Object notation):
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         scheduleContextMenu : {
 *             // Extra items for all events
 *             items : {
 *                 extraItem : {
 *                     text : 'Extra',
 *                     icon : 'b-fa b-fa-fw b-fa-flag',
 *                     onItem({date, resourceRecord, items}) {
 *                         // Custom date based action
 *                     }
 *                 }
 *             }
 *         }
 *     }
 * });
 * ```
 *
 * To remove existing items:
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         scheduleContextMenu : {
 *             items : {
 *                 addEvent : false
 *             }
 *         }
 *     }
 * });
 * ```
 *
 * Manipulate existing menu items:
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         scheduleContextMenu : {
 *             // Process items before menu is shown
 *             processItems({date, resourceRecord, items}) {
 *                  // Push an extra item for ancient times
 *                  if (date < new Date(2018, 11, 17)) {
 *                      items.modernize = {
 *                          text : 'Modernize',
 *                          ontItem({date}) {
 *                              // Custom date based action
 *                          }
 *                      };
 *                  }
 *
 *                  // Do not show menu for Sundays
 *                  if (date.getDay() === 0) {
 *                      return false;
 *                  }
 *             }
 *         }
 *     }
 * });
 * ```
 *
 * This feature is **enabled** by default
 *
 * @demo Scheduler/basic
 * @extends Scheduler/feature/base/TimeSpanRecordContextMenuBase
 */
class ScheduleContextMenu extends TimeSpanRecordContextMenuBase {
    //region Config

    static get $name() {
        return 'ScheduleContextMenu';
    }

    static get defaultConfig() {
        return {
            /**
             * An array of extra menu items to add to the context menu
             *
             * ```javascript
             * const scheduler = new Scheduler({
             *     features : {
             *         scheduleContextMenu : {
             *             // Extra items for all events
             *             items : [
             *                 {
             *                     text : 'Add meeting',
             *                     icon : 'b-fa b-fa-fw b-fa-calendar-plus',
             *                     onItem({ date, resourceRecord }) {
             *                         scheduler.eventStore.add({
             *                             name : 'Meeting',
             *                             startDate : date,
             *                             duration: 2,
             *                             resourceId : resourceRecord.id
             *                         });
             *                     }
             *                 }
             *             ]
             *         }
             *     }
             * });
             * ```
             *
             * or items config to add extra items to the context menu or hide default items
             *
             * ```javascript
             * features : {
             *     scheduleContextMenu : {
             *         items : {
             *             // Add custom 'Add meeting' item
             *             addMeeting : {
             *                 text : 'Add meeting',
             *                 icon : 'b-fa b-fa-fw b-fa-calendar-plus',
             *                 onItem({ date, resourceRecord }) {
             *                     scheduler.eventStore.add({
             *                         name : 'Meeting',
             *                         startDate : date,
             *                         duration: 2,
             *                         resourceId : resourceRecord.id
             *                     });
             *                 }
             *             },
             *             // Hide default 'Add event' item
             *             addEvent : false
             *         }
             *     }
             * }
             * ```
             *
             * @config {Object|Object[]}
             */
            items : null,

            /**
             * A function called before displaying the menu that allows manipulations of its items.
             * Called with a single parameter with format { date, resourceRecord, items }.
             * Returning `false` from this function prevents the menu from being shown.
             *
             * ```javascript
             * const scheduler = new Scheduler({
             *     features : {
             *         scheduleContextMenu : {
             *             // Process items before menu is shown
             *             processItems({date, resourceRecord, items}) {
             *                  // Push an extra item for ancient times
             *                  if (date < new Date(2018, 11, 17)) {
             *                      items.modernize = {
             *                          text : 'Modernize',
             *                          ontItem({date}) {
             *                              // Custom date based action
             *                          }
             *                      };
             *                  }
             *
             *                  // Do not show menu for Sundays
             *                  if (date.getDay() === 0) {
             *                      return false;
             *                  }
             *             }
             *         }
             *     }
             * });
             * ```
             *
             * @config {Function}
             */
            processItems : null,

            /**
             * This is a preconfigured set of {@link Core.widget.Container#config-namedItems} used to create the default context menu.
             *
             * The provided defaultItems setting is
             *
             *```javascript
             *    {
             *        addEvent : true
             *    }
             *```
             *
             * The `namedItems` provided by this feature are listed below. These are the property
             * names which you may configure in the feature's {@link #config-items} config:
             *
             * - `addEvent` Add an event for at the resource and time indicated by the `contextmenu` event.
             *
             * To remove existing items, set corresponding keys to `false`
             *
             * ```javascript
             * const scheduler = new Scheduler({
             *     features : {
             *         scheduleContextMenu : {
             *             items : {
             *                 addEvent : false
             *             }
             *         }
             *     }
             * });
             * ```
             *
             * @config {Object}
             */
            defaultItems : {
                addEvent : true
            }
        };
    }

    //endregion

    //region Events

    /**
     * Fired from scheduler before the context menu is shown for an event. Allows manipulation of the items
     * to show in the same way as in `processItems`. Returning false from a listener prevents the menu from
     * being shown.
     * @event scheduleContextMenuBeforeShow
     * @preventable
     * @param {Scheduler.view.Scheduler} source
     * @param {Object} items Menu item configs
     * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered
     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used
     * @param {HTMLElement} eventElement
     */

    /**
     * Fired from scheduler when an item is selected in the context menu.
     * @event scheduleContextMenuItem
     * @param {Scheduler.view.Scheduler} source
     * @param {Core.widget.MenuItem} item
     * @param {Scheduler.model.EventModel} eventRecord
     * @param {Scheduler.model.ResourceModel} resourceRecord
     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used
     * @param {HTMLElement} eventElement
     */

    /**
     * Fired from scheduler after showing the context menu for an event
     * @event scheduleContextMenuShow
     * @preventable
     * @param {Scheduler.view.Scheduler} source
     * @param {Core.widget.Menu} menu The menu
     * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered
     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record
     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used
     * @param {HTMLElement} eventElement
     */

    //endregion

    //region Init

    construct(scheduler, config) {
        super.construct(scheduler, config);

        this.scheduler = scheduler;
    }

    //endregion

    //region Events

    showEventContextMenu(event) {
        const
            scheduler        = this.scheduler,
            cellData         = scheduler.getEventData(event),
            isTimeAxisColumn = cellData
                ? scheduler.columns.getById(cellData.columnId) === scheduler.timeAxisColumn
                : scheduler.timeAxisSubGrid.element === event.target,
            // For vertical mode the resource must be resolved from the event
            resourceRecord   = scheduler.resolveResourceRecord(event) || scheduler.resourceStore.last;

        if (isTimeAxisColumn && !(resourceRecord && resourceRecord.meta.specialRow)) {
            this.showContextMenu({
                menuType : 'schedule',
                date     : scheduler.getDateFromDomEvent(event, 'floor'),
                resourceRecord,
                event
            });

            event.preventDefault();
        }
    }

    //endregion

    get namedItems() {
        const client = this.client;

        if (!this._namedItems) {
            this._namedItems = {
                addEvent : {
                    text     : client.L('Add event', null),
                    icon     : 'b-icon b-icon-add',
                    disabled : client.resourceStore.count === 0,
                    weight   : 100,
                    onItem({ date, resourceRecord }) {
                        client.internalAddEvent(date, resourceRecord, client.getRowFor(resourceRecord));
                    }
                }
            };
        }

        return this._namedItems;
    }
}

ScheduleContextMenu.featureClass = '';

ScheduleContextMenu._$name = 'ScheduleContextMenu'; GridFeatureManager.registerFeature(ScheduleContextMenu, true, 'Scheduler');

/**
 * @module Scheduler/feature/ScheduleTooltip
 */

/**
 * Feature that displays a tooltip containing the time at the mouse position when hovering empty parts of the schedule. To not show the tooltip, just disable this feature:
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         scheduleTooltip : false
 *     }
 * });
 * ```
 *
 * @extends Core/mixin/InstancePlugin
 * @demo Scheduler/basic
 * @externalexample scheduler/ScheduleTooltip.js
 */
class ScheduleTooltip extends InstancePlugin {
    //region Config

    static get $name() {
        return 'ScheduleTooltip';
    }

    static get defaultConfig() {
        return {
            messageTemplate : data => `<div class="b-sch-hovertip-msg">${data.message}</div>`
        };
    }

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            chain : ['render']
        };
    }

    //endregion

    //region Init

    /**
     * Called when scheduler is rendered. Sets up drag and drop and hover tooltip.
     * @private
     */
    render() {
        const me           = this,
            scheduler    = me.client;

        // TODO: render should not ever be called twice.
        if (me.hoverTip) {
            me.hoverTip.destroy();
        }

        let reshowListener;

        const tip = me.hoverTip = new Tooltip({
            id             : `${scheduler.id}-schedule-tip`,
            cls            : 'b-sch-scheduletip',
            allowOver      : true,
            hoverDelay     : 0,
            hideDelay      : 100,
            showOnHover    : true,
            forElement     : scheduler.timeAxisSubGridElement,
            anchorToTarget : false,
            trackMouse     : true,
            updateContentOnMouseMove : true,

            forSelector    : '.b-schedulerbase:not(.b-animating):not(.b-dragging-event):not(.b-dragcreating) .b-timeline-subgrid > :not(.b-sch-foreground-canvas):not(.b-group-footer):not(.b-group-row) *',
            // Do not constrain at all, want it to be able to go outside of the viewport to not get in the way
            constrainTo    : null,
            getHtml        : me.getHoverTipHtml.bind(me),
            onDocumentMouseDown(event) {
                // Click on the scheduler hides until the very next
                // non-button-pressed mouse move!
                if (tip.forElement.contains(event.event.target)) {
                    reshowListener = EventHelper.on({
                        element   : scheduler.timeAxisSubGridElement,
                        mousemove : e => tip.internalOnPointerOver(e),
                        capture   : true
                    });
                }

                const hideAnimation = tip.hideAnimation;
                tip.hideAnimation = false;
                tip.constructor.prototype.onDocumentMouseDown.call(tip, event);
                tip.hideAnimation = hideAnimation;
            },
            listeners : {
                pointerover : ({ event }) => {
                    const buttonsPressed = 'buttons' in event ? event.buttons > 0
                        : event.which > 0; // fallback for Safari which doesn't support 'buttons'

                    // This is the non-button-pressed mousemove
                    // after the document mousedown
                    if (!buttonsPressed && reshowListener) {
                        reshowListener();
                    }

                    // Never any tooltip while interaction is ongoing and a mouse button is pressed
                    return !me.disabled && !scheduler.readOnly && !buttonsPressed;
                }
            }
        });

        me.clockTemplate = new ClockTemplate({
            scheduler
        });
    }

    doDestroy() {
        const me = this;
        me.clockTemplate && me.clockTemplate.destroy();
        me.hoverTip && me.hoverTip.destroy();
        super.doDestroy();
    }

    //endregion

    //region Contents

    /**
     * Gets html to display in hover tooltip (tooltip displayed on empty parts of scheduler)
     */
    getHoverTipHtml({ tip, event }) {
        const
            me        = this,
            scheduler = me.client,
            date      = event && scheduler.getDateFromDomEvent(event, 'floor', true);

        let html      = me.lastHtml;

        if (date) {
            const resourceRecord = scheduler.resolveResourceRecord(event);

            if (date - me.lastTime !== 0 || resourceRecord !== me.lastResource) {
                me.lastResource = resourceRecord;
                html = me.lastHtml = me.generateTipContent(date, event);

            }
        }
        else {
            tip.hide();
            me.lastTime = null;
            me.lastResource = null;
        }

        return html;
    }

    /**
     * Called from getHoverTipHtml(), fills templates used.
     * @private
     */
    generateTipContent(date, event) {
        const me          = this,
            clockHtml   = me.clockTemplate.generateContent({
                date : date,
                text : me.client.getFormattedDate(date)
            }),
            messageHtml = me.messageTemplate({
                message : me.getText(date, event) || ''
            });

        me.lastTime = date;

        return clockHtml + messageHtml;
    }

    /**
     * Override this to render custom text to default hover tip
     * @param {Date} date
     * @param {Event} event Browser event
     * @return {String}
     */
    getText(date, event) {

    }

    //endregion
}

// TODO: Refactor SASS so thet auto-generated class name of 'b-' + cls.name.toLowerCase() can be used.
ScheduleTooltip.featureClass = 'b-scheduletip';

ScheduleTooltip._$name = 'ScheduleTooltip'; GridFeatureManager.registerFeature(ScheduleTooltip, true, 'Scheduler');

/**
 * @module Scheduler/view/Scheduler
 */

/**
 * The Scheduler widget is a very powerful and performant UI component that displays an arbitrary number of "locked"
 * columns with a schedule occupying the remaining space. The schedule has a timeaxis at the top, one row per resource
 * and any number of events per resource.
 *
 * ## Intro
 * The Scheduler widget has a wide range of features and a large API to allow users to work with it efficiently in the
 * browser.
 *
 * The timeaxis displayed at the top of the Scheduler is configured using a {@link Scheduler.view.TimelineBase#config-startDate},
 * {@link Scheduler.view.TimelineBase#config-endDate} and a {@link Scheduler.view.mixin.TimelineViewPresets#config-viewPreset}. The dates
 * determine the outer limits of the range shown in the timeaxis while the {@link Scheduler.preset.ViewPreset} decides
 * the appearance and which dates are actually shown. The Scheduler ships with a selection of predefined view presets,
 * which can be found in {@link Scheduler.preset.PresetManager}. If you want to specify view presets for a specific scheduler only, please
 * see {@link Scheduler.view.mixin.TimelineViewPresets#config-presets} config.
 *
 * The Scheduler uses a {@link Scheduler.data.ResourceStore} to hold resources and an {@link Scheduler.data.EventStore}
 * to hold events. You can use inline data or load data using ajax, see the "Working with data" guides for more
 * information.
 *
 * The simplest schedule configured with inline data would look like this:
 *
 *      let scheduler = new Scheduler({
 *          appendTo : document.body,
 *
 *          startDate  : new Date(2018,4,6),
 *          endDate    : new Date(2018,4,12),
 *          viewPreset : 'dayAndWeek',
 *
 *           columns : [
 *              { field : 'name', text : 'Name', width: 100 }
 *          ],
 *
 *          resources : [
 *              { id : 1, name : 'Bernard' },
 *              { id : 2, name : 'Bianca' }
 *          ],
 *
 *          events : [
 *              { id : 1, resourceId : 1, name : 'Interview', startDate : '2018-05-06', endDate : '2018-05-07' },
 *              { id : 2, resourceId : 1, name : 'Press conference', startDate : '2018-05-08', endDate : '2018-05-09' },
 *              { id : 3, resourceId : 2, name : 'Audition', startDate : '2018-05-06', endDate : '2018-05-08' },
 *              { id : 4, resourceId : 2, name : 'Script deadline', startDate : '2018-05-11', endDate : '2018-05-11' }
 *          ]
 *      });
 *
 * {@inlineexample scheduler/Simplest.js}
 * ## Inheriting from Bryntum Grid
 * Bryntum Scheduler inherits from Bryntum Grid, meaning that most features available for the grid are also available
 * for the scheduler. Common features include columns, cell editing, context menus, row grouping, sorting and more.
 *
 * For more information on configuring columns, filtering, search etc. please see the {@link Grid.view.Grid Grid API docs}.
 * {@region Loading data}
 * As mentioned above Bryntum Scheduler uses an {@link Scheduler.data.EventStore} and a {@link Scheduler.data.ResourceStore}
 * to hold its data. Data is expected to be in JSON format and can be assigned inline (from memory) using the
 * {@link Scheduler.view.mixin.SchedulerStores#config-events} and
 * {@link Scheduler.view.mixin.SchedulerStores#config-resources} shortcuts:
 * ```
 * let scheduler = new Scheduler({
 *    events : myArrayOfEventData,
 *    resources : myArrayOfResourceData
 * });
 * ```
 * If you need to give additional store configuration, you can also specify store configs or instances:
 * ```
 * let resourceStore = new ResourceStore({
 *   // ResourceStore config object
 * })
 *
 * let scheduler = new Scheduler({
 *    // EventStore config object
 *    eventStore : {
 *       ...
 *    },
 *
 *    // Already existing ResourceStore instance
 *    resourceStore
 * });
 * ```
 * To use Ajax to fetch data from a server, specify {@link Core.data.AjaxStore#config-readUrl}:
 * ```
 * let scheduler = new Scheduler({
 *    eventStore : {
 *        readUrl  : 'backend/read_events.php',
 *        autoLoad : true
 *    }
 * });
 * // If you do not specify autoLoad, trigger loading manually:
 * scheduler.eventStore.load();
 * ```
 * For more information, see the "Working with data" guides.
 * {@endregion}
 * {@region Event styling}
 * Bryntum Schedulers appearance can be affected in a few different ways:
 *
 * * Switching themes
 * * Choosing event styles and colors
 * * Using renderer functions
 *
 * ### Switching themes
 * Scheduler ships with four different themes, simply include the css file for the theme you would like to use on your
 * page. The themes are located in the `/build` folder. For example to include the light theme:
 * ```
 * <link rel="stylesheet" href="build/scheduler.light.css" id="bryntum-theme">
 * ```
 * Included themes are (from left to right) light, default, dark and material:
 *
 * <img src="../examples/basic/meta/thumb.light.png" alt="Light theme" width="300" style="margin-right: .5rem">
 * <img src="../examples/basic/meta/thumb.default.png" alt="Default theme" width="300" style="margin-right: .5rem">
 * <img src="../examples/basic/meta/thumb.dark.png" alt="Dark theme" width="300" style="margin-right: .5rem">
 * <img src="../examples/basic/meta/thumb.material.png" alt="Material theme" width="300">
 *
 * ### Choosing event styles and colors
 * The style and color of each event can be changed by assigning to the `eventStyle` and `eventColor` configs. These
 * configs are available at 3 different levels:
 *
 * * Scheduler level, affects all events (see {@link Scheduler.view.mixin.TimelineEventRendering#config-eventStyle} and {@link Scheduler.view.mixin.TimelineEventRendering#config-eventColor}).
 * * Resource level, affects all events assigned to that resource (see {@link Scheduler.model.ResourceModel#field-eventStyle}
 * and {@link Scheduler.model.ResourceModel#field-eventColor}).
 * * Event level, affects that event (see {@link Scheduler.model.EventModel#field-eventStyle} and
 * {@link Scheduler.model.EventModel#field-eventColor}).
 *
 * {@inlineexample scheduler/Styles.js}
 *
 * For available styles, see {@link Scheduler.view.mixin/TimelineEventRendering#config-eventStyle}. For colors,
 * {@link Scheduler.view.mixin/TimelineEventRendering#config-eventColor}. Also take a look at the
 * <a href="../examples/eventstyles" target="_blank">eventstyles demo</a>.
 *
 * ### Using render functions
 * Render function can be used to manipulate the rendering of rows (resources) and events. For information on row
 * renderers, see {@link Grid.column.Column#config-renderer}.
 *
 * Event rendering can be manipulated by specifying an {@link Scheduler.view.mixin/SchedulerEventRendering#config-eventRenderer} function. The function is called
 * for each event before it is rendered to DOM. By using its arguments you can add CSS classes, modify styling and
 * determine the contents of the event:
 * ```
 * let scheduler = new Scheduler({
 *
 *   events    : [...],
 *   resources : [...],
 *
 *   ...,
 *
 *   eventRenderer({resourceRecord, eventRecord, tplData}) {
 *      // add css class to the event
 *      tplData.cls.add('my-css-class');
 *
 *      // use an icon
 *      tplData.iconCls = 'b-fa b-fa-some-nice-icon';
 *
 *      // returnvalue is used as events text
 *      return `${resourceRecord.name}: ${eventRecord.name}`;
 *   }
 * });
 * ```
 * {@endregion}
 * {@region Event manipulation}
 * You can programmatically manipulate the events using data operations, see the "Working with data" guides for more
 * information. Events are reactive, changes reflect on the UI automatically. A small example on manipulating events:
 * ```
 * // change startDate of first event
 * scheduler.eventStore.first.startDate = new Date(2018,5,10);
 *
 * // remove last event
 * scheduler.eventStore.last.remove();
 *
 * // reassign an event
 * scheduler.eventStore.getById(10).resourceId = 2;
 * ```
 *
 * You can also allow your users to manipulate the events using the following features:
 *
 * * {@link Scheduler.feature.EventDrag}, drag and drop events within the schedule
 * * {@link Scheduler.feature.EventDragCreate}, create new events by click-dragging an empty area
 * * {@link Scheduler.feature.EventEdit}, show an event editing form
 * * {@link Scheduler.feature.SimpleEventEdit}, edit the event name easily
 * * {@link Scheduler.feature.EventResize}, resize events by dragging resize handles
 *
 * All of the features mentioned above are enabled by default.
 * {@endregion}
 *
 * {@region Default configs}
 * There is a myriad of configs and features available for Scheduler (browse the API docs to find them), some of them on
 * by default and some of them requiring extra configuration. The code below tries to illustrate the major things that
 * are used by default:
 *
 * ```javascript
 * let scheduler = new Scheduler({
 *    // The following features are enabled by default:
 *    features : {
 *        cellEdit            : true, // Cell editing in the columns part
 *        columnLines         : true, // Column lines in the schedule part
 *        columnPicker        : true, // Header context menu item to toggle visible columns
 *        columnReorder       : true, // Reorder columns in grid part using drag and drop
 *        columnResize        : true, // Resize columns in grid part using the mouse
 *        contextMenu         : true, // Context menu for cells and headers in the grid part
 *        eventContextMenu    : true, // Context menu for events
 *        eventDrag           : true, // Dragging events
 *        eventDragCreate     : true, // Drag creating events
 *        eventEdit           : true, // Event editor dialog
 *        eventFilter         : true, // Filtering events using header context menu
 *        eventResize         : true, // Resizing events using the mouse
 *        eventTooltip        : true, // Tooltips for events
 *        group               : true, // Row grouping
 *        headerContextMenu   : true, // Header context menu for schedule part
 *        scheduleContextMenu : true, // Context menu for empty parts of the schedule
 *        scheduleTooltip     : true, // Tooltip for empty parts of the schedule
 *        sort                : true  // Row sorting
 *    },
 *
 *    // From Grid
 *    animateRemovingRows       : false, // Rows will not slide out on removal
 *    autoHeight                : false, // Grid needs to have a height supplied through CSS (strongly recommended) or by specifying `height
 *    columnLines               : true,  // Grid part, themes might override it to hide lines anyway
 *    emptyText                 : 'No rows to display',
 *    enableTextSelection       : false, // Not allowed to select text in cells by default,
 *    fillLastColumn            : true,  // By default the last column is stretched to fill the grid
 *    fullRowRefresh            : true,  // Refreshes entire row when a cell value changes
 *    loadMask                  : 'Loading...',
 *    resizeToFitIncludesHeader : true,  // Also measure header when auto resizing columns
 *    responsiveLevels : {
 *      small : 400,
 *      medium : 600,
 *      large : '*'
 *    },
 *    rowHeight                  : 60,    // Scheduler specifies a default rowHeight in pixels
 *    showDirty                  : false, // No indicator for changed cells
 *    showRemoveRowInContextMenu : true,   // Context menu has "Remove row" item
 *
 *    // Scheduler specific
 *    autoAdjustTimeAxis             : true,      // startDate & endDate will be adjusted to display a suitable range
 *    allowOverlap                   : true,      // Events are allowed to overlap (overlays, stacks or packs depending on eventLayout)
 *    barMargin                      : 10,        // Space above + below each event
 *    createEventOnDblClick          : true,      // Allow creating new events by double clicking empty space
 *    enableDeleteKey                : true,      // Allow deleting events with delete / backspace keys
 *    enableEventAnimations          : true,      // Animate event changes
 *    eventBarTextField              : 'name',    // Field on EventModel to display in events
 *    eventColor                     : 'green',   // Use green as default color for events
 *    eventLayout                    : 'stack',   // Stack overlapping events by default
 *    eventStyle                     : 'plain',   // Use plain as default style for events
 *    managedEventSizing             : true,      // Calculate event sizes based on rowHeight & barMargin
 *    milestoneCharWidth             : 10,
 *    milestoneLayoutMode            : 'default',
 *    removeUnassignedEvent          : true,      // Remove event when all assignments for it are removed
 *    useInitialAnimation            : true,      // Fade in events initially
 *    viewPreset                     : 'weekAndDayLetter',
 *    zoomOnMouseWheel               : true,
 *    zoomOnTimeAxisDoubleClick      : true
 * });
 * ```
 * {@endregion}
 *
 * {@region Performance}
 * To make scheduler performance as good as possible it only renders the events and resources that are within view (plus
 * an additional buffer). Since adding to and removing from DOM comes with a performance penalty the elements are
 * instead repositioned and reused as you scroll. A side effect of this is that you cannot do direct DOM element
 * manipulation in a reliable way, instead you should use row and event renderer functions to achive what you want (see
 * the section on event styling above).
 *
 * To put the scheduler to the test, try our <a href="../examples/bigdataset" target="_blank">bigdataset demo</a>.
 * {@endregion}
 *
 * @extends Scheduler/view/SchedulerBase
 */
class Scheduler extends SchedulerBase {
    static get $name() {
        return 'Scheduler';
    }
}

Scheduler._$name = 'Scheduler'; BryntumWidgetAdapterRegister.register('scheduler', Scheduler);

VersionHelper.setVersion('scheduler', '3.1.0');

// Actions that trigger rerendering of group summary rows
const refreshActions = {
    add       : 1,
    remove    : 1,
    update    : 1,
    removeAll : 1,
    filter    : 1
};

/**
 * @module Scheduler/feature/GroupSummary
 */

// noinspection JSClosureCompilerSyntax
/**
 * A special version of the Grid GroupSummary feature that enables summaries within scheduler. To use a single summary
 * it is easiest to configure {@link #config-renderer}, for multiple summaries see {@link #config-summaries}.
 *
 * This feature is <strong>disabled</strong> by default. It is **not** supported in vertical mode.
 *
 * @extends Grid/feature/GroupSummary test
 *
 * @classtype groupsummary
 * @externalexample scheduler/GroupSummary.js
 * @demo Scheduler/groupsummary
 * @typings Grid/feature/GroupSummary -> Grid/feature/GridGroupSummary
 */
class GroupSummary$1 extends GroupSummary {
    //region Config

    static get $name() {
        return 'GroupSummary';
    }

    static get defaultConfig() {
        return {
            /**
             * Show tooltip containing summary values and labels
             * @config {Boolean}
             * @default
             */
            showTooltip : true,

            /**
             * Array of summary configs, with format
             * `[{ label: 'Label', renderer : ({startDate, endDate, eventStore, resourceStore, events, element}) }]`.
             * @config {Object[]}
             */
            summaries : null,

            /**
             * Easier way to configure when using a single summary. Accepts a renderer function with the format specified
             * in {@link #config-summaries}
             * @config {Function}
             */
            renderer : null
        };
    }

    static get pluginConfig() {
        return {
            chain : ['render']
        };
    }

    //endregion

    //region Init

    construct(scheduler, config) {
        const me = this;

        if (scheduler.isVertical) {
            throw new Error('GroupSummary feature is not supported in vertical mode');
        }

        me.scheduler = scheduler;

        super.construct(scheduler, config);

        if (!me.summaries && me.renderer) {
            me.summaries = [{ renderer : me.renderer }];
        }

        me.isScheduler = scheduler instanceof Scheduler;

        if (me.isScheduler) {
            scheduler.eventStore.on({
                change  : me.onEventStoreChange,
                thisObj : me
            });
            scheduler.timeAxis.on({
                reconfigure : me.onTimeAxisChange,
                thisObj     : me
            });
            scheduler.timeAxisViewModel.on({
                update  : me.onTimeAxisChange,
                thisObj : me
            });
        }

        
    }

    doDestroy() {
        if (this._tip) {
            this._tip.destroy();
        }

        super.doDestroy();
    }

    //endregion

    //region Events

    onTimeAxisChange() {
        this.rerenderGroupSummaries();
    }

    onEventStoreChange({ action }) {
        // Scheduler does minimal update on event changes, it will not rerender the summary rows.
        // Need to handle that here
        if (refreshActions[action]) {
            this.rerenderGroupSummaries();
        }
    }

    rerenderGroupSummaries() {
        // TODO: Sort out the affected rows by checking events resources
        this.scheduler.rowManager.rows.forEach(row => {
            if (row.isGroupFooter) {
                row.render();
            }
        });
    }

    //endregion

    //region Render

    /**
     * Called before rendering row contents, used to reset rows no longer used as group summary rows
     * @private
     */
    onBeforeRenderRow({ row, record }) {
        if (row.isGroupFooter && !record.meta.hasOwnProperty('groupFooterFor')) {
            const timeaxisCell = row.elements.normal.querySelector('.b-sch-timeaxis-cell');

            // remove summary cells if exist
            if (timeaxisCell) {
                timeaxisCell.innerHTML = '';
            }
        }

        super.onBeforeRenderRow(...arguments);
    }

    /**
     * Called by parent class to fill timeaxis with summary contents. Generates tick "cells" and populates them with
     * summaries.
     * ```
     * <div class="b-timeaxis-group-summary">
     *     <div class="b-timeaxis-tick">
     *         <div class="b-timeaxix-summary-value">x</div>
     *         ...
     *     </div>
     *     ...
     * </div>
     * ```
     * @private
     */
    generateHtml(column, records, cls) {
        if (column.type === 'timeAxis') {
            const
                me        = this,
                scheduler = me.scheduler,
                tickSize  = scheduler.tickSize;

            let html = '';

            scheduler.timeAxis.forEach(tick => {
                const
                    // events for current tick
                    events      = scheduler.eventStore.getEventsInTimeSpan(tick.startDate, tick.endDate, true, true),
                    // filter those events to current groups
                    groupEvents = events.filter(event => event.resources.some(resource => records.includes(resource)));

                // TODO: could turn this into a template

                const sumHtml = me.summaries.map(config => {
                    // summary renderer used to calculate and format value
                    const value = config.renderer({
                        startDate     : tick.startDate,
                        endDate       : tick.endDate,
                        eventStore    : scheduler.eventStore,
                        resourceStore : scheduler.resourceStore,
                        events        : groupEvents
                    });

                    return `<div class="b-timeaxis-summary-value">${value}</div>`;
                }).join('');

                html += `<div class="b-timeaxis-tick" style="width: ${tickSize}px">${sumHtml}</div>`;
            });

            return `<div class="b-timeaxis-group-summary">${html}</div>`;
        }

        return super.generateHtml(column, records, cls);
    }

    /**
     * Overrides parents function to return correct summary count, used when sizing row
     * @private
     */
    updateSummaryHtml(cellElement, column, records) {
        const count = super.updateSummaryHtml(cellElement, column, records);

        if (column.type === 'timeAxis') {
            let result = {
                count  : 0,
                height : 0
            };

            this.summaries.forEach(config => {
                if (config.height) {
                    result.height += config.height;
                }
                else {
                    result.count++;
                }
            });

            return result;
        }

        return count;
    }

    /**
     * Generates tooltip contents for hovered summary tick
     * @private
     */
    getTipHtml({ activeTarget }) {
        const me            = this,
            index         = Array.from(activeTarget.parentElement.children).indexOf(activeTarget),
            tick          = me.scheduler.timeAxis.getAt(index);

        let tipHtml = `<header>${me.L('Summary for')} ${me.scheduler.getFormattedDate(tick.startDate)}</header>`,
            showTip = false;

        DomHelper.forEachSelector(activeTarget, '.b-timeaxis-summary-value', (element, i) => {
            const label = me._labels[i],
                text  = element.innerText.trim();

            tipHtml += `<label>${label || ''}</label><div class="b-timeaxis-summary-value">${text}</div>`;

            if (element.innerHTML) showTip = true;
        });

        return showTip ? tipHtml : null;
    }

    /**
     * Initialize tooltip on render
     * @private
     */
    render() {
        const
            me = this,
            { scheduler } = me;

        if (me.isScheduler) {
            // if any sum config has a label, init tooltip
            if (me.summaries && me.summaries.some(config => config.label) && me.showTooltip && !me._tip) {
                me._labels = me.summaries.map(config => config.label || '');

                me._tip = new Tooltip({
                    id             : `${scheduler.id}-groupsummary-tip`,
                    cls            : 'b-timeaxis-summary-tip',
                    hoverDelay     : 0,
                    hideDelay      : 0,
                    forElement     : scheduler.timeAxisSubGridElement,
                    anchorToTarget : true,
                    forSelector    : '.b-timeaxis-group-summary .b-timeaxis-tick',
                    clippedBy      : [scheduler.timeAxisSubGridElement, scheduler.bodyContainer],
                    getHtml        : me.getTipHtml.bind(me)
                });
            }
        }
    }

    //endregion
}

// Needed for module bundle, which turns class name into GroupSummary$1 and registers it wrong
GroupSummary$1._$name = 'GroupSummary';

// Override Grids GroupSummary with this improved version
GroupSummary$1._$name = 'GroupSummary'; GridFeatureManager.registerFeature(GroupSummary$1, false, 'Scheduler');

/**
 * @module Scheduler/feature/HeaderZoom
 */

/**
 * Enables users to click and drag to zoom to a date range in Scheduler's header time axis.
 *
 * This feature is **disabled** by default.
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @example
 * let scheduler = new Scheduler({
 *   features : {
 *     headerZoom      : true
 *   }
 * });
 *
 * @classtype HeaderZoom
 * @externalexample scheduler/HeaderZoom.js
 */
class HeaderZoom extends InstancePlugin {

    static get $name() {
        return 'HeaderZoom';
    }

    // Plugin configuration. This plugin chains some of the functions in Scheduler.
    static get pluginConfig() {
        return {
            chain : ['onElementMouseDown', 'onElementMouseMove', 'onElementMouseUp']
        };
    }

    onElementMouseDown(event) {
        const
            me        = this,
            scheduler = me.client;

        // only react to mouse input, and left button
        if (event.touches || event.button !== 0 || me.disabled) {
            return;
        }

        // only react to mousedown directly on timeaxis cell
        if (event.target.matches('.b-sch-header-timeaxis-cell')) {
            const headerEl = scheduler.subGrids.normal.header.headersElement;

            me.startX = event.clientX;

            me.element = DomHelper.createElement({
                parent    : headerEl,
                tag       : 'div',
                className : 'b-headerzoom-rect'
            });

            me.headerElementRect = Rectangle.from(headerEl);
        }
    }

    onElementMouseMove(event) {
        const me = this;

        // Synthetic mousemove event has no button for IE11
        // Detect if a mouseup happened outside our element (or browser window for that matter). Note 'buttons' is not supported by Safari
        if (event.buttons === 0 && (!BrowserHelper.isSafari && (!BrowserHelper.isIE11 || event.isTrusted))) {
            me.onElementMouseUp(event);
            return;
        }

        if (typeof me.startX === 'number') {
            const
                x     = Math.max(event.clientX, me.headerElementRect.left),
                left  = Math.min(me.startX, x),
                width = Math.abs(me.startX - x),
                rect  = new Rectangle(left - me.headerElementRect.x + me.client.scrollLeft, 0, width, me.headerElementRect.height);

            DomHelper.setTranslateX(me.element, rect.left);
            me.element.style.width = rect.width + 'px';
        }
    }

    onElementMouseUp(event) {
        const me = this;

        if (typeof me.startX === 'number') {
            const
                timeline  = me.client,
                rect      = Rectangle.from(me.element),
                startDate = timeline.getDateFromCoordinate(rect.left, 'round', false),
                endDate   = timeline.getDateFromCoordinate(rect.right, 'round', false);

            me.element && me.element.remove();
            me.startX = null;

            me.client.zoomToSpan({
                startDate,
                endDate
            });
        }
    }
}

HeaderZoom._$name = 'HeaderZoom'; GridFeatureManager.registerFeature(HeaderZoom, false, 'Scheduler');

// TODO: Gantt uses its own rendering, split this into LabelsBase + Labels.
//  LabelsBase = everthing except onEventPaint, appendLabel & updateLabel

/**
 * @module Scheduler/feature/Labels
 */

const sides = [
        'top',
        'left',
        'right',
        'bottom'
    ],
    editorAlign = {
        top    : 'b-b',
        right  : 'l-l',
        bottom : 't-t',
        left   : 'r-r'
    },
    topBottom = {
        top    : 1,
        bottom : 1
    };

/**
 * Displays labels at positions {@link #config-top}, {@link #config-right}, {@link #config-bottom} and {@link #config-left}.
 *
 * Text in labels can be set from a field on the {@link Scheduler.model.EventModel EventModel}
 * or the {@link Scheduler.model.ResourceModel ResourceModel} or using a custom renderer.
 *
 * Since `top` and `bottom` labels occupy space that would otherwise be used by the event we recommend using bigger rowHeights
 * (>55px for both labels with default styling) and zero barMargins because `top`/`bottom` labels give space around events anyway.
 *
 * This feature is **disabled** by default. It is **not** supported in vertical mode.
 *
 * @extends Core/mixin/InstancePlugin
 * @demo Scheduler/labels
 * @externalexample scheduler/Labels.js
 */
class Labels extends InstancePlugin {
    //region Config

    static get $name() {
        return 'Labels';
    }

    static get defaultConfig() {
        return {
            /**
             * CSS class to apply to label elements
             * @config {String}
             * @default
             */
            labelCls : 'b-sch-label',

            /**
             * Top label configuration object. May contain the following properties:
             * - field : [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) The name of a field in one of the associated records,  {@link Scheduler.model.EventModel EventModel} or  {@link Scheduler.model.ResourceModel ResourceModel}. The record from which the field value is drawn will be ascertained by checking for field definitions by the specified name.<br>
             * - renderer : [Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) A function, which when passed an object containing `eventRecord`, `resourceRecord` and `labelElement` properties, returns the HTML to display as the label.<br>
             * - thisObj : [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) The `this` reference to use in the `renderer`.
             * - editor : [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) / {@link Core.widget.Field Field} If the label is to be editable, a field configuration object with a `type` property, or an instantiated Field. **The `field` property is mandatory for editing to work**.
             * @config {Object}
             * @default
             */
            top : null,

            /**
             * Right label configuration object. May contain the following properties:
             * - field : [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) The name of a field in one of the associated records,  {@link Scheduler.model.EventModel EventModel} or  {@link Scheduler.model.ResourceModel ResourceModel}. The record from which the field value is drawn will be ascertained by checking for field definitions by the specified name.<br>
             * - renderer : [Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) A function, which when passed an object containing `eventRecord`, `resourceRecord` and `labelElement` properties, returns the HTML to display as the label.<br>
             * - thisObj : [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) The `this` reference to use in the `renderer`.
             * - editor : [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) / {@link Core.widget.Field Field} If the label is to be editable, a field configuration object with a `type` property, or an instantiated Field. **The `field` property is mandatory for editing to work**.
             * @config {Object}
             * @default
             */
            right : null,

            /**
             * Bottom label configuration object. May contain the following properties:
             * - field : [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) The name of a field in one of the associated records,  {@link Scheduler.model.EventModel EventModel} or  {@link Scheduler.model.ResourceModel ResourceModel}. The record from which the field value is drawn will be ascertained by checking for field definitions by the specified name.<br>
             * - renderer : [Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) A function, which when passed an object containing `eventRecord`, `resourceRecord` and `labelElement` properties, returns the HTML to display as the label.<br>
             * - thisObj : [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) The `this` reference to use in the `renderer`.
             * - editor : [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) / {@link Core.widget.Field Field} If the label is to be editable, a field configuration object with a `type` property, or an instantiated Field. **The `field` property is mandatory for editing to work**.
             * @config {Object}
             * @default
             */
            bottom : null,

            /**
             * Left label configuration object. May contain the following properties:
             * - field : [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) The name of a field in one of the associated records,  {@link Scheduler.model.EventModel EventModel} or  {@link Scheduler.model.ResourceModel ResourceModel}. The record from which the field value is drawn will be ascertained by checking for field definitions by the specified name.<br>
             * - renderer : [Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) A function, which when passed an object containing `eventRecord`, `resourceRecord` and `labelElement` properties, returns the HTML to display as the label.<br>
             * - thisObj : [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) The `this` reference to use in the `renderer`.
             * - editor : [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) / {@link Core.widget.Field Field} If the label is to be editable, a field configuration object with a `type` property, or an instantiated Field. **The `field` property is mandatory for editing to work**.
             * @config {Object}
             * @default
             */
            left : null,

            thisObj : null,

            /**
             * What action should be taken when focus moves leaves the cell editor, for example when clicking outside.
             * May be `'complete'` or `'cancel`'.
             * @config {String}
             * @default
             */
            blurAction : 'cancel'
        };
    }

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {};
    }

    //endregion

    //region Init & destroy

    construct(scheduler, config) {
        const me = this;

        if (scheduler.isVertical) {
            throw new Error('Labels feature is not supported in vertical mode');
        }

        me.scheduler = scheduler;
        me.labelElements = {};

        super.construct(scheduler, config);

        const { top, bottom, left, right } = me;

        if (top || bottom || left || right) {
            me.schedulerDetatcher = scheduler.on({
                eventpaint   : 'onEventPaint',
                eventrepaint : 'onEventPaint',
                thisObj      : me
            });

            me.updateHostClasslist();

            // rowHeight warning, not in use
            //const labelCount = !!me.topLabel + !!me.bottomLabel;
            //if (scheduler.rowHeight < 60 - labelCount * 12) console.log('')
        }
    }

    updateHostClasslist() {
        const { top, bottom } = this,
            { classList } = this.scheduler.element;

        classList.remove('b-labels-topbottom');
        classList.remove('b-labels-top');
        classList.remove('b-labels-bottom');

        // OR is correct. This means that there are labels above OR below.
        if (top || bottom) {
            classList.add('b-labels-topbottom');
            if (top) {
                classList.add('b-labels-top');
            }
            if (bottom) {
                classList.add('b-labels-bottom');
            }
        }
    }

    onLabelDblClick(event) {
        const
            me     = this,
            target = event.target;

        if (target && !me.scheduler.readOnly) {
            const
                { side }                      = target.dataset,
                labelConfig                   = me[side],
                { editor, field, recordType } = labelConfig;

            if (editor) {
                const eventRecord = this.scheduler.resolveEventRecord(event.target);

                if (!(editor instanceof Editor)) {
                    labelConfig.editor = new Editor({
                        appendTo     : me.scheduler.element,
                        blurAction   : me.blurAction,
                        inputField   : editor,
                        scrollAction : 'realign'
                    });
                }

                labelConfig.editor.startEdit({
                    target,
                    align     : editorAlign[side],
                    matchSize : false,
                    record    : eventRecord,
                    field
                });

                event.stopImmediatePropagation();
                return false;
            }
        }
    }

    set top(top) {
        this._top = this.processLabelSpec(top, 'top');
        this.updateHostClasslist();
    }
    get top() {
        return this._top;
    }

    set right(right) {
        this._right = this.processLabelSpec(right, 'right');
        this.updateHostClasslist();
    }
    get right() {
        return this._right;
    }

    set bottom(bottom) {
        this._bottom = this.processLabelSpec(bottom, 'bottom');
        this.updateHostClasslist();
    }
    get bottom() {
        return this._bottom;
    }

    set left(left) {
        this._left = this.processLabelSpec(left, 'left');
        this.updateHostClasslist();
    }
    get left() {
        return this._left;
    }

    processLabelSpec(labelSpec, side) {
        if (typeof labelSpec === 'function') {
            labelSpec = {
                renderer : labelSpec
            };
        }
        else if (typeof labelSpec === 'string') {
            labelSpec = {
                field : labelSpec
            };
        }
        // Allow us to mutate ownProperties in the labelSpec without mutating outside object
        else if (labelSpec) {
            labelSpec = Object.setPrototypeOf({}, labelSpec);
        }
        else {
            return;
        }

        const { scheduler } = this,
            { eventStore, resourceStore, taskStore, id } = scheduler,
            { field, editor } = labelSpec;

        // If there are milestones, and we are changing the available height
        // either by adding a top/bottom label, or adding a top/bottom label
        // then during the next dependency refresh, milestone width must be recalculated.
        if (topBottom[side]) {
            scheduler.milestoneWidth = null;
        }

        // Find the field definition or property from whichever store and cache the type.
        if (field) {
            let fieldDef;

            if (eventStore && !taskStore) {
                fieldDef = eventStore.modelClass.fieldMap[field];
                if (fieldDef) {
                    labelSpec.fieldDef = fieldDef;
                    labelSpec.recordType = 'event';
                }
                // Check if it references a property
                else if (Reflect.has(eventStore.modelClass.prototype, field)) {
                    labelSpec.recordType = 'event';
                }
            }

            if (!fieldDef && taskStore) {
                fieldDef = taskStore.modelClass.fieldMap[field];
                if (fieldDef) {
                    labelSpec.fieldDef = fieldDef;
                    labelSpec.recordType = 'task';
                }
                // Check if it references a property
                else if (Reflect.has(resourceStore.modelClass.prototype, field)) {
                    labelSpec.recordType = 'task';
                }
            }

            if (!fieldDef && resourceStore) {
                fieldDef = resourceStore.modelClass.fieldMap[field];
                if (fieldDef) {
                    labelSpec.fieldDef = fieldDef;
                    labelSpec.recordType = 'resource';
                }
                // Check if it references a property
                else if (Reflect.has(resourceStore.modelClass.prototype, field)) {
                    labelSpec.recordType = 'resource';
                }
            }
            

            if (editor) {
                if (typeof editor === 'boolean') {
                    scheduler.editor = {
                        type : 'textfield'
                    };
                }
                else if (typeof editor === 'string') {
                    scheduler.editor = {
                        type : editor
                    };
                }
                EventHelper.on({
                    element  : scheduler.timeAxisSubGrid.element,
                    delegate : '.b-sch-label',
                    dblclick : 'onLabelDblClick',
                    thisObj  : this
                });
            }
        }

        

        return labelSpec;
    }

    doDestroy() {
        this.schedulerDetatcher && this.schedulerDetatcher();
        super.doDestroy();
    }

    doDisable(disable) {
        super.doDisable(disable);

        if (this.client.isPainted) {
            this.client.refresh();
        }
    }

    //endregion

    //region Events

    /**
     * Called when a new event element is created or updated. Make correct label state.
     * @private
     */
    onEventPaint(paintEvent) {
        // Tear down old label setup (we may have been reconfigured)
        DomHelper.removeEachSelector(paintEvent.element, '.b-sch-label');

        if (!this.disabled) {
            // Insert all configured labels
            for (const side of sides) {
                if (this[side]) {
                    this.appendLabel(side, paintEvent.element, paintEvent);
                }
            }
        }
    }

    //endregion

    //region Labels

    /**
     * Appends a label to a wrapping element
     * @private
     * @param side
     * @param appendTo
     * @param eventRecord
     */
    appendLabel(side, appendTo, paintEvent) {
        this.labelElements[side] = DomHelper.createElement({
            tag     : 'label',
            dataset : { side },
            parent  : appendTo
        });

        this.updateLabel(side, paintEvent);
    }

    /**
     * Updates a labels content
     * @private
     * @param side
     * @param eventRecord
     */
    updateLabel(side, paintEvent) {
        const me            = this,
            {
                field,
                fieldDef,
                recordType,
                renderer,
                thisObj
            }             = me[side],
            labelElement  = me.labelElements[side];

        let value;

        // Correct class name in case of element recycling from another render condition.
        labelElement.className = `${me.labelCls} ${me.labelCls}-${side}`;

        // If there's a renderer, use that by preference
        if (renderer) {
            value = renderer.call(thisObj || me.thisObj || me, Object.assign({ labelElement }, paintEvent));
        }
        else {
            value = paintEvent[`${recordType}Record`][field];

            // If it's a date, format it according to the Scheduler's defaults
            if (fieldDef && fieldDef.type === 'date' && !renderer) {
                value = DateHelper.format(value, me.scheduler.displayDateFormat);
            }
        }

        labelElement.innerHTML = value || '\xa0';
    }

    //endregion
}

// TODO: Refactor the SASS, so that the auto-generated class name of ''b-' + cls.name.toLowerCase() can be used.
Labels.featureClass = 'b-sch-labels';

Labels._$name = 'Labels'; GridFeatureManager.registerFeature(Labels, false, 'Scheduler');

/**
 * @module Scheduler/feature/AbstractTimeRanges
 */

/**
 * Abstract base class, you should not use this class directly.
 * @abstract
 * @mixes Core/mixin/Delayable
 * @extends Core/mixin/InstancePlugin
 */
class AbstractTimeRanges extends Delayable(InstancePlugin) {
    //region Config

    static get defaultConfig() {
        return {
            // CSS class to apply to range elements
            rangeCls : 'b-sch-range',

            // CSS class to apply to line elements (0-duration time range)
            lineCls : 'b-sch-line',

            /**
             * Store that holds timeRanges (using the {@link Scheduler.model.TimeSpan} model or subclass thereof).
             * A store will be automatically created if none is specified
             * @config {Object|Core.data.Store}
             */
            store : {
                modelClass : TimeSpan
            },

            /**
             * Set to `true` to enable dragging and resizing of range elements in the header. Only relevant when {@link #config-showHeaderElements} is true.
             * @config {Boolean}
             * @defaultValue
             */
            enableResizing : false,

            /**
             * Specifies whether or not to show tooltip while resizing range elements
             * @config {Boolean}
             * @default
             */
            showTooltip : true,

            /**
             * `true` to render range elements into the time axis header
             * @config {Boolean}
             * @default
             */
            showHeaderElements : true,

            dragTipTemplate : data => `
                <div class="b-sch-tip-${data.valid ? 'valid' : 'invalid'}">
                    <div class="b-sch-tip-name">${data.name || ''}</div>
                    ${data.startClockHtml}
                    ${data.endClockHtml || ''}
                </div>
            `,

            baseCls : 'b-sch-timerange',

            // a unique cls used by subclasses to get custom styling of the elements rendered
            cls : ''
        };
    }

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            chain : ['onPaint', 'getHeaderMenuItems']
        };
    }

    //endregion

    //region Init & destroy

    construct(client, config) {
        const me = this;

        super.construct(client, config);

        // Add a unique cls used by subclasses to get custom styling of the elements rendered
        // This makes sure that each class only removed its own elements from the DOM
        me.cls = me.cls || `b-timerange-${me.constructor.$name}`;

        me.baseSelector = `.${me.baseCls}.${me.cls}`;

        // header elements are required for interaction
        if (me.enableResizing) {
            me.showHeaderElements = true;
        }
    }

    doDestroy() {
        const me = this;

        me.storeDetacher && me.storeDetacher();
        me.timeAxisViewModelDetacher && me.timeAxisViewModelDetacher();
        me.timeAxisDetacher && me.timeAxisDetacher();

        me.clockTemplate && me.clockTemplate.destroy();
        me.tip && me.tip.destroy();

        me.drag && me.drag.destroy();
        me.resize && me.resize.destroy();

        super.doDestroy();
    }

    doDisable(disable) {
        if (this.client.isPainted) {
            this.renderRanges();
        }

        super.doDisable(disable);
    }

    //endregion

    //region Draw

    onPaint() {
        const me = this;

        if (!me.isPainted) {
            me.timeAxisViewModel = me.client.timeAxisViewModel;

            me.timeAxisViewModelDetacher = me.timeAxisViewModel.on({
                reconfigure : me.onTimeAxisViewModelUpdate,
                update      : me.onTimeAxisViewModelUpdate,
                thisObj     : me
            });

            me.timeAxisDetacher = me.client.timeAxis.on({
                includeChange : me.onTimeAxisViewModelUpdate,
                thisObj       : me
            });

            if (me.enableResizing && !me.client.hideHeaders) {
                me.drag = new DragHelper({
                    name               : 'rangeDrag',
                    mode               : me.client.isVertical ? 'translateY' : 'translateX',
                    constrain          : true,
                    outerElement       : me.headerContainerElement,
                    targetSelector     : `${me.baseSelector}`,
                    isElementDraggable : (el, event) => !me.client.readOnly && me.isElementDraggable(el, event),
                    transitionDuration : me.client.transitionDuration,

                    listeners : {
                        dragstart : me.onDragStart,
                        drag      : me.onDrag,
                        drop      : me.onDrop,
                        abort     : me.onInvalidDrop,
                        thisObj   : me
                    }
                });

                me.resize = new ResizeHelper({
                    direction          : me.client.mode,
                    targetSelector     : `${me.baseSelector}.b-sch-range`,
                    outerElement       : me.headerContainerElement,
                    isElementResizable : el => !el.closest('.b-dragging'),
                    listeners          : {
                        resizestart : me.onResizeStart,
                        resizing    : me.onResizeDrag,
                        resize      : me.onResize,
                        cancel      : me.onInvalidResize,
                        thisObj     : me
                    }
                });
            }

            me.renderRanges();
        }
    }

    renderRanges() {
        const
            me    = this,
            element = me.client.foregroundCanvas;

        // Scheduler/Gantt might not yet be rendered
        if (element) {
            const { headerContainerElement, store } = me;

            // remove existing timeRanges
            DomHelper.removeEachSelector(element, me.baseSelector);

            // Partnered Scheduler might not have header container element
            if (headerContainerElement) {
                DomHelper.removeEachSelector(headerContainerElement, me.baseSelector);
            }

            if (!me.disabled) {
                // add timeRanges
                for (const range of store) {
                    me.renderRange(range, true);
                }
            }
        }
    }

    renderRange(range, injectIntoDom) {
        const
            me     = this,
            client = me.client;

        if (
            range.duration && client.timeAxis.timeSpanInAxis(range.startDate, range.endDate) ||
            (range.startDate && client.timeAxis.dateInAxis(range.startDate))
        ) {
            const
                startPos    = client.getCoordinateFromDate(DateHelper.max(range.startDate, client.timeAxis.startDate), {
                    respectExclusion : true
                }),
                endPos      = range.duration && client.getCoordinateFromDate(DateHelper.min(range.endDate, client.timeAxis.endDate), {
                    respectExclusion : true,
                    isEnd            : true
                }),
                labelTpl    = `<label>${range.name || '&nbsp;'}</label>`,
                config      = {
                    className : `${me.baseCls} ${me.cls} ${endPos ? me.rangeCls : me.lineCls} ${range.cls || ''}`,
                    dataset   : {
                        id : range.id
                    },
                    style : client.isVertical
                        ? `transform: translateY(${startPos}px); ${endPos ? `height:${endPos - startPos}px` : ''};`
                        : `transform: translateX(${startPos}px); ${endPos ? `width:${endPos - startPos}px` : ''};`,
                    retainElement : true // To prevent DomHelper.sync from reusing the element
                },
                bodyElement = DomHelper.createElement(Object.assign({}, config, {
                    parent : injectIntoDom && client.foregroundCanvas,
                    style  : config.style + (range.style || ''),
                    html   : me.showHeaderElements ? '' : labelTpl
                }));

            let headerElement;

            if (me.showHeaderElements) {
                headerElement = DomHelper.createElement(Object.assign({
                    parent : injectIntoDom && me.headerContainerElement,
                    html   : range.name ? labelTpl : ''
                }, config));
            }

            const result = { bodyElement, headerElement };

            if (injectIntoDom) {
                // Make the label run vertically if it overflows the width
                me.rotateLabel(result);
            }

            return result;
        }
    }

    rotateLabel({ bodyElement }) {
        const label = bodyElement.firstChild;

        // Lines have no label
        if (!label) {
            return;
        }

        // Remove any rotation so with can be measured.
        label.classList.remove('b-vertical');

        const rotate = this.client.isVertical
            ? label.offsetHeight < bodyElement.offsetHeight
            : label.offsetWidth > bodyElement.offsetWidth;

        // If it overflows, rotate it.
        label.classList[rotate ? 'add' : 'remove']('b-vertical');
    }

    // returns one body el (+ optionally one header el) that represents a time range, or null if timeRanges is not currently rendered
    getElementsByRecord(idOrRecord) {
        const
            id            = typeof idOrRecord !== 'object' ? idOrRecord : idOrRecord.id,
            bodyElement   = this.client.foregroundCanvas.querySelector(`${this.baseSelector}[data-id="${id}"]`),
            headerElement = this.headerContainerElement.querySelector(`${this.baseSelector}[data-id="${id}"]`);

        return bodyElement ? { bodyElement, headerElement } : null;
    }

    getBodyElementByRecord(idOrRecord) {
        const id = typeof idOrRecord === 'string' ? idOrRecord : idOrRecord.id;

        return this.client.foregroundCanvas.querySelector(`${this.baseSelector}[data-id="${id}"]`);
    }

    getRecordByElement(el) {
        return this.store.getById(el.dataset.id);
    }

    get headerContainerElement() {
        const { isVertical, timeView, timeAxisColumn } = this.client;
        let element = null;

        // Render into the subGrid´s header element or the vertical timeaxis depending on mode
        if (isVertical && timeView.element) {
            element = timeView.element.parentElement;
        }
        else if (!isVertical) {
            element = timeAxisColumn.element;
        }

        return element;
    }

    //endregion

    //region Settings

    /**
     * Get/set if header elements should be rendered
     * @property {boolean}
     */
    get showHeaderElements() {
        return this._showHeaderElements;
    }

    set showHeaderElements(show) {
        this._showHeaderElements = show;

        if (!this.client.isPainted) return;

        if (show) {
            this.client.element.classList.add('b-sch-timeranges-with-headerelements');
        }
        else {
            this.client.element.classList.remove('b-sch-timeranges-with-headerelements');
        }
        this.renderRanges();
    }

    //endregion

    //region Menu items

    /**
     * @private
     */
    getHeaderMenuItems(column, items) {
        return [];
    }

    //endregion

    //region Store

    /**
     * Returns the {@link Core.data.Store store} used by this feature
     * @property {Core.data.Store}
     */
    get store() {
        return this._store;
    }

    set store(store) {
        const
            me = this;

        me._store = Store.getStore(store, Store);

        let renderRanges = false;

        // if we had some store assigned before we need to detach it
        if (me.storeDetacher) {
            me.storeDetacher();
            // then we'll need to render ranges provided by the new store
            renderRanges = true;
        }

        me.storeDetacher = me._store.on({
            change  : me.onStoreChanged,
            refresh : me.onStoreChanged,
            thisObj : me
        });

        // render ranges if needed
        renderRanges && this.renderRanges();
    }

    //endregion

    //region Events

    onTimeAxisViewModelUpdate() {
        this.renderRanges();
    }

    onStoreChanged(event) {
        const me = this;

        if (me.isConfiguring || (event.type === 'refresh' && event.action !== 'batch')) {
            return;
        }

        // Only animate changes that happen as a result of a pure data change, i.e. not after a drag drop
        if (event.action === 'update') {
            const
                id               = event.changes.hasOwnProperty('id') ? event.changes.id.oldValue : event.record.id,
                existingElements = me.getElementsByRecord(id),
                redrawnElements  = me.renderRange(event.record, !existingElements);

            if (existingElements && !redrawnElements) {
                existingElements.bodyElement.remove();
                existingElements.headerElement && existingElements.headerElement.remove();
            }

            if (!existingElements || !redrawnElements) return;

            me.client.runWithTransition(() => {
                DomHelper.sync(redrawnElements.bodyElement, existingElements.bodyElement);

                if (me.showHeaderElements) {
                    DomHelper.sync(redrawnElements.headerElement, existingElements.headerElement);
                }

                // Make the label run vertically if it overflows the width
                me.rotateLabel(existingElements);
            });
        }
        else {
            me.renderRanges();
        }
    }

    //endregion

    //region Drag drop

    showTip(context) {
        const me = this;

        if (me.showTooltip) {
            me.clockTemplate = new ClockTemplate({
                scheduler : me.client
            });

            me.tip = new Tooltip({
                id                       : `${me.client.id}-time-range-tip`,
                cls                      : 'b-interaction-tooltip',
                align                    : 'b-t',
                autoShow                 : true,
                updateContentOnMouseMove : true,
                forElement               : context.element,
                getHtml                  : () => me.getTipHtml(context.record, context.element)
            });
        }
    }

    isElementDraggable(el) {
        el = el.closest(this.baseSelector + ':not(.b-resizing)');

        return el && !el.classList.contains('b-over-resize-handle');
    }

    onDragStart({ context }) {
        const
            me          = this,
            record      = me.getRecordByElement(context.element.closest(me.baseSelector)),
            rangeBodyEl = me.getBodyElementByRecord(record),
            drag        = me.drag;

        Object.assign(context, {
            record,
            rangeBodyEl,
            originRangeX : DomHelper.getTranslateX(rangeBodyEl),
            originRangeY : DomHelper.getTranslateY(rangeBodyEl)
        });

        if (me.client.isVertical) {
            drag.minY = 0;
            // Moving the range, you can drag the start marker down until the end of the range hits the time axis end
            drag.maxY = me.timeAxisViewModel.totalSize - context.rangeBodyEl.offsetHeight;
            // Setting min/max for X makes drag right of the header valid, but visually still constrained vertically
            drag.minX = 0;
            drag.maxX = Number.MAX_SAFE_INTEGER;
        }
        else {
            drag.minX = 0;
            // Moving the range, you can drag the start marker right until the end of the range hits the time axis end
            drag.maxX = me.timeAxisViewModel.totalSize - context.rangeBodyEl.offsetWidth;
            // Setting min/max for Y makes drag below header valid, but visually still constrained horizontally
            drag.minY = 0;
            drag.maxY = Number.MAX_SAFE_INTEGER;
        }

        me.client.element.classList.add('b-dragging-timerange');

        me.showTip(context);
    }

    onDrag({ context }) {
        // sync body element with header element (x + width)
        if (this.client.isVertical) {
            DomHelper.setTranslateY(context.rangeBodyEl, DomHelper.getTranslateY(context.element));
        }
        else {
            DomHelper.setTranslateX(context.rangeBodyEl, DomHelper.getTranslateX(context.element));
        }
    }

    onDrop({ context }) {
        if (!context.valid) {
            return this.onInvalidDrop({ context });
        }

        const
            me          = this,
            record      = context.record,
            box         = context.rangeBodyEl.getBoundingClientRect(),
            newStart    = me.client.getDateFromCoordinate(me.client.isVertical ? box.top : box.left, 'round', false),
            wasModified = (record.startDate - newStart !== 0);

        if (wasModified) {
            record.setStartDate(newStart);
        }
        else {
            me.onInvalidDrop();
        }

        if (me.tip) {
            me.tip.destroy();
            me.tip = null;
        }

        me.client.element.classList.remove('b-dragging-timerange');
    }

    onInvalidDrop() {
        const me = this;

        me.drag.reset();
        me.renderRanges();
        me.client.element.classList.remove('b-dragging-timerange');

        if (me.tip) {
            me.tip.destroy();
            me.tip = null;
        }
    }

    // endregion

    // region Resize

    onResizeStart({ context }) {
        const
            me          = this,
            record      = me.getRecordByElement(context.element.closest(me.baseSelector)),
            rangeBodyEl = me.getBodyElementByRecord(record);

        Object.assign(context, {
            record,
            rangeBodyEl
        });

        me.showTip(context);
    }

    onResizeDrag({ context }) {
        const me = this;

        if (me.client.isVertical) {
            if (context.edge === 'top') {
                DomHelper.setTranslateY(context.rangeBodyEl, context.newY);
            }

            context.rangeBodyEl.style.height = context.newHeight + 'px';
        }
        else {
            if (context.edge === 'left') {
                DomHelper.setTranslateX(context.rangeBodyEl, context.newX);
            }

            context.rangeBodyEl.style.width = context.newWidth + 'px';
        }
    }

    onResize({ context }) {
        if (!context.valid) return this.onInvalidDrop({ context });

        const
            me          = this,
            { client }  = me,
            record      = context.record,
            box         = context.element.getBoundingClientRect(),
            startPos    = client.isVertical ? box.top : box.left,
            endPos      = client.isVertical ? box.bottom : box.right,
            newStart    = client.getDateFromCoordinate(startPos, 'round', false),
            isStart     = context.edge === 'left' || context.edge === 'top',
            newEnd      = client.getDateFromCoordinate(endPos, 'round', false),
            wasModified = (isStart && record.startDate - newStart !== 0) ||
                  (newEnd && record.endDate - newEnd !== 0);

        if (wasModified && newEnd > newStart) {
            if (isStart) {
                // could be that the drag operation placed the range with start/end outside the axis
                record.setStartDate(newStart, false);
            }
            else {
                record.setEndDate(newEnd, false);
            }
        }
        else {
            me.onInvalidResize();
        }

        if (me.tip) {
            me.tip.destroy();
            me.tip = null;
        }
    }

    onInvalidResize() {
        const me = this;

        me.resize.reset();
        me.renderRanges();

        if (me.tip) {
            me.tip.destroy();
            me.tip = null;
        }
    }

    //endregion

    //region Tooltip

    /**
     * Generates the html to display in the tooltip during drag drop.
     */
    getTipHtml(record, element) {
        const
            me         = this,
            { client } = me,
            box        = element.getBoundingClientRect(),
            startPos   = client.isVertical ? box.top : box.left,
            endPos     = client.isVertical ? box.bottom : box.right,
            startDate  = client.getDateFromCoordinate(startPos, 'round', false),
            endDate    = record.endDate && client.getDateFromCoordinate(endPos, 'round', false),
            startText  = client.getFormattedDate(startDate),
            endText    = endDate && client.getFormattedEndDate(endDate, startDate);

        return me.dragTipTemplate({
            name           : record.name || '',
            startDate      : startDate,
            endDate        : endDate,
            startText      : startText,
            endText        : endText,
            startClockHtml : me.clockTemplate.template({
                date : startDate,
                text : startText,
                cls  : 'b-sch-tooltip-startdate'
            }),
            endClockHtml : endText && me.clockTemplate.template({
                date : endDate,
                text : endText,
                cls  : 'b-sch-tooltip-enddate'
            })
        });
    }

    //endregion
}
AbstractTimeRanges._$name = 'AbstractTimeRanges';

/**
 * @module Scheduler/feature/NonWorkingTime
 */

/**
 * Feature that allows styling of weekends (and other non working time) by adding timeRanges for those days.
 *
 * This feature is **disabled** by default
 *
 * @extends Scheduler/feature/AbstractTimeRanges
 * @demo Scheduler/configuration
 * @externalexample scheduler/NonWorkingTime.js
 */
class NonWorkingTime extends AbstractTimeRanges {
    //region Default config

    static get $name() {
        return 'NonWorkingTime';
    }

    static get defaultConfig() {
        return {
            /**
             * Highlight weekends
             * @config {Boolean}
             * @default
             */
            highlightWeekends : true,

            showHeaderElements : true,

            cls : 'b-sch-nonworkingtime'
        };
    }

    //endregion

    //region Init & destroy

    construct(client, config) {
        const me = this;

        super.construct(client, config);

        if (!me.calendar || !client.calendar) {
            me.calendar = new Calendar();
        }

        me.bindCalendar(me.calendar);
    }

    doDestroy() {
        this.bindCalendar(null);
        super.doDestroy();
    }

    //endregion

    //region Calendar

    bindCalendar(calendar) {
        const me = this;

        if (me.calendarDetacher) me.calendarDetacher();

        if (calendar) {
            me.calendarDetacher = calendar.on({
                change  : me.renderRanges,
                thisObj : me,
                delay   : 1
            });
        }

        me.calendar = calendar;

        me.renderRanges();
    }

    //endregion

    //region Draw

    renderRanges() {
        const me = this;

        if (me.store && !me.store.isDestroyed) {
            const shouldPaint = DateHelper.as(me.client.timeAxis.unit, 1, 'week') >= 1;

            me.store.removeAll(true);

            if (me.calendar && me.highlightWeekends && shouldPaint) {
                me.store.add(me.calendar.getHolidaysRanges(me.client.timeAxis.startDate, me.client.timeAxis.endDate, true), true);
            }
        }

        super.renderRanges();
    }

    //endregion
}

NonWorkingTime._$name = 'NonWorkingTime'; GridFeatureManager.registerFeature(NonWorkingTime, false, 'Scheduler');

/**
 * @module Scheduler/feature/Pan
 */

/**
 * Makes the scheduler's timeline pannable by dragging with the mouses.
 *
 * This feature is **disabled** by default.
 *
 * **NOTE:** Incompatible with {@link Scheduler.feature.EventDragCreate EventDragCreate} feature.
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @example
 * // enable Pan
 * let scheduler = new Scheduler({
 *   features : {
 *     pan : true,
 *     eventDragCreate : false
 *   }
 * });
 *
 * @classtype pan
 */
class Pan extends InstancePlugin {
    // region Init

    static get $name() {
        return 'Pan';
    }

    static get defaultConfig() {
        return {
            /**
             * Set to false to only pan horizontally
             * @config {Boolean}
             * @default
             */
            vertical : true
        };
    }

    construct(timeline, config) {
        this.timeline = timeline;

        if (timeline.features.eventDragCreate && !timeline.features.eventDragCreate.disabled) {
            throw new Error('Cannot combine Pan and eventDragCreate features');
        }

        const targetSelectors = [
            '.b-grid-cell',
            '.b-timeline-subgrid'
        ];

        this.targetSelector = targetSelectors.join(',');

        super.construct(timeline, config);
    }

    //endregion

    //region Plugin config

    // Plugin configuration. This plugin chains some of the functions in Scheduler.
    static get pluginConfig() {
        return {
            chain : ['onElementMouseDown', 'onElementMouseMove', 'onElementMouseUp']
        };
    }

    //endregion

    onElementMouseDown(event) {
        const
            me                = this,
            timeline          = me.timeline,
            dragFeature       = Object.values(timeline.features).find(feature => feature instanceof DragBase),
            enablePanOnEvents = timeline.readOnly || !dragFeature || dragFeature.disabled;

        // only react to mouse input, and left button
        if (event.touches || event.button !== 0 || me.disabled) {
            return;
        }

        // only react to mousedown directly on grid cell, subgrid element or if drag is disabled - the events too
        if (event.target.matches(me.targetSelector) || (enablePanOnEvents && event.target.closest(timeline.eventSelector))) {
            me.mouseX = event.clientX;
            me.mouseY = event.clientY;
        }
    }

    onElementMouseMove(event) {
        const me = this;

        // Synthetic mousemove event has no button for IE11
        // Detect if a mouseup happened outside our element (or browser window for that matter). Note 'buttons' is not supported by Safari
        if (event.buttons === 0 && (!BrowserHelper.isSafari && (!BrowserHelper.isIE11 || event.isTrusted))) {
            me.onElementMouseUp();
            return;
        }

        if (typeof me.mouseX === 'number') {
            const xScroller = me.timeline.subGrids.normal.scrollable,
                yScroller = me.timeline.scrollable,
                x         = event.clientX,
                y         = event.clientY;

            event.preventDefault();

            if (me.vertical) {
                yScroller.scrollBy(0, me.mouseY - y);
            }

            xScroller.scrollBy(me.mouseX - x);

            me.mouseX = x;
            me.mouseY = y;
        }
    }

    onElementMouseUp(event) {
        this.mouseX = this.mouseY = null;
    }

    //endregion
}

Pan._$name = 'Pan'; GridFeatureManager.registerFeature(Pan, false, ['Scheduler', 'Gantt']);

/**
 * @module Scheduler/feature/RecurringTimeSpans
 */

/**
 * Class that adds recurring timespans functionality to the Scheduler.
 *
 * The main purpose of the class is generating occurrences of timespan models that should recur
 * for the displayed time range of the scheduler.
 * The feature tracks changes on the {@link #property-store} that contains timespan records
 * in order to propagate changes to all recurring record occurrences.
 * The feature also tracks the Scheduler visible date range to make sure it is properly populated with occurrences.
 *
 * This feature is **disabled** by default.
 *
 * @extends Core/mixin/InstancePlugin
 * @classtype recurringTimeSpans
 */
class RecurringTimeSpans extends InstancePlugin {

    static get $name() {
        return 'RecurringTimeSpans';
    }

    //region Config

    static get defaultConfig() {
        return {
            /**
             * Store to attach the feature to.
             * By default you don't need to provide the config since the store is taken from the scheduler.
             * @config {Object|Core.data.Store} [store]
             */
            store : undefined
        };
    }

    //endregion

    construct(plugInto, config) {
        this.isConstructing = true;

        super.construct(plugInto, config);

        this.isConstructing = false;
    }

    afterConstruct() {
        const me = this;

        // if feature is disabled or cannot function properly
        if (me.disabled || !me.isRecurrenceSupported) {
            me.disableRecurringTimeSpans();
        }
        else {
            me.enableRecurringTimeSpans();
        }
    }

    //region Init & destroy

    get disabled() {
        return super.disabled;
    }

    set disabled(disabled) {
        super.disabled = disabled;

        const me = this;

        // if we are not on construction step (that case is handled in construct() method)
        if (!me.isConstructing) {
            // if feature is disabled or cannot function properly
            if (disabled || !me.isRecurrenceSupported) {
                me.disableRecurringTimeSpans();
            }
            else {
                me.enableRecurringTimeSpans();
            }
        }
    }

    enableRecurringTimeSpans() {
        const { client, store } = this;

        if (client && store) {
            this.bindClient(client);
            this.bindStore(store);
            this.refreshOccurrences();
        }
    }

    disableRecurringTimeSpans() {
        this.bindClient(null);
        this.bindStore(null);

        if (this.store) {
            this.removeOccurrences();
        }
    }

    get trackingSuspended() {
        return Boolean(this._trackingSuspended);
    }

    suspendTracking() {
        if (isNaN(this._trackingSuspended)) {
            this._trackingSuspended = 0;
        }
        this._trackingSuspended++;
    }

    resumeTracking() {
        if (isNaN(this._trackingSuspended)) {
            this._trackingSuspended = 0;
        }
        else {
            this._trackingSuspended--;
        }
    }

    get client() {
        return super.client;
    }

    set client(client) {
        super.client = client;

        if (!this.isConstructing) {
            this.bindClient(client);
        }
    }

    /**
     * Setups event listeners to the provided scheduler panel or destroys existing listeners if `null` provided.
     * The method is called when setting {@link #property-client} property.
     * Override this to setup custom event listeners to the associated panel.
     * @param {Scheduler.view.Scheduler} [panel] Panel to listen to. Provide `null` or skip the argument to remove the current listeners.
     * @protected
     */
    bindClient(client) {
        this.bindTimeAxis(client && client.timeAxis);
    }

    /**
     * The timespan store associated with the feature.
     * @property {Core.data.Store}
     */
    set store(store) {
        const me        = this,
            isSupported = store && store.supportsRecurringTimeSpans;

        // the feature supports only stores having RecurringEventsMixin mixed in
        store = isSupported ? store : null;

        me._store = store;

        if (!me.isConstructing) {
            me.bindStore(store);

            // if feature is enabled and has everything it needs to work properly
            if (me.isRecurrenceSupported && !me.disabled) {
                me.enableRecurringTimeSpans();
            }
            else {
                me.disableRecurringTimeSpans();
            }
        }
    }

    get store() {
        return this._store;
    }

    // Indicates if the feature has everything set to work properly
    get isRecurrenceSupported() {
        const { store, startDate, endDate } = this;

        return Boolean(store && store.supportsRecurringTimeSpans && startDate && endDate);
    }

    /**
     * Setups event listeners to the provided timespan store (or destroys set listeners if `null` provided).
     * The method is called when setting {@link #property-store} property.
     * Override this to setup custom listeners to the store.
     * @param {Core.data.Store} [store] Timespan store to listen to. Provide `null` or skip the argument to remove the current listeners.
     * @protected
     */
    bindStore(store) {
        this.detachListeners('store');

        store && store.on({
            name                                : 'store',
            'refresh'                           : 'onTimeSpansRefresh',
            'add'                               : 'onTimeSpanAdd',
            'update'                            : 'onTimeSpanUpdate',
            'remove'                            : 'onTimeSpanRemove',
            'delayedgenerateoccurrencesstart'   : 'onGenerateOccurrencesStart',
            'delayedgenerateoccurrencesend'     : 'onGenerateOccurrencesEnd',
            'delayedregenerateoccurrencesstart' : 'onGenerateOccurrencesStart',
            'delayedregenerateoccurrencesend'   : 'onGenerateOccurrencesEnd',
            thisObj                             : this
        });
    }

    get timeAxis() {
        return this.client && this.client.timeAxis;
    }

    bindTimeAxis(timeAxis) {
        this.detachListeners('timeAxis');

        timeAxis && timeAxis.on({
            name          : 'timeAxis',
            'reconfigure' : 'onTimeAxisReconfigure',
            thisObj       : this
        });
    }

    onTimeAxisReconfigure() {
        if (!this.trackingSuspended) {
            this.refreshOccurrences();
        }
    }

    get startDate() {
        return this.timeAxis && this.timeAxis.startDate;
    }

    get endDate() {
        return this.timeAxis && this.timeAxis.endDate;
    }

    onGenerateOccurrencesStart() {
        this.suspendTracking();
    }

    onGenerateOccurrencesEnd() {
        this.resumeTracking();
    }

    refreshOccurrences() {
        const { store, startDate, endDate } = this;

        if (store && startDate && endDate) {
            store.generateOccurrencesForTimeSpansBuffered(store.getRecurringTimeSpans(), startDate, endDate);
        }
    }

    removeOccurrences() {
        const { store } = this;

        if (store) {
            store.removeOccurrencesForAll();
        }
    }

    onTimeSpansRefresh({ source, action, records }) {
        if (action == 'dataset' && !this.trackingSuspended) {
            const recurringTimeSpans = records.filter(record => record.isRecurring);

            if (recurringTimeSpans.length) {
                // schedule occurrences generation
                source.generateOccurrencesForTimeSpansBuffered(recurringTimeSpans, this.startDate, this.endDate);
            }
        }
    }

    onTimeSpanAdd({ source, records, allRecords }) {
        if (!this.trackingSuspended) {
            const recurringTimeSpans = (allRecords || records).filter(record => record.isRecurring);

            if (recurringTimeSpans.length) {
                // schedule occurrences generation
                source.generateOccurrencesForTimeSpansBuffered(recurringTimeSpans, this.startDate, this.endDate);
            }
        }
    }

    onTimeSpanUpdate({ source, record, changes }) {
        if (!this.trackingSuspended && this.isRecurrenceRelatedFieldChange(record, changes)) {

            const { startDate, endDate }                   = this,
                { startDate : timeSpanStartDate, recurrence } = record;

            // the record is no longer recurring
            if (!recurrence) {
                source.removeOccurrencesForTimeSpans(record);
            }
            // If we have start & end dates and the recurrence intersects the range
            else if (startDate && endDate && timeSpanStartDate && (!recurrence.endDate || (recurrence.endDate >= startDate && timeSpanStartDate <= endDate))) {
                // schedule occurrences regeneration
                source.regenerateOccurrencesForTimeSpansBuffered(record, startDate, endDate);
            }
        }
    }

    onTimeSpanRemove({ source, allRecords, records }) {
        if (!this.trackingSuspended) {
            const recurringTimeSpans = (allRecords || records).filter(record => record.isRecurring);

            if (recurringTimeSpans.length) {
                source.removeOccurrencesForTimeSpans(recurringTimeSpans);
            }
        }
    }

    /**
     * The method restricts which field modifications should trigger timespan occurrences building.
     * By default any field change of a recurring timespan causes the rebuilding.
     * @param  {Scheduler.model.TimeSpan} timeSpan The modified timespan.
     * @param  {Object} toSet Object containing changed fields.
     * @return {Boolean} `True` if the fields modification should trigger the timespan occurrences rebuilding.
     * @protected
     */
    isRecurrenceRelatedFieldChange(timeSpan, toSet) {
        return timeSpan.isRecurring || 'recurrenceRule' in toSet;
    }

}
RecurringTimeSpans._$name = 'RecurringTimeSpans'; GridFeatureManager.registerFeature(RecurringTimeSpans, false, 'Scheduler');

/**
 * @module Scheduler/feature/RecurringEvents
 */

/**
 * A feature that adds recurring events functionality to the Scheduler.
 *
 * The main purpose of the class is generating occurrences of the repeating events for the visible timespan.
 * To achieve this it tracks changes on the {@link Scheduler.view.mixin.SchedulerStores#config-eventStore event store} to apply a repeating event changes
 * to its visible occurrences.
 * The feature also tracks the Scheduler visible timespan changes to make sure the new timespan is populated
 * with corresponding event occurrences.
 *
 * Additionally the class implements displaying of a {@link Scheduler.view.recurrence.RecurrenceConfirmationPopup special confirmation}
 * on user mouse dragging/resizing repeating events and its occurrences.
 *
 * This feature is **disabled** by default.
 *
 * @extends Scheduler/feature/RecurringTimeSpans
 * @classtype recurringEvents
 * @demo Scheduler/recurrence
 */
class RecurringEvents extends RecurringTimeSpans {

    static get $name() {
        return 'RecurringEvents';
    }

    get client() {
        return super.client;
    }

    set client(client) {
        super.client = client;

        if (client) {
            this._onEventStoreChangeDetacher && this._onEventStoreChangeDetacher();
            // set listener to "eventstorechange" here to catch switching from a store not-supporting recurrences to a supporting one
            // listeners set in bindStore() got destroyed when assigning a store w/o recurrence support
            this._onEventStoreChangeDetacher = client.on('eventstorechange', this.onEventStoreChange, this);
        }

        this.store = client ? client.eventStore : null;
    }

    bindClient(client) {
        const me = this;

        super.bindClient(client);

        me._eventPanelDetacher && me._eventPanelDetacher();

        if (client) {
            me._eventPanelDetacher = client.on({
                'beforeeventdropfinalize'   : me.onBeforeEventDropFinalize,
                'beforeeventresizefinalize' : me.onBeforeEventResizeFinalize,
                'beforeEventDelete'         : me.onRecurrableEventBeforeDelete,

                thisObj : me
            });
        }
    }

    get confirmationPopup() {
        if (!this._confirmationPopup) {
            this._confirmationPopup = new RecurrenceConfirmationPopup();
        }

        return this._confirmationPopup;
    }

    set confirmationPopup(popup) {
        this._confirmationPopup = popup;
    }

    onEventStoreChange({ newEventStore, oldEventStore }) {
        this.store = newEventStore;
    }

    showDisplayConfirmationOnEventDelete(eventRecord) {
        const eventEdit = this.client.features.eventEdit;

        // show confirmation if we deal with a recurring event (or its occurrence)
        // and if the record is not being edited by event editor (since event editor has its own confirmation)
        return (eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence) &&
            (!eventEdit || !eventEdit.isEditing || eventEdit.eventRecord !== eventRecord));
    }

    onRecurrableEventBeforeDelete({ eventRecords, context }) {
        const [eventRecord] = eventRecords;

        if (this.showDisplayConfirmationOnEventDelete(eventRecord)) {
            this.confirmationPopup.confirm({
                actionType : 'delete',
                eventRecord,
                changerFn() {
                    context.finalize(true);
                },
                cancelFn() {
                    context.finalize(false);
                }
            });

            return false;
        }
    }

    onBeforeEventDropFinalize({ context }) {
        const { record : eventRecord } = context;

        if (eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence)) {
            context.async = true;

            this.confirmationPopup.confirm({
                actionType : 'update',
                eventRecord,
                changerFn() {
                    context.finalize(true);
                },
                cancelFn() {
                    context.finalize(false);
                }
            });
        }
    }

    onBeforeEventResizeFinalize({ context }) {
        const { eventRecord } = context;

        if (eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence)) {
            context.async = true;

            this.confirmationPopup.confirm({
                actionType : 'update',
                eventRecord,
                changerFn() {
                    context.finalize(true);
                },
                cancelFn() {
                    context.finalize(false);
                }
            });
        }
    }

}
RecurringEvents._$name = 'RecurringEvents'; GridFeatureManager.registerFeature(RecurringEvents, false, 'Scheduler');

/**
 * @module Scheduler/feature/ResourceTimeRanges
 */

/**
 * Feature that draws resource time ranges, shaded areas displayed behind events. These zones are similar to events in
 * that they have a start and end date but different in that they do not take part in the event layout and they always
 * occupy full row height.
 *
 * Each time range is represented by an instances of {@link Scheduler.model.ResourceTimeRangeModel}, held in a
 * {@link Scheduler.data.ResourceTimeRangeStore}. Currently the they are readonly UI-wise, but can be manipulated on
 * the data level. To style the rendered elements, use the {@link Scheduler.model.TimeSpan#field-cls cls} field or use the {@link Scheduler.model.ResourceTimeRangeModel#field-timeRangeColor} field.
 *
 * Data can be provided either using the {@link #config-store} config:
 *
 * ```javascript
 * new Scheduler({
 *   features :  {
 *       resourceTimeRanges : {
 *          store : new Scheduler.data.ResourceTimeRangeStore({
 *              readUrl : './resourceTimeRanges/'
 *          })
 *       }
 *   }
 * })
 * ```
 *
 * or the `resourceTimeRanges` config on the Scheduler config object:
 *
 * ```javascript
 * new Scheduler({
 *   features :  {
 *       resourceTimeRanges : true
 *   },
 *
 *   // Data specified directly on the Scheduler instance
 *   resourceTimeRanges : [
 *     // Either specify startDate & endDate or startDate & duration when defining a range
 *     { startDate : new Date(2019,0,1), endDate : new Date(2019,0,3), name : 'Occupied', timeRangeColor : 'red' },
 *     { startDate : new Date(2019,0,3), duration : 2, durationUnit : 'd', name : 'Available' },
 *   ]
 * })
 * ```
 *
 * This feature is **disabled** by default
 *
 * @extends Core/mixin/InstancePlugin
 * @demo Scheduler/resourcetimeranges
 * @externalexample scheduler/ResourceTimeRanges.js
 */
class ResourceTimeRanges extends InstancePlugin {
    //region Config

    static get $name() {
        return 'ResourceTimeRanges';
    }

    static get defaultConfig() {
        return {
            idPrefix : 'resourcetimerange',
            rangeCls : 'b-sch-resourcetimerange',

            /**
             * Store that holds resource time ranges (using ResourceTimeRangeModel or subclass thereof). A store will be
             * automatically created if none is specified
             * @config {Scheduler.data.ResourceTimeRangeStore}
             */
            store : false,

            /**
             * Time range definitions (data to ResourceTimeRangeModels). Will be added to store. Can also be specified
             * on Scheduler for convenience
             * @config {Scheduler.model.ResourceTimeRangeModel[]|Object[]}
             */
            resourceTimeRanges : null
        };
    }

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            chain : ['getEventsToRender', 'onEventDataGenerated', 'noFeatureElementsInAxis']
        };
    }

    // Let Scheduler know if we have ResourceTimeRanges in view or not
    noFeatureElementsInAxis() {
        const { timeAxis } = this.scheduler;
        return !this.store.storage.values.some(t => timeAxis.isTimeSpanInAxis(t));
    }

    //endregion

    //region Init

    construct(scheduler, config) {
        const me = this;

        me.scheduler = scheduler;

        super.construct(scheduler, config);

        // expose getter/setter for resourceTimeRanges on scheduler
        Object.defineProperty(scheduler, 'resourceTimeRanges', {
            get : () => me.store.records,
            set : resourceTimeRanges => me.store.data = resourceTimeRanges
        });
    }

    doDisable(disable) {
        if (this.client.isPainted) {
            this.client.refresh();
        }

        super.doDisable(disable);
    }

    /**
     * Called during construction to do product specific store setup
     * @private
     */
    set store(store) {
        const me       = this,
            { scheduler } = me;

        me._store = store = store || new ResourceTimeRangeStore();

        if (!scheduler.resourceTimeRangeStore) {
            scheduler.resourceTimeRangeStore = store;
        }

        // ResourceZones can be set on scheduler or feature, for convenience
        if (scheduler.resourceTimeRanges) {
            store.add(scheduler.resourceTimeRanges);
            delete scheduler.resourceTimeRanges;
        }

        // Link to schedulers resourceStore if not already linked to one
        if (!store.resourceStore) {
            store.resourceStore = scheduler.resourceStore;
        }

        me.storeDetacher && me.storeDetacher();

        me.storeDetacher = me.store.on({
            change  : me.onStoreChange,
            thisObj : me
        });
    }

    get store() {
        return this._store;
    }

    //endregion

    // Called on render of resources events to get events to render. Add any ranges
    // (chained function from Scheduler)
    getEventsToRender(resource, events) {
        if (resource.timeRanges && resource.timeRanges.length && !this.disabled) {
            events.push(...resource.timeRanges);
        }
        return events;
    }

    // Called for each event during render, allows manipulation of render data. Adjust any resource time ranges
    // (chained function from Scheduler)
    onEventDataGenerated(renderData) {
        const
            me = this,
            record = renderData.event || renderData.eventRecord; // Differs by mode

        if (record.isResourceTimeRange) {
            if (me.scheduler.isVertical) {
                renderData.width = me.scheduler.resourceColumnWidth;
            }
            else {
                renderData.top = 0;
                // Avoid colliding ids by using a prefix
                renderData.id = `${me.scheduler.id}-${me.idPrefix}-${record.id}`;
            }

            // Flag that we should fill entire row/col
            renderData.fillSize = true;
            // Needed for caching
            renderData.eventId = `${me.idPrefix}-${record.id}`;
            // Add our own cls
            renderData.wrapperCls[me.rangeCls] = 1;
            renderData.wrapperCls[`b-sch-color-${record.timeRangeColor}`] = record.timeRangeColor;
            // Add label
            renderData.body = document.createDocumentFragment();
            renderData.body.textContent = record.name;
        }
    }

    // Called when a ResourceTimeRangeModel is manipulated, relays to Scheduler#onInternalEventStoreChange which updates to UI
    onStoreChange(event) {
        this.scheduler.onInternalEventStoreChange(event);
    }
}

// No feature based styling needed, do not add a cls to Scheduler
ResourceTimeRanges.featureClass = '';

ResourceTimeRanges._$name = 'ResourceTimeRanges'; GridFeatureManager.registerFeature(ResourceTimeRanges, false, 'Scheduler');

/**
 * @module Scheduler/feature/SimpleEventEdit
 */

/**
 * Feature that displays a text field to edit the event name. You can control the flow of this by listening to the events relayed by this class from the underlying {@link Core.widget.Editor}.
 * To use this feature, you also need to disable the built-in default editing feature:
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         eventEdit       : false,
 *         simpleEventEdit : true
 *     }
 * });
 * ```
 *
 * This feature is **disabled** by default
 *
 * @extends Core/mixin/InstancePlugin
 * @demo Scheduler/simpleeditor
 * @externalexample scheduler/SimpleEventEdit.js
 */
class SimpleEventEdit extends InstancePlugin {

    // region Events
    /**
     * Fired before the editor is shown to start an edit operation. Returning `false` from a handler vetoes the edit operation.
     * @event beforeStart
     * @preventable
     * @property {Object} value - The value to be edited.
     * @property {Core.widget.Editor} source - The Editor that triggered the event.
     */
    /**
     * Fired when an edit operation has begun.
     * @event start
     * @property {Object} value - The starting value of the field.
     * @property {Core.widget.Editor} source - The Editor that triggered the event.
     */
    /**
     * Fired when an edit completion has been requested, either by `ENTER`, or focus loss (if configured to complete on blur).
     * The completion may be vetoed, in which case, focus is moved back into the editor.
     * @event beforeComplete
     * @property {Object} oldValue - The original value.
     * @property {Object} value - The new value.
     * @property {Core.widget.Editor} source - The Editor that triggered the event.
     * @preventable
     */
    /**
     * Edit has been completed, and any associated record or element has been updated.
     * @event complete
     * @property {Object} oldValue - The original value.
     * @property {Object} value - The new value.
     * @property {Core.widget.Editor} source - The Editor that triggered the event.
     */
    /**
     * Fired when cancellation has been requested, either by `ESC`, or focus loss (if configured to cancel on blur).
     * The cancellation may be vetoed, in which case, focus is moved back into the editor.
     * @event beforeCancel
     * @property {Object} oldValue - The original value.
     * @property {Object} value - The new value.
     * @property {Core.widget.Editor} source - The Editor that triggered the event.
     * @preventable
     */
    /**
     * Edit has been canceled without updating the associated record or element.
     * @event cancel
     * @property {Object} oldValue - The original value.
     * @property {Object} value - The value of the field.
     * @property {Core.widget.Editor} source - The Editor that triggered the event.
     */
    // endregion

    //region Config

    static get $name() {
        return 'SimpleEventEdit';
    }

    static get defaultConfig() {
        return {
            /**
             * The event that shall trigger showing the editor. Defaults to `eventdblclick`, set to `` or null to disable editing of existing events.
             * @config {String}
             * @default
             * @category Editor
             */
            triggerEvent : 'eventdblclick',

            /**
             * The current {@link Scheduler.model.EventModel} record, which is being edited by the event editor.
             * @property {Scheduler.model.EventModel}
             * @readonly
             */
            eventRecord : null,

            /**
             * The {@link Scheduler.model.EventModel} field to edit
             * @config {String}
             * @category Editor
             */
            field : 'name',

            /**
             * The editor configuration, where you can control which widget to show
             * @config {Object}
             * @category Editor
             */
            editorConfig : null
        };
    }

    static get pluginConfig() {
        return {
            chain  : ['onEventEnterKey'],
            assign : ['editEvent']
        };
    }

    //endregion

    //region Editing

    construct(scheduler, config) {
        const me = this;

        me.scheduler  = scheduler;
        me.eventStore = scheduler.eventStore;

        scheduler.eventEdit = me;

        super.construct(scheduler, config);

        me.clientListenersDetacher = scheduler.on({
            [me.triggerEvent] : ({ eventRecord, eventElement }) => me.editEvent(eventRecord, eventRecord.resource, eventElement),
            dragcreateend     : me.onDragCreateEnd,
            thisObj           : me
        });
    }

    doDestroy() {
        this.clientListenersDetacher();

        this.editor && this.editor.destroy();

        super.doDestroy();
    }

    // region Editor
    /**
     * Opens an Editor for the passed event. This function is exposed on Scheduler and can be called as
     * `scheduler.editEvent()`.
     * @param {Scheduler.model.EventModel} eventRecord The Event to edit
     * @param {Scheduler.model.ResourceModel} [resourceRecord] The Resource record for the event.
     */
    editEvent(eventRecord, resourceRecord, element) {
        const
            me        = this,
            scheduler = me.scheduler;

        if (scheduler.readOnly || me.disabled) {
            return;
        }

        // Want to put editor in inner element (b-sch-event) to get correct font size, but when drag creating the proxy
        // has no inner element
        element = DomHelper.down(element, scheduler.eventInnerSelector) || element;

        eventRecord = eventRecord instanceof AssignmentModel ? eventRecord.event : eventRecord;

        me.resource = resourceRecord;
        me.event = eventRecord;
        me.element = element;

        scheduler.element.classList.add('b-eventeditor-editing');

        if (!me.editor) {
            // Editor is contained in, and owned by the TimeAxisSubGrid to avoid focus flipping out and in.
            // The editor is an owned descendant of the SubGrid.
            me.editor = new Editor(Object.assign({
                owner        : me.scheduler.timeAxisSubGrid,
                appendTo     : me.scheduler.timeAxisSubGridElement,
                scrollAction : 'realign',
                cls          : 'b-simpleeventeditor',
                listeners    : {
                    complete : me.onEditorComplete,
                    cancel   : me.onEditorCancel,
                    thisObj  : me
                }
            }, me.editorConfig));

            me.relayEvents(me.editor, ['beforestart', 'start', 'beforecomplete', 'complete', 'beforecancel', 'cancel']);
        }

        me.editor.startEdit({
            target : element,
            record : eventRecord,
            field  : me.field
        });

        // No key navigation during editing
        me.scheduler.navigator.disabled = true;
    }

    onEditorComplete() {
        const me = this;

        if (me.event.stores.length === 0) {
            me.eventStore.add(me.editor.record);
            me.event.assign(me.resource);
        }

        // remove element if it's a drag create proxy
        if (me.element && me.element.classList.contains('b-sch-dragcreator-proxy')) {
            me.element.remove();
        }

        me.reset();
    }

    onEditorCancel() {
        if (this.event.stores.length === 0) {
            this.element.remove();
        }

        this.reset();
    }

    reset() {
        this.scheduler.element.classList.remove('b-eventeditor-editing');

        // Restore key navigation after editing
        this.scheduler.navigator.disabled = false;
    }

    //endregion

    // chained from EventNavigation
    onEventEnterKey({ assignmentRecord, eventRecord }) {
        const
            element = assignmentRecord ? this.scheduler.getElementFromAssignmentRecord(assignmentRecord) : this.scheduler.getElementFromEventRecord(eventRecord),
            resourceRecord = (assignmentRecord || eventRecord).resource;

        this.editEvent(eventRecord, resourceRecord, element);
    }

    //endregion

    onDragCreateEnd({ newEventRecord, resourceRecord, proxyElement }) {
        const me = this;

        // Call scheduler template method
        me.scheduler.onEventCreated(newEventRecord);

        // Clone proxy after showing editor so it's not deleted
        const phantomEventElement = proxyElement.cloneNode(true);
        phantomEventElement.removeAttribute('id');

        proxyElement.parentElement.appendChild(phantomEventElement);

        me.element = phantomEventElement;

        me.editEvent(newEventRecord, resourceRecord, phantomEventElement);
    }
}

SimpleEventEdit._$name = 'SimpleEventEdit'; GridFeatureManager.registerFeature(SimpleEventEdit, false, 'Scheduler');

/**
 * @module Grid/feature/Summary
 */

/**
 * Displays a summary row in the grid footer. Specify type of summary on columns, available types are:
 * <dl class="wide">
 * <dt>sum <dd>Sum of all values in the column
 * <dt>add <dd>Alias for sum
 * <dt>count <dd>Number of rows
 * <dt>countNotEmpty <dd>Number of rows containing a value
 * <dt>average <dd>Average of all values in the column
 * <dt>function <dd>A custom function, used with store.reduce. Should take arguments (sum, record)
 * </dl>
 * Columns can also specify a summaryRenderer to format the calculated sum.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * ```
 * { text : 'Score', data : 'score', width : 80, sum : true }
 * { text : 'Rank', data : 'rank', width : 80, sum : 'average', summaryRenderer: sum => return 'Average rank ' + sum }
 * ```
 *
 * Also it is possible to set up multiple summaries as array of summary configs:
 * ```
 * { text : 'Rank', data : 'rank', summaries : [{ sum : 'average', label : 'Average' }, { sum : 'count', label : 'Count' }] }
 * ```
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @demo Grid/features
 * @classtype summary
 * @externalexample feature/Summary.js
 */
class Summary extends SummaryFormatter(InstancePlugin) {
    //region Init

    static get $name() {
        return 'Summary';
    }

    construct(grid, config) {
        const me = this;

        Object.assign(me, {
            grid  : grid,
            store : grid.store
        });

        super.construct(grid, config);

        me.store.on({
            change  : me.onStoreChanged,
            thisObj : me
        });

        // footers aren't added by default, add
        me.grid.eachSubGrid(subGrid => {
            if (!subGrid.footer) {
                subGrid.footer = new Footer({
                    subGrid,
                    parent : subGrid  // Contained widgets need to know their parents
                });
            }
        });
    }

    doDestroy() {
        super.doDestroy();
    }

    doDisable(disable) {
        super.doDisable(disable);

        if (disable) {
            this.grid.element.classList.add('b-summary-disabled');
        }
        else {
            this.updateSummaries();
            this.grid.element.classList.remove('b-summary-disabled');
        }
    }

    //endregion

    //region Plugin config

    // Plugin configuration. This plugin chains some of the functions in Grid.
    static get pluginConfig() {
        return {
            chain : ['renderRows']
        };
    }

    //endregion

    //region Render

    renderRows() {
        this.updateSummaries();
    }

    /**
     * Updates summaries. Summaries are displayed as tables in footer (styling left out to keep brief):
     * ```
     * <table>
     *     <tr><td colspan="2">0</td></tr> // { sum : 'min' } Only a calculation, span entire table
     *     <tr><td>Max</td><td>10</td></tr> // { sum : 'max', label: 'Max' } Label + calculation
     *     <tr><td>Max</td><td>10</td></tr> // { sum : 'sum', label: 'Max' } Label + calculation
     * </table>
     * ```
     * @private
     */
    updateSummaries() {
        const
            me              = this,
            { grid, store } = me,
            cells           = DomHelper.children(grid.element, '.b-grid-footer'),
            records         = store.storage.values.filter(r => !r.meta.specialRow);

        // reset seeds, to not have ever increasing sums :)
        grid.columns.forEach(column => {
            column.summaries && column.summaries.forEach(config => {
                if ('seed' in config) {
                    if (!('initialSeed' in config)) {
                        config.initialSeed = config.seed;
                    }

                    if (['number', 'string', 'date'].includes(typeof config.initialSeed)) {
                        config.seed = config.initialSeed;
                    }
                    else {
                        // create shallow copy
                        config.seed = Object.assign({}, config.initialSeed);
                    }
                }
            });
        });

        cells.forEach(cellElement => {
            const
                column = grid.columns.get(cellElement.dataset.column),
                html   = me.generateHtml(column, records, 'b-grid-footer-summary');

            if (column.summaries ? column.summaries.length : column.sum ? 1 : 0) {
                // First time, set table
                if (!cellElement.children.length) {
                    cellElement.innerHTML = html;
                }
                // Following times, sync changes
                else {
                    DomHelper.sync(html, cellElement.firstElementChild);
                }
            }
        });
    }

    //endregion

    //region Events

    /**
     * Updates summaries on store changes (except record update, handled below)
     * @private
     */
    onStoreChanged({ action, changes }) {
        let shouldUpdate = true;

        if (this.disabled) {
            return;
        }

        if (action === 'update') {
            // only update summary when a field that affects summary is changed
            // TODO: this should maybe be removed, another column might depend on the value for its summary?
            shouldUpdate = Object.keys(changes).some(field => {
                const colField = this.grid.columns.get(field);
                // check existence, since a field not used in a column might have changed
                return Boolean(colField) && (Boolean(colField.sum) || Boolean(colField.summaries));
            });
        }

        if (shouldUpdate) {
            this.updateSummaries();
        }
    }

    //endregion
}

Summary.featureClass = 'b-summary';

Summary._$name = 'Summary'; GridFeatureManager.registerFeature(Summary);

/**
 * @module Scheduler/feature/Summary
 */

// noinspection JSClosureCompilerSyntax
/**
 * A special version of the Grid Summary feature. This feature displays a summary row in the grid footer.
 * For regular columns in the locked section - specify type of summary on columns, available types are:
 * <dl class="wide">
 * <dt>sum <dd>Sum of all values in the column
 * <dt>add <dd>Alias for sum
 * <dt>count <dd>Number of rows
 * <dt>countNotEmpty <dd>Number of rows containing a value
 * <dt>average <dd>Average of all values in the column
 * <dt>function <dd>A custom function, used with store.reduce. Should take arguments (sum, record)
 * </dl>
 * Columns can also specify a summaryRender to format the calculated sum.
 *
 * To summarize events, either provide a {@link #config-renderer} or use {@link #config-summaries}
 *
 * This feature is <strong>disabled</strong> by default. It is **not** supported in vertical mode.
 *
 * @extends Grid/feature/Summary
 *
 * @classtype summary
 * @externalexample scheduler/Summary.js
 * @demo Scheduler/summary
 * @typings Grid/feature/Summary -> Grid/feature/GridSummary
 */
class Summary$1 extends Summary {
    //region Config

    static get $name() {
        return 'Summary';
    }

    static get defaultConfig() {
        return {
            /**
             * Show tooltip containing summary values and labels
             * @config {Boolean}
             * @default
             */
            showTooltip : true,

            /**
             * Array of summary configs, with format
             * `[{ label: 'Label', renderer : ({startDate, endDate, eventStore, resourceStore, events, element}) }]`.
             * @config {Object[]}
             */
            summaries : null,

            /**
             * Easier way to configure When using single summary, accepts a renderer function with the format specified
             * in {@link #config-summaries}
             * @config {Function}
             */
            renderer : null
        };
    }

    //endregion

    //region Init

    construct(scheduler, config) {
        const me = this;

        if (scheduler.isVertical) {
            throw new Error('Summary feature is not supported in vertical mode');
        }

        me.scheduler = scheduler;

        super.construct(scheduler, config);

        if (!me.summaries) me.summaries = [{ renderer : me.renderer }];

        // Feature might be run from Grid (in docs), should not crash
        // https://app.assembla.com/spaces/bryntum/tickets/6801/details
        if (scheduler instanceof Scheduler) {
            scheduler.eventStore.on({
                change  : me.updateScheduleSummaries,
                thisObj : me
            });

            scheduler.resourceStore.on({
                change  : me.updateScheduleSummaries,
                thisObj : me
            });

            scheduler.timeAxisViewModel.on({
                update  : me.renderRows,
                thisObj : me
            });
        }
    }

    //endregion

    //region Render

    renderRows() {
        super.renderRows();
        this.render();
    }

    /**
     * Updates summaries.
     * @private
     */
    updateScheduleSummaries() {
        const me               = this,
            scheduler        = me.scheduler,
            summaryContainer = scheduler.element.querySelector('.b-grid-footer.b-sch-timeaxiscolumn');

        if (summaryContainer) {
            DomHelper.forEachSelector(summaryContainer, '.b-timeaxis-tick', (element, i) => {
                const tick      = scheduler.timeAxis.getAt(i),
                    events    = scheduler.eventStore.getEventsInTimeSpan(tick.startDate, tick.endDate, true, true);

                let html = '',
                    tipHtml = `<header>${me.L('Summary for')} ${scheduler.getFormattedDate(tick.startDate)}</header>`;

                me.summaries.forEach(config => {
                    const value = config.renderer({
                            startDate     : tick.startDate,
                            endDate       : tick.endDate,
                            eventStore    : scheduler.eventStore,
                            resourceStore : scheduler.resourceStore,
                            events,
                            element
                        }),
                        valueHtml = `<div class="b-timeaxis-summary-value">${value}</div>`;

                    if (me.summaries.length > 1 || value !== '') html += valueHtml;
                    tipHtml += `<label>${config.label || ''}</label>` + valueHtml;
                });

                element.innerHTML = html;
                element._tipHtml = tipHtml;
            });
        }
    }

    render() {
        const me        = this,
            scheduler = me.scheduler,
            summaryEl = scheduler.element.querySelector('.b-grid-footer.b-sch-timeaxiscolumn');

        if (summaryEl) {
            // if any sum config has a label, init tooltip
            if (me.summaries.some(config => config.label) && me.showTooltip && !me._tip) {
                me._tip = new Tooltip({
                    id             : `${scheduler.id}-summary-tip`,
                    cls            : 'b-timeaxis-summary-tip',
                    hoverDelay     : 0,
                    hideDelay      : 100,
                    forElement     : summaryEl,
                    anchorToTarget : true,
                    trackMouse     : false,
                    forSelector    : '.b-timeaxis-tick',
                    getHtml        : ({ activeTarget }) => activeTarget._tipHtml
                });
            }

            summaryEl.innerHTML =
                `<div class="b-timeaxis-tick" style="width: ${scheduler.tickSize}px"></div>`
                    .repeat(scheduler.timeAxis.count);

            me.updateScheduleSummaries();
        }
    }

    //endregion
}

// Needed for module bundle, which turns class name into Summary$1 and registers it wrong
Summary$1._$name = 'Summary';

// Override Grids Summary with this improved version
Summary$1._$name = 'Summary'; GridFeatureManager.registerFeature(Summary$1, false, 'Scheduler');

/**
 * @module Scheduler/feature/TimeRanges
 */

/**
 * Feature that renders global ranges of time in the timeline. Use this feature to visualize a `range` like a 1 hr lunch or some important point in time
 * (a `line`, i.e. a range with 0 duration). This feature can also show a current time indicator if you set {@link #config-showCurrentTimeLine} to true. To style
 * the rendered elements, use the {@link Scheduler.model.TimeSpan#field-cls cls} field of the `TimeSpan` class.
 *
 * Each time range is represented by an instances of {@link Scheduler.model.TimeSpan}, held in a simple {@link Core.data.Store}.
 * If {@link Scheduler.data.CrudManager} is specified for the scheduler, the {@link #config-store} will be added at the end of the CrudManager
 * {@link Scheduler.crud.AbstractCrudManager#property-stores} collection.
 *
 * This feature is **disabled** by default
 *
 * @extends Scheduler/feature/AbstractTimeRanges
 * @classtype timeRanges
 * @demo Scheduler/timeranges
 * @externalexample scheduler/TimeRanges.js
 */
class TimeRanges extends AbstractTimeRanges {
    //region Config

    static get $name() {
        return 'TimeRanges';
    }

    static get defaultConfig() {
        return {
            /**
             * Store that holds timeRanges (using the {@link Scheduler.model.TimeSpan} model or subclass thereof).
             * A store will be automatically created if none is specified
             * @config {Object|Core.data.Store}
             */
            store : {
                modelClass : TimeSpan,
                storeId    : 'timeRanges'
            },

            updateCurrentTimeLineInterval : 10000,

            /**
             * The date format to show in the header for the current time line, see {@link #config-showCurrentTimeLine}
             * @config {String}
             * @default
             */
            currentDateFormat : 'HH:mm',

            /**
             * Range definitions (data to {@link Scheduler.model.TimeSpan} models). Will be added to store.
             * @config {Scheduler.model.TimeSpan[]|Object[]}
             */
            timeRanges : null,

            /**
             * Show a line indicating current time
             * @config {Boolean}
             * @default
             */
            showCurrentTimeLine : false

        };
    }

    //endregion

    //region Init & destroy

    construct(client, config) {
        const me = this;

        super.construct(client, config);

        if (!client._timeRangesExposed) {
            // expose getter/setter for timeRanges on scheduler/gantt
            Object.defineProperty(client, 'timeRanges', {
                get : () => me.store.records,
                set : timeRanges => me.store.data = timeRanges
            });
            client._timeRangesExposed = true;
        }
    }

    startConfigure(config) {
        const { client } = this;

        // If the client's project has a timeRangeStore, we must use that
        if (client.project) {
            const store = client.project.timeRangeStore;

            if (store) {
                config.store = store;
            }
        }
    }

    //endregion

    //region Current time line

    initCurrentTimeLine() {
        const me  = this,
            now = new Date();

        if (me.currentTimeLine || !me.showCurrentTimeLine) {
            return;
        }

        me.currentTimeLine = new me.store.modelClass({
            'id'      : 'currentTime',
            cls       : 'b-sch-current-time',
            startDate : now,
            name      : DateHelper.format(now, me.currentDateFormat)
        });

        me.updateCurrentTimeLine = me.updateCurrentTimeLine.bind(me);

        me.currentTimeInterval = me.setInterval(me.updateCurrentTimeLine, me.updateCurrentTimeLineInterval);

        if (me.client.isPainted) {
            me.renderRanges();
        }
    }

    updateCurrentTimeLine() {
        const me = this;

        me.currentTimeLine.startDate = new Date();
        me.currentTimeLine.name      = DateHelper.format(me.currentTimeLine.startDate, me.currentDateFormat);
        me.onStoreChanged({ action : 'update', record : me.currentTimeLine, changes : {} });
    }

    hideCurrentTimeLine() {
        const me = this;

        if (!me.currentTimeLine) {
            return;
        }

        me.clearInterval(me.currentTimeInterval);
        me.currentTimeLine = null;

        if (me.client.isPainted) {
            me.renderRanges();
        }
    }

    renderRanges() {
        const me = this;

        super.renderRanges();

        if (me.showCurrentTimeLine && !me.disabled) {
            me.renderRange(me.currentTimeLine, true);
        }
    }

    /**
     * Get/set the current time line display state
     * @property {boolean}
     */
    get showCurrentTimeLine() {
        return this._showCurrentTimeLine;
    }

    set showCurrentTimeLine(show) {
        this._showCurrentTimeLine = show;

        if (show) {
            this.initCurrentTimeLine();
        }
        else {
            this.hideCurrentTimeLine();
        }
    }

    //endregion

    //region Menu items

    /**
     * Adds a menu item to show/hide current time line.
     * @param column Column
     * @param items Menu items
     * @returns {Object[]} Menu items
     * @private
     */
    getHeaderMenuItems(column, items) {
        const me = this;

        if (!items.some(item => item.isCurrentTimeline) && column.type === 'timeAxis') {
            items.push({
                isCurrentTimeline : true,
                text              : me.L('showCurrentTimeLine'),
                checked           : me.showCurrentTimeLine,
                onToggle          : ({ checked }) => {
                    me.showCurrentTimeLine = checked;
                }
            });
        }
    }

    //endregion

    //region Disable

    /**
     * Get/set the features disabled state
     * @property {Boolean}
     */
    get disabled() {
        return this._disabled;
    }

    set disabled(disabled) {
        this._disabled = disabled;

        if (this.client.isPainted) {
            this.renderRanges();
        }
    }

    /**
     * Returns the {@link Core.data.Store store} used by this feature
     * @property {Core.data.Store}
     */
    get store() {
        return this._store;
    }

    set store(store) {
        const
            me     = this,
            client = me.client;

        if (!store.storeId) {
            store.storeId = 'timeRanges';
        }

        super.store = store;

        // timeRanges can be set on scheduler/gantt or feature, for convenience. Should only be processed by the TimeRanges
        // and not any subclasses
        if (client.timeRanges && !client._timeRangesExposed) {
            me._store.add(client.timeRanges);
            delete client.timeRanges;
        }

        if (me.timeRanges) {
            me._store.add(me.timeRanges);
            delete me.timeRanges;
        }
    }

    //endregion
}

TimeRanges._$name = 'TimeRanges'; GridFeatureManager.registerFeature(TimeRanges, false, ['Scheduler', 'Gantt']);

const ScheduleRange = {
    completeview : 'completeview',
    // completedata : 'completedata',
    currentview  : 'currentview',
    daterange    : 'daterange'
};

var SchedulerExporterMixin = base => class SchedulerExporterMixin extends base {
    async scrollRowIntoView(client, index) {
        const promises = [];
    
        let scrollFired = false;
        
        const detacher = client.scrollable.on({
            scrollStart({ y }) {
                if (y != null) {
                    scrollFired = true;
                }
            }
        });
        
        promises.push(client.scrollRowIntoView(client.store.getAt(index), { block : 'start' }));
        
        detacher();
        
        if (scrollFired) {
            promises.push(
                new Promise(resolve => {
                    client.scrollable.on({
                        scrollEnd() {
                            resolve();
                        },
                        once : true
                    });
                })
            );
        }

        return Promise.all(promises);
    }
    
    async scrollToDate(client, date) {
        let scrollFired = false;
        
        const promises    = [];
        
        // Time axis is updated on element scroll, which is async event. We need to synchronize this logic.
        // If element horizontal scroll is changed then sync event is fired. We add listener to that one specific event
        // and remove it right after scrollToDate sync code, keeping listeners clean. If scrolling occurred, we need
        // to wait until time header is updated.
        const detacher = client.timeAxisSubGrid.scrollable.on({
            scrollstart({ x }) {
                if (x != null) {
                    scrollFired = true;
                }
            }
        });
        
        promises.push(client.scrollToDate(date));
        
        detacher();
        
        if (scrollFired) {
            // TODO: investigate EventsMixin.await
            promises.push(new Promise(resolve => {
                client.timeView.on({
                    refresh() {
                        resolve();
                    },
                    once : true
                });
            }));
        }
        
        await Promise.all(promises);
    }
    
    async prepareComponent(config) {
        const
            me             = this,
            { client }     = config;
            
        switch (config.scheduleRange) {
            case ScheduleRange.completeview:
                config.rangeStart = client.startDate;
                config.rangeEnd   = client.endDate;
                break;
            case ScheduleRange.currentview:
                const { startDate, endDate } = client.getVisibleDateRange();
                config.rangeStart = startDate;
                config.rangeEnd = endDate;
                break;
        }
    
        // set new timespan before calling parent to get proper scheduler header/content size
        client.setTimeSpan(config.rangeStart, config.rangeEnd);
        
        await super.prepareComponent(config);
        
        const
            { exportMeta } = me,
            fgCanvasEl     = me.element.querySelector('.b-sch-foreground-canvas'),
            timeAxisEl     = me.element.querySelector('.b-horizontaltimeaxis');
    
        if (config.scheduleRange !== ScheduleRange.completeview) {
            // If we are exporting subrange of dates we need to change subgrid size accordingly
            exportMeta.totalWidth -= exportMeta.subGrids.normal.width;
            exportMeta.totalWidth += exportMeta.subGrids.normal.width = client.timeAxisViewModel.getDistanceBetweenDates(config.rangeStart, config.rangeEnd);
            // store left scroll to imitate normal grid/header scroll using margin
            exportMeta.subGrids.normal.scrollLeft = client.getCoordinateFromDate(config.rangeStart);
        }
        
        exportMeta.timeAxisHeaders = [];
        exportMeta.timeAxisPlaceholders = [];
        exportMeta.headersColleted = false;
        
        DomHelper.forEachSelector(timeAxisEl, '.b-sch-header-row', headerRow => {
            exportMeta.timeAxisPlaceholders.push(me.createPlaceholder(headerRow));
            exportMeta.timeAxisHeaders.push(new Map());
        });
        
        // Add placeholder for events, clear all event elements, but not the entire elements as it contains svg canvas
        exportMeta.subGrids.normal.eventsPlaceholder = me.createPlaceholder(fgCanvasEl, false);
        DomHelper.removeEachSelector(fgCanvasEl, '.b-sch-event-wrap');
        
        exportMeta.eventsBoxes = new Map();
        exportMeta.client = client;
        
        if (client.features.dependencies && !client.features.dependencies.disabled) {
            const svgCanvasEl = me.element.querySelector(`[id="${client.svgCanvas.getAttribute('id')}"]`);
    
            // Same as above, clear only dependency lines, because there might be markers added by user
            if ((exportMeta.dependenciesPlaceholder = svgCanvasEl)) {
                DomHelper.removeEachSelector(svgCanvasEl, '.b-sch-dependency');
            }
        }
        
        // We need to scroll component to date to calculate correct start margin
        if (!DateHelper.betweenLesser(config.rangeStart, client.startDate, client.endDate)) {
            await me.scrollToDate(client, config.rangeStart);
        }
        
        const
            horizontalPages = Math.ceil(exportMeta.totalWidth / exportMeta.pageWidth),
            totalPages      = horizontalPages * exportMeta.verticalPages;
    
        exportMeta.horizontalPages = horizontalPages;
        exportMeta.totalPages = totalPages;
    }
    
    async onRowsCollected(rows, config) {
        await super.onRowsCollected(rows);
    
        const
            me                               = this,
            { client }                       = config,
            { timeView }                     = client,
            { pageRangeStart, pageRangeEnd } = me.getCurrentPageDateRange(config);
        
        let rangeProcessed = false;
        
        await me.scrollToDate(client, pageRangeStart);
        
        // Time axis and events are only rendered for the visible time span
        // we need to scroll the view and gather events/timeline elements
        // while (timeView.endDate <= config.rangeEnd) {
        while (!rangeProcessed) {
            me.collectHeaders(config);
            
            me.collectEvents(rows, config);
            
            if (DateHelper.timeSpanContains(timeView.startDate, timeView.endDate, pageRangeStart, pageRangeEnd)) {
                rangeProcessed = true;
            }
            else if (timeView.endDate.getTime() >= pageRangeEnd.getTime()) {
                rangeProcessed = true;
            }
            else {
                const endDate = timeView.endDate;
                
                await me.scrollToDate(client, timeView.endDate);
                
                // If timeview end date is same as before scroll it means client is not able to scroll to date
                // and will go into infinite loop unless we stop it
                if (endDate.getTime() === timeView.endDate.getTime()) {
                    throw new Error('Could not scroll to date');
                }
            }
        }
        
        await me.scrollToDate(client, config.rangeStart);
    }
    
    getCurrentPageDateRange({ rangeStart, rangeEnd, client }) {
        const
            me = this,
            { exportMeta } = me,
            { horizontalPages, horizontalPosition, pageWidth, subGrids } = exportMeta;
        
        let pageRangeStart, pageRangeEnd;
        
        // when exporting to multiple pages we only need to scroll sub-range within visible time span
        if (horizontalPages > 1) {
            const
                pageStartX = horizontalPosition * pageWidth,
                pageEndX   = (horizontalPosition + 1) * pageWidth,
                // Assuming normal grid is right next to right side of the locked grid
                // There is also a default splitter
                normalGridX = subGrids.locked.width;
            
            if (pageEndX <= normalGridX) {
                pageRangeEnd = pageRangeStart = null;
            }
            else {
                pageRangeStart = client.getDateFromCoordinate(Math.max(pageStartX - normalGridX, 0));
                // Extend visible schedule by 20% to cover up possible splitter
                pageRangeEnd = client.getDateFromCoordinate((pageEndX - normalGridX) * 1.2) || rangeEnd;
            }
        }
        else {
            pageRangeStart = rangeStart;
            pageRangeEnd   = rangeEnd;
        }
        
        return {
            pageRangeStart,
            pageRangeEnd
        };
    }
    
    prepareExportElement() {
        const
            { element, exportMeta }                = this,
            { id, headerId, footerId, scrollLeft } = exportMeta.subGrids.normal;
        
        const el = element.querySelector(`[id="${id}"]`);
        
        ['.b-sch-background-canvas', '.b-sch-foreground-canvas'].forEach(selector => {
            const canvasEl = el.querySelector(selector);
    
            if (canvasEl) {
                // Align canvases to last exported row bottom. If no such property exists - remove inline height
                if (exportMeta.lastExportedRowBottom) {
                    canvasEl.style.height = `${exportMeta.lastExportedRowBottom}px`;
                }
                else {
                    canvasEl.style.height = '';
                }
        
                // Simulate horizontal scroll
                if (scrollLeft) {
                    canvasEl.style.marginLeft = `-${scrollLeft}px`;
                }
            }
        });
        
        if (scrollLeft) {
            [headerId, footerId].forEach(id => {
                const el = element.querySelector(`[id="${id}"] .b-widget-scroller`);
                if (el) {
                    el.style.marginLeft = `-${scrollLeft}px`;
                }
            });
        }
        
        return super.prepareExportElement();
    }
    
    collectRow(row) {
        const
            me           = this,
            { subGrids } = me.exportMeta;
        
        Object.entries(row.elements).forEach(([key, value]) => {
            const rowConfig = [value.outerHTML, row.top, row.offsetHeight];
            
            if (key === 'normal') {
                rowConfig.push(new Map());
            }
            
            subGrids[key].rows.push(rowConfig);
        });
    }
    
    collectHeaders(config) {
        const
            me             = this,
            { client }     = config,
            { exportMeta } = me;
        
        // We only need to collect headers once, this flag is raised once they are collected along all exported range
        if (!exportMeta.headersCollected) {
            const
                timeAxisEl = client.timeView.element,
                timeAxisHeaders = exportMeta.timeAxisHeaders;
            
            DomHelper.forEachSelector(timeAxisEl, '.b-sch-header-row', (headerRow, index, headerRows) => {
                const headersMap = timeAxisHeaders[index];
                
                DomHelper.forEachSelector(headerRow, '.b-sch-header-timeaxis-cell', el => {
                    if (!headersMap.has(el.dataset.tickIndex)) {
                        headersMap.set(el.dataset.tickIndex, el.outerHTML);
                    }
                });
                
                if (index === headerRows.length - 1 && headersMap.has(String(client.timeAxis.count - 1))) {
                    exportMeta.headersCollected = true;
                }
            });
        }
    }
    
    collectEvents(rows, config) {
        const
            me         = this,
            addedRows  = rows.length,
            { client } = config,
            normalRows = me.exportMeta.subGrids.normal.rows;
        
        rows.forEach((row, index) => {
            const
                rowConfig = normalRows[normalRows.length - addedRows + index],
                resource  = client.store.getAt(row.dataIndex),
                eventsMap = rowConfig[3];
        
            resource.events.forEach(event => {
                if (event.isScheduled) {
                    let el = client.getElementFromEventRecord(event, resource);
                
                    if (el && (el = el.parentElement) && !eventsMap.has(event.id)) {
                        eventsMap.set(event.id, [el.outerHTML, Rectangle.from(el, el.offsetParent)]);
                    }
                }
            });
        });
    }
    
    buildPageHtml() {
        const
            me           = this,
            { subGrids, timeAxisHeaders, timeAxisPlaceholders } = me.exportMeta;
        
        // Now when rows are collected, we need to add them to exported grid
        let html = me.prepareExportElement();
        
        Object.values(subGrids).forEach(({ placeHolder, eventsPlaceholder, rows }) => {
            const
                placeHolderText       = placeHolder.outerHTML,
                // Rows can be repositioned, in which case event related to that row should also be translated
                { resources, events } = me.positionRows(rows);
            
            html = html.replace(placeHolderText, resources.join(''));
            
            if (eventsPlaceholder) {
                html = html.replace(eventsPlaceholder.outerHTML, events.join(''));
            }
        });
        
        timeAxisHeaders.forEach((headers, index) => {
            html = html.replace(timeAxisPlaceholders[index].outerHTML, Array.from(headers.values()).join(''));
        });
        
        html = me.buildDependenciesHtml(html);
    
        return html;
    }
    
    // outerHTML is not supported on SVG elements in IE11, using workaround
    getDependenciesOuterHTML() {
        const { dependenciesPlaceholder } = this.exportMeta;
        
        let result;
        
        if (BrowserHelper.isIE11) {
            const
                wrapper = document.createElement('div'),
                tmpEl   = dependenciesPlaceholder.cloneNode(true);
            
            wrapper.appendChild(tmpEl);
            result = wrapper.innerHTML;
        }
        else {
            result = dependenciesPlaceholder.outerHTML;
        }
        
        return result;
    }
    
    renderDependencies() {
        const
            me                                               = this,
            { client, dependenciesPlaceholder, eventsBoxes } = me.exportMeta,
            { dependencies }                                 = client,
            dependencyFeature                                = client.features.dependencies,
            eventsInView                                     = Array.from(eventsBoxes.keys());
        
        dependencies
            .filter(r => eventsInView.includes(String(r.from)) || eventsInView.includes(String(r.to)))
            .forEach(dependency => {
                let fromBox     = eventsBoxes.get(String(dependency.from)),
                    toBox       = eventsBoxes.get(String(dependency.to));
                
                const { sourceEvent, targetEvent } = dependency;
            
                // In case of single page export from/to boxes will always be present, also we cannot trust boxes from cache
                // because single page exporter can possible change row/event vertical position
                // In case of multipage we will get box from the dependency feature
                if (!fromBox) {
                    if (sourceEvent) {
                        const box = dependencyFeature.getBox(dependency, true);
                        
                        if (box) {
                            fromBox = box instanceof Rectangle ? box : new Rectangle(box.start, box.top, box.end - box.start, box.bottom - box.top);
                        }
                    }
                }
                
                if (!toBox) {
                    if (targetEvent) {
                        const box = dependencyFeature.getBox(dependency, false);
    
                        if (box) {
                            toBox = box instanceof Rectangle ? box : new Rectangle(box.start, box.top, box.end - box.start, box.bottom - box.top);
                        }
                    }
                }
    
                // Gantt dependencies feature modifies box size to point arrow to the top, clone box to keep original size
                const drawData = {
                    startRectangle : fromBox && fromBox.clone(),
                    endRectangle   : toBox && toBox.clone()
                };
            
                if (fromBox && toBox) {
                    dependencyFeature.drawDependency(dependency, drawData, null, dependenciesPlaceholder, false);
                }
            });
        
        const result = me.getDependenciesOuterHTML();
        
        DomHelper.removeEachSelector(dependenciesPlaceholder, '.b-sch-dependency');
        
        return result;
    }
    
    buildDependenciesHtml(html) {
        const { dependenciesPlaceholder } = this.exportMeta;
        
        if (dependenciesPlaceholder) {
            const placeholder = this.getDependenciesOuterHTML();
            html = html.replace(placeholder, this.renderDependencies());
        }
        
        return html;
    }
};

class MultiPageExporter$1 extends SchedulerExporterMixin(MultiPageExporter) {
    async stateNextPage(config) {
        await super.stateNextPage(config);
        
        this.exportMeta.eventsBoxes.clear();
    }
    
    positionRows(rows) {
        const
            resources   = [],
            events      = [];
        
        // In case of variable row height row vertical position is not guaranteed to increase
        // monotonously. Position row manually instead
        rows.forEach(([html, top, height, eventsHtml]) => {
            resources.push(html);
            eventsHtml && Array.from(eventsHtml.entries()).forEach(([key, [html, box]]) => {
                events.push(html);
    
                // Store event box to render dependencies later
                this.exportMeta.eventsBoxes.set(String(key), box);
            });
        });
        
        return { resources, events };
    }
}
MultiPageExporter$1._$name = 'MultiPageExporter';

class ScheduleRangeCombo extends LocalizableCombo {
    static get $name() {
        return 'ScheduleRangeCombo';
    }
    
    static get defaultConfig() {
        return {
            editable : false
        };
    }
    
    buildLocalizedItems() {
        const me = this;
        
        return Object.entries(ScheduleRange).map(([id, text]) => ({ id, text : me.L(text) }));
    }
}

ScheduleRangeCombo._$name = 'ScheduleRangeCombo'; BryntumWidgetAdapterRegister.register(ScheduleRangeCombo.$name.toLowerCase(), ScheduleRangeCombo);

/**
 * @module Scheduler/view/export/SchedulerExportDialog
 */

/**
 * Similar to dialog in Grid, but with few extra fields specific to scheduler.
 * @extends Grid/view/export/ExportDialog
 */
class SchedulerExportDialog extends ExportDialog {
    static get $name() {
        return 'SchedulerExportDialog';
    }
    
    onLocaleChange() {
        const
            labelWidth = this.L('labelWidth');
        
        this.width = this.L('width');
        
        this.items.forEach(widget => {
            if (widget instanceof Field) {
                widget.labelWidth = labelWidth;
            }
            else if (widget.ref === 'rangeFieldsContainer') {
                widget.items[0].width = labelWidth;
            }
        });
    }
    
    buildDialogItems(config) {
        const
            me         = this,
            { client } = config,
            items      = super.buildDialogItems(config),
            labelWidth = me.L('labelWidth');
    
        me.columnsStore = client.columns.chain(record => record.isLeaf && !(record instanceof TimeAxisColumn));
        
        const columnsField = items.find(item => item.ref === 'columnsField');
        columnsField.store = me.columnsStore;
        columnsField.value = me.columnsStore.allRecords;
        
        items.splice(1, 0,
            {
                labelWidth,
                type        : 'schedulerangecombo',
                ref         : 'scheduleRangeField',
                label       : 'L{Schedule range}',
                localeClass : me,
                value       : ScheduleRange.completeview,
                onChange({ value }) {
                    const
                        hidden    = value !== ScheduleRange.daterange,
                        widgetMap = this.owner.widgetMap;
                    
                    widgetMap.rangeStartField.hidden = widgetMap.rangeEndField.hidden = hidden;
                }
            },
            {
                type  : 'container',
                ref   : 'rangeFieldsContainer',
                flex  : '1 0 100%',
                items : [
                    {
                        // Filler widget to align date fields
                        type  : 'widget',
                        width : labelWidth
                    },
                    {
                        type        : 'datefield',
                        ref         : 'rangeStartField',
                        label       : 'L{Export from}',
                        hidden      : true,
                        flex        : '1 0 25%',
                        localeClass : me,
                        value       : config.client.startDate
                    },
                    {
                        type        : 'datefield',
                        ref         : 'rangeEndField',
                        label       : 'L{Export to}',
                        hidden      : true,
                        flex        : '1 0 25%',
                        localeClass : me,
                        value       : config.client.endDate
                    }
                ]
            }
        );
        
        return items;
    }
}
SchedulerExportDialog._$name = 'SchedulerExportDialog';

class SinglePageExporter$1 extends SchedulerExporterMixin(SinglePageExporter) {
    // We should not collect dependencies per each page, instead we'd render them once
    collectDependencies() {}
    
    positionRows(rows) {
        let currentTop  = 0,
            resources   = [],
            events      = [],
            translateRe = /translate\((\d+.?\d*)px, (\d+.?\d*)px\)/;

        // In case of variable row height row vertical position is not guaranteed to increase
        // monotonously. Position row manually instead
        rows.forEach(([html, top, height, eventsHtml]) => {
            resources.push(html.replace(translateRe, `translate($1px, ${currentTop}px)`));
            
            const rowTopDelta = currentTop - top;
            
            eventsHtml && Array.from(eventsHtml.entries()).forEach(([key, [html, box]]) => {
                // Fix event vertical position according to the row top
                box.translate(0, rowTopDelta);
                
                // Store event box to render dependencies later
                this.exportMeta.eventsBoxes.set(String(key), box);
                
                events.push(html.replace(translateRe, `translate($1px, ${box.y}px)`));
            });

            currentTop += height;
        });
        
        return { resources, events };
    }
}
SinglePageExporter$1._$name = 'SinglePageExporter';

/**
 * @module Scheduler/feature/export/PdfExport
 */

/**
 * Generates PDF/PNG files from the Scheduler component.
 *
 * <img src="resources/images/export-dialog.png" style="max-width : 300px" alt="Scheduler Export dialog">
 *
 * **NOTE:** This feature makes a fetch request to the server, posting
 * the HTML fragments to be exported. The {@link #config-exportServer} URL must be configured.
 *
 * ## Usage
 *
 * ```javascript
 * let scheduler = new Scheduler({
 *     features : {
 *         pdfExport : {
 *             exportServer : 'http://localhost:8080' // Required
 *         }
 *     }
 * })
 *
 * // Opens popup allowing to customize export settings
 * scheduler.features.pdfExport.showExportDialog();
 *
 * // Simple export
 * scheduler.features.pdfExport.export({
 *     columns : scheduler.columns.map(c => c.id) // Required, set list of column ids to export
 * }).then(result => {
 *     // Response instance and response content in JSON
 *     let { response, responseJSON } = result;
 * });
 * ```
 *
 * Appends configs related to exporting time axis: {@link #config-scheduleRange}, {@link #config-rangeStart},
 * {@link #config-rangeEnd}
 *
 * @extends Grid/feature/export/PdfExport
 * @typings Grid/feature/export/PdfExport -> Grid/feature/export/GridPdfExport
 */
class PdfExport$1 extends PdfExport {
    static get $name() {
        return 'PdfExport';
    }

    static get defaultConfig() {
        return {
            exporters : [SinglePageExporter$1, MultiPageExporter$1],

            /**
             * Specifies how to export time span.
             *  * completeview - Complete configured time span, from scheduler start date to end date
             *  * currentview  - Currently visible time span
             *  * daterange    - Use specific date range, provided additionally in config. See {@link #config-rangeStart}/
             *  {@link #config-rangeEnd}
             * @config {String}
             * @default
             * @group Export file config
             */
            scheduleRange : 'completeview',

            /**
             * Exported time span range start. Used with `daterange` config of the {@link #config-scheduleRange}
             * @config {Date}
             * @group Export file config
             */
            rangeStart : null,

            /**
             * Exported time span range end. Used with `daterange` config of the {@link #config-scheduleRange}
             * @config {Date}
             * @group Export file config
             */
            rangeEnd : null
        };
    }

    showExportDialog() {
        const me = this;

        if (!me.exportDialog) {
            me.exportDialog = new SchedulerExportDialog({
                client    : me.client,
                exporters : me.exporters,
                listeners : {
                    export  : me.onExportDialogExport,
                    thisObj : me
                }
            });
        }

        me.exportDialog.show();
    }

    buildExportConfig(config) {
        config = super.buildExportConfig(config);

        const {
            scheduleRange,
            rangeStart,
            rangeEnd
        } = this;

        // Time axis is filtered from UI, need to append it
        if (config.columns && !config.columns.find(col => col.type === 'timeAxis')) {
            config.columns.push(config.client.timeAxisColumn.id);
        }

        return ObjectHelper.assign({
            scheduleRange,
            rangeStart,
            rangeEnd
        }, config);
    }
}

PdfExport$1._$name = 'PdfExport'; GridFeatureManager.registerFeature(PdfExport$1, false, 'Scheduler');

/**
 * @module Scheduler/util/ScheduleTableExporter
 */

/**
 * This class transforms scheduler component into two arrays: rows and columns. Columns array contains objects with
 * meta information about column: field name, column name, width and type of the rendered value, rows array contains
 * arrays of cell values.
 *
 * ```javascript
 * const exporter = new ScheduleTableExporter({ target : scheduler });
 * exporter.export()
 *
 * // Output
 * {
 *     columns : [
 *         { field : 'name',      value : 'First name', type : 'string',  width : 100 },
 *         { field : 'name',      value : 'Task',       type : 'string',  width : 100, eventColumn : true },
 *         { field : 'startDate', value : 'Starts',     type : 'date',    width : 100, eventColumn : true },
 *         { field : 'endDate',   value : 'Ends',       type : 'date',    width : 100, eventColumn : true }
 *     ],
 *     rows : [
 *         ['Michael', 'Hand out dundies',      Date, Date],
 *         ['Michael', 'Buy condo',             Date, Date],
 *         ['Jim',     'Close sale to library', Date, Date]
 *     ]
 * }
 * ```
 *
 * ## How data is exported
 *
 * Data is exported as in the base class with minor addition: every event is exported on a separate row, like
 * demonstrated above.
 *
 * In case there are unassigned events, by default they will be exported as well
 *
 * ```javascript
 * // output
 * {
 *     rows : [
 *         ['Michael', 'Hand out dundies',      Date, Date],
 *         ['Michael', 'Buy condo',             Date, Date],
 *         ['Jim',     'Close sale to library', Date, Date],
 *         ['',        'No resource assigned'],
 *         ['',        'Halloween prep',        Date, Date],
 *         ['',        'New year prep',         Date, Date]
 *     ]
 * }
 * ```
 *
 * @extends Grid/util/TableExporter
 * @mixes Core/localization/Localizable
 */
class ScheduleTableExporter extends Localizable(TableExporter) {
    static get defaultConfig() {
        return {
            /**
             * Set to `false` to not include unassigned events in the export. `true` by default.
             * @config {Boolean} includeUnassigned
             * @default
             */
            includeUnassigned : true,

            /**
             * An array of Event columns configuration used to specify columns width, headers name, and column fields to get the data from.
             * 'field' config is required. If 'text' is missing, the 'field' config will be used instead.
             *
             * For example:
             * ```javascript
             * eventColumns    : [
             *     { text : 'Task', field : 'name' },
             *     { text : 'Starts', field : 'startDate', width : 140 },
             *     { text : 'Ends', field : 'endDate', width : 140 }
             * ]
             * ```
             *
             * @config {String[]|Object[]} eventColumns
             * @default
             */
            eventColumns : [
                { text : 'Task', field : 'name' },
                { text : 'Starts', field : 'startDate', width : 140 },
                { text : 'Ends', field : 'endDate', width : 140 }
            ]
        };
    }

    normalizeColumns(config) {
        super.normalizeColumns(config);

        config.eventColumns = config.eventColumns.map(col => {
            if (typeof col === 'string') {
                return { field : col };
            }
            else {
                return col;
            }
        });
    }

    generateExportData(config) {
        const
            me                 = this,
            isScheduler        = this.target instanceof Scheduler,
            resourceColumns    = me.generateColumns(config),
            eventColumns       = isScheduler ? me.generateEventColumns(config) : [],
            columns            = resourceColumns.concat(eventColumns),
            rows               = me.generateRows(config);

        return { columns, rows };
    }

    generateEventColumns(config) {
        return config.eventColumns.map(column => this.processEventColumn(column, config));
    }

    processEventColumn(column, config) {
        

        const
            { width, minWidth }    = column,
            { defaultColumnWidth } = config;

        return {
            field       : column.field,
            value       : column.text,
            width       : Math.max(width || defaultColumnWidth, minWidth || defaultColumnWidth),
            eventColumn : true,
            type        : this.getColumnType(column, this.target.eventStore)
        };
    }

    generateRows(config) {
        const
            me         = this,
            { target } = me;

        let result;

        if (!(target instanceof Scheduler)) {
            result = super.generateRows(config);
        }
        else {
            result = [];

            // forEach skips group records, summary records etc
            target.resourceStore.map(resourceRecord => {
                // Get all events for resource (including assignment store)
                const events = resourceRecord.events || [];

                // Set dummy event to have resource info printed without events
                if (!events.length) {
                    events.push('');
                }

                events.forEach(eventRecord => result.push(me.getRowData(config, resourceRecord, eventRecord)));
            });

            if (config.includeUnassigned && config.eventColumns.length) {
                const notAssignedEvents = target.eventStore.query(eventRecord => {
                    return !eventRecord.resources.length &&
                        // this extra check is needed until eventRecord.resources skips grouped and collapsed resources
                        // checked by ExcelExport.t.js when it can be removed
                        !target.resourceStore.isAvailable(eventRecord);
                });

                if (notAssignedEvents.length) {
                    // Use offset to match first event column
                    const cells = new Array(config.columns.length).fill('');

                    cells.push(me.L('No resource assigned'));

                    result.push(cells);

                    // Set dummy resource to have event info printed without resource
                    notAssignedEvents.forEach(eventRecord => result.push(me.getRowData(config, null, eventRecord)));
                }
            }

            // filter out empty rows
            result = result.filter(cells => cells.length);
        }

        return result;
    }

    getRowData(config, resource, event) {
        const
            {
                columns,
                eventColumns
            }     = config,
            cells = [];

        cells.push(...this.processRecord(resource, columns, config));

        if (!resource || !resource.meta.specialRow) {
            cells.push(...this.processRecord(event, eventColumns, config));
        }

        return cells;
    }
}
ScheduleTableExporter._$name = 'ScheduleTableExporter';

/*eslint no-undef: "error"*/

/**
 * @module Scheduler/feature/experimental/ExcelExporter
 */

/**
 * **NOTE**: This class requires a 3rd party library to operate.
 *
 * A plugin that allows exporting Scheduler data to Excel without involving the server. It uses {@link Scheduler.util.ScheduleTableExporter}
 * class as data provider, [zipcelx library](https://www.npmjs.com/package/zipcelx)
 * forked and adjusted to support [column width config](https://github.com/bryntum/zipcelx/tree/column-width-build)
 * and [Microsoft XML specification](https://msdn.microsoft.com/en-us/library/office/documentformat.openxml.spreadsheet.aspx).
 * Zipcelx should be either in global scope (window) or can be provided with {@link #config-zipcelx} config.
 *
 * ```
 * // Global scope
 * <script src="zipcelx.js"></script>
 *
 * // importing from package
 * import zipcelx from 'zipcelx';
 *
 * const grid = new Grid({
 *     features : {
 *         excelExporter : {
 *             zipcelx
 *         }
 *     }
 * })
 * ```
 *
 * Here is an example of how to add the feature:
 *
 * ```javascript
 * const scheduler = new Scheduler({
 *     features : {
 *         excelExporter : {
 *             // Choose the date format for date fields
 *             dateFormat : 'YYYY-MM-DD HH:mm',
 *
 *             // Choose the Resource fields to include in the exported file
 *             columns : [{ text : 'Staff', field : 'name' }],
 *
 *             // Choose the Event fields to include in the exported file
 *             eventColumns    : [
 *                 { text : 'Task', field : 'name' },
 *                 { text : 'Starts', field : 'startDate', width : 140 },
 *                 { text : 'Ends', field : 'endDate', width : 140 }
 *             ]
 *         }
 *     }
 * });
 * ```
 *
 * And how to call it:
 *
 * ```javascript
 * scheduler.features.excelExporter.export({
 *     filename : 'Export'
 * })
 * ```
 *
 * @extends Grid/feature/experimental/ExcelExporter
 * @demo Scheduler/exporttoexcel
 * @typings Grid/feature/experimental/ExcelExporter -> Grid/feature/experimental/GridExcelExporter
 */
class ExcelExporter$1 extends ExcelExporter {
    static get $name() {
        return 'ExcelExporter';
    }

    static get defaultConfig() {
        return {
            /**
             * Exporter class. Must subclass {@link Scheduler.util.ScheduleTableExporter}
             * @config {Scheduler.util.ScheduleTableExporter}
             * @default
             */
            exporterClass : ScheduleTableExporter,

            /**
             * Configuration object for {@link #config-exporterClass exporter class}.
             * @config {Object}
             */
            exporterConfig : null
        };
    }
}

ExcelExporter$1._$name = 'ExcelExporter'; GridFeatureManager.registerFeature(ExcelExporter$1, false, 'Scheduler');

/**
 * @module Scheduler/column/ResourceInfoColumn
 */

/**
 * Displays resource information. Defaults to showing image + name + event count, but what to show is configurable.
 * Be sure to specify {@link Scheduler.view.mixin.SchedulerEventRendering#config-resourceImagePath} to instruct the
 * column where to look for the images.
 * @externalexample scheduler/ResourceInfoColumn.js
 * @classType resourceInfo
 * @extends Grid/column/Column
 */
class ResourceInfoColumn extends Column {
    static get type() {
        return 'resourceInfo';
    }

    static get fields() {
        return ['showEventCount', 'showRole', 'showImage', 'imagePath', 'validNames', 'defaultImageName', 'autoScaleThreshold'];
    }

    static get defaults() {
        return {
            /**
             * Show image. Looks for image name in fields on the resource in the following order: 'imageUrl', 'image', 'name'.
             * Set `showImage` to a field name to use a custom field. Set `imagePath` to specify where to load
             * images from. If no extension found, defaults to {@link Scheduler.view.mixin.SchedulerEventRendering#config-resourceImageExtension}.
             * @config {Boolean}
             * @default
             */
            showImage : true,

            /**
             * Show number of events assigned to the resource below the name.
             * @config {Boolean}
             * @default
             */
            showEventCount : true,

            /**
             * Show resource role below the name. Specify `true` to display data from the `role` field, or specify a field
             * name to read this value from.
             * @config {Boolean|String}
             * @default
             */
            showRole : false,

            /**
             * Path to load images from.
             * Defaults to using the value of {@link Scheduler.view.mixin.SchedulerEventRendering#config-resourceImagePath}
             * @config {String}
             * @deprecated 2.2
             */
            imagePath : null,

            /**
             * Valid image names. Set to `null` to allow all names.
             * @config {String[]}
             * @default
             */
            validNames : [
                'amit',
                'angelo',
                'arcady',
                'arnold',
                'celia',
                'chang',
                'dan',
                'dave',
                'emilia',
                'george',
                'gloria',
                'henrik',
                'hitomi',
                'jong',
                'kate',
                'lee',
                'linda',
                'lisa',
                'lola',
                'macy',
                'madison',
                'malik',
                'mark',
                'maxim',
                'mike',
                'rob',
                'steve'
            ],

            /**
             * Generic user image, used when an invalid name is specified.
             * Defaults to using the value of {@link Scheduler.view.mixin.SchedulerEventRendering#config-defaultResourceImageName}
             * @config {String}
             * @deprecated 2.2
             */
            defaultImageName : null,

            /**
             * Specify 0 to prevent the column from adapting its content according to the used row height, or specify a
             * a threshold (row height) at which scaling should start.
             * @config {Number}
             * @default
             */
            autoScaleThreshold : 40,

            field      : 'name',
            htmlEncode : false,
            width      : 140,
            cellCls    : 'b-resourceinfo-cell',

            autoSyncHtml : true,

            editor : VersionHelper.isTestEnv ? false : 'text'
        };
    }

    construct() {
        const me = this;

        super.construct(...arguments);

        if (me.grid.isPainted) {
            me.addErrorListener();
        }
        else {
            me.grid.on({
                paint   : me.addErrorListener,
                thisObj : me,
                once    : true
            });
        }
    }

    set imagePath(path) {
        this.set('imagePath', path);
    }

    get imagePath() {
        return this.get('imagePath') || this.grid.resourceImagePath;
    }

    set defaultImageName(name) {
        this.set('defaultImageName', name);
    }

    get defaultImageName() {
        return this.get('defaultImageName') || this.grid.defaultResourceImageName;
    }

    getImageURL(imageName) {
        return StringHelper.joinPaths([this.imagePath || '', imageName || '']);
    }

    addErrorListener() {
        EventHelper.on({
            element  : this.grid.element,
            delegate : '.b-resource-image',
            error    : event => this.setDefaultResourceImage(event.target),
            capture  : true
        });
    }

    setDefaultResourceImage(target) {
        if (this.defaultImageName) {
            const defaultURL = this.getImageURL(this.defaultImageName);
            // Set image to defaultURL if it is not already set
            if (target.src && !target.src.endsWith(defaultURL.replace(/^[./]*/gm, ''))) {
                target.src = defaultURL;
            }
        }
    }

    template(record) {
        const me        = this,
            {
                showImage,
                showRole,
                showEventCount
            }         = me,
            roleField = typeof showRole === 'string' ? showRole : 'role',
            role      = record[roleField],
            count     = record.events.length,
            value     = record.get(me.field);

        let imageUrl;

        if (showImage) {
            if (record.imageUrl) {
                imageUrl = record.imageUrl;
            }
            else {
                // record.image supposed to be a file name, located at imagePath
                const
                    imageName = typeof showImage === 'string' ? showImage
                        : (record.image || value && (value.toLowerCase() + me.grid.resourceImageExtension) || me.defaultImageName);

                imageUrl = me.getImageURL(imageName);

                // Image name supposed to have an extension
                if (!imageName.includes('.')) {
                    // If validNames is specified, check that imageName is valid
                    if (!me.validNames || me.validNames.includes(imageName)) {
                        imageUrl += me.grid.resourceImageExtension;
                    }
                    // If name is not valid, use generic image
                    else {
                        imageUrl = me.getImageURL(me.defaultImageName);
                    }
                }
            }
        }

        return `
            <div class="b-resource-info">
                ${imageUrl ? `<img class="b-resource-image" draggable="false" src="${imageUrl}">` : ''}
                <dl>
                <dt>${value}</dt>
                ${showRole ? `<dd class="b-resource-role">${role}</dd>` : ''}
                ${showEventCount ? `<dd class="b-resource-events">${me.L('eventCountText', count)}</dd>` : ''}
                </dl>
            </div>
        `;
    }

    defaultRenderer({ grid, record, cellElement, value, isExport }) {
        let result;

        if (record.meta.specialRow) {
            result = '';
        }
        else if (isExport) {
            result = value;
        }
        else {
            if (this.autoScaleThreshold && grid.rowHeight < this.autoScaleThreshold) {
                cellElement.style.fontSize = (grid.rowHeight / 40) + 'em';
            }
            else {
                cellElement.style.fontSize = '';
            }

            result = this.template(record);
        }

        return result;
    }
}

ColumnStore.registerColumnType(ResourceInfoColumn);
ResourceInfoColumn._$name = 'ResourceInfoColumn';

//TODO: If we want to improve on this, add settings as attributes, replace data-field with field etc.

/**
 * @module Scheduler/customElements/SchedulerTag
 */

/**
 * Import this file to be able to use the tag **&lt;bryntum-scheduler&gt;** to create a scheduler. This is more of a
 * proof of concept than a ready to use class. Dataset from **&lt;data&gt;** and **&lt;bryntum-scheduler&gt;** tags is
 * applied to record and scheduler config, which means, that you can pass any documented config there, not only
 * demonstrated here. Dataset attributes are translated as follows:
 *
 *  * data-view-preset -> viewPreset
 *  * data-start-date -> startDate
 *
 *  etc.
 * ## Example
 * ```
 * &lt;bryntum-scheduler data-view-preset="weekAndDay" data-start-date="2018-04-02" data-end-date="2018-04-09"&gt;
 *  &lt;column data-field="name"&gt;Name&lt;/column&gt;
 *      &lt;data&gt;
 *          &lt;events&gt;
 *              &lt;data data-id="1" data-resource-id="1" data-start-date="2018-04-03" data-end-date="2018-04-05"&gt;&lt;/data&gt;
 *              &lt;data data-id="2" data-resource-id="2" data-start-date="2018-04-04" data-end-date="2018-04-06"&gt;&lt;/data&gt;
 *              &lt;data data-id="3" data-resource-id="3" data-start-date="2018-04-05" data-end-date="2018-04-07"&gt;&lt;/data&gt;
 *          &lt;/events&gt;
 *          &lt;resources&gt;
 *              &lt;data data-id="1" data-name="Daniel"&gt;&lt;/data&gt;
 *              &lt;data data-id="2" data-name="Steven"&gt;&lt;/data&gt;
 *              &lt;data data-id="3" data-name="Sergei"&gt;&lt;/data&gt;
 *          &lt;/resources&gt;
 *      &lt;/data&gt;
 * &lt;/bryntum-scheduler&gt;
 * ```
 */
// This is required to make trial build function normally
const TagBase = window.customElements ? HTMLElement : Object;

class SchedulerTag extends TagBase {
    constructor() {
        super();

        const
            me        = this,
            columns   = [],
            resources = [],
            events    = [];

        // create columns and data
        for (let tag of me.children) {
            if (tag.tagName === 'COLUMN') {
                const
                    width  = parseInt(tag.dataset.width),
                    flex   = parseInt(tag.dataset.flex),
                    column = {
                        field : tag.dataset.field,
                        text  : tag.innerHTML
                    };

                if (width) column.width = width;
                else if (flex) column.flex = flex;
                else column.flex = 1;

                columns.push(column);
            }
            else if (tag.tagName === 'DATA') {
                for (let storeType of tag.children) {
                    for (let record of storeType.children) {
                        const row = {};

                        Object.assign(row, record.dataset);

                        if (storeType.tagName === 'EVENTS') {
                            events.push(row);
                        }
                        else if (storeType.tagName === 'RESOURCES') {
                            resources.push(row);
                        }
                    }
                }
            }
        }

        const
            // go over to the dark side
            shadowRoot = this.attachShadow({ mode : 'open' }),
            // include css and target div in shadow dom
            link       = document.createElement('link');

        link.rel = 'stylesheet';
        link.href = '../../build/scheduler.default.css';

        link.onload = () => {
            const div = document.createElement('div');

            div.id = 'container';
            div.style.width = '100%';
            div.style.height = '100%';

            shadowRoot.appendChild(div);

            // Listen to focus events on shadow root to handle focus inside the shadow dom
            setupFocusListeners(shadowRoot);

            const config = {
                appendTo : div,
                columns  : columns,
                resources,
                events
            };
            Object.assign(config, me.dataset);

            // render as usual
            const scheduler = new Scheduler(config);

            // for testing, set first scheduler as global variable
            if (!window.scheduler) window.scheduler = scheduler;
        };

        shadowRoot.appendChild(link);
    }
}

// Try-catch to make trial work
try {
    window.customElements && window.customElements.define('bryntum-scheduler', SchedulerTag);
}
catch (error) {

}
SchedulerTag._$name = 'SchedulerTag';

/* eslint-disable */
// leave in, comment removed in bryntum-loader. also needs to go at top since polyfill is used by other code
//import "nodelist-foreach-polyfill";

if (!window.bryntum) window.bryntum = {};

export { AbstractCrudManager, AbstractRecurrenceIterator, AggregateColumn, AjaxHelper, AjaxStore, AjaxTransport, ArrayHelper, AssignmentModel, AssignmentStore, Badge, Bag, Base, BooleanCombo, BrowserHelper, BryntumWidgetAdapter, BryntumWidgetAdapterRegister, Button, ButtonGroup, CSSHelper, Calendar, CalendarDayModel, CalendarPanel, CellEdit, CellTooltip, CheckColumn, Checkbox, ChipView, ClickRepeater, Collection, CollectionFilter, CollectionSorter, Column, ColumnDragToolbar, ColumnLines, ColumnPicker, ColumnReorder, ColumnResize, ColumnStore, Combo, Container, ContextMenu, CrudManager, CrudManagerView, DailyRecurrenceIterator, DataGenerator, DateColumn, DateField, DateHelper, DatePicker, Delayable, DemoBot, Dependencies, DependencyBaseModel, DependencyEdit, DependencyModel, DependencyStore, DisplayField, DomClassList, DomDataStore, DomHelper, DomSync, DragHelper, Duration, DurationField, Editor, EventContextMenu, EventDrag, EventDragCreate, EventDragSelect, EventEdit, EventFilter, EventHelper, EventModel, EventResize, EventStore, EventTooltip, Events, ExcelExporter$1 as ExcelExporter, Field, FileField, FileFormat, FilePicker, Filter, FilterBar, FlagField, Footer, Fullscreen, FunctionHelper, GlobalEvents, Grid, GridBase, ExcelExporter as GridExcelExporter, ExportDialog as GridExportDialog, GridFeatureManager, MultiPageExporter as GridMultiPageExporter, PdfExport as GridPdfExport, GridRowModel, SinglePageExporter as GridSinglePageExporter, Group, GroupSummary$1 as GroupSummary, Header, HeaderContextMenu, HeaderZoom, HorizontalTimeAxis, IdHelper, InstancePlugin, JsonEncoder, Labels, List, LocaleManagerSingelton as LocaleManager, Localizable, Mask, Menu, MenuItem, md as MessageDialog, Model, Month, MonthlyRecurrenceIterator, MultiPageExporter$1 as MultiPageExporter, NonWorkingTime, NumberField, ObjectHelper, Orientation, Override, PagingToolbar, Pan, Panel, PaperFormat, Parser, PdfExport$1 as PdfExport, PercentColumn, Pluggable, Point, Popup, pm as PresetManager, PresetStore, QuickFind, RandomGenerator, RatingColumn, Rectangle, RectangularPathFinder, RecurrenceCombo, RecurrenceConfirmationPopup, RecurrenceDayRuleEncoder, RecurrenceDaysButtonGroup, RecurrenceDaysCombo, RecurrenceEditor, RecurrenceFrequencyCombo, RecurrenceLegend, RecurrenceLegendButton, RecurrenceModel, RecurrenceMonthDaysButtonGroup, RecurrenceMonthsButtonGroup, RecurrencePositionsCombo, RecurrenceStopConditionCombo, RecurringEventEdit, RecurringEvents, RecurringEventsMixin, RecurringTimeSpan, RecurringTimeSpans, RecurringTimeSpansMixin, RegionResize, ResizeHelper, ResizeMonitor, ResourceInfoColumn, ResourceModel, ResourceStore, ResourceTimeRangeModel, ResourceTimeRangeStore, ResourceTimeRanges, Ripple, RowManager, RowNumberColumn, RowReorder, RowsRange, ScheduleRange, ScheduleTableExporter, ScheduleTooltip, Scheduler, SchedulerBase, SchedulerCommon, SchedulerExportDialog, SchedulerTag, ScrollManager, Scroller, Search, SimpleEventEdit, SinglePageExporter$1 as SinglePageExporter, Slider, Sort, Splitter, State, StateTrackingManager, Store, StringHelper, Stripe, Summary$1 as Summary, TabPanel, TableExporter, TemplateColumn, TemplateHelper, TextAreaField, TextField, TimeAxis, TimeAxisColumn, TimeAxisViewModel, TimeColumn, TimeField, TimePicker, TimeRanges, TimeSpan, Toast, Tool, Toolbar, Tooltip, Transaction, Tree, TreeColumn, TreeGrid, VersionHelper, ViewPreset, WeeklyRecurrenceIterator, Widget, WidgetColumn, WidgetHelper, YearlyRecurrenceIterator };
//# sourceMappingURL=scheduler.module.js.map
